/home/atharvakale/390r-debugging-setup/p7zip/C/Compiler.hUNUSED_VAR(x)(void)x;__7Z_COMPILER_H__clang___MSC_VERUNDER_CE_MSC_VER >= 1300/* #define UNUSED_VAR(x) x=x; */// #pragma clang diagnostic ignored "-Wreserved-id-macro"// identifier was truncated to '255' characters in the debug information// function marked as __forceinline not inlined// not inlined// unreachable code// unreferenced inline function has been removed// assignment operator could not be generated// copy constructor could not be generated// This function or variable may be unsafe// nonstandard extension used : bit field types other than int// nonstandard extension used : nameless struct/union/* #pragma warning(disable : 4115) // '_RPC_ASYNC_STATE' : named type definition in parentheses *//* Compiler.h
2021-01-05 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/home/atharvakale/390r-debugging-setup/p7zip/home/atharvakale/390r-debugging-setup/home/atharvakale/home//home/atharvakale/390r-debugging-setup/p7zip/C/Precomp.h"Compiler.h"__7Z_PRECOMP_H/* #include "7zTypes.h" *//* Precomp.h -- StdAfx
2013-11-12 : Igor Pavlov : Public domain *//usr/include/features.h<gnu/stubs.h><sys/cdefs.h><stdc-predef.h><features-time64.h>__USE_EXTERN_INLINES1__GLIBC_PREREQ(maj,min)((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))__GLIBC_MINOR__36__GLIBC__2__GNU_LIBRARY__6__GLIBC_USE_DEPRECATED_SCANF0__GLIBC_USE_DEPRECATED_GETS__USE_FORTIFY_LEVEL__USE_ATFILE__USE_MISC__USE_FILE_OFFSET64__USE_LARGEFILE_ATFILE_SOURCE__USE_XOPEN2K8__USE_ISOC99__USE_ISOC95__USE_XOPEN2K__USE_POSIX199506__USE_POSIX199309__USE_POSIX2__USE_POSIX_POSIX_C_SOURCE200809L_POSIX_SOURCE__USE_POSIX_IMPLICITLY__USE_ISOC11__GLIBC_USE_ISOC2X_DEFAULT_SOURCE__GLIBC_USE(F)__GLIBC_USE_ ## F__glibc_clang_prereq(maj,min)__GNUC_PREREQ(maj,min)((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))__KERNEL_STRICT_NAMES__USE_GNU__USE_DYNAMIC_STACK_SIZE__USE_LARGEFILE64__USE_XOPEN2K8XSI__USE_XOPEN2KXSI__USE_UNIX98__USE_XOPEN_EXTENDED__USE_XOPEN__USE_ISOCXX11_FEATURES_H_LOOSE_KERNEL_NAMESdefined __GNUC__ && defined __GNUC_MINOR__defined __clang_major__ && defined __clang_minor__(defined _BSD_SOURCE || defined _SVID_SOURCE) \_GNU_SOURCE(defined _DEFAULT_SOURCE					\(defined _ISOC2X_SOURCE \(defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE \(defined _ISOC99_SOURCE || defined _ISOC11_SOURCE			\__cplusplus__cplusplus >= 201703L__cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__!defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE((!defined __STRICT_ANSI__					\defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700((!defined _POSIX_C_SOURCE || (_POSIX_C_SOURCE - 0) < 199506L) \(defined _POSIX_SOURCE					\defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCEdefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199309Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199506Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200112Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200809L_XOPEN_SOURCE(_XOPEN_SOURCE - 0) >= 500(_XOPEN_SOURCE - 0) >= 600(_XOPEN_SOURCE - 0) >= 700_XOPEN_SOURCE_EXTENDED_LARGEFILE_SOURCE_LARGEFILE64_SOURCEdefined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64defined _DEFAULT_SOURCE_DYNAMIC_STACK_SIZE_SOURCEdefined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0!defined __OPTIMIZE__ || __OPTIMIZE__ <= 0!__GNUC_PREREQ (4, 1)_FORTIFY_SOURCE > 2 && (__glibc_clang_prereq (9, 0)		      \_FORTIFY_SOURCE > 3_FORTIFY_SOURCE > 1_FORTIFY_SOURCE > 2defined __cplusplus ? __cplusplus >= 201402L : defined __USE_ISOC11(defined __USE_GNU							\__ASSEMBLER___SYS_CDEFS_Hdefined __USE_FILE_OFFSET64 && !defined __REDIRECT__GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \__OPTIMIZE____GNUC_MINOR__7__GNUC__12__STDC_VERSION__201710L_FILE_OFFSET_BITS64_REENTRANT/* features.h  *//* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  *//* Decide whether we can define 'extern inline' functions in headers.  *//* !ASSEMBLER *//* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. *//* This is here only because every header file already includes this one.  *//* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  *//* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  *//* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  *//* GNU formerly extended the scanf functions with modified format
   specifiers %as, %aS, and %a[...] that allocate a buffer for the
   input using malloc.  This extension conflicts with ISO C99, which
   defines %a as a standalone format specifier that reads a floating-
   point number; moreover, POSIX.1-2008 provides the same feature
   using the modifier letter 'm' instead (%ms, %mS, %m[...]).

   We now follow C99 unless GNU extensions are active and the compiler
   is specifically in C89 or C++98 mode (strict or not).  For
   instance, with GCC, -std=gnu11 will have C99-compliant scanf with
   or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
   old extension.  *//* The function 'gets' existed in C89, but is impossible to use
   safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
   compatibility with various implementations of <cstdio>, this test
   must consider only the value of __cplusplus when compiling C++.  *//* Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
   defined in all multithreaded code.  GNU libc has not required this
   for many years.  We now treat them as compatibility synonyms for
   _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
   comprehensive support for multithreaded code.  Using them never
   lowers the selected level of POSIX conformance, only raises it.  *//* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  *//* This is to enable compatibility for ISO C++11.
   Check the temporary macro for now, too.  *//* This is to enable compatibility for ISO C++17.  *//* This is to enable the ISO C90 Amendment 1:1995 extension.  *//* This is to enable the ISO C99 extension.  *//* This is to enable the ISO C11 extension.  *//* This is to enable the ISO C2X extension.  *//* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  *//* If _GNU_SOURCE was defined by the user, turn on all the other features.  *//* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  *//* Whether to use feature set F.  *//* Similarly for clang.  Features added to GCC after version 4.2 may
   or may not also be available in clang, and clang's definitions of
   __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
   features can be queried via __has_extension/__has_feature.  *//* Convenience macro to test the version of gcc.
   Use like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
   added in 2.0.  *//* Suppress kernel-name space pollution unless user expressedly asks
   for it.  *//* Undefine everything, so we get a clean slate.  *//* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
   __STDC_WANT_LIB_EXT2__
			Extensions to ISO C99 from TR 27431-2:2010.
   __STDC_WANT_IEC_60559_BFP_EXT__
			Extensions to ISO C11 from TS 18661-1:2014.
   __STDC_WANT_IEC_60559_FUNCS_EXT__
			Extensions to ISO C11 from TS 18661-4:2015.
   __STDC_WANT_IEC_60559_TYPES_EXT__
			Extensions to ISO C11 from TS 18661-3:2015.
   __STDC_WANT_IEC_60559_EXT__
			ISO C2X interfaces defined only in Annex F.

   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _ATFILE_SOURCE	Additional *at interfaces.
   _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _DEFAULT_SOURCE	The default set of features (taking precedence over
			__STRICT_ANSI__).

   _FORTIFY_SOURCE	Add security hardening to many library functions.
			Set to 1 or 2; 2 performs stricter checks than 1.

   _REENTRANT, _THREAD_SAFE
			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __GLIBC_USE (F)	Define things from feature set F.  This is defined
			to 1 or 0; the subsequent macros are either defined
			or undefined, and those tests should be moved to
			__GLIBC_USE.
   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_ISOCXX11	Define ISO C++11 things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_MISC		Define things from 4.3BSD or System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   __USE_GNU		Define GNU extensions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.

   ISO C feature test macros depend on the definition of the macro
   when an affected header is included, not when the first system
   header is included, and so they are handled in
   <bits/libc-header-start.h>, which does not have a multiple include
   guard.  Feature test macros that can be handled from the first
   system header included are handled here.  *//* Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/usr/home/atharvakale/390r-debugging-setup/p7zip/C/7zTypes.h<stddef.h><errno.h>SecToRead_CreateVTableCSecToRead *struct <unnamed> *SecToLook_CreateVTableCSecToLook *LookToRead2_CreateVTableCLookToRead2 *LookInStream_Readconst ILookInStreamconst ILookInStream *ILookInStream *void *LookInStream_Read2LookInStream_SeekToLookInStream_LookReadsize_t *unsigned long *SeqInStream_ReadByteconst ISeqInStreamconst ISeqInStream *ISeqInStream *Byte *unsigned char *SeqInStream_Read2SeqInStream_ReadISzAllocconst ISzAllocconst ISzAlloc *ISzAlloc *ISzAllocPtrICompressProgressCSecToReadstruct <unnamed>CSecToLookCLookToRead2ILookInStreamISeekInStreamESzSeek(unnamed enum)SZ_SEEK_SETSZ_SEEK_CURSZ_SEEK_ENDISeqOutStreamISeqInStreamIByteOutIByteInBoolIntSizeTUInt64Int64SIZE_TDWORD_PTRLONG_PTRUINT_PTRINT_PTRLPVOIDDWORDULONGLONGUINT32UINTINT32INTUInt32Int32UInt16Int16ByteWResSRes..(*)(..)FreeAllocconst ICompressProgressconst ICompressProgress *ICompressProgress *ProgressrealStreamvtbufSizebufsizeposconst ISeekInStreamconst ISeekInStream *ISeekInStream *Int64 *long long *SeekReadSkipconst voidconst void *const void **void **Lookconst ISeqOutStreamconst ISeqOutStream *ISeqOutStream *Writeconst IByteOutconst IByteOut *IByteOut *const IByteInconst IByteIn *IByteIn *k_PropVar_TimePrec_1ns(k_PropVar_TimePrec_Base + 9)k_PropVar_TimePrec_100ns(k_PropVar_TimePrec_Base + 7)k_PropVar_TimePrec_Base16k_PropVar_TimePrec_HighPrec3k_PropVar_TimePrec_DOSk_PropVar_TimePrec_Unixk_PropVar_TimePrec_0WSTRING_PATH_SEPARATORL"/"STRING_PATH_SEPARATOR"/"WCHAR_PATH_SEPARATORL'/'CHAR_PATH_SEPARATOR'/'MY_memset_0_ARRAY(a)memset((a), 0, sizeof(a))CONTAINER_FROM_VTBL_CLS(ptr,type,m)CONTAINER_FROM_VTBL_SIMPLE(ptr, type, m)CONTAINER_FROM_VTBL(ptr,type,m)MY_container_of(ptr, type, m)CONTAINER_FROM_VTBL_SIMPLE(ptr,type,m)((type *)(void *)(ptr))MY_container_of(ptr,type,m)((type *)(void *)((char *)(void *)(1 ? (ptr) : &((type *)0)->m) - MY_offsetof(type, m)))MY_offsetof(type,m)offsetof(type, m)IAlloc_Free(p,a)ISzAlloc_Free(p, a)IAlloc_Alloc(p,size)ISzAlloc_Alloc(p, size)ISzAlloc_Free(p,a)(p)->Free(p, a)ISzAlloc_Alloc(p,size)(p)->Alloc(p, size)ICompressProgress_Progress(p,inSize,outSize)(p)->Progress(p, inSize, outSize)LookToRead2_Init(p){ (p)->pos = (p)->size = 0; }ILookInStream_Seek(p,pos,origin)(p)->Seek(p, pos, origin)ILookInStream_Read(p,buf,size)(p)->Read(p, buf, size)ILookInStream_Skip(p,offset)(p)->Skip(p, offset)ILookInStream_Look(p,buf,size)(p)->Look(p, buf, size)ISeekInStream_Seek(p,pos,origin)ISeekInStream_Read(p,buf,size)ISeqOutStream_Write(p,buf,size)(p)->Write(p, buf, size)ISeqInStream_Read(p,buf,size)IByteOut_Write(p,b)(p)->Write(p, b)IByteIn_Read(p)(p)->Read(p)MY_FAST_CALLMY_CDECLMY_FORCE_INLINEMY_NO_INLINE__attribute__((noinline))MY_STD_CALLFalseTrueUINT64_CONST(n)n ## ULLMY_HRES_ERROR__INTERNAL_ERROR((HRESULT)0x8007054FL)HRESULTVOIDvoidRINOK_WRes(x){ WRes __result__ = (x); if (__result__ != 0) return __result__; }RINOK(x){ int __result__ = (x); if (__result__ != 0) return __result__; }FILE_ATTRIBUTE_UNIX_EXTENSION0x8000FILE_ATTRIBUTE_ENCRYPTED0x4000FILE_ATTRIBUTE_NOT_CONTENT_INDEXED0x2000FILE_ATTRIBUTE_OFFLINE0x1000FILE_ATTRIBUTE_COMPRESSED0x0800FILE_ATTRIBUTE_REPARSE_POINT0x0400FILE_ATTRIBUTE_SPARSE_FILE0x0200FILE_ATTRIBUTE_TEMPORARY0x0100FILE_ATTRIBUTE_NORMAL0x0080FILE_ATTRIBUTE_DEVICE0x0040FILE_ATTRIBUTE_ARCHIVE0x0020FILE_ATTRIBUTE_DIRECTORY0x0010FILE_ATTRIBUTE_SYSTEM0x0004FILE_ATTRIBUTE_HIDDEN0x0002FILE_ATTRIBUTE_READONLY0x0001TEXT(quote)quoteMY__E_ERROR_NEGATIVE_SEEK((HRESULT)0x80070083L)E_INVALIDARG((HRESULT)0x80070057L)E_OUTOFMEMORY((HRESULT)0x8007000EL)ERROR_REPARSE_TAG_INVALID((HRESULT)0x80071129L)ERROR_INVALID_REPARSE_DATA((HRESULT)0x80071128L)ERROR_TOO_MANY_POSTS((HRESULT)0x8007012AL)ERROR_DISK_FULLENOSPCERROR_FILE_NOT_FOUNDENOENTERROR_PATH_NOT_FOUNDERROR_FILE_EXISTSEEXISTERROR_ALREADY_EXISTSERROR_INVALID_FUNCTIONEINVALERROR_INVALID_PARAMETERHRESULT_FROM_WIN32(x)MY_SRes_HRESULT_FROM_WRes(x)((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : MY_HRESULT_FROM_errno_CONST_ERROR(x))MY_HRESULT_FROM_errno_CONST_ERROR(x)((HRESULT)( ( (HRESULT)(x) & 0x0000FFFF) | (MY__FACILITY__WRes << 16) | (HRESULT)0x80000000 ))MY__FACILITY__WResMY__FACILITY_ERRNOMY__FACILITY_WIN320x800MY_ALIGN(n)__attribute__ ((aligned(n)))SZ_ERROR_NO_ARCHIVE17SZ_ERROR_ARCHIVESZ_ERROR_THREADSZ_ERROR_FAIL11SZ_ERROR_PROGRESS10SZ_ERROR_WRITE9SZ_ERROR_READ8SZ_ERROR_OUTPUT_EOFSZ_ERROR_INPUT_EOFSZ_ERROR_PARAM5SZ_ERROR_UNSUPPORTED4SZ_ERROR_CRCSZ_ERROR_MEMSZ_ERROR_DATASZ_OKEXTERN_C_ENDEXTERN_C_BEGIN__7Z_TYPES_H_WIN32_MSC_VER > 1200RINOKRINOK_WRes_LZMA_UINT32_IS_ULONG_SZ_NO_INT_64defined(_MSC_VER) || defined(__BORLANDC__)_LZMA_NO_SYSTEM_SIZE_T(defined(__GNUC__) && (__GNUC__ >= 4)) \defined(_M_IX86) \defined(MY_CPU_AMD64)MY_offsetofoffsetofMY_container_ofc_linkage/*
#define CONTAINER_FROM_VTBL_CLS(ptr, type, m) CONTAINER_FROM_VTBL(ptr, type, m)
*//*
#define CONTAINER_FROM_VTBL(ptr, type, m) CONTAINER_FROM_VTBL_SIMPLE(ptr, type, m)
*//*
  GCC shows warning: "perhaps the 'offsetof' macro was used incorrectly"
    GCC 3.4.4 : classes with constructor
    GCC 4.8.1 : classes with non-public variable members"
*//*
#define MY_container_of(ptr, type, m) container_of(ptr, type, m)
#define MY_container_of(ptr, type, m) CONTAINING_RECORD(ptr, type, m)
#define MY_container_of(ptr, type, m) ((type *)((char *)(ptr) - offsetof(type, m)))
#define MY_container_of(ptr, type, m) (&((type *)0)->m == (ptr), ((type *)(((char *)(ptr)) - MY_offsetof(type, m))))
*//*
    #define MY_offsetof(type, m) FIELD_OFFSET(type, m)
    *//* deprecated *//* address can be 0 *//* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. *//* the following variables must be set outside *//* it's data size *//* reads via ILookInStream::Read *//* reads directly (without buffer). It's same as ISeqInStream::Read *//* offset must be <= output(*size) of Look *//* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed *//* same as ISeqInStream::Read *//* Returns: result - the number of actually written bytes.
       (result < size) means error *//* it can return SZ_ERROR_INPUT_EOF *//* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed *//* reads one byte, returns 0 in case of EOF or error *//* The following interfaces use first parameter as pointer to structure *///  _MSC_VER// #define MY_FAST_CALL __attribute__((ms_abi))// #define MY_FAST_CALL __attribute__((cdecl))// #define MY_FAST_CALL __attribute__((fastcall))// #define MY_FORCE_INLINE __attribute__((always_inline)) inline/* typedef BoolInt Bool; *//* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! *///  _WIN32// gcc / clang on Unix  : sizeof(long==sizeof(void*) in 32 or 64 bits)// typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;// typedef void VOID;// LONG, ULONG and DWORD must be 32-bit for _WIN32 compatibility/* trick for Unix *//*
// we can use FACILITY_ERRNO for some COM errors, that have errno equivalents:
#define E_OUTOFMEMORY             MY_HRESULT_FROM_errno_CONST_ERROR(ENOMEM)
#define E_INVALIDARG              MY_HRESULT_FROM_errno_CONST_ERROR(EINVAL)
#define MY__E_ERROR_NEGATIVE_SEEK MY_HRESULT_FROM_errno_CONST_ERROR(EINVAL)
*/// we use FACILITY_WIN32 for COM errors:// if (MY__FACILITY__WRes != FACILITY_WIN32),// Too many posts were made to a semaphore.// we use FACILITY_WIN32 for errors that has no errno equivalent// #define ERROR_INVALID_HANDLE        EBADF// we use errno equivalents for some WIN32 errors:/*
#define ERROR_FILE_NOT_FOUND             2L
#define ERROR_ACCESS_DENIED              5L
#define ERROR_NO_MORE_FILES              18L
#define ERROR_LOCK_VIOLATION             33L
#define ERROR_FILE_EXISTS                80L
#define ERROR_DISK_FULL                  112L
#define ERROR_NEGATIVE_SEEK              131L
#define ERROR_ALREADY_EXISTS             183L
#define ERROR_DIRECTORY                  267L
#define ERROR_TOO_MANY_POSTS             298L

#define ERROR_INTERNAL_ERROR             1359L
#define ERROR_INVALID_REPARSE_DATA       4392L
#define ERROR_REPARSE_TAG_INVALID        4393L
#define ERROR_REPARSE_TAG_MISMATCH       4394L
*/// we call macro HRESULT_FROM_WIN32 for system errors (WRes) that are (errno)// (FACILITY_ERRNO = 0x800) is 7zip's FACILITY constant to represent (errno) errors in HRESULT// #define ENV_HAVE_LSTAT// _WIN32// #define MY_HRES_ERROR__INTERNAL_ERROR  MY_SRes_HRESULT_FROM_WRes(ERROR_INTERNAL_ERROR)/* typedef DWORD WRes; *//* #include <windows.h> *//* 7zTypes.h -- Basic types
2022-04-01 : Igor Pavlov : Public domain */plookaheadstreamerrorTypeoffset/home/atharvakale/390r-debugging-setup/p7zip/C/7zBuf.h"7zTypes.h"Buf_FreeCBuf *Buf_CreateBuf_InitCDynBufCBufdata__7Z_BUF_HDynBuf_FreeCDynBuf *DynBuf_Writeconst Byteconst Byte *DynBuf_SeekToBegDynBuf_Construct/* 7zBuf.h -- Byte Buffer
2017-04-03 : Igor Pavlov : Public domain */alloccompiled as c/usr/include/string.h/usr/include/bits/libc-header-start.h/usr/include/features-time64.h/usr/include/bits/wordsize.h/usr/include/bits/timesize.h/usr/include/stdc-predef.h/usr/include/sys/cdefs.h/usr/include/bits/long-double.h13/usr/include/gnu/stubs.h14/usr/include/gnu/stubs-64.h15/usr/lib/gcc/x86_64-redhat-linux/12/include/stddef.h/usr/include/bits/types/locale_t.h/usr/include/bits/types/__locale_t.h18/usr/include/strings.h19202122/usr/include/errno.h23/usr/include/bits/errno.h24/usr/include/linux/errno.h25/usr/include/asm/errno.h26/usr/include/asm-generic/errno.h27/usr/include/asm-generic/errno-base.h2829/home/atharvakale/390r-debugging-setup/p7zip/C/7zBuf2.c"7zBuf.h"<string.h>"Precomp.h"p->datanewSizevoid *__restrict__const void *__restrict__/* 7zBuf2.c -- Byte Buffer
2017-04-03 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/7zCrc.h/home/atharvakale/390r-debugging-setup/p7zip/C/CpuArch.h/home/atharvakale/390r-debugging-setup/p7zip/C/7zCrc.c"CpuArch.h""7zCrc.h"CrcGenerateTablei256rj3988292384kCrcPoly(UInt32)0UInt32[2048]unsigned int[2048]CRC_NUM_TABLES2048256 * CRC_NUM_TABLESUInt32 *unsigned int *2550xFFconst UInt32const UInt32 *CrcUpdateT1pEndv*pCrcCalc4294967295CRC_INIT_VALCrcUpdateCrcUpdateT8CrcUpdateT4CRC_FUNCg_CrcTableg_CrcUpdateg_CrcUpdateT0_64g_CrcUpdateT0_32g_CrcUpdateT8g_CrcUpdateT4CRC_UPDATE_BYTE_2(crc,b)(table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))0xEDB88320MY_CPU_LEMY_CPU_BEdefined(MY_CPU_ARM_OR_ARM64)defined(_MSC_VER)defined(MY_CPU_ARM64)(_MSC_VER >= 1910)(defined(__clang__) && (__clang_major__ >= 3)) \!defined(__ARM_FEATURE_CRC32)(!defined(__clang__) || (__clang_major__ > 3))defined(__ARM_FEATURE_CRC32)USE_CRC_EMUdefined(USE_ARM64_CRC) || defined(USE_CRC_EMU)ATTRIB_CRCCRC_NUM_TABLES < 4CRC_NUM_TABLES >= 8MY_CPU_X86_OR_AMD64USE_ARM64_CRCdefined(MY_CPU_ARM)extern// MY_CPU_LE// defined(USE_ARM64_CRC) || defined(USE_CRC_EMU)// #pragma message("USE ARM HW CRC")// defined(MY_CPU_ARM64) && defined(MY_CPU_LE)// USE_CRC_EMU// #define USE_CRC_EMU// no hardware CRC// fix these numbers// #pragma message("ARM*")/* ---------- hardware CRC ---------- *//* 7zCrc.c -- CRC32 init
2021-04-01 : Igor Pavlov : Public domain */table/home/atharvakale/390r-debugging-setup/p7zip/C/7zCrcOpt.cd17920x70015360x60012800x50010240x4007680x3005120x2000x1000x000/* 7zCrcOpt.c -- CRC32 calculation
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/7zStream.cSecToRead_Readstaticppchar *p->realStreamSecToLook_ReadLookToRead2_SeekoriginLookToRead2_ReadremLookToRead2_SkipLookToRead2_Look_Exactres SZ_OKsize2p->bufLookToRead2_Look_Lookahead&size2ILookInStream_Read(stream, buf, &processed)(stream)->Read(stream, buf, &processed)&processedprocessed__result__lookBufILookInStream_Look(stream, &lookBuf, size)(stream)->Look(stream, &lookBuf, size)&lookBuf*sizet&tISeqInStream_Read(stream, buf, &processed)GET_LookToRead2CLookToRead2 *p = CONTAINER_FROM_VTBL(pp, CLookToRead2, vt);/* 7zStream.c -- 7z Stream functions
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Aes.hAesCtr_Code_HW_256AesCbc_Decode_HW_256AesCtr_Code_HWAesCbc_Decode_HWAesCbc_Encode_HWAES_CODE_FUNCAES_SET_KEY_FUNCDECLARE__AES_CODE_FUNC(funcName)void MY_FAST_CALL funcName(UInt32 *ivAes, Byte *data, size_t numBlocks);k_Aes_SupportedFunctions_HW_256(1 << 3)k_Aes_SupportedFunctions_HW(1 << 2)AES_NUM_IVMRK_WORDS((1 + 1 + 15) * 4)AES_BLOCK_SIZE__AES_H_SFXAesCtr_CodeAesCbc_DecodeAesCbc_Encodeg_Aes_SupportedFunctions_Flagsg_AesCtr_Codeg_AesCbc_Encodeg_AesCbc_DecodeAesCbc_InitAes_SetKey_DecAes_SetKey_EncAesGenTablesvoid_param_list/* numBlocks - the number of 16-byte blocks in data array *//* data - 16-byte aligned pointer to data *//* iv size is AES_BLOCK_SIZE *//* ivAes - 16-byte aligned pointer to iv+keyMode+roundKeys sequence: UInt32[AES_NUM_IVMRK_WORDS] *//* keySize = 16 or 24 or 32 (bytes) *//* aes - 16-byte aligned pointer to keyMode+roundKeys sequence *//* 16-byte (4 * 32-bit words) blocks: 1 (IV) + 1 (keyMode) + 15 (AES-256 roundKeys) *//* UInt32 pointers must be 16-byte aligned *//* Call AesGenTables one time before other AES functions *//* Aes.h -- AES encryption / decryption
2018-04-28 : Igor Pavlov : Public domain */ivAesnumBlocksivaeskeykeySize/home/atharvakale/390r-debugging-setup/p7zip/C/Aes.c"Aes.h"UInt32[4]unsigned int[4]tempinoutdata + 4data + 8data + 12p[0] ^ out[0]p[1] ^ out[1]p[2] ^ out[2]p[3] ^ out[3]p[0]p[1]p[2]p[3]iv + i * 4Aes_DecodesmnumRounds2s[(0 - 0) & 3]s[(0 - 1) & 3]s[(0 - 2) & 3]s[(0 - 3) & 3]s[(1 - 0) & 3]s[(1 - 1) & 3]s[(1 - 2) & 3]s[(1 - 3) & 3]s[(2 - 0) & 3]s[(2 - 1) & 3]s[(2 - 2) & 3]s[(2 - 3) & 3]s[(3 - 0) & 3]s[(3 - 1) & 3]s[(3 - 2) & 3]s[(3 - 3) & 3]m[(0 - 0) & 3]m[(0 - 1) & 3]m[(0 - 2) & 3]m[(0 - 3) & 3]m[(1 - 0) & 3]m[(1 - 1) & 3]m[(1 - 2) & 3]m[(1 - 3) & 3]m[(2 - 0) & 3]m[(2 - 1) & 3]m[(2 - 2) & 3]m[(2 - 3) & 3]m[(3 - 0) & 3]m[(3 - 1) & 3]m[(3 - 2) & 3]m[(3 - 3) & 3]UInt32[1024]unsigned int[1024]256 * 4-1-2-3wdestsrcFD(0, 0)InvS[( (m[(0 - 0) & 3]) & 0xFF)]FD(0, 1)InvS[(((m[(0 - 1) & 3]) >> ( 8)) & 0xFF)]FD(0, 2)InvS[(((m[(0 - 2) & 3]) >> (16)) & 0xFF)]FD(0, 3)InvS[(((m[(0 - 3) & 3]) >> (24)))]Byte[256]unsigned char[256]FD(1, 0)InvS[( (m[(1 - 0) & 3]) & 0xFF)]FD(1, 1)InvS[(((m[(1 - 1) & 3]) >> ( 8)) & 0xFF)]FD(1, 2)InvS[(((m[(1 - 2) & 3]) >> (16)) & 0xFF)]FD(1, 3)InvS[(((m[(1 - 3) & 3]) >> (24)))]FD(2, 0)InvS[( (m[(2 - 0) & 3]) & 0xFF)]FD(2, 1)InvS[(((m[(2 - 1) & 3]) >> ( 8)) & 0xFF)]FD(2, 2)InvS[(((m[(2 - 2) & 3]) >> (16)) & 0xFF)]FD(2, 3)InvS[(((m[(2 - 3) & 3]) >> (24)))]FD(3, 0)InvS[( (m[(3 - 0) & 3]) & 0xFF)]FD(3, 1)InvS[(((m[(3 - 1) & 3]) >> ( 8)) & 0xFF)]FD(3, 2)InvS[(((m[(3 - 2) & 3]) >> (16)) & 0xFF)]FD(3, 3)InvS[(((m[(3 - 3) & 3]) >> (24)))]Aes_Encodes[(0 + 0) & 3]s[(0 + 1) & 3]s[(0 + 2) & 3]s[(0 + 3) & 3]s[(1 + 0) & 3]s[(1 + 1) & 3]s[(1 + 2) & 3]s[(1 + 3) & 3]s[(2 + 0) & 3]s[(2 + 1) & 3]s[(2 + 2) & 3]s[(2 + 3) & 3]s[(3 + 0) & 3]s[(3 + 1) & 3]s[(3 + 2) & 3]s[(3 + 3) & 3]m[(0 + 0) & 3]m[(0 + 1) & 3]m[(0 + 2) & 3]m[(0 + 3) & 3]m[(1 + 0) & 3]m[(1 + 1) & 3]m[(1 + 2) & 3]m[(1 + 3) & 3]m[(2 + 0) & 3]m[(2 + 1) & 3]m[(2 + 2) & 3]m[(2 + 3) & 3]m[(3 + 0) & 3]m[(3 + 1) & 3]m[(3 + 2) & 3]m[(3 + 3) & 3]FT(0, 0)Sbox[( (m[(0 + 0) & 3]) & 0xFF)]FT(0, 1)Sbox[(((m[(0 + 1) & 3]) >> ( 8)) & 0xFF)]FT(0, 2)Sbox[(((m[(0 + 2) & 3]) >> (16)) & 0xFF)]FT(0, 3)Sbox[(((m[(0 + 3) & 3]) >> (24)))]const Byte[256]FT(1, 0)Sbox[( (m[(1 + 0) & 3]) & 0xFF)]FT(1, 1)Sbox[(((m[(1 + 1) & 3]) >> ( 8)) & 0xFF)]FT(1, 2)Sbox[(((m[(1 + 2) & 3]) >> (16)) & 0xFF)]FT(1, 3)Sbox[(((m[(1 + 3) & 3]) >> (24)))]FT(2, 0)Sbox[( (m[(2 + 0) & 3]) & 0xFF)]FT(2, 1)Sbox[(((m[(2 + 1) & 3]) >> ( 8)) & 0xFF)]FT(2, 2)Sbox[(((m[(2 + 2) & 3]) >> (16)) & 0xFF)]FT(2, 3)Sbox[(((m[(2 + 3) & 3]) >> (24)))]FT(3, 0)Sbox[( (m[(3 + 0) & 3]) & 0xFF)]FT(3, 1)Sbox[(((m[(3 + 1) & 3]) >> ( 8)) & 0xFF)]FT(3, 2)Sbox[(((m[(3 + 2) & 3]) >> (16)) & 0xFF)]FT(3, 3)Sbox[(((m[(3 + 3) & 3]) >> (24)))]numwLimrconSbox[gb1(t)] ^ rconSbox[(((t) >> ( 8)) & 0xFF)] ^ rconSbox[gb2(t)]Sbox[(((t) >> (16)) & 0xFF)]Sbox[gb3(t)]Sbox[(((t) >> (24)))]Sbox[gb0(t)]Sbox[( (t) & 0xFF)]Sbox[gb1(t)]Sbox[(((t) >> ( 8)) & 0xFF)]0x1ba1a2a3a4aEa9aDaB128a8ecflagsprintf("\n===AES HW\n")printf("\n===vaes avx2\n")InvSDSboxTFD4(i)dest[i] = Ui32(FD(i, 0), FD(i, 1), FD(i, 2), FD(i, 3)) ^ w[i];FD(i,x)InvS[gb(x, m[(i - x) & 3])]HD16(m,s,p)HD4(m, 0, s, p); HD4(m, 1, s, p); HD4(m, 2, s, p); HD4(m, 3, s, p);HD4(m,i,s,p)m[i] = HD(i, 0, s) ^ HD(i, 1, s) ^ HD(i, 2, s) ^ HD(i, 3, s) ^ w[p + i];HD(i,x,s)DD(x)[gb(x, s[(i - x) & 3])]FT4(i)dest[i] = Ui32(FT(i, 0), FT(i, 1), FT(i, 2), FT(i, 3)) ^ w[i];FT(i,x)Sbox[gb(x, m[(i + x) & 3])]HT16(m,s,p)HT4(m, 0, s, p); HT4(m, 1, s, p); HT4(m, 2, s, p); HT4(m, 3, s, p);HT4(m,i,s,p)m[i] = HT(i, 0, s) ^ HT(i, 1, s) ^ HT(i, 2, s) ^ HT(i, 3, s) ^ w[p + i]HT(i,x,s)TT(x)[gb(x, s[(i + x) & 3])]_PRF(x)USE_HW_AESDD(x)(D + (x << 8))TT(x)(T + (x << 8))gb(n,x)gb ## n(x)gb3(x)(((x) >> (24)))gb2(x)(((x) >> (16)) & 0xFF)gb1(x)(((x) >> ( 8)) & 0xFF)gb0(x)( (x) & 0xFF)Ui32(a0,a1,a2,a3)((UInt32)(a0) | ((UInt32)(a1) << 8) | ((UInt32)(a2) << 16) | ((UInt32)(a3) << 24))xtime(x)((((x) << 1) ^ (((x) & 0x80) != 0 ? 0x1B : 0)) & 0xFF)defined(MY_CPU_ARM_OR_ARM64) && defined(MY_CPU_LE)defined(__clang__)(__clang_major__ >= 8)defined(__GNUC__)(__GNUC__ >= 6)_MSC_VER >= 1910_SHOW_AES_STATUSMY_CPU_LE_UNALIGN// MY_FORCE_INLINE/* Aes_Encode and Aes_Decode functions work with little-endian words.
  src and dest are pointers to 4 UInt32 words.
  src and dest can point to same block */// #pragma message ("AES HW")// fix that check// #define _SHOW_AES_STATUS/* Aes.c -- AES encryption / decryption
2021-05-13 : Igor Pavlov : Public domain *//usr/lib/gcc/x86_64-redhat-linux/12/include/wmmintrin.h/usr/lib/gcc/x86_64-redhat-linux/12/include/emmintrin.h/usr/lib/gcc/x86_64-redhat-linux/12/include/xmmintrin.h/usr/lib/gcc/x86_64-redhat-linux/12/include/mmintrin.h/usr/lib/gcc/x86_64-redhat-linux/12/include/mm_malloc.h/usr/include/stdlib.h30/usr/include/bits/waitflags.h31/usr/include/bits/waitstatus.h32/usr/include/bits/floatn.h33/usr/include/bits/floatn-common.h3435/usr/include/sys/types.h/usr/include/bits/types.h37383940/usr/include/bits/typesizes.h41/usr/include/bits/time64.h42/usr/include/bits/types/clock_t.h43/usr/include/bits/types/clockid_t.h44/usr/include/bits/types/time_t.h45/usr/include/bits/types/timer_t.h4647/usr/include/bits/stdint-intn.h48/usr/include/endian.h49/usr/include/bits/endian.h50/usr/include/bits/endianness.h51/usr/include/bits/byteswap.h52/usr/include/bits/uintn-identity.h53/usr/include/sys/select.h54/usr/include/bits/select.h55/usr/include/bits/types/sigset_t.h56/usr/include/bits/types/__sigset_t.h57/usr/include/bits/types/struct_timeval.h58/usr/include/bits/types/struct_timespec.h59/usr/include/bits/pthreadtypes.h60/usr/include/bits/thread-shared-types.h61/usr/include/bits/pthreadtypes-arch.h6263/usr/include/bits/atomic_wide_counter.h/usr/include/bits/struct_mutex.h65/usr/include/bits/struct_rwlock.h66/usr/include/alloca.h6768/usr/include/bits/stdlib-bsearch.h69/usr/include/bits/stdlib-float.h7071/usr/lib/gcc/x86_64-redhat-linux/12/include/immintrin.h72/usr/lib/gcc/x86_64-redhat-linux/12/include/x86gprintrin.h73/usr/lib/gcc/x86_64-redhat-linux/12/include/ia32intrin.h7475/usr/lib/gcc/x86_64-redhat-linux/12/include/adxintrin.h76/usr/lib/gcc/x86_64-redhat-linux/12/include/bmiintrin.h77/usr/lib/gcc/x86_64-redhat-linux/12/include/bmi2intrin.h78/usr/lib/gcc/x86_64-redhat-linux/12/include/cetintrin.h79/usr/lib/gcc/x86_64-redhat-linux/12/include/cldemoteintrin.h80/usr/lib/gcc/x86_64-redhat-linux/12/include/clflushoptintrin.h81/usr/lib/gcc/x86_64-redhat-linux/12/include/clwbintrin.h82/usr/lib/gcc/x86_64-redhat-linux/12/include/clzerointrin.h83/usr/lib/gcc/x86_64-redhat-linux/12/include/enqcmdintrin.h84/usr/lib/gcc/x86_64-redhat-linux/12/include/fxsrintrin.h85/usr/lib/gcc/x86_64-redhat-linux/12/include/lzcntintrin.h86/usr/lib/gcc/x86_64-redhat-linux/12/include/lwpintrin.h87/usr/lib/gcc/x86_64-redhat-linux/12/include/movdirintrin.h88/usr/lib/gcc/x86_64-redhat-linux/12/include/mwaitintrin.h89/usr/lib/gcc/x86_64-redhat-linux/12/include/mwaitxintrin.h90/usr/lib/gcc/x86_64-redhat-linux/12/include/pconfigintrin.h91/usr/lib/gcc/x86_64-redhat-linux/12/include/popcntintrin.h92/usr/lib/gcc/x86_64-redhat-linux/12/include/pkuintrin.h93/usr/lib/gcc/x86_64-redhat-linux/12/include/rdseedintrin.h94/usr/lib/gcc/x86_64-redhat-linux/12/include/rtmintrin.h95/usr/lib/gcc/x86_64-redhat-linux/12/include/serializeintrin.h96/usr/lib/gcc/x86_64-redhat-linux/12/include/sgxintrin.h97/usr/lib/gcc/x86_64-redhat-linux/12/include/tbmintrin.h98/usr/lib/gcc/x86_64-redhat-linux/12/include/tsxldtrkintrin.h99/usr/lib/gcc/x86_64-redhat-linux/12/include/uintrintrin.h100/usr/lib/gcc/x86_64-redhat-linux/12/include/waitpkgintrin.h101/usr/lib/gcc/x86_64-redhat-linux/12/include/wbnoinvdintrin.h102/usr/lib/gcc/x86_64-redhat-linux/12/include/xsaveintrin.h103/usr/lib/gcc/x86_64-redhat-linux/12/include/xsavecintrin.h104/usr/lib/gcc/x86_64-redhat-linux/12/include/xsaveoptintrin.h105/usr/lib/gcc/x86_64-redhat-linux/12/include/xsavesintrin.h106/usr/lib/gcc/x86_64-redhat-linux/12/include/xtestintrin.h107/usr/lib/gcc/x86_64-redhat-linux/12/include/hresetintrin.h108/usr/lib/gcc/x86_64-redhat-linux/12/include/pmmintrin.h109/usr/lib/gcc/x86_64-redhat-linux/12/include/tmmintrin.h110/usr/lib/gcc/x86_64-redhat-linux/12/include/smmintrin.h111/usr/lib/gcc/x86_64-redhat-linux/12/include/avxintrin.h112/usr/lib/gcc/x86_64-redhat-linux/12/include/avxvnniintrin.h113/usr/lib/gcc/x86_64-redhat-linux/12/include/avx2intrin.h114/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512fintrin.h115/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512erintrin.h116/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512pfintrin.h117/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512cdintrin.h118/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vlintrin.h119/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512bwintrin.h120/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512dqintrin.h121/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vlbwintrin.h122/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vldqintrin.h123/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512ifmaintrin.h124/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512ifmavlintrin.h125/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vbmiintrin.h126/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vbmivlintrin.h127/usr/lib/gcc/x86_64-redhat-linux/12/include/avx5124fmapsintrin.h/usr/lib/gcc/x86_64-redhat-linux/12/include/avx5124vnniwintrin.h129/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vpopcntdqintrin.h130/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vbmi2intrin.h131/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vbmi2vlintrin.h132/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vnniintrin.h133/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vnnivlintrin.h134/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vpopcntdqvlintrin.h135/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512bitalgintrin.h136/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vp2intersectintrin.h137/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512vp2intersectvlintrin.h138/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512fp16intrin.h139/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512fp16vlintrin.h140/usr/lib/gcc/x86_64-redhat-linux/12/include/shaintrin.h141/usr/lib/gcc/x86_64-redhat-linux/12/include/fmaintrin.h142/usr/lib/gcc/x86_64-redhat-linux/12/include/f16cintrin.h143144/usr/lib/gcc/x86_64-redhat-linux/12/include/gfniintrin.h145/usr/lib/gcc/x86_64-redhat-linux/12/include/vaesintrin.h146/usr/lib/gcc/x86_64-redhat-linux/12/include/vpclmulqdqintrin.h147/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512bf16vlintrin.h148/usr/lib/gcc/x86_64-redhat-linux/12/include/avx512bf16intrin.h149/usr/lib/gcc/x86_64-redhat-linux/12/include/amxtileintrin.h150/usr/lib/gcc/x86_64-redhat-linux/12/include/amxint8intrin.h151/usr/lib/gcc/x86_64-redhat-linux/12/include/amxbf16intrin.h152/usr/lib/gcc/x86_64-redhat-linux/12/include/prfchwintrin.h153/usr/lib/gcc/x86_64-redhat-linux/12/include/keylockerintrin.h154/home/atharvakale/390r-debugging-setup/p7zip/C/AesOpt.c<immintrin.h><wmmintrin.h>target"aes,vaes,avx2"ctrnumRoundsconst __m128iconst __m128i *__attribute((vector_size(16))) long long *dataEndonectr2twoAVX__CTR_LOOP_STARTctr2 = _mm256_setr_m128i(_mm_sub_epi64(ctr, one), ctr); two = _mm256_setr_m128i(one, one); two = _mm256_add_epi64(two, two);AVX__DECLARE_VARm0m1m2m3m4m5m6m7AVX__CTR_START_mm256_add_epi64AVX__AES_ENC_mm256_aesenc_epi128AVX__AES_ENC_LAST_mm256_aesenclast_epi128AVX__CTR_END((__m256i *)(void *)data)[0]_mm256_xor_si256((__m256i *)(void *)data)[1]((__m256i *)(void *)data)[2]((__m256i *)(void *)data)[3]((__m256i *)(void *)data)[4]((__m256i *)(void *)data)[5]((__m256i *)(void *)data)[6]((__m256i *)(void *)data)[7]AVX__CTR_LOOP_ENCctr = _mm256_extracti128_si256 (ctr2, 1);__m256i[15]__attribute((vector_size(32))) long long__attribute((vector_size(32))) long long[15]keysii__m256i *__attribute((vector_size(32))) long long *const __m256iconst __m256i *const int_mm_add_epi64_mm_aesenc_si128w[0]w[1]_mm_aesenclast_si128*data_mm_xor_si128__m128i *__attribute((vector_size(16))) long long;AVX__LOAD_dataAVX__AES_XORAVX__AES_DEC_mm256_aesdec_epi128AVX__AES_DEC_LAST_mm256_aesdeclast_epi128_mm256_setr_m128i(iv, data[0])AVX__XOR_data_M1(((const __m256i *)(const void *)(data - 1))[1])(((const __m256i *)(const void *)(data - 1))[2])(((const __m256i *)(const void *)(data - 1))[3])(((const __m256i *)(const void *)(data - 1))[4])(((const __m256i *)(const void *)(data - 1))[5])(((const __m256i *)(const void *)(data - 1))[6])(((const __m256i *)(const void *)(data - 1))[7])AVX__STORE_dataNUM_WAYS_mm_aesdec_si128_mm_aesdeclast_si128"aes"numRoundsMinus2DECLARE_VARCTR_STARTAES_XORAES_ENCAES_ENC_LASTCTR_ENDdata[0]data[1]data[2]data[3]data[4]data[5]data[6]data[7]wStartLOAD_dataAES_DECAES_DEC_LASTXOR_data_M1data[1- 1]data[2- 1]data[3- 1]data[4- 1]data[5- 1]data[6- 1]data[7- 1]STORE_datak0k1VAES_FUNC_START2(name)AES_FUNC_START (name); ATTRIB_VAES AES_FUNC_START (name)WIDE_LOOP_END_AVX(OP)data += NUM_WAYS * 2; } while (data <= dataEnd); dataEnd += NUM_WAYS * 2; OP _mm256_zeroupper(); }WIDE_LOOP_START_AVX(OP)dataEnd = data + numBlocks; if (numBlocks >= NUM_WAYS * 2) { __m256i keys[NUM_AES_KEYS_MAX]; UInt32 ii; OP for (ii = 0; ii < numRounds; ii++) keys[ii] = _mm256_broadcastsi128_si256(p[ii]); dataEnd -= NUM_WAYS * 2; do {NUM_AES_KEYS_MAXSINGLE_LOOPfor (; data < dataEnd; data++)WIDE_LOOP_ENDdata += NUM_WAYS; } while (data <= dataEnd); dataEnd += NUM_WAYS; }WIDE_LOOP_STARTdataEnd = data + numBlocks; if (numBlocks >= NUM_WAYS) { dataEnd -= NUM_WAYS; do {AVX__WOP_KEY(op,n){ const __m256i key = w[n]; WOP(op); }WOP_KEY(op,n){ const __m128i key = w[n]; WOP(op); }AVX__CTR_END(reg,ii)AVX_XOR (((__m256i *)(void *)data)[ii], reg);AVX__CTR_START(reg,ii)MM_OP (_mm256_add_epi64, ctr2, two); reg = _mm256_xor_si256(ctr2, key);CTR_END(reg,ii)MM_XOR (data[ii], reg);CTR_START(reg,ii)MM_OP (_mm_add_epi64, ctr, one); reg = ctr;AVX__AES_XOR(reg,ii)MM_OP_key (_mm256_xor_si256, reg)AVX__AES_ENC_LAST(reg,ii)MM_OP_key (_mm256_aesenclast_epi128, reg)AVX__AES_ENC(reg,ii)MM_OP_key (_mm256_aesenc_epi128, reg)AVX__AES_DEC_LAST(reg,ii)MM_OP_key (_mm256_aesdeclast_epi128, reg)AVX__AES_DEC(reg,ii)MM_OP_key (_mm256_aesdec_epi128, reg)AES_XOR(reg,ii)MM_OP_key (_mm_xor_si128, reg)AES_ENC_LAST(reg,ii)MM_OP_key (_mm_aesenclast_si128, reg)AES_ENC(reg,ii)MM_OP_key (_mm_aesenc_si128, reg)AES_DEC_LAST(reg,ii)MM_OP_key (_mm_aesdeclast_si128, reg)AES_DEC(reg,ii)MM_OP_key (_mm_aesdec_si128, reg)MM_OP_key(op,reg)MM_OP(op, reg, key);AVX__XOR_data_M1(reg,ii)AVX_XOR (reg, (((const __m256i *)(const void *)(data - 1))[ii]));AVX__STORE_data(reg,ii)((__m256i *)(void *)data)[ii] = reg;AVX__LOAD_data(reg,ii)reg = ((const __m256i *)(const void *)data)[ii];AVX__DECLARE_VAR(reg,ii)__m256i regXOR_data_M1(reg,ii)MM_XOR (reg, data[ii- 1]);STORE_data(reg,ii)data[ii] = reg;LOAD_data(reg,ii)reg = data[ii];DECLARE_VAR(reg,ii)__m128i regWOP(op)op (m0, 0); WOP_M1(op)WOP_M1WOP_8WOP_8(op)WOP_7 (op) op (m7, 7);WOP_7(op)WOP_6 (op) op (m6, 6);WOP_6(op)WOP_5 (op) op (m5, 5);WOP_5(op)WOP_4 (op) op (m4, 4);WOP_4(op)WOP_3 (op) op (m3, 3);WOP_3(op)WOP_2 (op) op (m2, 2);WOP_2(op)WOP_1 (op) op (m1, 1);WOP_1(op)AVX_XOR(dest,src)MM_OP(_mm256_xor_si256, dest, src);MM_XOR(dest,src)MM_OP(_mm_xor_si128, dest, src);MM_OP_m(op,src)MM_OP(op, m, src);MM_OP(op,dest,src)dest = op(dest, src);AES_FUNC_START2(name)AES_FUNC_START (name); ATTRIB_AES AES_FUNC_START (name)AES_FUNC_START(name)void MY_FAST_CALL name(__m128i *p, __m128i *data, size_t numBlocks)ATTRIB_VAES__attribute__((__target__("aes,vaes,avx2")))USE_INTEL_VAESATTRIB_AES__attribute__((__target__("aes")))USE_INTEL_AES__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >= 8)(__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)__AES__(__GNUC__ >= 8)defined(__INTEL_COMPILER)(__INTEL_COMPILER >= 1110)(__INTEL_COMPILER >= 1900)(_MSC_VER > 1500) || (_MSC_FULL_VER >= 150030729)MY_CPU_AMD64(NUM_WAYS > 1)defined(__clang__) && defined(_MSC_VER)defined(__clang__) || defined(__GNUC__)MY_CPU_ARM64defined(_MSC_VER) && defined(MY_CPU_ARM64)// MY_CPU_ARM_OR_ARM64// USE_HW_AES// for arm32// _MSC_VER// #pragma message("=== AES HW === ")// ! USE_INTEL_VAES// USE_INTEL_AES/* no USE_INTEL_AES */// USE_INTEL_VAES// two = _mm256_setr_epi64x(2, 0, 2, 0);/*
SSE2: _mm_cvtsi32_si128 : movd
AVX:  _mm256_setr_m128i            : vinsertf128
AVX2: _mm256_add_epi64             : vpaddq ymm, ymm, ymm
      _mm256_extracti128_si256     : vextracti128
      _mm256_broadcastsi128_si256  : vbroadcasti128
*//* MSVC for x86: If we don't call _mm256_zeroupper(), and -arch:IA32 is not specified,
   MSVC still can insert vzeroupper instruction. *//*
#define WOP_9(op)   WOP_8 (op)  op (m8, 8);
#define WOP_10(op)  WOP_9 (op)  op (m9, 9);
#define WOP_11(op)  WOP_10(op)  op (m10, 10);
#define WOP_12(op)  WOP_11(op)  op (m11, 11);
#define WOP_13(op)  WOP_12(op)  op (m12, 12);
#define WOP_14(op)  WOP_13(op)  op (m13, 13);
*//* AesOpt.c -- AES optimized code for x86 AES hardware instructions
2021-04-01 : Igor Pavlov : Public domain *//usr/include/stdio.h<bits/stdio.h><bits/floatn.h><bits/stdio_lim.h><bits/types/struct_FILE.h><bits/types/FILE.h><bits/types/__FILE.h><bits/types/__fpos64_t.h><bits/types/__fpos_t.h><bits/types.h><stdarg.h><bits/libc-header-start.h>__overflowFILE *_IO_FILE *__uflowfunlockfileftrylockfileflockfilectermidpopenconst charconst char *pclosefileno_unlockedfilenoperrorclearerr_unlockedferrorfeofclearerrfsetposconst fpos_tconst fpos_t *_G_fpos64_t *fgetposFILE *__restrict__fpos_t *fpos_t *__restrict__ftellofseekorewindftellfseekfwrite_unlockedfread_unlockedfwritefreadungetcputsfputsconst char *__restrict__getlinechar **char **__restrict__size_t *__restrict__getdelim__getdelimfgetschar *__restrict__putwgetwputcfputcgetcfgetcvsscanfvscanfvfscanfsscanfscanffscanfdprintfvdprintfvsnprintfsnprintfvsprintfvfprintfsprintfprintffprintfsetlinebufsetbuffersetvbufsetbufopen_memstreamfmemopenfdopenfreopenfopenfflush_unlockedfflushtempnamtmpnam_rchar[20]L_tmpnamtmpnamtmpfilefcloserenameatrenameremovefpos_tssize_toff_tva_list__va_list_tag[1]stderrstdoutstdin__attr_dealloc_fclose__attr_dealloc (fclose, 1)P_tmpdir"/tmp"SEEK_ENDSEEK_CURSEEK_SETEOF(-1)BUFSIZ8192_IONBF_IOLBF_IOFBF__ssize_t_defined__off_t_defined_VA_LIST_DEFINED__need___va_list__need_NULL__need_size_t__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION_STDIO_Hdefined __USE_XOPEN || defined __USE_XOPEN2K8defined __USE_UNIX98 || defined __USE_XOPEN2Kdefined __USE_LARGEFILE64 && !defined __off64_t_defineddefined __USE_MISC || defined __USE_XOPEN__GLIBC_USE (ISOC2X)__REDIRECTdefined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2)_WCHAR_Hdefined __USE_ISOC99 || defined __USE_UNIX98__GLIBC_USE (LIB_EXT2)!__GLIBC_USE (DEPRECATED_SCANF) && !defined __LDBL_COMPAT \!__GLIBC_USE (DEPRECATED_SCANF)defined __REDIRECT && !defined __LDBL_COMPAT \!defined __REDIRECTdefined __USE_MISC \__GLIBC_USE (DEPRECATED_GETS)defined __USE_LARGEFILE || defined __USE_XOPEN2K(defined __USE_XOPEN && !defined __USE_XOPEN2K) || defined __USE_GNUdefined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU__USE_FORTIFY_LEVEL > 0 && defined __fortify_functiondefined __LDBL_COMPAT || __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1nothrowleafaccess__write_only__,mallocintferror_unlockedgnu_inlinefeof_unlocked(FILE *__stream, const fpos_t *__pos)fsetpos64(FILE *__restrict __stream, fpos_t *__restrict __pos)fgetpos64(FILE *__stream)ftello64(FILE *__stream, __off64_t __off, int __whence)fseeko64putchar_unlockedputc_unlockedfputc_unlockedputcharfgetc_unlockedgetchar_unlockedgetc_unlockedgetcharformat__scanf__(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg)__isoc99_vsscanf(const char *__restrict __format, __gnuc_va_list __arg)__isoc99_vscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg)__isoc99_vfscanf(const char *__restrict __s, const char *__restrict __format, ...)__isoc99_sscanf(const char *__restrict __format, ...)__isoc99_scanf(FILE *__restrict __stream, const char *__restrict __format, ...)__isoc99_fscanf__printf__vprintf(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream)freopen64(const char *__restrict __filename, const char *__restrict __modes)fopen64(void)tmpfile64LIB_EXT2"freopen64"__USER_LABEL_PREFIX__"fopen64"__builtin_free"tmpfile64"ISOC2X(__write_only__, 1)"fsetpos64""fgetpos64""ftello64""fseeko64"DEPRECATED_GETS(__write_only__, 1, 2)"__isoc99_vsscanf""__isoc99_vscanf""__isoc99_vfscanf"DEPRECATED_SCANF"__isoc99_sscanf""__isoc99_scanf""__isoc99_fscanf"/* <stdio.h> included.  *//* Now include the function definitions and redirects too.  *//* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  *//* The following headers provide asm redirections.  These redirections must
   appear before the first usage of these functions, e.g. in bits/stdio.h.  *//* Declare all functions from bits/stdio2-decl.h first.  *//* Slow-path routines used by the optimized inline functions in
   bits/stdio.h.  *//*  X/Open Issues 1-5 required getopt to be declared in this
   header.  It was removed in Issue 6.  GNU follows Issue 6.  *//* POSIX *//* Relinquish the ownership granted for STREAM.  *//* Try to acquire ownership of STREAM but do not block if it is not
   possible.  *//* Acquire ownership of STREAM.  *//* These are defined in POSIX.1:1996.  *//* Use GNU.  *//* Write formatted output to an obstack.  *//* See <obstack.h>.  *//* Use X/Open, but not issue 6.  *//* Return the name of the current user.  *//* Use POSIX.  *//* Return the name of the controlling terminal.  *//* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Faster version when locking is not required.  *//* Return the system file descriptor for STREAM.  *//* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Faster versions when locking is not required.  *//* Return the error indicator for STREAM.  *//* Return the EOF indicator for STREAM.  *//* Clear the error and EOF indicators for STREAM.  *//* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  *//* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  *//* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  *//* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Get a newline-terminated string from stdin, removing the newline.

   This function is impossible to use safely.  It has been officially
   removed from ISO C11 and ISO C++14, and we have also removed it
   from the _GNU_SOURCE feature list.  It remains available when
   explicitly using an old ISO C, Unix, or POSIX standard.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a word (int) to STREAM.  *//* Get a word (int) from STREAM.  *//* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  *//* Use MISC.  *//* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  *//* Use ISO C9x.  *//* Same redirection as above for the v*scanf family.  *//* Read formatted input from S into argument list ARG.  *//* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* For historical reasons, the C99-compliant versions of the scanf
   functions are at alternative names.  When __LDBL_COMPAT or
   __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI are in effect, this is handled in
   bits/stdio-ldbl.h.  *//* Read formatted input from S.  *//* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write formatted output to a file descriptor.  *//* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  *//* Maximum chars of output to write in MAXLEN.  *//* Write formatted output to S from argument list ARG.  *//* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write formatted output to S.  *//* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Make STREAM line-buffered.  *//* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  *//* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  *//* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  *//* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  Declared here only to add attribute malloc
   and only if <wchar.h> has been previously #included.  *//* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  *//* Create a new stream that refers to a memory buffer.  *//* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  *//* Create a new stream that refers to an existing system file descriptor.  *//* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  *//* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  *//* Generate a temporary filename.  *//* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Rename file OLD relative to OLDFD to NEW relative to NEWFD, with
   additional flags.  *//* Flags for renameat2.  *//* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  *//* Rename file OLD to NEW.  *//* Remove file FILENAME.  *//* C89/C99 say they're macros.  Make them happy.  *//* Standard error output stream.  *//* Standard output stream.  *//* Standard input stream.  *//* Standard streams.  *//* Maximum length of printf output for a NaN.  *//* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  *//* Default path prefix for `tempnam' and `tmpnam'.  *//* Seek to next hole.  *//* Seek to next data.  *//* Seek from end of file.  *//* Seek from current position.  *//* Seek from beginning of file.  *//* The possibilities for the third argument to `fseek'.
   These values should not be changed.  *//* The value returned by fgetc and similar functions to indicate the
   end of the file.  *//* Default buffer size.  *//* No buffering.  *//* Line buffered.  *//* Fully buffered.  *//* The possibilities for the third argument to `setvbuf'.  *//* The type of the second argument to `fgetpos' and `fsetpos'.  *//*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 *//* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__stream__s__command__modes__pos__off__whence__ptr__size__n__c__lineptr__delimiter__w__format__arg__fd__fmt__maxlen__buf__bufloc__sizeloc__len__filename__dir__pfx__oldfd__old__newfd__new<bits/pthreadtypes.h><sys/select.h><endian.h><bits/stdint-intn.h><bits/types/timer_t.h><bits/types/time_t.h><bits/types/clockid_t.h><bits/types/clock_t.h><features.h>fsfilcnt_tfsblkcnt_tblkcnt_tblksize_tregister_tmode__word__u_int64_tu_int32_tu_int16_tu_int8_tuintushortulongkey_tcaddr_tdaddr_tid_tpid_tuid_tnlink_tmode_tgid_tdev_tino_tloff_tfsid_tu_quad_tquad_tu_longu_intu_shortu_char__fsfilcnt_t_defined__fsblkcnt_t_defined__blkcnt_t_defined__blksize_t_defined__BIT_TYPES_DEFINED____key_t_defined__daddr_t_defined__id_t_defined__pid_t_defined__uid_t_defined__nlink_t_defined__mode_t_defined__gid_t_defined__dev_t_defined__ino_t_defined__u_char_defined_SYS_TYPES_Hdefined __USE_LARGEFILE64 && !defined __ino64_t_defined(defined __USE_XOPEN || defined __USE_XOPEN2K8) \(defined __USE_MISC || defined __USE_XOPEN) && !defined __key_t_defined__useconds_t_defined__suseconds_t_defined__GNUC_PREREQ (2, 7)(defined __USE_UNIX98 || defined __USE_XOPEN2K8) \defined __USE_POSIX199506 || defined __USE_UNIX98/* sys/types.h *//* Now add the thread types.  *//* Type to count file system inodes.  *//* Type to count file system blocks.  *//* Type to count number of disk blocks. *//* Type to count number of disk blocks.  *//* Types from the Large File Support interface.  *//* Use misc.  *//* It also defines `fd_set' and the FD_* macros for `select'.  *//* In BSD <sys/types.h> is expected to define BYTE_ORDER.  *//* Some code from BIND tests this macro to see if the types above are
   defined.  *//* These were defined by ISO C without the first `_'.  *//* These size-specific names are used by some of the inet code.  *//* Old compatibility names for C types.  *//*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 *//usr/include/sys<bits/stdlib-float.h><bits/stdlib-bsearch.h><alloca.h><sys/types.h><bits/waitstatus.h><bits/waitflags.h>getloadavgdouble[]getsuboptchar *constchar *const *char *const *__restrict__rpmatchwcstombsconst wchar_tconst wchar_t *int *const wchar_t *__restrict__mbstowcswchar_t *wchar_t *__restrict__wctombmbtowcmblenqfcvt_rint *__restrict__qecvt_rfcvt_recvt_rqgcvtqfcvtqecvtgcvtfcvtecvtlldivldivdivllabslabsabsqsortrealpathsystemmkdtempmkstempsmkstempmktempclearenvunsetenvsetenvputenvgetenv_Exitquick_exitexiton_exitat_quick_exitatexitabortaligned_allocposix_memalignvallocreallocarrayfreerealloccallocarc4random_uniformarc4random_bufarc4randomlcong48_runsigned short[7]drand48_data *seed48_runsigned short[3]srand48_rjrand48_rdrand48_data *__restrict__long *long *__restrict__mrand48_rnrand48_rlrand48_rerand48_rdouble *double *__restrict__drand48_rlcong48unsigned short *seed48srand48jrand48mrand48nrand48lrand48erand48drand48rand_rsrandrandsetstate_rrandom_data *random_data *__restrict__initstate_rsrandom_rrandom_rint32_t *signed int *int32_t *__restrict__setstateinitstatesrandomrandoma64ll64along longatollatoll (const char *__nptr)(char **) NULLlongatolatol (const char *__nptr)atoiatoi (const char *__nptr)strtoullstrtollstrtouqstrtoqstrtoulstrtolstrtoldstrtofstrtod__ctype_get_mb_cur_max__compar_fn_tdrand48_datarandom_datalldiv_tldiv_tdiv_t__a__init__old_x__xend_ptrrand_seprand_degrand_typestaterptrfptrquot__COMPAR_FN_TMB_CUR_MAX(__ctype_get_mb_cur_max ())EXIT_SUCCESSEXIT_FAILURERAND_MAX2147483647__lldiv_t_defined__ldiv_t_definedWIFCONTINUED(status)__WIFCONTINUED (status)WIFSTOPPED(status)__WIFSTOPPED (status)WIFSIGNALED(status)__WIFSIGNALED (status)WIFEXITED(status)__WIFEXITED (status)WSTOPSIG(status)__WSTOPSIG (status)WTERMSIG(status)__WTERMSIG (status)WEXITSTATUS(status)__WEXITSTATUS (status)_STDLIB_H__need_wchar_t(defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H__WIFCONTINUEDdefined __USE_ISOC99 && !defined __lldiv_t_defined__HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)__GLIBC_USE (IEC_60559_BFP_EXT_C2X)__HAVE_FLOAT16__HAVE_FLOAT32__HAVE_FLOAT64__HAVE_FLOAT128__HAVE_FLOAT32X__HAVE_FLOAT64X__HAVE_FLOAT128Xdefined __USE_MISC || defined __USE_XOPEN_EXTENDED(defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \defined __USE_ISOC11 || defined __USE_ISOCXX11defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8(defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K(1)nonnull(1, 2, 3)__read_only__(3, 4, 5)(3)(3, 4)const(1, 4)bsearch(1, 2, 5)(char *__template, int __suffixlen)mkstemps64(char *__template)mkstemp64(2)noreturnalloc_alignalloc_sizewarn_unused_result(2, 3)(1, 2)(2, 4)puredoubleatof"mkstemps64""mkstemp64"(__read_only__, 2)(__write_only__, 1, 3)IEC_60559_TYPES_EXTIEC_60559_BFP_EXT_C2X/* stdlib.h  *//* Define some macros helping to catch buffer overflows.  *//* Return the index into the active-logins file (utmp) for
   the controlling terminal.  *//* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  *//* Open a master pseudo terminal and return its file descriptor.  *//* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  *//* Return the pathname of the pseudo terminal slave associated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  *//* Release an internal lock so the slave can be opened.
   Call after grantpt().  *//* Chown the slave to the calling user.  *//* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  *//* Return a master pseudo-terminal handle.  *//* X/Open pseudo terminal handling.  *//* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  *//* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  *//* Convert a wide char string to multibyte string.  *//* Convert a multibyte string to a wide char string.  *//* Put the multibyte character represented
   by WCHAR in S, returning its length.  *//* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  *//* Return the length of the multibyte character
   in S, which is no longer than N.  *//* misc *//* Reentrant version of the functions above which provide their own
   buffers.  *//* Long double versions of above functions.  *//* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  *//* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  *//* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  *//* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  *//* GCC may have built-ins for these someday.  *//* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. *//* Return the absolute value of X.  *//* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  *//* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  *//* Shorthand for type of comparison functions.  *//* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  *//* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  *//* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  *//* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Always returns TEMPLATE, it's either a temporary file name or a null
   string if it cannot get a unique file name.  *//* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  *//* Remove the variable NAME from the environment.  *//* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  *//* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  *//* The SVID says this is in <stdio.h>, but this seems a better place.	*//* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  *//* Return the value of envariable NAME, or NULL if it doesn't exist.  *//* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  *//* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  *//* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  *//* Register a function to be called with the status
   given to `exit' and the given argument.  *//* Register a function to be called when `quick_exit' is called.  *//* Register a function to be called when `exit' is called.  *//* Abort execution and generate a core-dump.  *//* ISO C variant of aligned allocation.  *//* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  *//* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  *//* Add reallocarray as its own deallocator.  *//* __attribute_malloc__ is not used, because if reallocarray returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  *//* Re-allocate the previously allocated block in PTR, making the new
   block large enough for NMEMB elements of SIZE bytes each.  *//* Free a block allocated by `malloc', `realloc' or `calloc'.  *//* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  *//* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  *//* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  *//* Allocate SIZE bytes of memory.  *//* Use misc or X/Open.  *//* Return a random number between zero (inclusive) and the specified
   limit (exclusive).  *//* Fill the buffer with random data.  *//* Return a random integer between zero and 2**32-1 (inclusive).  *//* Seed random number generator.  *//* Return signed, long integers in [-2^31,2^31).  *//* Return non-negative, long integer in [0,2^31).  *//* Return non-negative, double-precision floating-point value in [0.0,1.0).  *//* Factor in congruential
						   formula.  *//* Flag for initializing.  *//* Additive const. in congruential formula.  *//* Old state.  *//* Current state.  *//* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  *//* System V style 48-bit random number generator functions.  *//* Reentrant interface according to POSIX.1.  *//* Seed the random number generator with the given number.  *//* Return a random integer between 0 and RAND_MAX inclusive.  *//* Use extended X/Open || misc. *//* Pointer behind state table.  *//* Distance between front and rear.  *//* Degree of random number generator.  *//* Type of random number generator.  *//* Array of state values.  *//* Rear pointer.  *//* Front pointer.  *//* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  *//* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  *//* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  *//* Return a random long integer between 0 and 2^31-1 inclusive.  *//* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  *//* we need int32_t... *//* Use misc || extended X/Open.  *//* Read a number from a string S in base 64 as above.  *//* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  *//* Optimizing and Inlining.  *//* GNU *//* Parallel versions of the functions above which take the locale to
   use as an additional parameter.  These are GNU extensions inspired
   by the POSIX.1-2008 extended locale API.  *//* Convert a floating-point number to a string.  *//* ISO C99 or use MISC.  *//* Convert a string to an unsigned quadword integer.  *//* Convert a string to a quadword integer.  *//* Convert a string to an unsigned long integer.  *//* Convert a string to a long integer.  *//* Likewise for '_FloatN' and '_FloatNx'.  *//* Likewise for `float' and `long double' sizes of floating-point numbers.  *//* Convert a string to a floating-point number.  *//* Convert a string to a long long integer.  *//* Convert a string to an integer.  *//* Maximum length of a multibyte character in the current locale.  *//* Successful exit status.  *//* Failing exit status.  *//* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  *//* The largest number rand will return (same as INT_MAX).  *//* Remainder.  *//* Quotient.  *//* Returned by `lldiv'.  *//* Returned by `ldiv'.  *//* Returned by `div'.  *//* _FloatN API tests for enablement.  *//* X/Open or XPG7 and <sys/wait.h> not included.  *//* Define the macros <sys/wait.h> also would define this way.  *//* XPG requires a few symbols from <sys/wait.h> being defined.  *//* Get size_t, wchar_t and NULL from <stddef.h>.  *//*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 *//* Copyright (C) 1991-2022 Free Software Foundation, Inc.
   Copyright The GNU Toolchain Authors.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__nptr__loadavg__nelem__optionp__tokens__valuep__response__pwcs__wchar__pwc__value__ndigit__decpt__sign__numer__denom__base__nmemb__compar__key__name__resolved__template__suffixlen__replace__string__status__func__alignment__memptr__upper_bound__param__buffer__seed16v__seedval__xsubi__result__seed__statebuf__statelen__endptr/home/atharvakale/390r-debugging-setup/p7zip/C/Alloc.hCAlignOffsetAllocnumAlignBitsbaseAllocg_MidAllocg_AlignedAllocg_BigAllocBigFree(address)MyFree(address)BigAlloc(size)MyAlloc(size)MidFree(address)MidAlloc(size)__COMMON_ALLOC_HAlignOffsetAlloc_CreateVTableCAlignOffsetAlloc *g_AllocMyFreeMyAlloc/* (offset == (k * sizeof(void *)) && offset < (1 << numAlignBits) *//* ((1 << numAlignBits) >= sizeof(void *)) *//* Alloc.h -- Memory allocation functions
2021-07-13 : Igor Pavlov : Public domain */address/usr/lib/gcc/x86_64-redhat-linux/12/include/stdarg.h/usr/include/bits/types/__fpos_t.h/usr/include/bits/types/__mbstate_t.h/usr/include/bits/types/__fpos64_t.h/usr/include/bits/types/__FILE.h/usr/include/bits/types/FILE.h/usr/include/bits/types/struct_FILE.h/usr/include/bits/stdio_lim.h/usr/include/bits/stdio.h/home/atharvakale/390r-debugging-setup/p7zip/C/Alloc.c"Alloc.h"<stdlib.h><stdio.h>AlignOffsetAlloc_Free"- Aligned Free: "p->baseAllocREAL_BLOCK_PTR_VAR(address)((void **)((void *)((((UIntPtr)(address)) & ~((UIntPtr)(sizeof(void *)) - 1)))))[-1]sizeof(void *)-8AlignOffsetAlloc_AllocadrpAlignedextraalignSize(size_t)1NULLsizeof(void *) - 1(sizeof(void *) - 1)ADJUST_ALLOC_SIZE(char *)adr + alignSize - p->offset + extra + ADJUST_ALLOC_SIZE(char *)adr + alignSize - p->offset + extra + 0"- Aligned: "" size="" a_size="" ptr="" a_ptr="SzAlignedFreeSzAlignedAllocALLOC_ALIGN_SIZE" posix_memalign="SzFreeSzAlloc"Free    "g_allocCount"Alloc    "UIntPtrREAL_BLOCK_PTR_VAR(p)((void **)MY_ALIGN_PTR_DOWN_1(p))[-1]MY_ALIGN_PTR_DOWN_1(p)MY_ALIGN_PTR_DOWN(p, sizeof(void *))((size_t)1 << 7)USE_posix_memalignMY_ALIGN_PTR_DOWN(p,align)((void *)((((UIntPtr)(p)) & ~((UIntPtr)(align) - 1))))PrintAddr(p)PrintHex(v,align)PrintLn()Print(s)PRINT_FREE(name,cnt,ptr)PRINT_ALLOC(name,cnt,size,ptr)_SZ_ALLOC_DEBUG_7ZIP_LARGE_PAGESMEM_LARGE_PAGES!defined(_WIN32) && defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 200112L)/* also we can allocate additional dummy ALLOC_ALIGN_SIZE bytes after aligned
     block to prevent cache line sharing with another allocated blocks *//*
#define REAL_BLOCK_PTR_VAR(p) ((void **)(p))[-1]
*//* we align ptr to support cases where CAlignOffsetAlloc::offset is not multiply of sizeof(void *) *//*
  ALLOC_ALIGN_SIZE >= sizeof(void *)
  ALLOC_ALIGN_SIZE >= cache_line_size
*//*
static int posix_memalign(void **ptr, size_t align, size_t size)
{
  size_t newSize = size + align;
  void *p;
  void *pAligned;
  *ptr = NULL;
  if (newSize < size)
    return 12; // ENOMEM
  p = MyAlloc(newSize);
  if (!p)
    return 12; // ENOMEM
  pAligned = MY_ALIGN_PTR_UP_PLUS(p, align);
  ((void **)pAligned)[-1] = p;
  *ptr = pAligned;
  return 0;
}
*//*
  This posix_memalign() is for test purposes only.
  We also need special Free() function instead of free(),
  if this posix_memalign() is used.
*//*
#define MY_ALIGN_PTR_DOWN(p, align) ((void *)((char *)(p) - ((size_t)(UIntPtr)(p) & ((align) - 1))))
*//*
  Use (ADJUST_ALLOC_SIZE = (sizeof(void *) - 1)), if
     MyAlloc() can return address that is NOT multiple of sizeof(void *).
*//*
#define ADJUST_ALLOC_SIZE (sizeof(void *) - 1)
*//*
  typedef uintptr_t UIntPtr;
  *//*
  uintptr_t : <stdint.h> C99 (optional)
            : unsupported in VS6
*/// _7ZIP_LARGE_PAGES// PRINT_ALLOC("Alloc    ", g_allocCount, size, p);/* use _SZ_ALLOC_DEBUG to debug alloc/free operations *//* #define _SZ_ALLOC_DEBUG *//* Alloc.c -- Memory allocation functions
2021-07-13 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Bcj2.hBcj2Enc_EncodeCBcj2Enc *Bcj2Enc_InitCBcj2EncEBcj2Enc_FinishModeBCJ2_ENC_FINISH_MODE_CONTINUEBCJ2_ENC_FINISH_MODE_END_BLOCKBCJ2_ENC_FINISH_MODE_END_STREAMCBcj2DecBCJ2_ENC_STATE_ORIGBCJ2_NUM_STREAMSBCJ2_ENC_STATE_OKBCJ2_DEC_STATE_ORIG_0BCJ2_DEC_STATE_ORIG_1BCJ2_DEC_STATE_ORIG_2BCJ2_DEC_STATE_ORIG_3BCJ2_DEC_STATE_ORIGBCJ2_DEC_STATE_OKBCJ2_STREAM_MAINBCJ2_STREAM_CALLBCJ2_STREAM_JUMPBCJ2_STREAM_RCUInt16[258]unsigned short[258]2582 + 256probsflushPosByte[8]unsigned char[8]4 * 2tempPostempTargetrelatLimitfileSizefileIpipcacheSizelowrangecacheprevBytefinishModesrcLimconst Byte *[4]unsigned char *[4]limsByte *[4]bufscodeByte[4]unsigned char[4]destLimBCJ2_FileSize_MAX((UInt32)1 << 31)BCJ2_RELAT_LIMIT((UInt32)1 << BCJ2_RELAT_LIMIT_NUM_BITS)BCJ2_RELAT_LIMIT_NUM_BITSBcj2Enc_IsFinished(p)((p)->flushPos == 5)Bcj2Enc_Get_InputData_Size(p)((SizeT)((p)->srcLim - (p)->src) + (p)->tempPos)Bcj2Dec_IsFinished(_p_)((_p_)->code == 0)BCJ2_IS_32BIT_STREAM(s)((s) == BCJ2_STREAM_CALL || (s) == BCJ2_STREAM_JUMP)__BCJ2_HBcj2Dec_DecodeCBcj2Dec *Bcj2Dec_Init/* limit for CBcj2Enc::fileSize variable *//* (relatLimit <= ((UInt32)1 << 31)), 0 means desable_conversion *//* (fileSize <= ((UInt32)1 << 31)), 0 means no_limit *//* 32-bit ralative offset in JUMP/CALL commands is
       - (mod 4 GB)   in 32-bit mode
       - signed Int32 in 64-bit mode
     We use (mod 4 GB) check for fileSize.
     Use fileSize up to 2 GB, if you want to support 32-bit and 64-bit code conversion. *//* Returns: SZ_OK or SZ_ERROR_DATA *//* BCJ2_STREAM_MAIN has more priority than BCJ2_STATE_ORIG *//*
CBcj2Dec:
dest is allowed to overlap with bufs[BCJ2_STREAM_MAIN], with the following conditions:
  bufs[BCJ2_STREAM_MAIN] >= dest &&
  bufs[BCJ2_STREAM_MAIN] - dest >= tempReserv +
        BUF_SIZE(BCJ2_STREAM_CALL) +
        BUF_SIZE(BCJ2_STREAM_JUMP)
     tempReserv = 0 : for first call of Bcj2Dec_Decode
     tempReserv = 4 : for any other calls of Bcj2Dec_Decode
  overlap with offset = 1 is not allowed
*//*
CBcj2Dec / CBcj2Enc
bufs sizes:
  BUF_SIZE(n) = lims[n] - bufs[n]
bufs sizes for BCJ2_STREAM_CALL and BCJ2_STREAM_JUMP must be mutliply of 4:
    (BUF_SIZE(BCJ2_STREAM_CALL) & 3) == 0
    (BUF_SIZE(BCJ2_STREAM_JUMP) & 3) == 0
*//* Bcj2.h -- BCJ2 Converter for x86 code
2014-11-10 : Igor Pavlov : Public domain */CPU_IsSupported_PageGBCPU_IsSupported_SHACPU_IsSupported_SSE41CPU_IsSupported_SSSE3CPU_IsSupported_VAES_AVX2CPU_IsSupported_AVX2CPU_IsSupported_AESCPU_Is_InOrderx86cpuid_GetFirmconst Cx86cpuidconst Cx86cpuid *x86cpuid_CheckAndReadCx86cpuid *MyCPUIDCPU_FIRM_INTELCPU_FIRM_AMDCPU_FIRM_VIACx86cpuidbverUInt32[3]unsigned int[3]vendormaxFuncx86cpuid_GetStepping(ver)(ver & 0xF)x86cpuid_GetModel(ver)(((ver >> 12) & 0xF0) | ((ver >> 4) & 0xF))x86cpuid_GetFamily(ver)(((ver >> 16) & 0xFF0) | ((ver >> 8) & 0xF))GetBe16(p)( (UInt16) ( ((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1] ))SetBe32(p,v)(*(UInt32 *)(void *)(p)) = __builtin_bswap32(v)GetBe64(p)__builtin_bswap64(*(const UInt64 *)(const void *)(p))GetBe32(p)__builtin_bswap32(*(const UInt32 *)(const void *)(p))MY__has_builtin(x)__has_builtin(x)SetUi64(p,v){ *(UInt64 *)(void *)(p) = (v); }SetUi32(p,v){ *(UInt32 *)(void *)(p) = (v); }SetUi16(p,v){ *(UInt16 *)(void *)(p) = (v); }GetUi64(p)(*(const UInt64 *)(const void *)(p))GetUi32(p)(*(const UInt32 *)(const void *)(p))GetUi16(p)(*(const UInt16 *)(const void *)(p))MY_CPU_LE_UNALIGN_64MY_CPU_pragma_pop_Pragma("pack(pop)")MY_CPU_pragma_pack_push_1_Pragma("pack(push, 1)")MY_CPU_64BITMY_CPU_SIZEOF_POINTERMY_CPU_NAME"x64"__CPU_ARCH_Hdefined(_M_X64) \__ILP32__defined(_M_ARM64) \defined(_M_ARM) \defined(__thumb__) || defined(__THUMBEL__) || defined(_M_ARMT)defined(_M_IA64) \defined(__mips64) \defined(__mips__)defined(__ppc64__) \defined(__sparc64__)defined(__sparc__)defined(MY_CPU_X86) || defined(MY_CPU_AMD64)defined(MY_CPU_ARM) || defined(MY_CPU_ARM64)MY_CPU_ARM_M_IA64defined(MY_CPU_X86_OR_AMD64) \defined(__BIG_ENDIAN__) \defined(MY_CPU_LE) && defined(MY_CPU_BE)defined(MY_CPU_32BIT) && defined(MY_CPU_64BIT)__SIZEOF_POINTER__MY_CPU_SIZEOF_POINTER != __SIZEOF_POINTER__defined(MY_CPU_SIZEOF_POINTER) && (MY_CPU_SIZEOF_POINTER == 4)defined (_LP64)__xlC__defined(MY_CPU_BE)defined(__ARM_FEATURE_UNALIGNED)__has_builtindefined(MY_CPU_LE_UNALIGN) &&defined(MY_CPU_LE_UNALIGN) && ( \GetBe16defined(_WIN32)defined(__APPLE__)__builtin_bswap16__ORDER_BIG_ENDIAN__4321__ORDER_LITTLE_ENDIAN__1234__BYTE_ORDER____amd64____x86_64__/* #define GetBe16(p) __builtin_bswap16(*(const UInt16 *)(const void *)(p)) *//* #define GetBe16(p) _byteswap_ushort(*(const UInt16 *)(const Byte *)(p)) *//* Note: we use bswap instruction, that is unsupported in 386 cpu *//* defined(_WIN64) && *//* gcc9 for 32-bit arm can use LDRD instruction that requires 32-bit alignment.
       So we can't use unaligned 64-bit operations. *//*
    #define MY_CPU_NAME ""
    *//* #define MY_CPU_32BIT *//*
MY_CPU_LE means that CPU is LITTLE ENDIAN.
MY_CPU_BE means that CPU is BIG ENDIAN.
If MY_CPU_LE and MY_CPU_BE are not defined, we don't know about ENDIANNESS of platform.

MY_CPU_LE_UNALIGN means that CPU is LITTLE ENDIAN and CPU supports unaligned memory accesses.

MY_CPU_64BIT means that processor can work with 64-bit registers.
  MY_CPU_64BIT can be used to select fast code branch
  MY_CPU_64BIT doesn't mean that (sizeof(void *) == 8)
*//* CpuArch.h -- CPU specific code
2021-07-13 : Igor Pavlov : Public domain */functiona/home/atharvakale/390r-debugging-setup/p7zip/C/Bcj2.c"Bcj2.h"const Byte **unsigned char **0xFFFFFFFFp->statecurval16777216kTopValue0x0F2400xF00x802540xFE2320xE8(unsigned)BCJ2_STREAM_MAIN(unsigned)BCJ2_DEC_STATE_ORIGboundtttUInt16 *probprev2330xE9cj__builtin_bswap32516sizeof(p->probs)sizeof(p->probs[0])sizeof(p->probs) / sizeof(p->probs[0])kBitModelTotal_UPDATE_1p->range -= bound; p->code -= bound; *prob = (CProb)(ttt - (ttt >> kNumMoveBits));_UPDATE_0p->range = bound; *prob = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));_IF_BIT_0ttt = *prob; bound = (p->range >> kNumModelBits) * ttt; if (p->code < bound)kNumMoveBits(1 << kNumModelBits)kNumModelBits((UInt32)1 << 24)CProb/*
  if (BCJ2_IS_32BIT_STREAM(p->state))
  {
    const Byte *cur = p->bufs[p->state];
    if (cur == p->lims[p->state])
      return SZ_OK;
    p->bufs[p->state] = cur + 4;
    
    {
      UInt32 val;
      Byte *dest;
      SizeT rem;
      
      p->ip += 4;
      val = GetBe32(cur) - p->ip;
      dest = p->dest;
      rem = p->destLim - dest;
      if (rem < 4)
      {
        SizeT i;
        SetUi32(p->temp, val);
        for (i = 0; i < rem; i++)
          dest[i] = p->temp[i];
        p->dest = dest + rem;
        p->state = BCJ2_DEC_STATE_ORIG_0 + (unsigned)rem;
        return SZ_OK;
      }
      SetUi32(dest, val);
      p->temp[3] = (Byte)(val >> 24);
      p->dest = dest + 4;
      p->state = BCJ2_DEC_STATE_OK;
    }
  }
  *//* Bcj2.c -- BCJ2 Decoder (Converter for x86 code)
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Bcj2Enc.cprintf("     ip = %8d   tempPos = %8d   src = %8d\n", p->ip, p->tempPos, p->srcLim - p->src)printf("\n")printf("---- ip = %8d   tempPos = %8d   src = %8d\n", p->ip, p->tempPos, p->srcLim - p->src)printf("++++ ip = %8d   tempPos = %8d   src = %8d\n", p->ip, p->tempPos, p->srcLim - p->src)Bcj2Enc_Encode_2p->tempTargetByte **absValcontextneedConvertrelatValRangeEnc_ShiftLow42781900800xFF000000(UInt32)0xFF00000067108864PRF(x)SHOW_STAT/* #define SHOW_STAT *//* Bcj2Enc.c -- BCJ2 Encoder (Converter for x86 code)
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Blake2.hCBlake2spCBlake2sbufPosCBlake2s[8]struct <unnamed>[8]BLAKE2SP_PARALLEL_DEGREESUInt32[2]unsigned int[2]dummylastNode_f1Byte[64]unsigned char[64]BLAKE2S_BLOCK_SIZEfUInt32[8]unsigned int[8]hBLAKE2S_DIGEST_SIZE__BLAKE2_HBlake2sp_FinalCBlake2sp *Blake2sp_UpdateBlake2sp_Init/*
void Blake2s_Init0(CBlake2s *p);
void Blake2s_Update(CBlake2s *p, const Byte *data, size_t size);
void Blake2s_Final(CBlake2s *p, Byte *digest);
*//* You need to xor CBlake2s::h[i] with input parameter block after Blake2s_Init0() *//* for sizeof(CBlake2s) alignment *//* Blake2.h -- BLAKE2 Hash
2015-06-30 : Igor Pavlov : Public domain
2015 : Samuel Neves : Public domain */digest/home/atharvakale/390r-debugging-setup/p7zip/C/RotateDefs.hrotrFixed(x,n)(((x) >> (n)) | ((x) << (32 - (n))))rotlFixed(x,n)(((x) << (n)) | ((x) >> (32 - (n))))__ROTATE_DEFS_H/* new compilers can translate these macros to fast commands. *//* #endif *//* #if (_MSC_VER >= 1200) *//* don't use _rotl with MINGW. It can insert slow call to function. *//* RotateDefs.h -- Rotate functions
2015-03-25 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Blake2s.c"RotateDefs.h""Blake2.h"RCBlake2s *BLAKE2S_FINAL_FLAGByte[32]unsigned char[32]hashindex(BLAKE2S_BLOCK_SIZE - 1)511(BLAKE2S_BLOCK_SIZE * BLAKE2SP_PARALLEL_DEGREE - 1)Blake2sp_Init_Spec(UInt32)BLAKE2SP_PARALLEL_DEGREE524288(UInt32)BLAKE2SP_PARALLEL_DEGREE << 16((UInt32)BLAKE2SP_PARALLEL_DEGREE << 16)524320(UInt32)233554432(UInt32)2 << 24((UInt32)2 << 24)34078752(BLAKE2S_DIGEST_SIZE | ((UInt32)BLAKE2SP_PARALLEL_DEGREE << 16) | ((UInt32)2 << 24))(UInt32)BLAKE2S_DIGEST_SIZE536870912(UInt32)BLAKE2S_DIGEST_SIZE << 24((UInt32)BLAKE2S_DIGEST_SIZE << 24)Blake2s_Final(UInt32)p->bufPosdigest + sizeof(p->h[i]) * ip->h[i]Blake2s_UpdateBlake2s_CompressUInt32[16]unsigned int[16]p->buf + i * sizeof(m[i])const UInt32[8]v[ 0]v[ 4]v[ 8]v[12]v[ 1]v[ 5]v[ 9]v[13]v[ 2]v[ 6]v[10]v[14]v[ 3]v[ 7]v[11]v[15]BLAKE2S_NUM_ROUNDSsigmaconst Byte[16]unsigned char[16]const Byte[10][16]unsigned char[10][16]const Byte(*)[16]unsigned char(*)[16]node_offsetnode_depthBlake2s_Init0k_Blake2s_Sigmak_Blake2s_IV17790337030x6A09E667UL31441342770xBB67AE85UL10139042420x3C6EF372UL27734807620xA54FF53AUL13598931190x510E527FUL26008229240x9B05688CUL5287346350x1F83D9ABUL15414592250x5BE0CD19ULBlake2s_Set_LastBlock(p){ p->f[0] = BLAKE2S_FINAL_FLAG; p->f[1] = p->lastNode_f1; }Blake2s_Increment_Counter(S,inc){ p->t[0] += (inc); p->t[1] += (p->t[0] < (inc)); }GR(r)G(r,0,v[ 0],v[ 4],v[ 8],v[12]); G(r,1,v[ 1],v[ 5],v[ 9],v[13]); G(r,2,v[ 2],v[ 6],v[10],v[14]); G(r,3,v[ 3],v[ 7],v[11],v[15]); G(r,4,v[ 0],v[ 5],v[10],v[15]); G(r,5,v[ 1],v[ 6],v[11],v[12]); G(r,6,v[ 2],v[ 7],v[ 8],v[13]); G(r,7,v[ 3],v[ 4],v[ 9],v[14]);G(r,i,a,b,c,d)a += b + m[sigma[2*i+0]]; d ^= a; d = rotr32(d, 16); c += d; b ^= c; b = rotr32(b, 12); a += b + m[sigma[2*i+1]]; d ^= a; d = rotr32(d, 8); c += d; b ^= c; b = rotr32(b, 7);(~(UInt32)0)rotr32rotrFixed/*
  P->digest_length = BLAKE2S_DIGEST_SIZE;
  P->key_length = 0;
  P->fanout = BLAKE2SP_PARALLEL_DEGREE;
  P->depth = 2;
  P->leaf_length = 0;
  store48(P->node_offset, node_offset);
  P->node_depth = node_depth;
  P->inner_length = BLAKE2S_DIGEST_SIZE;
  *//*
typedef struct
{
  Byte  digest_length;
  Byte  key_length;
  Byte  fanout;
  Byte  depth;
  UInt32 leaf_length;
  Byte  node_offset[6];
  Byte  node_depth;
  Byte  inner_length;
  Byte  salt[BLAKE2S_SALTBYTES];
  Byte  personal[BLAKE2S_PERSONALBYTES];
} CBlake2sParam;
*//* we need to xor CBlake2s::h[i] with input parameter block after Blake2s_Init0() *//* ---------- BLAKE2s ---------- *//* R(0); R(1); R(2); R(3); R(4); R(5); R(6); R(7); R(8); R(9); *//* Blake2s.c -- BLAKE2s and BLAKE2sp Hash
2021-02-09 : Igor Pavlov : Public domain
2015 : Samuel Neves : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Bra.hIA64_Convertx86_Convertx86_Convert_Init(state){ state = 0; }__BRA_HSPARC_ConvertPPC_ConvertARMT_ConvertARM_Convert/*
These functions convert relative addresses to absolute addresses
in CALL instructions to increase the compression ratio.
  
  In:
    data     - data buffer
    size     - size of data
    ip       - current virtual Instruction Pinter (IP) value
    state    - state variable for x86 converter
    encoding - 0 (for decoding), 1 (for encoding)
  
  Out:
    state    - state variable for x86 converter

  Returns:
    The number of processed bytes. If you call these functions with multiple calls,
    you must start next call with first byte after block of processed bytes.
  
  Type   Endian  Alignment  LookAhead
  
  x86    little      1          4
  ARMT   little      2          2
  ARM    little      4          0
  PPC     big        4          0
  SPARC   big        4          0
  IA64   little     16          0

  size must be >= Alignment + LookAhead, if it's not last block.
  If (size < Alignment + LookAhead), converter returns 0.

  Example:

    UInt32 ip = 0;
    for ()
    {
      ; size must be >= Alignment + LookAhead, if it's not last block
      SizeT processed = Convert(data, size, ip, 1);
      data += processed;
      size -= processed;
      ip += processed;
    }
*//* Bra.h -- Branch converters for executables
2013-01-18 : Igor Pavlov : Public domain */encoding/home/atharvakale/390r-debugging-setup/p7zip/C/Bra.c"Bra.h"lim(size_t)318446744073709551612~(size_t)3p - 4-40x401920xC00x7F335544310x01FFFFFF(UInt32)1(UInt32)1 << 2410737418240x400000002520xFC0x48671088630x03FFFFFF12079595520x4800000018446744073709551614~(size_t)1b1b32480xF80x72350xEB167772150x00FFFFFF39426457600xEB000000/*
      v = GetBe32(p);
      p += 4;
      m = v + ((UInt32)5 << 29);
      m ^= (UInt32)7 << 29;
      m += (UInt32)1 << 22;
      if ((m & ((UInt32)0x1FF << 23)) == 0)
        break;
      *//* if ((v & 0xFC000003) == 0x48000001) *//*
      SetUi16(p - 4, (UInt16)(((v >> 11) & 0x7FF) | 0xF000));
      SetUi16(p - 2, (UInt16)(v | 0xF800));
      *//* Bra.c -- Converters for RISC code
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Bra86.cmaskp[(size_t)(mask >> 1) + 1]p[4](Byte)(v >> sh)limitsh(UInt32)0x100Test86MSByte(b)((((b) + 1) & 0xFE) == 0)/* Bra86.c -- Converter for x86 code (BCJ)
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/BraIA64.craw8605532160x334B0000(UInt32)0x334B00000x1E0x7010485750xFFFFF83886081 << 23(1 << 23)20971510x1FFFFF73400320x70000094371830x8FFFFF(UInt32)0x8FFFFF/* BraIA64.c -- Converter for IA-64 code
2017-01-26 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/BwtSort.hBLOCK_SORT_BUF_SIZE(blockSize)((blockSize) * 2 + BLOCK_SORT_EXTERNAL_SIZE(blockSize) + (1 << 16))BLOCK_SORT_EXTERNAL_SIZE(blockSize)__BWT_SORT_HBLOCK_SORT_EXTERNAL_FLAGSBlockSort/* #define BLOCK_SORT_EXTERNAL_FLAGS *//* use BLOCK_SORT_EXTERNAL_FLAGS if blockSize can be > 1M *//* BwtSort.h -- BWT block sorting
2013-01-18 : Igor Pavlov : Public domain */indicesblockSize/home/atharvakale/390r-debugging-setup/p7zip/C/Sort.hHeapSort64UInt64 *unsigned long long *HeapSort__7Z_SORT_H/* void HeapSortRef(UInt32 *p, UInt32 *vals, size_t size); *//* Sort.h -- Sort functions
2014-04-05 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/BwtSort.c"Sort.h""BwtSort.h"countersGroups65536kNumHashValuessumgroupSizeprevGroupSizeNumRefBitsNumSortedByteskNumRefBitsMaxIndices + i - finishedGroupSizenewGroupSizefinishedGroupSizenewLimit32212254720xC00000001073741823~0xC0000000kNumBitsMaxfinishedGroup21474836480x80000000kNumExtra0Bits1048576kIndexMask1023kNumHashBytesIndicesSortGroupind2thereAreGroupsgroupcggPrevgResspgprevGroupStartcgCurindmidSetGroupSizekNumExtra0Mask1 << kNumExtra0Bits(1 << kNumExtra0Bits)SetFinishedGroupSize(p,size){ *(p) |= ((((size) - 1) & kNumExtra0Mask) << kNumBitsMax); if ((size) > (1 << kNumExtra0Bits)) { *(p) |= 0x40000000; *((p) + 1) |= ((((size) - 1)>> kNumExtra0Bits) << kNumBitsMax); } }((1 << kNumExtra0Bits) - 1)(kNumExtraBits - 2)kNumExtraBits(32 - kNumBitsMax)((1 << kNumBitsMax) - 1)BS_TEMP_SIZE(1 << (kNumHashBytes * 8))NO_INLINEBLOCK_SORT_USE_HEAP_SORT/* Flags[t >> kNumFlagsBits] &= ~(1 << (t & kFlagsMask)); *//* Radix-Sort for 2 bytes *//* conditions: blockSize > 0 *//* Write new Groups values and Check that there are groups *//* Write Flags *//* ---------- Heap Sort ---------- *//* ---------- Range Sort ---------- *//* Check that all strings are in one group (cannot sort) *//*
    #ifndef BLOCK_SORT_EXTERNAL_FLAGS
    SetFinishedGroupSize(ind2, 1);
    #endif
    *//*
SortGroup - is recursive Range-Sort function with HeapSort optimization for small blocks
  "range" is not real range. It's only for optimization.
returns: 1 - if there are groups, 0 - no more groups
*//* 32 Flags in UInt32 word *//* kNumRefBitsMax must be < (kNumHashBytes * 8) = 16 *//* Don't change it !!! *//* #define BLOCK_SORT_USE_HEAP_SORT *//* BwtSort.c -- BWT block sorting
2021-04-01 : Igor Pavlov : Public domain */BlockSizegroupOffsetleft/home/atharvakale/390r-debugging-setup/p7zip/C/CpuArch.ccpuid21474836490x80000001X86_CPUID_ECX_Get_Flagsfirmfamilymodelp.ver40800x1C0x260x270x350x360xA0xFconst UInt32[3]const UInt32[3][3]unsigned int[3][3]sizeof(kVendors)const UInt32(*)[3]unsigned int(*)[3]sizeof(kVendors[i])sizeof(kVendors) / sizeof(kVendors[i])const UInt32[][3]unsigned int[][3]kVendors19701691590x756E654712313841690x49656E6918185882700x6C65746E17524626570x6874754117692381170x69746E6511459136990x444D416319533919390x746E654312154607050x4872756119364877770x736C7561CHECK_SYS_SSE_SUPPORTCHECK_CPUID_IS_SUPPORTEDUSE_ASM(defined(_MSC_VER) && !defined(MY_CPU_AMD64)) || defined(__GNUC__)!defined(USE_ASM) && _MSC_VER >= 1500defined(USE_ASM) && !defined(MY_CPU_AMD64)_MSC_VER >= 1600defined(MY_CPU_AMD64) && defined(__PIC__)defined(MY_CPU_X86) && defined(__PIC__)!defined(MY_CPU_AMD64) && defined(_WIN32)USE_HWCAP__APPLE____PIC__// __APPLE__// USE_HWCAP// MY_HWCAP_CHECK_FUNC (ASIMD)/*
  Print_sysctlbyname("hw.pagesize");
  Print_sysctlbyname("machdep.cpu.brand_string");
  *//*
#include <stdio.h>
#include <string.h>
static void Print_sysctlbyname(const char *name)
{
  size_t bufSize = 256;
  char buf[256];
  int res = sysctlbyname(name, &buf, &bufSize, NULL, 0);
  {
    int i;
    printf("\nres = %d : %s : '%s' : bufSize = %d, numeric", res, name, buf, (unsigned)bufSize);
    for (i = 0; i < 20; i++)
      printf(" %2x", (unsigned)(Byte)buf[i]);

  }
}
*/// vaes // VEX-256/EVEX// & (d[1] >> 31) // avx512vl// avx2// printf("\ncpuid(7): ebx=%8x ecx=%8x\n", d[1], d[2]);// #include <stdio.h>/* 32 nm, N2xxx, D2xxx *//* 32 nm, Z2760 *//* 32 nm, Z2460 *//* 45 nm, Z6xx *//* 45 nm, N4xx, D4xx, N5xx, D5xx, 230, 330 *//* In-Order Atom CPU *//*
 __cpuid (function == 4) requires subfunction number in ECX.
  MSDN: The __cpuid intrinsic clears the ECX register before calling the cpuid instruction.
   __cpuid() in new MSVC clears ECX.
   __cpuid() in old MSVC (14.00) doesn't clear ECX
 We still can use __cpuid for low (function) values that don't require ECX,
 but __cpuid() in old MSVC will be incorrect for some function values: (function == 4).
 So here we use the hack for old MSVC to send (subFunction) in ECX register to cpuid instruction,
 where ECX value is first parameter for FAST_CALL / NO_INLINE function,
 So the caller of MY__cpuidex_HACK() sets ECX as subFunction, and
 old MSVC for __cpuid() doesn't change ECX and cpuid instruction gets (subFunction) value.
 
 DON'T remove MY_NO_INLINE and MY_FAST_CALL for MY__cpuidex_HACK() !!!
*//* CpuArch.c -- CPU specific code
2021-07-13 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Delta.hDELTA_STATE_SIZE__DELTA_HDelta_DecodeDelta_EncodeDelta_Init/* Delta.h -- Delta converter
2013-01-18 : Igor Pavlov : Public domain */delta/home/atharvakale/390r-debugging-setup/p7zip/C/Delta.c"Delta.h"difk/*
    #define B(n) b ## n
    #define I(n) Byte B(n) = state[n];
    #define U(n) { B(n) = (Byte)((B(n)) + *data++); data[-1] = (B(n)); }
    #define F(n) if (data != lim) { U(n) }

    if (delta == 1)
    {
      I(0)
      if ((lim - data) & 1) { U(0) }
      while (data != lim) { U(0) U(0) }
      data -= 1;
    }
    else if (delta == 2)
    {
      I(0) I(1)
      lim -= 1; while (data < lim) { U(0) U(1) }
      lim += 1; F(0)
      data -= 2;
    }
    else if (delta == 3)
    {
      I(0) I(1) I(2)
      lim -= 2; while (data < lim) { U(0) U(1) U(2) }
      lim += 2; F(0) F(1)
      data -= 3;
    }
    else if (delta == 4)
    {
      I(0) I(1) I(2) I(3)
      lim -= 3; while (data < lim) { U(0) U(1) U(2) U(3) }
      lim += 3; F(0) F(1) F(2)
      data -= 4;
    }
    else
    *//* Delta.c -- Delta converter
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/HuffEnc.h__HUFF_ENC_HHuffman_Generate/*
Conditions:
  num <= 1024 = 2 ^ NUM_BITS
  Sum(freqs) < 4M = 2 ^ (32 - NUM_BITS)
  maxLen <= 16 = kMaxLen
  Num_Items(p) >= HUFFMAN_TEMP_SIZE(num)
*//* HuffEnc.h -- Huffman encoding
2013-01-18 : Igor Pavlov : Public domain */freqslensmaxLen/home/atharvakale/390r-debugging-setup/p7zip/C/HuffEnc.c"HuffEnc.h"UInt32[64]unsigned int[64]NUM_COUNTERSfreqNUM_BITSminCodemaxCodeMASKn4294966272~MASKUInt32[17]unsigned int[17]kMaxLenlenCounterslennextCodesHUFFMAN_SPEED_OPT(((unsigned)1 << NUM_BITS) - 1)/* if (code + lenCounters[kMaxLen] - 1 != (1 << kMaxLen) - 1) throw 1; *//* if (maxLen > 10) maxLen = 10; *//* HuffEnc.c -- functions for Huffman encoding
2021-02-09 : Igor Pavlov : Public domain */numSymbols/home/atharvakale/390r-debugging-setup/p7zip/C/LzFind.hIMatchFinder2_IMatchFinderMf_Skip_FuncMf_GetMatches_FuncMf_GetPointerToCurrentPos_FuncMf_GetNumAvailableBytes_FuncMf_Init_FuncCMatchFinder_CMatchFinderCLzRefGetMatchesGetPointerToCurrentPosGetNumAvailableBytesInitexpectedDataSizenumRefsUInt32[256]unsigned int[256]crcresulthashSizeSumfixedHashSizehistorySizedirectInputRemnumHashByteskeepSizeAfterkeepSizeBeforebufferBasecutValuehashMaskCLzRef *sonmatchMaxLendirectInputbigHashbtModestreamEndWasReachedcyclicBufferSizecyclicBufferPoslenLimitstreamPosposLimitbufferInline_MatchFinder_ReduceOffsets(p,subValue)(p)->pos -= (subValue); (p)->streamPos -= (subValue);Inline_MatchFinder_GetNumAvailableBytes(p)((UInt32)((p)->streamPos - (p)->pos))Inline_MatchFinder_GetPointerToCurrentPos(p)((const Byte *)(p)->buffer)__LZ_FIND_HLzFindPrepareHc3Zip_MatchFinder_SkipCMatchFinder *_CMatchFinder *Bt3Zip_MatchFinder_SkipHc3Zip_MatchFinder_GetMatchesBt3Zip_MatchFinder_GetMatchesMatchFinder_InitMatchFinder_Init_4MatchFinder_Init_HighHashMatchFinder_Init_LowHashMatchFinder_CreateVTableIMatchFinder2 *_IMatchFinder *GetMatchesSpec1MatchFinder_Normalize3noinlineMatchFinder_FreeMatchFinder_CreateMatchFinder_ConstructMatchFinder_ReadIfRequiredMatchFinder_MoveBlockMatchFinder_NeedMove/*
Conditions:
  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
*//*
#define Inline_MatchFinder_InitPos(p, val) \
    (p)->pos = (val); \
    (p)->streamPos = (val);
*/// void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);/* Conditions:
     historySize <= 3 GB
     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
*//* Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p); *//*
#define Inline_MatchFinder_IsFinishedOK(p) \
    ((p)->streamEndWasReached \
        && (p)->streamPos == (p)->pos \
        && (!(p)->directInput || (p)->directInputRem == 0))
*//* it must be = (historySize + 1) *//* wrap over Zero is allowed (streamPos < pos). Use (UInt32)(streamPos - pos) *//* LzFind.h -- Match finder for LZ algorithms
2021-07-13 : Igor Pavlov : Public domain */distancesvTablecurMatch_cyclicBufferPos_cyclicBufferSize_cutValuesubValueitemsnumItemskeepAddBufferBeforekeepAddBufferAfter/home/atharvakale/390r-debugging-setup/p7zip/C/LzHash.hkLzHash_CrcShift_2kLzHash_CrcShift_1kFix4HashSize(kHash2Size + kHash3Size)kFix3HashSize(kHash2Size)kHash3Size(1 << 16)kHash2Size(1 << 10)__LZ_HASH_H/*
  We use up to 3 crc values for hash:
    crc0
    crc1 << Shift_1
    crc2 << Shift_2
  (Shift_1 = 5) and (Shift_2 = 10) is good tradeoff.
  Small values for Shift are not good for collision rate.
  Big value for Shift_2 increases the minimum size
  of hash table, that will be slow for small files.
*/// #define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)// #define kHash4Size (1 << 20)/*
  (kHash2Size >= (1 <<  8)) : Required
  (kHash3Size >= (1 << 16)) : Required
*//* LzHash.h -- HASH functions for LZ algorithms
2019-10-30 : Igor Pavlov : Public domain */_mm_set1_pi8always_inlineartificial_mm_set1_pi16_mm_set1_pi32_mm_setr_pi8_mm_setr_pi16_mm_setr_pi32_mm_set_pi8__builtin_ia32_vec_init_v8qi__attribute((vector_size(8))) char_mm_set_pi16__builtin_ia32_vec_init_v4hi__attribute((vector_size(8))) short_mm_set_pi32__builtin_ia32_vec_init_v2si__attribute((vector_size(8))) int_mm_setzero_si640LL_m_pcmpgtd_mm_cmpgt_pi32__builtin_ia32_pcmpgtd_m_pcmpeqd_mm_cmpeq_pi32__builtin_ia32_pcmpeqd_m_pcmpgtw_mm_cmpgt_pi16__builtin_ia32_pcmpgtw_m_pcmpeqw_mm_cmpeq_pi16__builtin_ia32_pcmpeqw_m_pcmpgtb_mm_cmpgt_pi8__builtin_ia32_pcmpgtb_m_pcmpeqb_mm_cmpeq_pi8__builtin_ia32_pcmpeqb_m_pxor_mm_xor_si64__builtin_ia32_pxor_m_por_mm_or_si64__builtin_ia32_por_m_pandn_mm_andnot_si64__builtin_ia32_pandn_m_pand_mm_and_si64__builtin_ia32_pand_m_psrlqi_mm_srli_si64__builtin_ia32_psrlqi__attribute((vector_size(8))) long long_m_psrlq_mm_srl_si64__builtin_ia32_psrlq_m_psrldi_mm_srli_pi32__builtin_ia32_psrldi_m_psrld_mm_srl_pi32__builtin_ia32_psrld_m_psrlwi_mm_srli_pi16__builtin_ia32_psrlwi_m_psrlw_mm_srl_pi16__builtin_ia32_psrlw_m_psradi_mm_srai_pi32__builtin_ia32_psradi_m_psrad_mm_sra_pi32__builtin_ia32_psrad_m_psrawi_mm_srai_pi16__builtin_ia32_psrawi_m_psraw_mm_sra_pi16__builtin_ia32_psraw_m_psllqi_mm_slli_si64__builtin_ia32_psllqi_m_psllq_mm_sll_si64__builtin_ia32_psllq_m_pslldi_mm_slli_pi32__builtin_ia32_pslldi_m_pslld_mm_sll_pi32__builtin_ia32_pslld_m_psllwi_mm_slli_pi16__builtin_ia32_psllwi_m_psllw_mm_sll_pi16__builtin_ia32_psllw_m_pmullw_mm_mullo_pi16__builtin_ia32_pmullw_m_pmulhw_mm_mulhi_pi16__builtin_ia32_pmulhw_m_pmaddwd_mm_madd_pi16__builtin_ia32_pmaddwd_m_psubusw_mm_subs_pu16__builtin_ia32_psubusw_m_psubusb_mm_subs_pu8__builtin_ia32_psubusb_m_psubsw_mm_subs_pi16__builtin_ia32_psubsw_m_psubsb_mm_subs_pi8__builtin_ia32_psubsb_mm_sub_si64__builtin_ia32_psubq_m_psubd_mm_sub_pi32/usr/lib/gcc/x86_64-redhat-linux/12/include/usr/lib/gcc/x86_64-redhat-linux/12/usr/lib/gcc/x86_64-redhat-linux/usr/lib/gcc/usr/lib__b__i__b0__b1__b2__b3__b4__b5__b6__b7__w0__w1__w2__w3__i0__i1__m1__m2__m__count__builtin_ia32_psubd_m_psubw_mm_sub_pi16__builtin_ia32_psubw_m_psubb_mm_sub_pi8__builtin_ia32_psubb_m_paddusw_mm_adds_pu16__builtin_ia32_paddusw_m_paddusb_mm_adds_pu8__builtin_ia32_paddusb_m_paddsw_mm_adds_pi16__builtin_ia32_paddsw_m_paddsb_mm_adds_pi8__builtin_ia32_paddsb_mm_add_si64__builtin_ia32_paddq_m_paddd_mm_add_pi32__builtin_ia32_paddd_m_paddw_mm_add_pi16__builtin_ia32_paddw_m_paddb_mm_add_pi8__builtin_ia32_paddb_m_punpckldq_mm_unpacklo_pi32__builtin_ia32_punpckldq_m_punpcklwd_mm_unpacklo_pi16__builtin_ia32_punpcklwd_m_punpcklbw_mm_unpacklo_pi8__builtin_ia32_punpcklbw_m_punpckhdq_mm_unpackhi_pi32__builtin_ia32_punpckhdq_m_punpckhwd_mm_unpackhi_pi16__builtin_ia32_punpckhwd_m_punpckhbw_mm_unpackhi_pi8__builtin_ia32_punpckhbw_m_packuswb_mm_packs_pu16__builtin_ia32_packuswb_m_packssdw_mm_packs_pi32__builtin_ia32_packssdw_m_packsswb_mm_packs_pi16__builtin_ia32_packsswb_mm_cvtsi64_si64x_mm_cvtm64_si64_m_to_int64_m_to_int_mm_cvtsi64_si32__builtin_ia32_vec_ext_v2si_mm_set_pi64x_mm_cvtsi64x_si64_mm_cvtsi64_m64_m_from_int64_m_from_int_mm_cvtsi32_si64_m_empty_mm_empty__builtin_ia32_emms__attribute((vector_size(8))) float__v2sfvector_size__v1di__v8qi__v4hi__v2si__attribute((vector_size(2))) short__m16_umay_aliasaligned__attribute((vector_size(4))) int__m32_u__m64_u__m16__m32__m64_MMINTRIN_H_INCLUDEDdefined __x86_64__ && !defined __SSE__ || !defined __MMX____MMX_WITH_SSE__defined __x86_64____SSE2____DISABLE_SSE2____DISABLE_MMX____MMX____SSE__/* _MMINTRIN_H_INCLUDED *//* __DISABLE_MMX__ *//* Creates a vector of eight 8-bit values, all elements containing B.  *//* Creates a vector of four 16-bit values, all elements containing W.  *//* Creates a vector of two 32-bit values, both elements containing I.  *//* Similar, but with the arguments in reverse order.  *//* Creates a vector of eight 8-bit values; B0 is least significant.  *//* Creates a vector of four 16-bit values; W0 is least significant.  *//* Creates a vector of two 32-bit values; I0 is least significant.  *//* Creates a 64-bit zero.  *//* Compare two 32-bit values.  The result of the comparison is 0xFFFFFFFF if
   the test is true and zero if false.  *//* Compare four 16-bit values.  The result of the comparison is 0xFFFF if
   the test is true and zero if false.  *//* Compare eight 8-bit values.  The result of the comparison is 0xFF if the
   test is true and zero if false.  *//* Bit-wise exclusive OR the 64-bit values in M1 and M2.  *//* Bit-wise inclusive OR the 64-bit values in M1 and M2.  *//* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the
   64-bit value in M2.  *//* Bit-wise AND the 64-bit values in M1 and M2.  *//* Shift the 64-bit value in M left by COUNT; shift in zeros.  *//* Shift two 32-bit values in M right by COUNT; shift in zeros.  *//* Shift four 16-bit values in M right by COUNT; shift in zeros.  *//* Shift two 32-bit values in M right by COUNT; shift in the sign bit.  *//* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  *//* Shift the 64-bit value in M left by COUNT.  *//* Shift two 32-bit values in M left by COUNT.  *//* Shift four 16-bit values in M left by COUNT.  *//* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce
   the low 16 bits of the results.  *//* Multiply four signed 16-bit values in M1 by four signed 16-bit values in
   M2 and produce the high 16 bits of the 32-bit results.  *//* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing
   four 32-bit intermediate results, which are then summed by pairs to
   produce two 32-bit results.  *//* Subtract the 16-bit values in M2 from the 16-bit values in M1 using
   unsigned saturating arithmetic.  *//* Subtract the 8-bit values in M2 from the 8-bit values in M1 using
   unsigned saturating arithmetic.  *//* Subtract the 16-bit values in M2 from the 16-bit values in M1 using
   signed saturating arithmetic.  *//* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed
   saturating arithmetic.  *//* __DISABLE_SSE2__ *//* __SSE2__ *//* Add the 64-bit values in M1 to the 64-bit values in M2.  *//* Subtract the 32-bit values in M2 from the 32-bit values in M1.  *//* Subtract the 16-bit values in M2 from the 16-bit values in M1.  *//* Subtract the 8-bit values in M2 from the 8-bit values in M1.  *//* Add the 16-bit values in M1 to the 16-bit values in M2 using unsigned
   saturated arithmetic.  *//* Add the 8-bit values in M1 to the 8-bit values in M2 using unsigned
   saturated arithmetic.  *//* Add the 16-bit values in M1 to the 16-bit values in M2 using signed
   saturated arithmetic.  *//* Add the 8-bit values in M1 to the 8-bit values in M2 using signed
   saturated arithmetic.  *//* Add the 32-bit values in M1 to the 32-bit values in M2.  *//* Add the 16-bit values in M1 to the 16-bit values in M2.  *//* Add the 8-bit values in M1 to the 8-bit values in M2.  *//* Interleave the 32-bit value from the low half of M1 with the 32-bit
   value from the low half of M2.  *//* Interleave the two 16-bit values from the low half of M1 with the two
   16-bit values from the low half of M2.  *//* Interleave the four 8-bit values from the low half of M1 with the four
   8-bit values from the low half of M2.  *//* Interleave the 32-bit value from the high half of M1 with the 32-bit
   value from the high half of M2.  *//* Interleave the two 16-bit values from the high half of M1 with the two
   16-bit values from the high half of M2.  *//* Interleave the four 8-bit values from the high half of M1 with the four
   8-bit values from the high half of M2.  *//* Pack the four 16-bit values from M1 into the lower four 8-bit values of
   the result, and the four 16-bit values from M2 into the upper four 8-bit
   values of the result, all with unsigned saturation.  *//* Pack the two 32-bit values from M1 in to the lower two 16-bit values of
   the result, and the two 32-bit values from M2 into the upper two 16-bit
   values of the result, all with signed saturation.  *//* Pack the four 16-bit values from M1 into the lower four 8-bit values of
   the result, and the four 16-bit values from M2 into the upper four 8-bit
   values of the result, all with signed saturation.  *//* Microsoft intrinsic.  *//* Intel intrinsic.  *//* Convert the __m64 object to a 64bit integer.  *//* Convert the lower 32 bits of the __m64 object into an integer.  *//* Convert I to a __m64 object.  *//* Convert I to a __m64 object.  The integer is zero-extended to 64-bits.  *//* Empty the multimedia state.  *//* Internal data types for implementing the intrinsics.  *//* Unaligned version of the same type  *//* The Intel API is flexible enough that we must allow aliasing with other
   vector types, and their scalar components.  *//* __MMX__ *//* Implemented from the specification included in the Intel C++ Compiler
   User Guide and Reference, version 9.0.  *//* Copyright (C) 2002-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mm_free_mm_mallocsizeof (void *)sizeof (void *) == 8_MM_MALLOC_H_INCLUDED/* _MM_MALLOC_H_INCLUDED *//* We can't depend on <stdlib.h> since the prototype of posix_memalign
   may not be visible.  *//* Copyright (C) 2004-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_EMMINTRIN_H_INCLUDED/* _EMMINTRIN_H_INCLUDED *//* Casts between various SP, DP, INT vector types.  Note that these do no
   conversion of values, they just change the type.  *//* Create a vector of zeros.  *//* Create an undefined vector.  *//* Create a vector with element 0 as *P and the rest zero.  *//* Create a vector of Qi, where i is the element number.
   The parameter order is reversed from the _mm_set_epi* functions.  *//* Set all of the elements of the vector to A.  *//* Create a vector of Qi, where i is the element number.  *//* Return pair {sqrt (B[0]), A[1]}.  *//* Store two DPFP values in reverse order.  The address must be aligned.  *//* Store the lower DPFP value across two words.
   The address must be 16-byte aligned.  *//* Stores the upper DPFP value.  *//* Stores the lower DPFP value.  *//* Store two DPFP values.  The address need not be 16-byte aligned.  *//* Store two DPFP values.  The address must be 16-byte aligned.  *//* Load two DPFP values in reverse order.  The address must be aligned.  *//* Create a vector with all two elements equal to *P.  *//* Load two DPFP values from P.  The address need not be 16-byte aligned.  *//* Load two DPFP values from P.  The address must be 16-byte aligned.  *//* Sets the low DPFP value of A from the low value of B.  *//* Create a vector with the lower value W and upper value X.  *//* Create a vector with the lower value X and upper value W.  *//* Create a vector with both elements equal to F.  *//* Create a vector with element 0 as F and the rest zero.  *//* Create a selector for use with the SHUFPD instruction.  *//* Unaligned version of the same types.  *//* SSE2 *//* We need definitions from the SSE header files*//* Copyright (C) 2003-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */<emmintrin.h><mm_malloc.h><mmintrin.h>__attribute((vector_size(16))) char__v16qi__v2di_mm_pause__builtin_ia32_pause_mm_sfence__builtin_ia32_sfence_mm_stream_psfloat *__builtin_ia32_movntps__attribute((vector_size(16))) float_mm_stream_pi__m64 *__attribute((vector_size(8))) int *__builtin_ia32_movntq_m_psadbw_mm_sad_pu8__builtin_ia32_psadbw_m_pavgw_mm_avg_pu16__builtin_ia32_pavgw_m_pavgb_mm_avg_pu8__builtin_ia32_pavgb_m_maskmovq_mm_maskmove_si64__A128__N1280xf__builtin_ia32_pslldqi1282 * 83 * 84 * 85 * 86 * 87 * 88 * 8__builtin_ia32_maskmovdqu_m_pshufw_mm_shuffle_pi16__builtin_ia32_pshufw_m_pmulhuw_mm_mulhi_pu16__builtin_ia32_pmulhuw_m_pmovmskb_mm_movemask_pi8__builtin_ia32_pmovmskb_m_pminub_mm_min_pu8__builtin_ia32_pminub_m_pminsw_mm_min_pi16__builtin_ia32_pminsw_m_pmaxub_mm_max_pu8__builtin_ia32_pmaxub_m_pmaxsw_mm_max_pi16__builtin_ia32_pmaxsw_m_pinsrwconst __m64_mm_insert_pi16__builtin_ia32_vec_set_v4hi_m_pextrw_mm_extract_pi16__builtin_ia32_vec_ext_v4hi_mm_move_ss__attribute((vector_size(16))) int_mm_storer_ps__va__tmp__builtin_ia32_shufps_MM_SHUFFLE (0,1,2,3)_mm_store_ps1_mm_store1_ps_MM_SHUFFLE (0,0,0,0)_mm_storeu_ps__m128_u *__attribute((vector_size(16))) float *_mm_store_ps__m128 *_mm_cvtss_f32_mm_store_ss_mm_setr_ps_mm_set_psconst float_mm_loadr_psconst float *__v4sf *_mm_loadu_ps_mm_load_ps_mm_load_ps1_mm_load1_ps_mm_load_ss_mm_set_ps1_mm_set1_ps_mm_set_ss0.00.0f_MM_SET_FLUSH_ZERO_MODE32768_MM_FLUSH_ZERO_MASK__P__A__B__N__D__Z__Y__X__W__F__mode4294934527~_MM_FLUSH_ZERO_MASK_MM_SET_ROUNDING_MODE24576_MM_ROUND_MASK4294942719~_MM_ROUND_MASK_MM_SET_EXCEPTION_MASK8064_MM_MASK_MASK4294959231~_MM_MASK_MASK_MM_SET_EXCEPTION_STATE_MM_EXCEPT_MASK4294967232~_MM_EXCEPT_MASK_mm_setcsr__builtin_ia32_ldmxcsr_MM_GET_FLUSH_ZERO_MODE_MM_GET_ROUNDING_MODE_MM_GET_EXCEPTION_MASK_MM_GET_EXCEPTION_STATE_mm_getcsr__builtin_ia32_stmxcsr_mm_movemask_ps__builtin_ia32_movmskps_mm_storel_pi__builtin_ia32_storelps__attribute((vector_size(8))) float *__v2sf *_mm_loadl_piconst __m64 *__builtin_ia32_loadlpsconst __attribute((vector_size(8))) floatconst __attribute((vector_size(8))) float *const __v2sfconst __v2sf *_mm_movelh_ps__builtin_ia32_movlhps_mm_movehl_ps__builtin_ia32_movhlps_mm_storeh_pi__builtin_ia32_storehps_mm_loadh_pi__builtin_ia32_loadhps_mm_unpacklo_ps__builtin_ia32_unpcklps_mm_unpackhi_ps__builtin_ia32_unpckhps_mm_shuffle_ps_mm_cvtps_pi8_mm_cvtps_pi16__hisf__losf__hisi__builtin_ia32_cvtps2pi__losi_mm_cvtpi32x2_ps__zero__sfa__builtin_ia32_cvtpi2ps__sfb_mm_cvtpu8_ps_mm_cvtpi8_ps_mm_cvtpu16_ps__ra__rb_mm_cvtpi16_ps_mm_cvt_pi2ps_mm_cvtpi32_ps_mm_cvtsi64x_ss__builtin_ia32_cvtsi642ss_mm_cvtsi64_ss_mm_cvt_si2ss_mm_cvtsi32_ss__builtin_ia32_cvtsi2ss_mm_cvtt_ps2pi_mm_cvttps_pi32__builtin_ia32_cvttps2pi_mm_cvttss_si64x__builtin_ia32_cvttss2si64_mm_cvttss_si64_mm_cvtt_ss2si_mm_cvttss_si32__builtin_ia32_cvttss2si_mm_cvt_ps2pi_mm_cvtps_pi32_mm_cvtss_si64x__builtin_ia32_cvtss2si64_mm_cvtss_si64_mm_cvt_ss2si_mm_cvtss_si32__builtin_ia32_cvtss2si_mm_ucomineq_ss__builtin_ia32_ucomineq_mm_ucomige_ss__builtin_ia32_ucomige_mm_ucomigt_ss__builtin_ia32_ucomigt_mm_ucomile_ss__builtin_ia32_ucomile_mm_ucomilt_ss__builtin_ia32_ucomilt_mm_ucomieq_ss__builtin_ia32_ucomieq_mm_comineq_ss__builtin_ia32_comineq_mm_comige_ss__builtin_ia32_comige_mm_comigt_ss__builtin_ia32_comigt_mm_comile_ss__builtin_ia32_comile_mm_comilt_ss__builtin_ia32_comilt_mm_comieq_ss__builtin_ia32_comieq_mm_cmpunord_ps__builtin_ia32_cmpunordps_mm_cmpord_ps__builtin_ia32_cmpordps_mm_cmpnge_ps__builtin_ia32_cmpngeps_mm_cmpngt_ps__builtin_ia32_cmpngtps_mm_cmpnle_ps__builtin_ia32_cmpnleps_mm_cmpnlt_ps__builtin_ia32_cmpnltps_mm_cmpneq_ps__builtin_ia32_cmpneqps_mm_cmpge_ps__builtin_ia32_cmpgeps_mm_cmpgt_ps__builtin_ia32_cmpgtps_mm_cmple_ps__builtin_ia32_cmpleps_mm_cmplt_ps__builtin_ia32_cmpltps_mm_cmpeq_ps__builtin_ia32_cmpeqps_mm_cmpunord_ss__builtin_ia32_cmpunordss__mask__I_mm_cmpord_ss__builtin_ia32_cmpordss_mm_cmpnge_ss__builtin_ia32_movss__builtin_ia32_cmpnless_mm_cmpngt_ss__builtin_ia32_cmpnltss_mm_cmpnle_ss_mm_cmpnlt_ss_mm_cmpneq_ss__builtin_ia32_cmpneqss_mm_cmpge_ss__builtin_ia32_cmpless_mm_cmpgt_ss__builtin_ia32_cmpltss_mm_cmple_ss_mm_cmplt_ss_mm_cmpeq_ss__builtin_ia32_cmpeqss_mm_xor_ps__builtin_ia32_xorps_mm_or_ps__builtin_ia32_orps_mm_andnot_ps__builtin_ia32_andnps_mm_and_ps__builtin_ia32_andps_mm_max_ps__builtin_ia32_maxps_mm_min_ps__builtin_ia32_minps_mm_rsqrt_ps__builtin_ia32_rsqrtps_mm_rcp_ps__builtin_ia32_rcpps_mm_sqrt_ps__builtin_ia32_sqrtps_mm_div_ps_mm_mul_ps_mm_sub_ps_mm_add_ps_mm_max_ss__builtin_ia32_maxss_mm_min_ss__builtin_ia32_minss_mm_rsqrt_ss__builtin_ia32_rsqrtss_mm_rcp_ss__builtin_ia32_rcpss_mm_sqrt_ss__builtin_ia32_sqrtss_mm_div_ss__builtin_ia32_divss_mm_mul_ss__builtin_ia32_mulss_mm_sub_ss__builtin_ia32_subss_mm_add_ss__builtin_ia32_addss_mm_setzero_ps_mm_undefined_ps_mm_prefetch__builtin_prefetch0x40x3__v4sf__m128_u__m128_mm_hint_MM_HINT_ET0_MM_HINT_ET1_MM_HINT_T0_MM_HINT_T1_MM_HINT_T2_MM_HINT_NTA_MM_TRANSPOSE4_PS(row0,row1,row2,row3)do { __v4sf __r0 = (row0), __r1 = (row1), __r2 = (row2), __r3 = (row3); __v4sf __t0 = __builtin_ia32_unpcklps (__r0, __r1); __v4sf __t1 = __builtin_ia32_unpcklps (__r2, __r3); __v4sf __t2 = __builtin_ia32_unpckhps (__r0, __r1); __v4sf __t3 = __builtin_ia32_unpckhps (__r2, __r3); (row0) = __builtin_ia32_movlhps (__t0, __t1); (row1) = __builtin_ia32_movhlps (__t1, __t0); (row2) = __builtin_ia32_movlhps (__t2, __t3); (row3) = __builtin_ia32_movhlps (__t3, __t2); } while (0)_MM_FLUSH_ZERO_OFF0x0000_MM_FLUSH_ZERO_ON_MM_ROUND_TOWARD_ZERO0x6000_MM_ROUND_UP_MM_ROUND_DOWN_MM_ROUND_NEAREST_MM_MASK_INEXACT_MM_MASK_UNDERFLOW_MM_MASK_OVERFLOW_MM_MASK_DIV_ZERO_MM_MASK_DENORM_MM_MASK_INVALID0x1f80_MM_EXCEPT_INEXACT_MM_EXCEPT_UNDERFLOW_MM_EXCEPT_OVERFLOW0x0008_MM_EXCEPT_DIV_ZERO_MM_EXCEPT_DENORM_MM_EXCEPT_INVALID0x003f_MM_SHUFFLE(fp3,fp2,fp1,fp0)(((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | (fp0))_XMMINTRIN_H_INCLUDED__DISABLE_SSE____SIZE_TYPE__long unsigned int/* _XMMINTRIN_H_INCLUDED *//* The execution of the next instruction is delayed by an implementation
   specific amount of time.  The instruction does not modify the
   architectural state.  This is after the pop_options pragma because
   it does not require SSE support in the processor--the encoding is a
   nop on processors that do not support it.  *//* __DISABLE_SSE__ *//* For backward source compatibility.  *//* Transpose the 4x4 matrix composed of row[0-3].  *//* Guarantees that every preceding store is globally visible before
   any subsequent store.  *//* Likewise.  The address must be 16-byte aligned.  *//* Stores the data in A to the address P without polluting the caches.  *//* Compute the sum of the absolute differences of the unsigned 8-bit
   values in A and B.  Return the value in the lower 16-bit word; the
   upper words are cleared.  *//* Compute the rounded averages of the unsigned 16-bit values in A and B.  *//* Compute the rounded averages of the unsigned 8-bit values in A and B.  *//* Shift __A128 and __N128 to the left by the adjustment.  *//* If the misalignment of __P > 8, subtract __P by 8 bytes.
	 Otherwise, subtract __P by the misalignment.  *//* Check the alignment of __P.  *//* Zero-extend __A and __N to 128 bits.  *//* Emulate MMX maskmovq with SSE2 maskmovdqu and handle unmapped bits
     64:127 at address __P.  *//* Conditionally store byte elements of A into P.  The high bit of each
   byte in the selector N determines whether the corresponding byte from
   A is stored.  *//* Return a combination of the four 16-bit values in A.  The selector
   must be an immediate.  *//* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values
   in B and produce the high 16 bits of the 32-bit results.  *//* Create an 8-bit mask of the signs of 8-bit values.  *//* Compute the element-wise minimum of unsigned 8-bit values.  *//* Compute the element-wise minimum of signed 16-bit values.  *//* Compute the element-wise maximum of unsigned 8-bit values.  *//* Compute the element-wise maximum of signed 16-bit values.  *//* Inserts word D into one of four words of A.  The selector N must be
   immediate.  *//* Extracts one of the four words of A.  The selector N must be immediate.  *//* Sets the low SPFP value of A from the low value of B.  *//* Store four SPFP values in reverse order.  The address must be aligned.  *//* Store the lower SPFP value across four words.  *//* Store four SPFP values.  The address need not be 16-byte aligned.  *//* Store four SPFP values.  The address must be 16-byte aligned.  *//* Stores the lower SPFP value.  *//* Create the vector [W X Y Z].  *//* Create the vector [Z Y X W].  *//* Load four SPFP values in reverse order.  The address must be aligned.  *//* Load four SPFP values from P.  The address need not be 16-byte aligned.  *//* Load four SPFP values from P.  The address must be 16-byte aligned.  *//* Create a vector with all four elements equal to *P.  *//* Create a vector with all four elements equal to F.  *//* Set exception bits in the control register.  *//* Set the control register to I.  *//* Read exception bits from the control register.  *//* Return the contents of the control register.  *//* Creates a 4-bit mask from the most significant bits of the SPFP values.  *//* Stores the lower two SPFP values of A into P.  *//* Sets the lower two SPFP values with 64-bits of data loaded from P;
   the upper two values are passed through from A.  *//* Moves the lower two values of B into the upper two values of A.  *//* Moves the upper two values of B into the lower two values of A.  *//* Stores the upper two SPFP values of A into P.  *//* Sets the upper two SPFP values with 64-bits of data loaded from P;
   the lower two values are passed through from A.  *//* Selects and interleaves the lower two SPFP values from A and B.  *//* Selects and interleaves the upper two SPFP values from A and B.  *//* Selects four specific SPFP values from A and B based on MASK.  *//* Convert the four SPFP values in A to four signed 8-bit integers.  *//* Convert the four SPFP values in A to four signed 16-bit integers.  *//* Convert the four signed 32-bit values in A and B to SPFP form.  *//* Convert the low four unsigned 8-bit values in A to SPFP form.  *//* Convert the four low bytes to words.  *//* This comparison against zero gives us a mask that can be used to
     fill in the missing sign bits in the unpack operations below, so
     that we get signed values after unpacking.  *//* Convert the low four signed 8-bit values in A to SPFP form.  *//* Convert the doublewords to floating point two at a time.  *//* Convert the four words to doublewords.  *//* Convert the four unsigned 16-bit values in A to SPFP form.  *//* Convert the four signed 16-bit values in A to SPFP form.  *//* Convert the two 32-bit values in B to SPFP form and insert them
   as the two lower elements in A.  *//* Convert B to a SPFP value and insert it as element zero in A.  *//* Truncate the two lower SPFP values to 32-bit integers.  Return the
   integers in packed form.  *//* Truncate the lower SPFP value to a 32-bit integer.  *//* Convert the two lower SPFP values to 32-bit integers according to the
   current rounding mode.  Return the integers in packed form.  *//* Convert the lower SPFP value to a 32-bit integer according to the
   current rounding mode.  *//* Convert the lower SPFP value to a 32-bit integer according to the current
   rounding mode.  *//* Compare the lower SPFP values of A and B and return 1 if true
   and 0 if false.  *//* Perform a comparison on the four SPFP values of A and B.  For each
   element, if the comparison is true, place a mask of all ones in the
   result, otherwise a mask of zeros.  *//* Perform a comparison on the lower SPFP values of A and B.  If the
   comparison is true, place a mask of all ones in the result, otherwise a
   mask of zeros.  The upper three SPFP values are passed through from A.  *//* Perform logical bit-wise operations on 128-bit values.  *//* Perform the respective operation on the four SPFP values in A and B.  *//* Perform the respective operation on the lower SPFP (single-precision
   floating-point) values of A and B; the upper three SPFP values are
   passed through from A.  *//* Bits in the MXCSR.  *//* Create a selector for use with the SHUFPS instruction.  *//* Unaligned version of the same type.  *//* __SSE__ *//* Loads one cache line from address P to a location "closer" to the
   processor.  The selector I specifies the type of prefetch operation.  *//* _MM_HINT_ET is _MM_HINT_T with set 3rd bit.  *//* Constants for use with _mm_prefetch.  *//* Get _mm_malloc () and _mm_free ().  *//* We need type definitions from the MMX header file.  */<xmmintrin.h>_mm_castsi128_pd_mm_castsi128_ps_mm_castps_si128_mm_castps_pd_mm_castpd_si128_mm_castpd_ps_mm_cvtsi64x_si128_mm_cvtsi64_si128_mm_cvtsi32_si128_mm_mfence__builtin_ia32_mfence_mm_lfence__builtin_ia32_lfence_mm_clflush__builtin_ia32_clflush_mm_stream_pd__builtin_ia32_movntpd__attribute((vector_size(16))) double_mm_stream_si128__builtin_ia32_movntdq__v2di *_mm_stream_si64__builtin_ia32_movnti64_mm_stream_si32__builtin_ia32_movnti_mm_sad_epu8__builtin_ia32_psadbw128_mm_avg_epu16__builtin_ia32_pavgw128__attribute((vector_size(16))) short_mm_avg_epu8__builtin_ia32_pavgb128_mm_maskmoveu_si128_mm_shuffle_epi32__builtin_ia32_pshufd_mm_shufflelo_epi16__builtin_ia32_pshuflw_mm_shufflehi_epi16__builtin_ia32_pshufhw_mm_mulhi_epu16__builtin_ia32_pmulhuw128_mm_movemask_epi8__builtin_ia32_pmovmskb128_mm_min_epu8__builtin_ia32_pminub128_mm_min_epi16__builtin_ia32_pminsw128_mm_max_epu8__builtin_ia32_pmaxub128_mm_max_epi16__builtin_ia32_pmaxsw128_mm_insert_epi16__builtin_ia32_vec_set_v8hi_mm_extract_epi16__builtin_ia32_vec_ext_v8hi_mm_cmpgt_epi32_mm_cmpgt_epi16_mm_cmpgt_epi8_mm_cmplt_epi32_mm_cmplt_epi16_mm_cmplt_epi8_mm_cmpeq_epi32_mm_cmpeq_epi16_mm_cmpeq_epi8__attribute((vector_size(16))) unsigned long long_mm_or_si128_mm_andnot_si128__builtin_ia32_pandn128_mm_and_si128_mm_srl_epi64__builtin_ia32_psrlq128_mm_srl_epi32__builtin_ia32_psrld128_mm_srl_epi16__builtin_ia32_psrlw128_mm_sra_epi32__builtin_ia32_psrad128_mm_sra_epi16__builtin_ia32_psraw128_mm_sll_epi64__builtin_ia32_psllq128_mm_sll_epi32__builtin_ia32_pslld128_mm_sll_epi16__builtin_ia32_psllw128_mm_srli_epi64__builtin_ia32_psrlqi128_mm_srli_epi32__builtin_ia32_psrldi128_mm_srli_epi16__builtin_ia32_psrlwi128_mm_slli_si128_mm_srli_si128__builtin_ia32_psrldqi128_mm_bslli_si128_mm_bsrli_si128_mm_srai_epi32__builtin_ia32_psradi128_mm_srai_epi16__builtin_ia32_psrawi128_mm_slli_epi64__builtin_ia32_psllqi128_mm_slli_epi32__builtin_ia32_pslldi128_mm_slli_epi16__builtin_ia32_psllwi128_mm_mul_epu32__builtin_ia32_pmuludq128_mm_mul_su32__builtin_ia32_pmuludq_mm_mullo_epi16__attribute((vector_size(16))) unsigned short_mm_mulhi_epi16__builtin_ia32_pmulhw128_mm_madd_epi16__builtin_ia32_pmaddwd128_mm_subs_epu16__builtin_ia32_psubusw128_mm_subs_epu8__builtin_ia32_psubusb128__C_mm_subs_epi16__builtin_ia32_psubsw128_mm_subs_epi8__builtin_ia32_psubsb128_mm_sub_epi64_mm_sub_epi32__attribute((vector_size(16))) unsigned int_mm_sub_epi16_mm_sub_epi8__attribute((vector_size(16))) unsigned char_mm_adds_epu16__builtin_ia32_paddusw128_mm_adds_epu8__builtin_ia32_paddusb128_mm_adds_epi16__builtin_ia32_paddsw128_mm_adds_epi8__builtin_ia32_paddsb128_mm_add_epi32_mm_add_epi16_mm_add_epi8_mm_unpacklo_epi64__builtin_ia32_punpcklqdq128_mm_unpacklo_epi32__builtin_ia32_punpckldq128_mm_unpacklo_epi16__builtin_ia32_punpcklwd128_mm_unpacklo_epi8__builtin_ia32_punpcklbw128_mm_unpackhi_epi64__builtin_ia32_punpckhqdq128_mm_unpackhi_epi32__builtin_ia32_punpckhdq128_mm_unpackhi_epi16__builtin_ia32_punpckhwd128_mm_unpackhi_epi8__builtin_ia32_punpckhbw128_mm_packus_epi16__builtin_ia32_packuswb128_mm_packs_epi32__builtin_ia32_packssdw128_mm_packs_epi16__builtin_ia32_packsswb128_mm_movemask_pd__builtin_ia32_movmskpd_mm_loadl_pdconst doubleconst double *__builtin_ia32_loadlpd_mm_loadh_pd__builtin_ia32_loadhpd_mm_unpacklo_pd__builtin_ia32_unpcklpd_mm_unpackhi_pd__builtin_ia32_unpckhpd_mm_shuffle_pd__builtin_ia32_shufpd_mm_cvtss_sd__builtin_ia32_cvtss2sd_mm_cvtsi64x_sd__builtin_ia32_cvtsi642sd_mm_cvtsi64_sd_mm_cvtsi32_sd__builtin_ia32_cvtsi2sd_mm_cvtsd_ss__builtin_ia32_cvtsd2ss_mm_cvttsd_si64x__builtin_ia32_cvttsd2si64_mm_cvttsd_si64_mm_cvttsd_si32__builtin_ia32_cvttsd2si_mm_cvtsd_si64x__builtin_ia32_cvtsd2si64_mm_cvtsd_si64_mm_cvtsd_si32__builtin_ia32_cvtsd2si_mm_cvtps_pd__builtin_ia32_cvtps2pd_mm_cvttps_epi32__builtin_ia32_cvttps2dq_mm_cvtps_epi32__builtin_ia32_cvtps2dq_mm_cvtpi32_pd__builtin_ia32_cvtpi2pd_mm_cvttpd_pi32__builtin_ia32_cvttpd2pi_mm_cvttpd_epi32__builtin_ia32_cvttpd2dq_mm_cvtpd_ps__builtin_ia32_cvtpd2ps_mm_cvtpd_pi32__builtin_ia32_cvtpd2pi_mm_cvtpd_epi32__builtin_ia32_cvtpd2dq_mm_cvtepi32_ps__builtin_ia32_cvtdq2ps_mm_cvtepi32_pd__builtin_ia32_cvtdq2pd_mm_setzero_si128_mm_undefined_si128_mm_move_epi64__builtin_ia32_movq128_mm_movpi64_epi64_mm_movepi64_pi64_mm_storeu_si16__m16_u *__attribute((vector_size(2))) short *_mm_storeu_si32__m32_u *__attribute((vector_size(4))) int *_mm_storeu_si64__m128i_u *_mm_storel_epi64__m64_u *_mm_storeu_si128_mm_store_si128_mm_loadu_si16_mm_loadu_si32_mm_loadu_si64const __m128i_uconst __m128i_u *_mm_loadl_epi64_mm_loadu_si128_mm_load_si128_mm_setr_epi8_mm_setr_epi16_mm_setr_epi32__q00__q01__q02__q03__q04__q05__q06__q07__q08__q09__q10__q11__q12__q13__q14__q15__q0__q1__q2__q3__q4__q5__q6__q7_mm_setr_epi64_mm_set1_epi8_mm_set1_epi16_mm_set1_epi32_mm_set1_epi64_mm_set1_epi64x_mm_set_epi8_mm_set_epi16_mm_set_epi32_mm_set_epi64_mm_set_epi64x_mm_ucomineq_sd__builtin_ia32_ucomisdneq_mm_ucomige_sd__builtin_ia32_ucomisdge_mm_ucomigt_sd__builtin_ia32_ucomisdgt_mm_ucomile_sd__builtin_ia32_ucomisdle_mm_ucomilt_sd__builtin_ia32_ucomisdlt_mm_ucomieq_sd__builtin_ia32_ucomisdeq_mm_comineq_sd__builtin_ia32_comisdneq_mm_comige_sd__builtin_ia32_comisdge_mm_comigt_sd__builtin_ia32_comisdgt_mm_comile_sd__builtin_ia32_comisdle_mm_comilt_sd__builtin_ia32_comisdlt_mm_comieq_sd__builtin_ia32_comisdeq_mm_cmpunord_sd__builtin_ia32_cmpunordsd_mm_cmpord_sd__builtin_ia32_cmpordsd_mm_cmpnge_sd__builtin_ia32_movsd__builtin_ia32_cmpnlesd_mm_cmpngt_sd__builtin_ia32_cmpnltsd_mm_cmpnle_sd_mm_cmpnlt_sd_mm_cmpneq_sd__builtin_ia32_cmpneqsd_mm_cmpge_sd__builtin_ia32_cmplesd_mm_cmpgt_sd__builtin_ia32_cmpltsd_mm_cmple_sd_mm_cmplt_sd_mm_cmpeq_sd__builtin_ia32_cmpeqsd_mm_cmpunord_pd__builtin_ia32_cmpunordpd_mm_cmpord_pd__builtin_ia32_cmpordpd_mm_cmpnge_pd__builtin_ia32_cmpngepd_mm_cmpngt_pd__builtin_ia32_cmpngtpd_mm_cmpnle_pd__builtin_ia32_cmpnlepd_mm_cmpnlt_pd__builtin_ia32_cmpnltpd_mm_cmpneq_pd__builtin_ia32_cmpneqpd_mm_cmpge_pd__builtin_ia32_cmpgepd_mm_cmpgt_pd__builtin_ia32_cmpgtpd_mm_cmple_pd__builtin_ia32_cmplepd_mm_cmplt_pd__builtin_ia32_cmpltpd_mm_cmpeq_pd__builtin_ia32_cmpeqpd_mm_xor_pd__builtin_ia32_xorpd_mm_or_pd__builtin_ia32_orpd_mm_andnot_pd__builtin_ia32_andnpd_mm_and_pd__builtin_ia32_andpd_mm_max_sd__builtin_ia32_maxsd_mm_max_pd__builtin_ia32_maxpd_mm_min_sd__builtin_ia32_minsd_mm_min_pd__builtin_ia32_minpd_mm_sqrt_sd__builtin_ia32_sqrtsd_mm_sqrt_pd__builtin_ia32_sqrtpd_mm_div_sd__builtin_ia32_divsd_mm_div_pd_mm_mul_sd__builtin_ia32_mulsd_mm_mul_pd_mm_sub_sd__builtin_ia32_subsd_mm_sub_pd_mm_add_sd__builtin_ia32_addsd_mm_add_pd_mm_cvtsi128_si64x_mm_cvtsi128_si64_mm_cvtsi128_si32__builtin_ia32_vec_ext_v4si_mm_storer_pd_MM_SHUFFLE2 (0,1)_mm_store_pd1_mm_store1_pd_MM_SHUFFLE2 (0,0)_mm_storeh_pd_mm_storel_pd_mm_cvtsd_f64_mm_store_sd_mm_storeu_pd__m128d_u *__attribute((vector_size(16))) double *_mm_store_pd__m128d *_mm_loadr_pd_mm_load_pd1_mm_load_sd_mm_load1_pd_mm_loadu_pd_mm_load_pd_mm_move_sd_mm_setzero_pd_mm_undefined_pd_mm_setr_pd_mm_set_pd_mm_set_pd1_mm_set1_pd_mm_set_sd__m128d_u__m128i_u__m128d__m128i__v16qu__attribute((vector_size(16))) signed char__v16qs__v8hu__v8hi__v4su__v4si__v2du__v2df_MM_SHUFFLE2(fp1,fp0)(((fp1) << 1) | (fp0))_mm_mwait__builtin_ia32_mwait_mm_monitor__builtin_ia32_monitor__DISABLE_MWAIT___MWAITINTRIN_H_INCLUDED__MWAIT__GCC push_optionsGCC target("mwait")GCC pop_options/* _MWAITINTRIN_H_INCLUDED *//* __DISABLE_MWAIT__ *//* __MWAIT__ *//* Copyright (C) 2021-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */__E__H<mwaitintrin.h>_mm_lddqu_si128__builtin_ia32_lddqu_mm_movedup_pd_mm_loaddup_pd_mm_hsub_pd__builtin_ia32_hsubpd_mm_hadd_pd__builtin_ia32_haddpd_mm_addsub_pd__builtin_ia32_addsubpd_mm_moveldup_ps__builtin_ia32_movsldup_mm_movehdup_ps__builtin_ia32_movshdup_mm_hsub_ps__builtin_ia32_hsubps_mm_hadd_ps__builtin_ia32_haddps_mm_addsub_ps__builtin_ia32_addsubps__DISABLE_SSE3___MM_GET_DENORMALS_ZERO_MODE()(_mm_getcsr() & _MM_DENORMALS_ZERO_MASK)_MM_SET_DENORMALS_ZERO_MODE(mode)_mm_setcsr ((_mm_getcsr () & ~_MM_DENORMALS_ZERO_MASK) | (mode))_MM_DENORMALS_ZERO_OFF_MM_DENORMALS_ZERO_ON_MM_DENORMALS_ZERO_MASK_PMMINTRIN_H_INCLUDED__SSE3__GCC target("sse3")/* _PMMINTRIN_H_INCLUDED *//* __DISABLE_SSE3__ *//* Additional bits in the MXCSR.  *//* __SSE3__ *//* We need definitions from the SSE2 and SSE header files*/<pmmintrin.h>_mm_abs_pi32__builtin_ia32_pabsd_mm_abs_pi16__builtin_ia32_pabsw_mm_abs_pi8__builtin_ia32_pabsb_mm_abs_epi32__builtin_ia32_pabsd128_mm_abs_epi16__builtin_ia32_pabsw128_mm_abs_epi8__builtin_ia32_pabsb128_mm_alignr_pi8__builtin_ia32_palignr_mm_alignr_epi8__builtin_ia32_palignr128_mm_sign_pi32__builtin_ia32_psignd_mm_sign_pi16__builtin_ia32_psignw_mm_sign_pi8__builtin_ia32_psignb_mm_sign_epi32__builtin_ia32_psignd128_mm_sign_epi16__builtin_ia32_psignw128_mm_sign_epi8__builtin_ia32_psignb128_mm_shuffle_pi8__builtin_ia32_pshufb_mm_shuffle_epi8__builtin_ia32_pshufb128_mm_mulhrs_pi16__builtin_ia32_pmulhrsw_mm_mulhrs_epi16__builtin_ia32_pmulhrsw128_mm_maddubs_pi16__builtin_ia32_pmaddubsw_mm_maddubs_epi16__builtin_ia32_pmaddubsw128_mm_hsubs_pi16__builtin_ia32_phsubsw_mm_hsub_pi32__builtin_ia32_phsubd_mm_hsub_pi16__builtin_ia32_phsubw_mm_hsubs_epi16__builtin_ia32_phsubsw128_mm_hsub_epi32__builtin_ia32_phsubd128_mm_hsub_epi16__builtin_ia32_phsubw128_mm_hadds_pi16__builtin_ia32_phaddsw_mm_hadd_pi32__builtin_ia32_phaddd_mm_hadd_pi16__builtin_ia32_phaddw_mm_hadds_epi16__builtin_ia32_phaddsw128_mm_hadd_epi32__builtin_ia32_phaddd128_mm_hadd_epi16__builtin_ia32_phaddw128__DISABLE_SSSE3___TMMINTRIN_H_INCLUDED__SSSE3__GCC target("ssse3")/* _TMMINTRIN_H_INCLUDED *//* __DISABLE_SSSE3__ *//* __SSSE3__ *//* We need definitions from the SSE3, SSE2 and SSE header files*//* Implemented from the specification included in the Intel C++ Compiler
   User Guide and Reference, version 9.1.  *//* Copyright (C) 2006-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mm_popcnt_u64__builtin_popcountll_mm_popcnt_u32__builtin_popcount__DISABLE_POPCNT___POPCNTINTRIN_H_INCLUDED__POPCNT__GCC target("popcnt")/* _POPCNTINTRIN_H_INCLUDED *//* __DISABLE_POPCNT__ *//* Calculate a number of bits set to 1.  *//* __POPCNT__ *//* Copyright (C) 2009-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */<popcntintrin.h><tmmintrin.h>_mm_crc32_u64__builtin_ia32_crc32di_mm_crc32_u32__builtin_ia32_crc32si_mm_crc32_u16__builtin_ia32_crc32hi_mm_crc32_u8__builtin_ia32_crc32qi_mm_cmpgt_epi64__attribute((vector_size(16))) long_mm_cmpestrz__builtin_ia32_pcmpestriz128_mm_cmpestrs__builtin_ia32_pcmpestris128_mm_cmpestro__builtin_ia32_pcmpestrio128_mm_cmpestrc__builtin_ia32_pcmpestric128_mm_cmpestra__builtin_ia32_pcmpestria128_mm_cmpistrz__builtin_ia32_pcmpistriz128_mm_cmpistrs__builtin_ia32_pcmpistris128_mm_cmpistro__builtin_ia32_pcmpistrio128_mm_cmpistrc__builtin_ia32_pcmpistric128_mm_cmpistra__builtin_ia32_pcmpistria128_mm_cmpestri__builtin_ia32_pcmpestri128_mm_cmpestrm__builtin_ia32_pcmpestrm128_mm_cmpistri__builtin_ia32_pcmpistri128_mm_cmpistrm__builtin_ia32_pcmpistrm128_mm_stream_load_si128__builtin_ia32_movntdqa_mm_mpsadbw_epu8__builtin_ia32_mpsadbw128_mm_packus_epi32__builtin_ia32_packusdw128_mm_cvtepu8_epi16__builtin_ia32_pmovzxbw128_mm_cvtepu16_epi64__builtin_ia32_pmovzxwq128_mm_cvtepu32_epi64__builtin_ia32_pmovzxdq128_mm_cvtepu8_epi64__builtin_ia32_pmovzxbq128_mm_cvtepu16_epi32__builtin_ia32_pmovzxwd128_mm_cvtepu8_epi32__builtin_ia32_pmovzxbd128_mm_cvtepi8_epi16__builtin_ia32_pmovsxbw128_mm_cvtepi16_epi64__builtin_ia32_pmovsxwq128_mm_cvtepi32_epi64__builtin_ia32_pmovsxdq128_mm_cvtepi8_epi64__builtin_ia32_pmovsxbq128_mm_cvtepi16_epi32__builtin_ia32_pmovsxwd128_mm_cvtepi8_epi32__builtin_ia32_pmovsxbd128_mm_minpos_epu16__builtin_ia32_phminposuw128_mm_extract_epi64__builtin_ia32_vec_ext_v2di_mm_extract_epi32_mm_extract_epi8__builtin_ia32_vec_ext_v16qi_mm_insert_epi64__builtin_ia32_vec_set_v2di_mm_insert_epi32__builtin_ia32_vec_set_v4si_mm_insert_epi8__builtin_ia32_vec_set_v16qi_mm_extract_psunion <unnamed>__builtin_ia32_vec_ext_v4sf_mm_insert_ps__builtin_ia32_insertps128_mm_mul_epi32__builtin_ia32_pmuldq128_mm_mullo_epi32_mm_max_epu32__builtin_ia32_pmaxud128_mm_min_epu32__builtin_ia32_pminud128_mm_max_epi32__builtin_ia32_pmaxsd128_mm_min_epi32__builtin_ia32_pminsd128_mm_max_epu16__builtin_ia32_pmaxuw128_mm_min_epu16__builtin_ia32_pminuw128_mm_max_epi8__builtin_ia32_pmaxsb128_mm_min_epi8__builtin_ia32_pminsb128_mm_cmpeq_epi64_mm_dp_pd__builtin_ia32_dppd_mm_dp_ps__builtin_ia32_dpps_mm_blendv_pd__builtin_ia32_blendvpd_mm_blend_pd__builtin_ia32_blendpd_mm_blendv_ps__builtin_ia32_blendvps__V__LX__LY__M__S_mm_blend_ps__builtin_ia32_blendps_mm_blendv_epi8__builtin_ia32_pblendvb128_mm_blend_epi16__builtin_ia32_pblendw128_mm_round_ss__builtin_ia32_roundss_mm_round_ps__builtin_ia32_roundps_mm_round_sd__builtin_ia32_roundsd_mm_round_pd__builtin_ia32_roundpd_mm_testnzc_si128__builtin_ia32_ptestnzc128_mm_testc_si128__builtin_ia32_ptestc128_mm_testz_si128__builtin_ia32_ptestz128__f__DISABLE_CRC32____DISABLE_SSE4_1____DISABLE_SSE4_2___SIDD_UNIT_MASK_SIDD_BIT_MASK0x00_SIDD_MOST_SIGNIFICANT_SIDD_LEAST_SIGNIFICANT_SIDD_MASKED_NEGATIVE_POLARITY0x30_SIDD_MASKED_POSITIVE_POLARITY0x20_SIDD_NEGATIVE_POLARITY0x10_SIDD_POSITIVE_POLARITY_SIDD_CMP_EQUAL_ORDERED0x0c_SIDD_CMP_EQUAL_EACH0x08_SIDD_CMP_RANGES0x04_SIDD_CMP_EQUAL_ANY_SIDD_SWORD_OPS0x03_SIDD_SBYTE_OPS0x02_SIDD_UWORD_OPS0x01_SIDD_UBYTE_OPS_MM_PICK_OUT_PS(X,N)_mm_insert_ps (_mm_setzero_ps (), (X), _MM_MK_INSERTPS_NDX ((N), 0, 0x0e))_MM_EXTRACT_FLOAT(D,S,N){ (D) = __builtin_ia32_vec_ext_v4sf ((__v4sf)(S), (N)); }_MM_MK_INSERTPS_NDX(S,D,M)(((S) << 6) | ((D) << 4) | (M))_mm_floor_ss(D,V)_mm_round_ss ((D), (V), _MM_FROUND_FLOOR)_mm_floor_ps(V)_mm_round_ps ((V), _MM_FROUND_FLOOR)_mm_ceil_ss(D,V)_mm_round_ss ((D), (V), _MM_FROUND_CEIL)_mm_ceil_ps(V)_mm_round_ps ((V), _MM_FROUND_CEIL)_mm_floor_sd(D,V)_mm_round_sd ((D), (V), _MM_FROUND_FLOOR)_mm_floor_pd(V)_mm_round_pd((V), _MM_FROUND_FLOOR)_mm_ceil_sd(D,V)_mm_round_sd ((D), (V), _MM_FROUND_CEIL)_mm_ceil_pd(V)_mm_round_pd ((V), _MM_FROUND_CEIL)_mm_test_mix_ones_zeros(M,V)_mm_testnzc_si128 ((M), (V))_mm_test_all_ones(V)_mm_testc_si128 ((V), _mm_cmpeq_epi32 ((V), (V)))_mm_test_all_zeros(M,V)_mm_testz_si128 ((M), (V))_MM_FROUND_NEARBYINT(_MM_FROUND_CUR_DIRECTION | _MM_FROUND_NO_EXC)_MM_FROUND_RINT(_MM_FROUND_CUR_DIRECTION | _MM_FROUND_RAISE_EXC)_MM_FROUND_TRUNC(_MM_FROUND_TO_ZERO | _MM_FROUND_RAISE_EXC)_MM_FROUND_CEIL(_MM_FROUND_TO_POS_INF | _MM_FROUND_RAISE_EXC)_MM_FROUND_FLOOR(_MM_FROUND_TO_NEG_INF | _MM_FROUND_RAISE_EXC)_MM_FROUND_NINT(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_RAISE_EXC)_MM_FROUND_NO_EXC_MM_FROUND_RAISE_EXC_MM_FROUND_CUR_DIRECTION_MM_FROUND_TO_ZERO_MM_FROUND_TO_POS_INF_MM_FROUND_TO_NEG_INF_MM_FROUND_TO_NEAREST_INT_SMMINTRIN_H_INCLUDED__SSE4_1__GCC target("sse4.1")__SSE4_2__GCC target("sse4.2")__CRC32__GCC target("crc32")/* _SMMINTRIN_H_INCLUDED *//* __DISABLE_CRC32__ *//* Accumulate CRC32 (polynomial 0x11EDC6F41) value.  *//* __CRC32__ *//* __DISABLE_SSE4_1__ *//* __DISABLE_SSE4_2__ *//* Packed integer 64-bit comparison, zeroing or filling with ones
   corresponding parts of result.  *//* Intrinsics for text/string processing and reading values of
   EFlags.  *//* Intrinsics for text/string processing.  *//* These macros specify the output selection in _mm_cmpXstrm ().  *//* These macros specify the output selection in _mm_cmpXstri ().  *//* These macros specify the polarity.  *//* These macros specify the comparison operation.  *//* These macros specify the source data format.  *//* __SSE4_2__ *//* Load double quadword using non-temporal aligned hint.  *//* Sum absolute 8-bit integer difference of adjacent groups of 4
   byte integers in the first 2 operands.  Starting offsets within
   operands are determined by the 3rd mask operand.  *//* Pack 8 double words from 2 operands into 8 words of result with
   unsigned saturation. *//* Packed integer zero-extension. *//* Packed integer sign-extension.  *//* Return horizontal packed word minimum and its index in bits [15:0]
   and bits [18:16] respectively.  *//* Extract integer from packed integer array element of X selected by
   index N.  *//* Insert integer, S, into packed integer array element of D
   selected by index N.  *//* Extract specified single precision float element into the lower
   part of __m128.  *//* Extract binary representation of single precision float into
   D from packed single precision array element of S selected
   by index N.  *//* Extract binary representation of single precision float from packed
   single precision array element of X selected by index N.  *//* Helper macro to create the N value for _mm_insert_ps.  *//* Insert single precision float into packed single precision array
   element selected by index N.  The bits [7-6] of N define S
   index, the bits [5-4] define D index, and bits [3-0] define
   zeroing mask for D.  *//* Packed integer 32-bit multiplication of 2 pairs of operands
   with two 64-bit results.  *//* Packed integer 32-bit multiplication with truncation of upper
   halves of results.  *//*  Min/max packed integer instructions.  *//* Dot product instructions with mask-defined summing and zeroing parts
   of result.  *//* Double precision floating point blend instructions - select data
   from 2 sources using constant/variable mask.  *//* Single precision floating point blend instructions - select data
   from 2 sources using constant/variable mask.  *//* Integer blend instructions - select data from 2 sources using
   constant/variable mask.  *//* SSE4.1 *//* Macros for ceil/floor intrinsics.  *//* Packed/scalar single precision floating point rounding.  *//* Packed/scalar double precision floating point rounding.  *//* Macros for packed integer 128-bit comparison intrinsics.  *//* Packed integer 128-bit bitwise comparison. Return 1 if
   (__V & __M) != 0 && (__V & ~__M) != 0.  *//* Packed integer 128-bit bitwise comparison. Return 1 if
   (__V & ~__M) == 0.  *//* Packed integer 128-bit bitwise comparison. Return 1 if
   (__V & __M) == 0.  *//* Test Instruction *//* Rounding mode macros. *//* __SSE4_1__ *//* We need definitions from the SSSE3, SSE3, SSE2 and SSE header
   files.  *//* Implemented from the specification included in the Intel C++ Compiler
   User Guide and Reference, version 10.0.  *//* Copyright (C) 2007-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */__writeeflags__builtin_ia32_writeeflags_u64__readeflags__builtin_ia32_readeflags_u64__rorq__rolq__popcntq__crc32q__bswapq__builtin_bswap64__bsrq__builtin_ia32_bsrdi__bsfq__builtin_ctzll__pause__rord__rorw__builtin_ia32_rorhi__rorb__builtin_ia32_rorqi__rold__rolw__builtin_ia32_rolhi__rolb__builtin_ia32_rolqi__rdtscp__builtin_ia32_rdtscp__rdtsc__builtin_ia32_rdtsc__rdpmc__builtin_ia32_rdpmc__popcntd__crc32d__crc32w__crc32b__bswapd__bsrd__builtin_ia32_bsrsi__bsfd__builtin_ctz_rotr(a,b)__rord((a), (b))_rotl(a,b)__rold((a), (b))_rotwr(a,b)__rorw((a), (b))_rotwl(a,b)__rolw((a), (b))_rdtsc()__rdtsc()_rdtscp(a)__rdtscp(a)_rdpmc(a)__rdpmc(a)_popcnt32(a)__popcntd(a)_bswap(a)__bswapd(a)_bit_scan_reverse(a)__bsrd(a)_bit_scan_forward(a)__bsfd(a)_lrotr(a,b)__rorq((a), (b))_lrotl(a,b)__rolq((a), (b))_popcnt64(a)__popcntq(a)_bswap64(a)__bswapq(a)_X86GPRINTRIN_H_INCLUDED__iamcu____LP64__/* __iamcu__ *//* On LP64 systems, longs are 64-bit.  Use the appropriate rotate
 * function.  *//* Write flags register *//* Read flags register *//* 64bit ror *//* 64bit rol *//* 64bit popcnt *//* 64bit accumulate CRC32 (polynomial 0x11EDC6F41) value.  *//* 64bit bswap *//* 64bit bsr *//* 64bit bsf *//* Pause *//* 32bit ror *//* 16bit ror *//* 8bit ror *//* 32bit rol *//* 16bit rol *//* 8bit rol *//* rdtscp *//* rdtsc *//* rdpmc *//* 32bit popcnt *//* 32bit accumulate CRC32 (polynomial 0x11EDC6F41) value.  *//* 32bit bswap *//* 32bit bsr *//* 32bit bsf */_addcarryx_u64__builtin_ia32_addcarryx_u64_addcarry_u64_subborrow_u64__builtin_ia32_sbb_u64_addcarryx_u32__builtin_ia32_addcarryx_u32_addcarry_u32_subborrow_u32__builtin_ia32_sbb_u32_ADXINTRIN_H_INCLUDED/* _ADXINTRIN_H_INCLUDED *//* Copyright (C) 2012-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */__CF_tzcnt_u64__builtin_ia32_tzcnt_u64__tzcnt_u64_blsr_u64__blsr_u64_blsmsk_u64__blsmsk_u64_blsi_u64__blsi_u64_bextr_u64__builtin_ia32_bextr_u640xff__bextr_u64_andn_u64__andn_u64_tzcnt_u32__builtin_ia32_tzcnt_u32__tzcnt_u32_blsr_u32__blsr_u32_blsmsk_u32__blsmsk_u32_blsi_u32__blsi_u32_bextr_u32__builtin_ia32_bextr_u32__bextr_u32_andn_u32__andn_u32_tzcnt_u16__builtin_ia32_tzcnt_u16__tzcnt_u16__DISABLE_BMI___BMIINTRIN_H_INCLUDED__BMI__GCC target("bmi")/* _BMIINTRIN_H_INCLUDED *//* __DISABLE_BMI__ *//* __x86_64__  *//* __BMI__ *//* Copyright (C) 2010-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mulx_u64__res_pext_u64__builtin_ia32_pext_di_pdep_u64__builtin_ia32_pdep_di_bzhi_u64__builtin_ia32_bzhi_di_pext_u32__builtin_ia32_pext_si_pdep_u32__builtin_ia32_pdep_si_bzhi_u32__builtin_ia32_bzhi_si__DISABLE_BMI2___BMI2INTRIN_H_INCLUDED__BMI2__GCC target("bmi2")/* _BMI2INTRIN_H_INCLUDED *//* __DISABLE_BMI2__ *//* !__x86_64__  *//* !__x86_64__ *//* __BMI2__ *//* Copyright (C) 2011-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_clrssbsy__builtin_ia32_clrssbsy_setssbsy__builtin_ia32_setssbsy_wrussq__builtin_ia32_wrussq_wrussd__builtin_ia32_wrussd_wrssq__builtin_ia32_wrssq_wrssd__builtin_ia32_wrssd_rstorssp__builtin_ia32_rstorssp_saveprevssp__builtin_ia32_saveprevssp_inc_ssp__builtin_ia32_incsspq_get_ssp__builtin_ia32_rdsspq__DISABLE_SHSTK___CETINTRIN_H_INCLUDED__SHSTK__GCC target ("shstk")/* _CETINTRIN_H_INCLUDED.  *//* __DISABLE_SHSTK__ *//* __SHSTK__ *//* Copyright (C) 2015-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_cldemote__builtin_ia32_cldemote__DISABLE_CLDEMOTE___CLDEMOTE_H_INCLUDED__CLDEMOTE__GCC target("cldemote")/* _CLDEMOTE_H_INCLUDED *//* __DISABLE_CLDEMOTE__ *//* __CLDEMOTE__ *//* Copyright (C) 2018-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mm_clflushopt__builtin_ia32_clflushopt__DISABLE_CLFLUSHOPT___CLFLUSHOPTINTRIN_H_INCLUDED__CLFLUSHOPT__GCC target("clflushopt")/* _CLFLUSHOPTINTRIN_H_INCLUDED *//* __DISABLE_CLFLUSHOPT__ *//* __CLFLUSHOPT__ *//* Copyright (C) 2013-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mm_clwb__builtin_ia32_clwb__DISABLE_CLWB___CLWBINTRIN_H_INCLUDED__CLWB__GCC target("clwb")/* _CLWBINTRIN_H_INCLUDED *//* __DISABLE_CLWB__ *//* __CLWB__ */_mm_clzero__builtin_ia32_clzero__DISABLE_CLZERO___CLZEROINTRIN_H_INCLUDED__CLZERO__GCC target("clzero")/* _CLZEROINTRIN_H_INCLUDED *//* __DISABLE_CLZERO__ *//* __CLZERO__ */_enqcmds__builtin_ia32_enqcmds_enqcmd__builtin_ia32_enqcmd__DISABLE_ENQCMD___ENQCMDINTRIN_H_INCLUDED__ENQCMD__GCC target ("enqcmd")/* _ENQCMDINTRIN_H_INCLUDED.  *//* __DISABLE_ENQCMD__ *//* __ENQCMD__ *//* Copyright (C) 2019-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */__Q_fxrstor64__builtin_ia32_fxrstor64_fxsave64__builtin_ia32_fxsave64_fxrstor__builtin_ia32_fxrstor_fxsave__builtin_ia32_fxsave_FXSRINTRIN_H_INCLUDED__FXSR____DISABLE_FXSR__/* _FXSRINTRIN_H_INCLUDED *//* __DISABLE_FXSR__ *//* __FXSR__ */_lzcnt_u64__builtin_ia32_lzcnt_u64__lzcnt64_lzcnt_u32__builtin_ia32_lzcnt_u32__lzcnt32__lzcnt16__builtin_ia32_lzcnt_u16__DISABLE_LZCNT___LZCNTINTRIN_H_INCLUDED__LZCNT__GCC target("lzcnt")/* _LZCNTINTRIN_H_INCLUDED *//* __DISABLE_LZCNT__ *//* __LZCNT__ */__lwpins64__builtin_ia32_lwpins64__lwpins32__builtin_ia32_lwpins32__lwpval64__builtin_ia32_lwpval64__lwpval32__builtin_ia32_lwpval32__slwpcb__builtin_ia32_slwpcb__llwpcb__builtin_ia32_llwpcb__DISABLE_LWP___LWPINTRIN_H_INCLUDED__LWP__GCC target("lwp")/* _LWPINTRIN_H_INCLUDED *//* __DISABLE_LWP__ *//* __LWP__ */__data2__data1__flags__pcbAddress_movdir64b__builtin_ia32_movdir64b_directstoreu_u64__builtin_ia32_directstoreu_u64_directstoreu_u32__builtin_ia32_directstoreu_u32__DISABLE_MOVDIR64B____DISABLE_MOVDIRI___MOVDIRINTRIN_H_INCLUDED__MOVDIRI__GCC target ("movdiri")__MOVDIR64B__GCC target ("movdir64b")/* _MOVDIRINTRIN_H_INCLUDED.  *//* __DISABLE_MOVDIR64B__ *//* __MOVDIR64B__ *//* __DISABLE_MOVDIRI__ *//* __MOVDIRI__ */_mm_mwaitx__builtin_ia32_mwaitx_mm_monitorx__builtin_ia32_monitorx__DISABLE_MWAITX___MWAITXINTRIN_H_INCLUDED__MWAITX__GCC target("mwaitx")/* _MWAITXINTRIN_H_INCLUDED *//* __DISABLE_MWAITX__ *//* __MWAITX__ */_pconfig_u32const unsigned intsize_t[]unsigned long[]__pconfig_type__PCONFIG_KEY_PROGRAM__R__L__D[0]__D[1]__D[2]__builtin_constant_p__DISABLE_PCONFIG____pconfig_generic(leaf,b,c,d,retval)__asm__ __volatile__ ("pconfig\n\t" : "=a" (retval), "=b" (b), "=c" (c), "=d" (d) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__pconfig_b(leaf,b,retval)__asm__ __volatile__ ("pconfig\n\t" : "=a" (retval) : "a" (leaf), "b" (b) : "cc")_PCONFIGINTRIN_H_INCLUDED__PCONFIG__GCC target("pconfig")/* _PCONFIGINTRIN_H_INCLUDED *//* __DISABLE_PCONFIG__ *//* __PCONFIG__ */_wrpkru__builtin_ia32_wrpkru_rdpkru_u32__builtin_ia32_rdpkru__DISABLE_PKU___PKUINTRIN_H_INCLUDED__PKU__GCC target("pku")/* _PKUINTRIN_H_INCLUDED *//* __DISABLE_PKU__ *//* __PKU__ */_rdseed64_step__builtin_ia32_rdseed_di_step_rdseed32_step__builtin_ia32_rdseed_si_step_rdseed16_step__builtin_ia32_rdseed_hi_step__DISABLE_RDSEED___RDSEEDINTRIN_H_INCLUDED__RDSEED__GCC target("rdseed")/* _RDSEEDINTRIN_H_INCLUDED *//* __DISABLE_RDSEED__ *//* __RDSEED__ */__p_xabort__builtin_ia32_xabort_xend__builtin_ia32_xend_xbegin__builtin_ia32_xbegin__DISABLE_RTM___XABORT_CODE(x)(((x) >> 24) & 0xFF)_XABORT_NESTED(1 << 5)_XABORT_DEBUG(1 << 4)_XABORT_CAPACITY_XABORT_CONFLICT_XABORT_RETRY(1 << 1)_XABORT_EXPLICIT(1 << 0)_XBEGIN_STARTED(~0u)_RTMINTRIN_H_INCLUDED__RTM__GCC target("rtm")/* _RTMINTRIN_H_INCLUDED *//* __DISABLE_RTM__ *//* __OPTIMIZE__ *//* Force an RTM abort condition. The control is transferred to the
   outermost transaction fallback handler with the abort condition IMM.  *//* Specify the end of an RTM code region.  If it corresponds to the
   outermost transaction, then attempts the transaction commit.  If the
   commit fails, then control is transferred to the outermost transaction
   fallback handler.  *//* Start an RTM code region.  Return _XBEGIN_STARTED on success and the
   abort condition otherwise.  *//* __RTM__ */__imm_serialize__builtin_ia32_serialize__DISABLE_SERIALIZE___SERIALIZE_H_INCLUDED__SERIALIZE__GCC target("serialize")/* _SERIALIZE_H_INCLUDED.  *//* __DISABLE_SERIALIZE__ *//* __SERIALIZE__ */__enclu_type__SGX_EREPORT__SGX_EGETKEY__SGX_EENTER__SGX_ERESUME__SGX_EEXIT__SGX_EACCEPT0x05__SGX_EMODPE0x06__SGX_EACCEPTCOPY0x07__encls_type__SGX_ECREATE__SGX_EADD__SGX_EINIT__SGX_EREMOVE__SGX_EDBGRD__SGX_EDBGWR__SGX_EEXTEND__SGX_ELDB__SGX_ELDU__SGX_EBLOCK0x09__SGX_EPA0x0A__SGX_EWB0x0B__SGX_ETRACK0x0C__SGX_EAUG0x0D__SGX_EMODPR0x0E__SGX_EMODT__SGX_ERDINFO__SGX_ETRACKC0x11__SGX_ELDBC0x12__SGX_ELDUC0x13_enclv_u32__enclv_type__SGX_EDECVIRTCHILD__SGX_EINCVIRTCHILD__SGX_ESETCONTEXT_enclu_u32__T_encls_u32__DISABLE_SGX____enclv_generic(leaf,b,c,d,retval)__asm__ __volatile__("enclv\n\t" : "=a" (retval), "=b" (b), "=c" (b), "=d" (d) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__enclv_cd(leaf,c,d,retval)__asm__ __volatile__("enclv\n\t" : "=a" (retval) : "a" (leaf), "c" (c), "d" (d) : "cc")__enclv_bc(leaf,b,c,retval)__asm__ __volatile__("enclv\n\t" : "=a" (retval) : "a" (leaf), "b" (b), "c" (c) : "cc")__enclu_generic(leaf,b,c,d,retval)__asm__ __volatile__("enclu\n\t" : "=a" (retval), "=b" (b), "=c" (c), "=d" (d) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__enclu_eexit(leaf,b,c,retval)__asm__ __volatile__("enclu\n\t" : "=a" (retval), "=c" (c) : "a" (leaf), "b" (b) : "cc")__enclu_eenter(leaf,b,c,retval)__asm__ __volatile__("enclu\n\t" : "=a" (retval), "=c" (c) : "a" (leaf), "b" (b), "c" (c) : "cc")__enclu_bcd(leaf,b,c,d,retval)__asm__ __volatile__("enclu\n\t" : "=a" (retval) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__enclu_bc(leaf,b,c,retval)__asm__ __volatile__("enclu\n\t" : "=a" (retval) : "a" (leaf), "b" (b), "c" (c) : "cc")__encls_generic(leaf,b,c,d,retval)__asm__ __volatile__("encls\n\t" : "=a" (retval), "=b" (b), "=c" (c), "=d" (d) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__encls_edbgrd(leaf,b,c,retval)__asm__ __volatile__("encls\n\t" : "=a" (retval), "=b" (b) : "a" (leaf), "c" (c))__encls_c(leaf,c,retval)__asm__ __volatile__("encls\n\t" : "=a" (retval) : "a" (leaf), "c" (c) : "cc")__encls_bcd(leaf,b,c,d,retval)__asm__ __volatile__("encls\n\t" : "=a" (retval) : "a" (leaf), "b" (b), "c" (c), "d" (d) : "cc")__encls_bc(leaf,b,c,retval)__asm__ __volatile__ ("encls\n\t" : "=a" (retval) : "a" (leaf), "b" (b), "c" (c) : "cc")_SGXINTRIN_H_INCLUDED__SGX__GCC target("sgx")/* _SGXINTRIN_H_INCLUDED *//* __DISABLE_SGX__ *//* __SGX__ *//* Copyright (C) 2017-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */__tzmsk_u64__t1mskc_u64__blsic_u64__blsfill_u64__blcs_u64__blcmsk_u64__blcic_u64__blci_u64__blcfill_u64__bextri_u64__builtin_ia32_bextri_u64__tzmsk_u32__t1mskc_u32__blsic_u32__blsfill_u32__blcs_u32__blcmsk_u32__blcic_u32__blci_u32__blcfill_u32__bextri_u32__builtin_ia32_bextri_u32__DISABLE_TBM___TBMINTRIN_H_INCLUDED__TBM__GCC target("tbm")/* _TBMINTRIN_H_INCLUDED *//* __DISABLE_TBM__ *//*__OPTIMIZE__ *//* __TBM__ */_xresldtrk__builtin_ia32_xresldtrk_xsusldtrk__builtin_ia32_xsusldtrk__DISABLE_TSXLDTRK___TSXLDTRKINTRIN_H_INCLUDED!defined(__TSXLDTRK__)GCC target("tsxldtrk")/* _TSXLDTRKINTRIN_H_INCLUDED *//* __DISABLE_TSXLDTRK__ *//* __TSXLDTRK__ *//* Copyright (C) 2020-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_testui__builtin_ia32_testui_senduipi__builtin_ia32_senduipi_stui__builtin_ia32_stui_clui__builtin_ia32_clui__uintr_framersprflagsrip__DISABLE_UINTR___UINTRNTRIN_H_INCLUDED__UINTR__GCC target ("uintr")/* _UINTRNTRIN_H_INCLUDED.  *//* __DISABLE_UINTR__ *//* RSP of the interrupted user process.  *//* RFLAGS of the interrupted user process.  *//* RIP of the interrupted user process.  *//* __UINTR__ */_tpause__builtin_ia32_tpause_umwait__builtin_ia32_umwait_umonitor__builtin_ia32_umonitor__DISABLE_WAITPKG___WAITPKG_H_INCLUDED__WAITPKG__GCC target("waitpkg")/* _WAITPKG_H_INCLUDED.  *//* __DISABLE_WAITPKG__ *//* __WAITPKG__ */_wbnoinvd__builtin_ia32_wbnoinvd__DISABLE_WBNOINVD___WBNOINVDINTRIN_H_INCLUDED__WBNOINVD__GCC target("wbnoinvd")/* _WBNOINVDINTRIN_H_INCLUDED *//* __DISABLE_WBNOINVD__ *//* __WBNOINVD__ */_xrstor64__builtin_ia32_xrstor64_xsave64__builtin_ia32_xsave64_xgetbv__builtin_ia32_xgetbv_xsetbv__builtin_ia32_xsetbv_xrstor__builtin_ia32_xrstor_xsave__builtin_ia32_xsave__DISABLE_XSAVE___XSAVEINTRIN_H_INCLUDED__XSAVE__GCC target("xsave")/* _XSAVEINTRIN_H_INCLUDED *//* __DISABLE_XSAVE__ *//* __XSAVE__ */_xsavec64__builtin_ia32_xsavec64_xsavec__builtin_ia32_xsavec__DISABLE_XSAVEC___XSAVECINTRIN_H_INCLUDED__XSAVEC__GCC target("xsavec")/* _XSAVECINTRIN_H_INCLUDED *//* __DISABLE_XSAVEC__ *//* __XSAVEC__ *//* Copyright (C) 2014-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_xsaveopt64__builtin_ia32_xsaveopt64_xsaveopt__builtin_ia32_xsaveopt__DISABLE_XSAVEOPT___XSAVEOPTINTRIN_H_INCLUDED__XSAVEOPT__GCC target("xsaveopt")/* _XSAVEOPTINTRIN_H_INCLUDED *//* __DISABLE_XSAVEOPT__ *//* __XSAVEOPT__ */_xsaves64__builtin_ia32_xsaves64_xrstors64__builtin_ia32_xrstors64_xrstors__builtin_ia32_xrstors_xsaves__builtin_ia32_xsaves__DISABLE_XSAVES___XSAVESINTRIN_H_INCLUDED__XSAVES__GCC target("xsaves")/* _XSAVESINTRIN_H_INCLUDED *//* __DISABLE_XSAVES__ *//* __XSAVES__ */_xtest__builtin_ia32_xtest_XTESTINTRIN_H_INCLUDED/* _XTESTINTRIN_H_INCLUDED *//* Return non-zero if the instruction executes inside an RTM or HLE code
   region.  Return zero otherwise.   */_hreset__builtin_ia32_hreset__DISABLE_HRESET___HRESETINTRIN_H_INCLUDED!defined _X86GPRINTRIN_H_INCLUDED__HRESET__GCC target ("hreset")/* _HRESETINTRIN_H_INCLUDED.  *//* __DISABLE_HRESET__ *//* __HRESET__ */__EAX<hresetintrin.h><xtestintrin.h><xsavesintrin.h><xsaveoptintrin.h><xsavecintrin.h><xsaveintrin.h><wbnoinvdintrin.h><waitpkgintrin.h><uintrintrin.h><tsxldtrkintrin.h><tbmintrin.h><sgxintrin.h><serializeintrin.h><rtmintrin.h><rdseedintrin.h><pkuintrin.h><pconfigintrin.h><mwaitxintrin.h><movdirintrin.h><lwpintrin.h><lzcntintrin.h><fxsrintrin.h><enqcmdintrin.h><clzerointrin.h><clwbintrin.h><clflushoptintrin.h><cldemoteintrin.h><cetintrin.h><bmi2intrin.h><bmiintrin.h><adxintrin.h><ia32intrin.h>_ptwrite32__builtin_ia32_ptwrite32_ptwrite64__builtin_ia32_ptwrite64_rdrand64_step__builtin_ia32_rdrand64_step_writegsbase_u64__builtin_ia32_wrgsbase64_writegsbase_u32__builtin_ia32_wrgsbase32_writefsbase_u64__builtin_ia32_wrfsbase64_writefsbase_u32__builtin_ia32_wrfsbase32_readgsbase_u64__builtin_ia32_rdgsbase64_readgsbase_u32__builtin_ia32_rdgsbase32_readfsbase_u64__builtin_ia32_rdfsbase64_readfsbase_u32__builtin_ia32_rdfsbase32_rdpid_u32__builtin_ia32_rdpid_rdrand32_step__builtin_ia32_rdrand32_step_rdrand16_step__builtin_ia32_rdrand16_step_wbinvd__builtin_ia32_wbinvd__DISABLE_GENERAL_REGS_ONLY____DISABLE_PTWRITE____DISABLE_RDRND____DISABLE_FSGSBASE____DISABLE_RDPID__!defined _SOFT_FLOAT || defined __MMX__ || defined __SSE__GCC target("general-regs-only")__RDRND__GCC target("rdrnd")__RDPID__GCC target("rdpid")__FSGSBASE__GCC target("fsgsbase")__PTWRITE__GCC target("ptwrite")/* _X86GPRINTRIN_H_INCLUDED.  *//* __DISABLE_GENERAL_REGS_ONLY__ *//* __DISABLE_PTWRITE__ *//* __x86_64__ *//* __DISABLE_RDRND__ *//* __RDRND__ *//* __DISABLE_FSGSBASE__ *//* __FSGSBASE__ *//* __DISABLE_RDPID__ *//* __RDPID__ */_mm_clmulepi64_si128__builtin_ia32_pclmulqdq128_mm_aeskeygenassist_si128__builtin_ia32_aeskeygenassist128_mm_aesimc_si128__builtin_ia32_aesimc128__builtin_ia32_aesenclast128__builtin_ia32_aesenc128__builtin_ia32_aesdeclast128__builtin_ia32_aesdec128__DISABLE_PCLMUL____DISABLE_AES___WMMINTRIN_H_INCLUDED!defined(__AES__) || !defined(__SSE2__)GCC target("aes,sse2")!defined(__PCLMUL__) || !defined(__SSE2__)GCC target("pclmul,sse2")/* _WMMINTRIN_H_INCLUDED *//* __DISABLE_PCLMUL__ *//* Performs carry-less integer multiplication of 64-bit halves of
   128-bit input operands.  The third parameter inducates which 64-bit
   haves of the input parameters v1 and v2 should be used. It must be
   a compile time constant.  *//* __PCLMUL__ *//* PCLMUL *//* __DISABLE_AES__ *//* Generates a m128i round key for the input m128i AES cipher key and
   byte round constant.  The second parameter must be a compile time
   constant.  *//* Performs the InverseMixColumn operation on the source m128i 
   and stores the result into m128i destination.  *//* Performs the last round of AES encryption of the first m128i
   using the second m128i as a round key.  *//* Performs 1 round of AES encryption of the first m128i using 
   the second m128i as a round key.  *//* Performs the last round of AES decryption of the first m128i 
   using the second m128i as a round key.  *//* Performs 1 round of AES decryption of the first m128i using 
   the second m128i as a round key.  *//* __AES__ *//* AES *//* We need definitions from the SSE2 header file.  *//* Implemented from the specification included in the Intel C++ Compiler
   User Guide and Reference, version 10.1.  *//* Copyright (C) 2008-2022 Free Software Foundation, Inc.

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */_mm256_storeu2_m128i_mm256_loadu2_m128i_mm256_storeu2_m128d_mm256_loadu2_m128d_mm256_storeu2_m128_mm256_loadu2_m128_mm256_setr_m128i_mm256_setr_m128d_mm256_setr_m128_mm256_set_m128i_mm256_set_m128d_mm256_set_m128_mm256_zextsi128_si256_mm256_zextps128_ps256_mm256_zextpd128_pd256_mm256_castsi128_si256__builtin_ia32_si256_si__attribute((vector_size(32))) int_mm256_castps128_ps256__builtin_ia32_ps256_ps__attribute((vector_size(32))) float_mm256_castpd128_pd256__builtin_ia32_pd256_pd__attribute((vector_size(32))) double_mm256_castsi256_si128__builtin_ia32_si_si256_mm256_castps256_ps128__builtin_ia32_ps_ps256_mm256_castpd256_pd128__builtin_ia32_pd_pd256_mm256_castsi256_pd_mm256_castsi256_ps_mm256_castps_si256_mm256_castps_pd_mm256_castpd_si256_mm256_castpd_ps_mm256_setr_epi64x_mm256_setr_epi8_mm256_setr_epi16_mm256_setr_epi32_mm256_setr_ps_mm256_setr_pd_mm256_set1_epi64x_mm256_set1_epi8_mm256_set1_epi16_mm256_set1_epi32_mm256_set1_ps_mm256_set1_pd_mm256_set_epi64x_mm256_set_epi8_mm256_set_epi16_mm256_set_epi32_mm256_set_ps_mm256_set_pd_mm256_setzero_si256_mm256_setzero_ps_mm256_setzero_pd_mm256_undefined_si256_mm256_undefined_ps__PH__PL__q31__q30__q29__q28__q27__q26__q25__q24__q23__q22__q21__q20__q19__q18__q17__q16__G_mm256_undefined_pd_mm256_movemask_ps__builtin_ia32_movmskps256_mm256_movemask_pd__builtin_ia32_movmskpd256_mm256_testnzc_si256__builtin_ia32_ptestnzc256_mm256_testc_si256__builtin_ia32_ptestc256_mm256_testz_si256__builtin_ia32_ptestz256_mm256_testnzc_ps__builtin_ia32_vtestnzcps256_mm256_testc_ps__builtin_ia32_vtestcps256_mm256_testz_ps__builtin_ia32_vtestzps256_mm256_testnzc_pd__builtin_ia32_vtestnzcpd256_mm256_testc_pd__builtin_ia32_vtestcpd256_mm256_testz_pd__builtin_ia32_vtestzpd256_mm_testnzc_ps__builtin_ia32_vtestnzcps_mm_testc_ps__builtin_ia32_vtestcps_mm_testz_ps__builtin_ia32_vtestzps_mm_testnzc_pd__builtin_ia32_vtestnzcpd_mm_testc_pd__builtin_ia32_vtestcpd_mm_testz_pd__builtin_ia32_vtestzpd_mm256_unpacklo_ps__builtin_ia32_unpcklps256_mm256_unpackhi_ps__builtin_ia32_unpckhps256_mm256_unpacklo_pd__builtin_ia32_unpcklpd256_mm256_unpackhi_pd__builtin_ia32_unpckhpd256_mm256_round_ps__builtin_ia32_roundps256_mm256_round_pd__builtin_ia32_roundpd256_mm256_sqrt_ps__builtin_ia32_sqrtps256_mm256_sqrt_pd__builtin_ia32_sqrtpd256_mm256_rsqrt_ps__builtin_ia32_rsqrtps256_mm256_rcp_ps__builtin_ia32_rcpps256_mm256_stream_ps__builtin_ia32_movntps256_mm256_stream_pd__builtin_ia32_movntpd256_mm256_stream_si256__builtin_ia32_movntdq256__v4di *_mm256_lddqu_si256__builtin_ia32_lddqu256__attribute((vector_size(32))) char_mm256_movedup_pd__builtin_ia32_movddup256_mm256_moveldup_ps__builtin_ia32_movsldup256_mm256_movehdup_ps__builtin_ia32_movshdup256_mm256_maskstore_ps__builtin_ia32_maskstoreps256__attribute((vector_size(32))) float *__v8sf *_mm256_maskload_ps__builtin_ia32_maskloadps256const __attribute((vector_size(32))) floatconst __attribute((vector_size(32))) float *const __v8sfconst __v8sf *_mm_maskstore_ps__builtin_ia32_maskstoreps_mm_maskload_ps__builtin_ia32_maskloadpsconst __attribute((vector_size(16))) floatconst __attribute((vector_size(16))) float *const __v4sfconst __v4sf *_mm256_maskstore_pd__builtin_ia32_maskstorepd256__attribute((vector_size(32))) double *__v4df *_mm256_maskload_pd__builtin_ia32_maskloadpd256const __attribute((vector_size(32))) doubleconst __attribute((vector_size(32))) double *const __v4dfconst __v4df *_mm_maskstore_pd__builtin_ia32_maskstorepd__v2df *_mm_maskload_pd__builtin_ia32_maskloadpdconst __attribute((vector_size(16))) doubleconst __attribute((vector_size(16))) double *const __v2dfconst __v2df *_mm256_storeu_si256__m256i_u *_mm256_loadu_si256const __m256i_uconst __m256i_u *_mm256_store_si256_mm256_load_si256_mm256_storeu_ps__m256_u *_mm256_loadu_ps_mm256_storeu_pd__m256d_u *_mm256_loadu_pd_mm256_store_ps__m256 *_mm256_load_ps_mm256_store_pd__m256d *_mm256_load_pd_mm256_insert_epi64_mm256_insert_epi8_mm256_insert_epi16_mm256_insert_epi32_mm256_insertf128_si256__builtin_ia32_vinsertf128_si256_mm256_insertf128_ps__builtin_ia32_vinsertf128_ps256_mm256_insertf128_pd__builtin_ia32_vinsertf128_pd256_mm256_broadcast_psconst __m128const __m128 *__builtin_ia32_vbroadcastf128_ps256_mm256_broadcast_pdconst __m128dconst __m128d *__builtin_ia32_vbroadcastf128_pd256_mm256_broadcast_ss__builtin_ia32_vbroadcastss256_mm256_broadcast_sd__builtin_ia32_vbroadcastsd256_mm_broadcast_ss__builtin_ia32_vbroadcastss_mm256_permute2f128_si256__builtin_ia32_vperm2f128_si256_mm256_permute2f128_ps__builtin_ia32_vperm2f128_ps256_mm256_permute2f128_pd__builtin_ia32_vperm2f128_pd256_mm256_permute_ps__builtin_ia32_vpermilps256__O_mm_permute_ps__builtin_ia32_vpermilps_mm256_permute_pd__builtin_ia32_vpermilpd256_mm_permute_pd__builtin_ia32_vpermilpd_mm256_permutevar_ps__builtin_ia32_vpermilvarps256_mm_permutevar_ps__builtin_ia32_vpermilvarps_mm256_permutevar_pd__builtin_ia32_vpermilvarpd256_mm_permutevar_pd__builtin_ia32_vpermilvarpd_mm256_zeroupper__builtin_ia32_vzeroupper_mm256_zeroall__builtin_ia32_vzeroall_mm256_extract_epi64_mm256_extract_epi8_mm256_extract_epi16_mm256_extract_epi32_mm256_extractf128_si256__builtin_ia32_vextractf128_si256_mm256_extractf128_ps__builtin_ia32_vextractf128_ps256_mm256_extractf128_pd__builtin_ia32_vextractf128_pd256_mm256_cvtss_f32_mm256_cvtsd_f64_mm256_cvttps_epi32__builtin_ia32_cvttps2dq256_mm256_cvtpd_epi32__builtin_ia32_cvtpd2dq256_mm256_cvttpd_epi32__builtin_ia32_cvttpd2dq256_mm256_cvtps_pd__builtin_ia32_cvtps2pd256_mm256_cvtps_epi32__builtin_ia32_cvtps2dq256_mm256_cvtpd_ps__builtin_ia32_cvtpd2ps256_mm256_cvtepi32_ps__builtin_ia32_cvtdq2ps256_mm256_cvtepi32_pd__builtin_ia32_cvtdq2pd256_mm256_cvtsi256_si32_mm_cmp_ss__builtin_ia32_cmpss_mm_cmp_sd__builtin_ia32_cmpsd_mm256_cmp_ps__builtin_ia32_cmpps256_mm256_cmp_pd__builtin_ia32_cmppd256_mm_cmp_ps__builtin_ia32_cmpps_mm_cmp_pd__builtin_ia32_cmppd_mm256_xor_ps__builtin_ia32_xorps256_mm256_xor_pd__builtin_ia32_xorpd256_mm256_sub_ps_mm256_sub_pd_mm256_shuffle_ps__builtin_ia32_shufps256_mm256_shuffle_pd__builtin_ia32_shufpd256_mm256_or_ps__builtin_ia32_orps256_mm256_or_pd__builtin_ia32_orpd256_mm256_mul_ps_mm256_mul_pd_mm256_min_ps__builtin_ia32_minps256_mm256_min_pd__builtin_ia32_minpd256_mm256_max_ps__builtin_ia32_maxps256_mm256_max_pd__builtin_ia32_maxpd256_mm256_hsub_ps__builtin_ia32_hsubps256_mm256_hsub_pd__builtin_ia32_hsubpd256_mm256_hadd_ps__builtin_ia32_haddps256_mm256_hadd_pd__builtin_ia32_haddpd256_mm256_dp_ps__builtin_ia32_dpps256_mm256_div_ps_mm256_div_pd_mm256_blendv_ps__builtin_ia32_blendvps256_mm256_blendv_pd__builtin_ia32_blendvpd256_mm256_blend_ps__builtin_ia32_blendps256_mm256_blend_pd__builtin_ia32_blendpd256_mm256_andnot_ps__builtin_ia32_andnps256_mm256_andnot_pd__builtin_ia32_andnpd256_mm256_and_ps__builtin_ia32_andps256_mm256_and_pd__builtin_ia32_andpd256_mm256_addsub_ps__builtin_ia32_addsubps256_mm256_addsub_pd__builtin_ia32_addsubpd256_mm256_add_ps_mm256_add_pd__m256d_u__m256i_u__m256_u__m256d__m256i__m256__attribute((vector_size(32))) unsigned char__v32qu__attribute((vector_size(32))) signed char__v32qs__v32qi__attribute((vector_size(32))) unsigned short__v16hu__attribute((vector_size(32))) short__v16hi__attribute((vector_size(32))) unsigned int__v8su__v8si__attribute((vector_size(32))) unsigned long long__v4du__v4di__v8sf__v4df__DISABLE_AVX___mm256_floor_ps(V)_mm256_round_ps ((V), _MM_FROUND_FLOOR)_mm256_ceil_ps(V)_mm256_round_ps ((V), _MM_FROUND_CEIL)_mm256_floor_pd(V)_mm256_round_pd ((V), _MM_FROUND_FLOOR)_mm256_ceil_pd(V)_mm256_round_pd ((V), _MM_FROUND_CEIL)_CMP_TRUE_US0x1f_CMP_GT_OQ0x1e_CMP_GE_OQ0x1d_CMP_NEQ_OS0x1c_CMP_FALSE_OS_CMP_NGT_UQ0x1a_CMP_NGE_UQ0x19_CMP_EQ_US0x18_CMP_ORD_S0x17_CMP_NLE_UQ0x16_CMP_NLT_UQ0x15_CMP_NEQ_US0x14_CMP_UNORD_S_CMP_LE_OQ_CMP_LT_OQ_CMP_EQ_OS_CMP_TRUE_UQ0x0f_CMP_GT_OS0x0e_CMP_GE_OS0x0d_CMP_NEQ_OQ_CMP_FALSE_OQ0x0b_CMP_NGT_US0x0a_CMP_NGE_US_CMP_EQ_UQ_CMP_ORD_Q_CMP_NLE_US_CMP_NLT_US_CMP_NEQ_UQ_CMP_UNORD_Q_CMP_LE_OS_CMP_LT_OS_CMP_EQ_OQ_AVXINTRIN_H_INCLUDED_IMMINTRIN_H_INCLUDED__AVX__GCC target("avx")/* _AVXINTRIN_H_INCLUDED *//* __DISABLE_AVX__ *//* Similarly, but with zero extension instead of undefined values.  *//* When cast is done from a 128 to 256-bit type, the low 128 bits of
   the 256-bit result contain source parameter value and the upper 128
   bits of the result are undefined.  Those intrinsics shouldn't
   generate any extra moves.  *//* Create vectors of elements in the reversed order from the
   _mm256_set_XXX functions.  *//* Create a vector with all elements equal to A.  *//* Create the vector [A B C D E F G H].  *//* Create the vector [A B C D].  *//* Double/single precision floating point blend instructions - select
   data from 2 sources using constant/variable mask.  *//* True (unordered, signaling)  *//* Greater-than (ordered, non-signaling)  *//* Greater-than-or-equal (ordered, non-signaling)  *//* Not-equal (ordered, signaling)  *//* False (ordered, signaling)  *//* Not-greater-than (unordered, non-signaling)  *//* Not-greater-than-or-equal (unordered, non-signaling)  *//* Equal (unordered, signaling)  *//* Ordered (signaling)  *//* Not-less-than-or-equal (unordered, non-signaling)  *//* Not-less-than (unordered, non-signaling)  *//* Not-equal (unordered, signaling)  *//* Unordered (signaling)  *//* Less-than-or-equal (ordered, non-signaling)  *//* Less-than (ordered, non-signaling)  *//* Equal (ordered, signaling)  *//* True (unordered, non-signaling)  *//* Greater-than (ordered, signaling)  *//* Greater-than-or-equal (ordered, signaling)  *//* Not-equal (ordered, non-signaling)  *//* False (ordered, non-signaling)  *//* Not-greater-than (unordered, signaling)  *//* Not-greater-than-or-equal (unordered, signaling)  *//* Equal (unordered, non-signaling)  *//* Ordered (nonsignaling)   *//* Not-less-than-or-equal (unordered, signaling)  *//* Not-less-than (unordered, signaling)  *//* Not-equal (unordered, non-signaling)  *//* Unordered (non-signaling)  *//* Less-than-or-equal (ordered, signaling)  *//* Less-than (ordered, signaling)  *//* Equal (ordered, non-signaling)  *//* Compare predicates for scalar and packed compare intrinsics.  *//* __AVX__ *//* Implemented from the specification included in the Intel C++ Compiler
   User Guide and Reference, version 11.0.  */_mm_dpwssds_avx_epi32__builtin_ia32_vpdpwssds_v4si_mm256_dpwssds_avx_epi32__builtin_ia32_vpdpwssds_v8si_mm_dpwssd_avx_epi32__builtin_ia32_vpdpwssd_v4si_mm256_dpwssd_avx_epi32__builtin_ia32_vpdpwssd_v8si_mm_dpbusds_avx_epi32__builtin_ia32_vpdpbusds_v4si_mm256_dpbusds_avx_epi32__builtin_ia32_vpdpbusds_v8si_mm_dpbusd_avx_epi32__builtin_ia32_vpdpbusd_v4si_mm256_dpbusd_avx_epi32__builtin_ia32_vpdpbusd_v8si__DISABLE_AVXVNNIVL___AVXVNNIINTRIN_H_INCLUDED!defined(__AVXVNNI__)GCC target("avxvnni")/* _AVXVNNIINTRIN_H_INCLUDED *//* __DISABLE_AVXVNNIVL__ *//* __AVXVNNIVL__ */_mm256_mask_i64gather_epi32const int *__builtin_ia32_gatherdiv4si256_mm256_i64gather_epi32__src~0_mm_mask_i64gather_epi32__builtin_ia32_gatherdiv4si_mm_i64gather_epi32_mm256_mask_i32gather_epi32__builtin_ia32_gathersiv8si_mm256_i32gather_epi32_mm_mask_i32gather_epi32__builtin_ia32_gathersiv4si_mm_i32gather_epi32_mm256_mask_i64gather_epi64const long longconst long long *__builtin_ia32_gatherdiv4di_mm256_i64gather_epi64_mm_mask_i64gather_epi64__builtin_ia32_gatherdiv2di_mm_i64gather_epi64_mm256_mask_i32gather_epi64__builtin_ia32_gathersiv4di_mm256_i32gather_epi64_mm_mask_i32gather_epi64__builtin_ia32_gathersiv2di_mm_i32gather_epi64_mm256_mask_i64gather_ps__builtin_ia32_gatherdiv4sf256_mm256_i64gather_ps_mm_mask_i64gather_ps__builtin_ia32_gatherdiv4sf_mm_i64gather_ps_mm256_mask_i32gather_ps__builtin_ia32_gathersiv8sf_mm256_i32gather_ps_mm_mask_i32gather_ps__builtin_ia32_gathersiv4sf_mm_i32gather_ps_mm256_mask_i64gather_pd__builtin_ia32_gatherdiv4df_mm256_i64gather_pd_mm_mask_i64gather_pd__builtin_ia32_gatherdiv2df_mm_i64gather_pd_mm256_mask_i32gather_pd__builtin_ia32_gathersiv4df_mm256_i32gather_pd_mm_mask_i32gather_pd__builtin_ia32_gathersiv2df_mm_i32gather_pd_mm_srlv_epi64__builtin_ia32_psrlv2di__index__scale_mm256_srlv_epi64__builtin_ia32_psrlv4di_mm_srlv_epi32__builtin_ia32_psrlv4si_mm256_srlv_epi32__builtin_ia32_psrlv8si_mm_srav_epi32__builtin_ia32_psrav4si_mm256_srav_epi32__builtin_ia32_psrav8si_mm_sllv_epi64__builtin_ia32_psllv2di_mm256_sllv_epi64__builtin_ia32_psllv4di_mm_sllv_epi32__builtin_ia32_psllv4si_mm256_sllv_epi32__builtin_ia32_psllv8si_mm_maskstore_epi64__builtin_ia32_maskstoreq_mm_maskstore_epi32__builtin_ia32_maskstored__attribute((vector_size(16))) int *__v4si *_mm256_maskstore_epi64__builtin_ia32_maskstoreq256_mm256_maskstore_epi32__builtin_ia32_maskstored256__attribute((vector_size(32))) int *__v8si *_mm_maskload_epi64__builtin_ia32_maskloadqconst __attribute((vector_size(16))) long longconst __attribute((vector_size(16))) long long *const __v2diconst __v2di *_mm_maskload_epi32__builtin_ia32_maskloaddconst __attribute((vector_size(16))) intconst __attribute((vector_size(16))) int *const __v4siconst __v4si *_mm256_maskload_epi64__builtin_ia32_maskloadq256const __attribute((vector_size(32))) long longconst __attribute((vector_size(32))) long long *const __v4diconst __v4di *_mm256_maskload_epi32__builtin_ia32_maskloadd256const __attribute((vector_size(32))) intconst __attribute((vector_size(32))) int *const __v8siconst __v8si *_mm256_inserti128_si256__builtin_ia32_insert128i256_mm256_extracti128_si256__builtin_ia32_extract128i256_mm256_permute2x128_si256__builtin_ia32_permti256_mm256_permute4x64_epi64__builtin_ia32_permdi256_mm256_permutevar8x32_ps__builtin_ia32_permvarsf256_mm256_permute4x64_pd__builtin_ia32_permdf256_mm256_permutevar8x32_epi32__builtin_ia32_permvarsi256_mm_broadcastq_epi64__builtin_ia32_pbroadcastq128_mm_broadcastd_epi32__builtin_ia32_pbroadcastd128_mm_broadcastw_epi16__builtin_ia32_pbroadcastw128_mm_broadcastb_epi8__builtin_ia32_pbroadcastb128_mm256_broadcastq_epi64__builtin_ia32_pbroadcastq256_mm256_broadcastd_epi32__builtin_ia32_pbroadcastd256_mm256_broadcastw_epi16__builtin_ia32_pbroadcastw256_mm256_broadcastb_epi8__builtin_ia32_pbroadcastb256_mm256_blend_epi32__builtin_ia32_pblendd256_mm_blend_epi32__builtin_ia32_pblendd128_mm256_broadcastsi128_si256__builtin_ia32_vbroadcastsi256_mm256_broadcastsd_pd__builtin_ia32_vbroadcastsd_pd256_mm256_broadcastss_ps__builtin_ia32_vbroadcastss_ps256_mm_broadcastss_ps__builtin_ia32_vbroadcastss_ps_mm256_stream_load_si256__builtin_ia32_movntdqa256_mm256_unpacklo_epi64__builtin_ia32_punpcklqdq256_mm256_unpacklo_epi32__builtin_ia32_punpckldq256_mm256_unpacklo_epi16__builtin_ia32_punpcklwd256_mm256_unpacklo_epi8__builtin_ia32_punpcklbw256_mm256_unpackhi_epi64__builtin_ia32_punpckhqdq256_mm256_unpackhi_epi32__builtin_ia32_punpckhdq256_mm256_unpackhi_epi16__builtin_ia32_punpckhwd256_mm256_unpackhi_epi8__builtin_ia32_punpckhbw256_mm256_subs_epu16__builtin_ia32_psubusw256_mm256_subs_epu8__builtin_ia32_psubusb256_mm256_subs_epi16__builtin_ia32_psubsw256_mm256_subs_epi8__builtin_ia32_psubsb256_mm256_sub_epi64_mm256_sub_epi32_mm256_sub_epi16_mm256_sub_epi8_mm256_srl_epi64__builtin_ia32_psrlq256_mm256_srli_epi64__builtin_ia32_psrlqi256_mm256_srl_epi32__builtin_ia32_psrld256_mm256_srli_epi32__builtin_ia32_psrldi256_mm256_srl_epi16__builtin_ia32_psrlw256_mm256_srli_epi16__builtin_ia32_psrlwi256_mm256_srli_si256__builtin_ia32_psrldqi256_mm256_bsrli_epi128_mm256_sra_epi32__builtin_ia32_psrad256_mm256_srai_epi32__builtin_ia32_psradi256_mm256_sra_epi16__builtin_ia32_psraw256_mm256_srai_epi16__builtin_ia32_psrawi256_mm256_sll_epi64__builtin_ia32_psllq256_mm256_slli_epi64__builtin_ia32_psllqi256_mm256_sll_epi32__builtin_ia32_pslld256_mm256_slli_epi32__builtin_ia32_pslldi256_mm256_sll_epi16__builtin_ia32_psllw256_mm256_slli_epi16__builtin_ia32_psllwi256_mm256_slli_si256__builtin_ia32_pslldqi256_mm256_bslli_epi128_mm256_sign_epi32__builtin_ia32_psignd256_mm256_sign_epi16__builtin_ia32_psignw256_mm256_sign_epi8__builtin_ia32_psignb256_mm256_shufflelo_epi16__builtin_ia32_pshuflw256_mm256_shufflehi_epi16__builtin_ia32_pshufhw256_mm256_shuffle_epi32__builtin_ia32_pshufd256_mm256_shuffle_epi8__builtin_ia32_pshufb256_mm256_sad_epu8__builtin_ia32_psadbw256_mm256_or_si256_mm256_mul_epu32__builtin_ia32_pmuludq256_mm256_mullo_epi32_mm256_mullo_epi16_mm256_mulhi_epi16__builtin_ia32_pmulhw256_mm256_mulhi_epu16__builtin_ia32_pmulhuw256_mm256_mulhrs_epi16__builtin_ia32_pmulhrsw256_mm256_mul_epi32__builtin_ia32_pmuldq256_mm256_cvtepu32_epi64__builtin_ia32_pmovzxdq256_mm256_cvtepu16_epi64__builtin_ia32_pmovzxwq256_mm256_cvtepu16_epi32__builtin_ia32_pmovzxwd256_mm256_cvtepu8_epi64__builtin_ia32_pmovzxbq256_mm256_cvtepu8_epi32__builtin_ia32_pmovzxbd256_mm256_cvtepu8_epi16__builtin_ia32_pmovzxbw256_mm256_cvtepi32_epi64__builtin_ia32_pmovsxdq256_mm256_cvtepi16_epi64__builtin_ia32_pmovsxwq256_mm256_cvtepi16_epi32__builtin_ia32_pmovsxwd256_mm256_cvtepi8_epi64__builtin_ia32_pmovsxbq256_mm256_cvtepi8_epi32__builtin_ia32_pmovsxbd256_mm256_cvtepi8_epi16__builtin_ia32_pmovsxbw256_mm256_movemask_epi8__builtin_ia32_pmovmskb256_mm256_min_epu32__builtin_ia32_pminud256_mm256_min_epu16__builtin_ia32_pminuw256_mm256_min_epu8__builtin_ia32_pminub256_mm256_min_epi32__builtin_ia32_pminsd256_mm256_min_epi16__builtin_ia32_pminsw256_mm256_min_epi8__builtin_ia32_pminsb256_mm256_max_epu32__builtin_ia32_pmaxud256_mm256_max_epu16__builtin_ia32_pmaxuw256_mm256_max_epu8__builtin_ia32_pmaxub256_mm256_max_epi32__builtin_ia32_pmaxsd256_mm256_max_epi16__builtin_ia32_pmaxsw256_mm256_max_epi8__builtin_ia32_pmaxsb256_mm256_madd_epi16__builtin_ia32_pmaddwd256_mm256_maddubs_epi16__builtin_ia32_pmaddubsw256_mm256_hsubs_epi16__builtin_ia32_phsubsw256_mm256_hsub_epi32__builtin_ia32_phsubd256_mm256_hsub_epi16__builtin_ia32_phsubw256_mm256_hadds_epi16__builtin_ia32_phaddsw256_mm256_hadd_epi32__builtin_ia32_phaddd256_mm256_hadd_epi16__builtin_ia32_phaddw256_mm256_cmpgt_epi64__attribute((vector_size(32))) long_mm256_cmpgt_epi32_mm256_cmpgt_epi16_mm256_cmpgt_epi8_mm256_cmpeq_epi64_mm256_cmpeq_epi32_mm256_cmpeq_epi16_mm256_cmpeq_epi8_mm256_blend_epi16__builtin_ia32_pblendw256_mm256_blendv_epi8__builtin_ia32_pblendvb256_mm256_avg_epu16__builtin_ia32_pavgw256_mm256_avg_epu8__builtin_ia32_pavgb256_mm256_andnot_si256__builtin_ia32_andnotsi256_mm256_and_si256_mm256_alignr_epi8__builtin_ia32_palignr256_mm256_adds_epu16__builtin_ia32_paddusw256_mm256_adds_epu8__builtin_ia32_paddusb256_mm256_adds_epi16__builtin_ia32_paddsw256_mm256_adds_epi8__builtin_ia32_paddsb256_mm256_add_epi32_mm256_add_epi16_mm256_add_epi8_mm256_packus_epi16__builtin_ia32_packuswb256_mm256_packus_epi32__builtin_ia32_packusdw256_mm256_packs_epi16__builtin_ia32_packsswb256_mm256_packs_epi32__builtin_ia32_packssdw256_mm256_abs_epi32__builtin_ia32_pabsd256_mm256_abs_epi16__builtin_ia32_pabsw256_mm256_abs_epi8__builtin_ia32_pabsb256_mm256_mpsadbw_epu8__builtin_ia32_mpsadbw256__DISABLE_AVX2___mm_broadcastsd_pd(X)_mm_movedup_pd(X)_mm_broadcastsi128_si256(X)_mm256_broadcastsi128_si256(X)_AVX2INTRIN_H_INCLUDED__AVX2__GCC target("avx2")/* _AVX2INTRIN_H_INCLUDED *//* __DISABLE_AVX2__ *//* Use define instead *//* In that case (__N*8) will be in vreg, and insn will not be matched. *//* __AVX2__ */_mm512_mask_reduce_max_pd__builtin_inf+Infinity__builtin_inf ()max_pd__T1__T2__T3__T4__T5__T6__T7__T8_mm512_mask_reduce_min_pdmin_pd_mm512_reduce_max_pd_mm512_reduce_min_pd_mm512_mask_reduce_mul_pd1.0*_mm512_mask_reduce_add_pd+_mm512_reduce_mul_pd_mm512_reduce_add_pd_mm512_mask_reduce_max_epu64max_epu64_mm512_mask_reduce_min_epu64~0LLmin_epu64__U_mm512_reduce_max_epu64_mm512_reduce_min_epu64_mm512_mask_reduce_max_epi649223372036854775807-9223372036854775807-__LONG_LONG_MAX__-9223372036854775808-__LONG_LONG_MAX__ - 1max_epi64_mm512_mask_reduce_min_epi64min_epi64_mm512_reduce_max_epi64_mm512_reduce_min_epi64_mm512_mask_reduce_or_epi64|_mm512_mask_reduce_and_epi64&_mm512_mask_reduce_mul_epi641LL_mm512_mask_reduce_add_epi64_mm512_reduce_or_epi64_mm512_reduce_and_epi64_mm512_reduce_mul_epi64_mm512_reduce_add_epi64_mm512_mask_reduce_max_ps__builtin_inff__builtin_inff ()max_ps__T9__T10_mm512_mask_reduce_min_psmin_ps_mm512_reduce_max_ps_mm512_reduce_min_ps_mm512_mask_reduce_mul_ps1.0f_mm512_mask_reduce_add_ps_mm512_reduce_mul_ps_mm512_reduce_add_ps_mm512_mask_reduce_max_epu32max_epu32_mm512_mask_reduce_min_epu32min_epu32_mm512_mask_reduce_max_epi32-2147483647-__INT_MAX__-2147483648-__INT_MAX__ - 1max_epi32_mm512_mask_reduce_min_epi32min_epi32_mm512_reduce_max_epu32_mm512_reduce_min_epu32_mm512_reduce_max_epi32_mm512_reduce_min_epi32_mm512_mask_reduce_or_epi32_mm512_mask_reduce_and_epi32_mm512_mask_reduce_mul_epi32_mm512_mask_reduce_add_epi32_mm512_reduce_or_epi32_mm512_reduce_and_epi32_mm512_reduce_mul_epi32_mm512_reduce_add_epi32_mm512_cmpgt_epu64_mask__builtin_ia32_ucmpq512_mask__attribute((vector_size(64))) long long(__mmask8) -1_mm512_mask_cmpgt_epu64_mask_mm512_mask_cmpgt_epu32_mask__builtin_ia32_ucmpd512_mask__attribute((vector_size(64))) int_mm512_cmpgt_epu32_mask65535(__mmask16) -1_mm512_cmpeq_epu64_mask_mm512_mask_cmpeq_epu64_mask_mm512_mask_cmpeq_epu32_mask_mm512_cmpeq_epu32_mask_mm512_zextsi256_si512_mm512_zextps256_ps512_mm512_zextpd256_pd512_mm512_zextsi128_si512_mm512_zextps128_ps512_mm512_zextpd128_pd512_mm512_castsi256_si512__builtin_ia32_si512_256si_mm512_castps256_ps512__builtin_ia32_ps512_256ps__attribute((vector_size(64))) float_mm512_castpd256_pd512__builtin_ia32_pd512_256pd__attribute((vector_size(64))) double_mm512_castsi128_si512__builtin_ia32_si512_si_mm512_castps128_ps512__builtin_ia32_ps512_ps_mm512_castpd128_pd512__builtin_ia32_pd512_pd_mm512_castsi512_si256_mm512_castps512_ps256_mm512_castpd512_pd256_mm512_castsi512_si128_mm512_castps512_ps128_mm512_castpd512_pd128_mm512_castsi512_pd_mm512_castsi512_ps_mm512_castps_si512_mm512_castps_pd_mm512_castpd_si512_mm512_castpd_ps_mm512_kmov__builtin_ia32_kmovw_mm512_mask_cmpord_ps_mask__builtin_ia32_cmpps512_mask_mm512_cmpord_ps_mask_mm512_mask_cmpnle_ps_mask_mm512_cmpnle_ps_mask_mm512_mask_cmpnlt_ps_mask_mm512_cmpnlt_ps_mask_mm512_mask_cmpneq_ps_mask_mm512_cmpneq_ps_mask_mm512_mask_cmpunord_ps_mask_mm512_cmpunord_ps_mask_mm512_mask_cmple_ps_mask_mm512_cmple_ps_mask_mm512_mask_cmplt_ps_mask_mm512_cmplt_ps_mask_mm512_mask_cmpeq_ps_mask_mm512_cmpeq_ps_mask_mm512_mask_cmpord_pd_mask__builtin_ia32_cmppd512_mask_mm512_cmpord_pd_mask_mm512_mask_cmpnle_pd_mask_mm512_cmpnle_pd_mask_mm512_mask_cmpnlt_pd_mask_mm512_cmpnlt_pd_mask_mm512_mask_cmpneq_pd_mask_mm512_cmpneq_pd_mask_mm512_mask_cmpunord_pd_mask_mm512_cmpunord_pd_mask_mm512_mask_cmple_pd_mask_mm512_cmple_pd_mask_mm512_mask_cmplt_pd_mask_mm512_cmplt_pd_mask_mm512_mask_cmpeq_pd_mask_mm512_cmpeq_pd_mask_mm_mask_cmp_ss_mask__builtin_ia32_cmpss_mask_mm_cmp_ss_mask_mm_mask_cmp_sd_mask__builtin_ia32_cmpsd_mask_mm_cmp_sd_mask_mm512_mask_cmp_pd_mask_mm512_mask_cmp_ps_mask_mm512_cmp_ps_mask_mm512_cmp_pd_mask_mm_maskz_roundscale_sd__builtin_ia32_rndscalesd_mask_round_mm_mask_roundscale_sd_mm_roundscale_sd_mm_maskz_roundscale_ss__builtin_ia32_rndscaless_mask_round_mm_mask_roundscale_ss_mm_roundscale_ss_mm512_maskz_roundscale_pd__builtin_ia32_rndscalepd_mask_mm512_mask_roundscale_pd_mm512_roundscale_pd_mm512_maskz_roundscale_ps__builtin_ia32_rndscaleps_mask_mm512_mask_roundscale_ps_mm512_roundscale_ps_mm_maskz_getmant_ss__builtin_ia32_getmantss_mask_round_mm_mask_getmant_ss_mm_getmant_ss__builtin_ia32_getmantss_round_mm_maskz_getmant_sd__builtin_ia32_getmantsd_mask_round_mm_mask_getmant_sd_mm_getmant_sd__builtin_ia32_getmantsd_round_mm512_maskz_getmant_ps__builtin_ia32_getmantps512_mask_mm512_mask_getmant_ps_mm512_getmant_ps_mm512_maskz_getmant_pd__builtin_ia32_getmantpd512_mask_mm512_mask_getmant_pd_mm512_getmant_pd_mm_maskz_getexp_sd__builtin_ia32_getexpsd_mask_round_mm_mask_getexp_sd_mm_getexp_sd__builtin_ia32_getexpsd128_round_mm_maskz_getexp_ss__builtin_ia32_getexpss_mask_round_mm_mask_getexp_ss_mm_getexp_ss__builtin_ia32_getexpss128_round_mm512_maskz_getexp_pd__builtin_ia32_getexppd512_mask_mm512_mask_getexp_pd_mm512_getexp_pd_mm512_maskz_getexp_ps__builtin_ia32_getexpps512_mask_mm512_mask_getexp_ps_mm512_getexp_ps_mm512_maskz_cvtpd_ps__builtin_ia32_cvtpd2ps512_mask_mm512_mask_cvtpd_ps_mm512_cvtpd_ps_mm512_maskz_cvtph_ps__builtin_ia32_vcvtph2ps512_mask_mm512_mask_cvtph_ps_mm512_cvtph_ps_mm512_maskz_cvtps_pd__builtin_ia32_cvtps2pd512_mask_mm512_mask_cvtps_pd_mm512_cvtps_pd_mm_cvttsd_i32__builtin_ia32_vcvttsd2si32_mm_cvttsd_u32__builtin_ia32_vcvttsd2usi32_mm_cvtsd_u32__builtin_ia32_vcvtsd2usi32_mm_cvti64_ss_mm_cvti64_sd_mm_cvtss_i64_mm_cvtsd_i64_mm_cvttsd_i64__builtin_ia32_vcvttsd2si64_mm_cvttsd_u64__builtin_ia32_vcvttsd2usi64_mm_cvtsd_u64__builtin_ia32_vcvtsd2usi64_mm_cvti32_ss_mm_cvti32_sd_mm_cvtss_i32_mm_cvtsd_i32_mm_cvttss_i32__builtin_ia32_vcvttss2si32_mm_cvttss_u32__builtin_ia32_vcvttss2usi32_mm_cvtss_u32__builtin_ia32_vcvtss2usi32_mm512_cvtsi512_si32_mm_cvttss_i64__builtin_ia32_vcvttss2si64_mm_cvttss_u64__builtin_ia32_vcvttss2usi64_mm_cvtss_u64__builtin_ia32_vcvtss2usi64_mm_maskz_fixupimm_ss__builtin_ia32_fixupimmss_maskz_mm_mask_fixupimm_ss__builtin_ia32_fixupimmss_mask_mm_fixupimm_ss_mm_maskz_fixupimm_sd__builtin_ia32_fixupimmsd_maskz_mm_mask_fixupimm_sd__builtin_ia32_fixupimmsd_mask_mm_fixupimm_sd_mm512_maskz_fixupimm_ps__builtin_ia32_fixupimmps512_maskz_mm512_mask_fixupimm_ps__builtin_ia32_fixupimmps512_mask_mm512_fixupimm_ps_mm512_maskz_fixupimm_pd__builtin_ia32_fixupimmpd512_maskz_mm512_mask_fixupimm_pd__builtin_ia32_fixupimmpd512_mask_mm512_fixupimm_pd_mm512_maskz_cvtepu32_ps__builtin_ia32_cvtudq2ps512_mask_mm512_mask_cvtepu32_ps_mm512_cvtepu32_ps_mm512_maskz_cvtepi32_ps__builtin_ia32_cvtdq2ps512_mask_mm512_mask_cvtepi32_ps_mm512_cvtepi32_ps_mm_cvtu32_ss__builtin_ia32_cvtusi2ss32_mm_cvtu64_sd__builtin_ia32_cvtusi2sd64_mm_cvtu64_ss__builtin_ia32_cvtusi2ss64_mm512_cvtss_f32_mm512_cvtsd_f64_mm512_maskz_cvtps_epu32__builtin_ia32_cvtps2udq512_mask_mm512_mask_cvtps_epu32_mm512_cvtps_epu32_mm512_maskz_cvtps_epi32__builtin_ia32_cvtps2dq512_mask_mm512_mask_cvtps_epi32_mm512_cvtps_epi32_mm512_maskz_cvttps_epu32__builtin_ia32_cvttps2udq512_mask_mm512_mask_cvttps_epu32_mm512_cvttps_epu32_mm512_maskz_cvttps_epi32__builtin_ia32_cvttps2dq512_mask_mm512_mask_cvttps_epi32_mm512_cvttps_epi32_mm512_maskz_cvtpd_epu32__builtin_ia32_cvtpd2udq512_mask_mm512_mask_cvtpd_epu32_mm512_cvtpd_epu32_mm512_maskz_cvtpd_epi32__builtin_ia32_cvtpd2dq512_mask_mm512_mask_cvtpd_epi32_mm512_cvtpd_epi32_mm512_maskz_cvttpd_epu32__builtin_ia32_cvttpd2udq512_mask_mm512_mask_cvttpd_epu32_mm512_cvttpd_epu32_mm512_maskz_cvttpd_epi32__builtin_ia32_cvttpd2dq512_mask_mm512_mask_cvttpd_epi32_mm512_cvttpd_epi32_mm512_maskz_fnmsub_ps__builtin_ia32_vfnmsubps512_maskz_mm512_mask3_fnmsub_ps__builtin_ia32_vfnmsubps512_mask3_mm512_mask_fnmsub_ps__builtin_ia32_vfnmsubps512_mask_mm512_fnmsub_ps_mm512_maskz_fnmsub_pd__builtin_ia32_vfnmsubpd512_maskz_mm512_mask3_fnmsub_pd__builtin_ia32_vfnmsubpd512_mask3_mm512_mask_fnmsub_pd__builtin_ia32_vfnmsubpd512_mask_mm512_fnmsub_pd_mm512_maskz_fnmadd_ps__builtin_ia32_vfnmaddps512_maskz_mm512_mask3_fnmadd_ps__builtin_ia32_vfnmaddps512_mask3_mm512_mask_fnmadd_ps__builtin_ia32_vfnmaddps512_mask_mm512_fnmadd_ps_mm512_maskz_fnmadd_pd__builtin_ia32_vfnmaddpd512_maskz_mm512_mask3_fnmadd_pd__builtin_ia32_vfnmaddpd512_mask3_mm512_mask_fnmadd_pd__builtin_ia32_vfnmaddpd512_mask_mm512_fnmadd_pd_mm512_maskz_fmsubadd_ps__builtin_ia32_vfmaddsubps512_maskz_mm512_mask3_fmsubadd_ps__builtin_ia32_vfmsubaddps512_mask3_mm512_mask_fmsubadd_ps__builtin_ia32_vfmaddsubps512_mask_mm512_fmsubadd_ps_mm512_maskz_fmsubadd_pd__builtin_ia32_vfmaddsubpd512_maskz_mm512_mask3_fmsubadd_pd__builtin_ia32_vfmsubaddpd512_mask3_mm512_mask_fmsubadd_pd__builtin_ia32_vfmaddsubpd512_mask_mm512_fmsubadd_pd_mm512_maskz_fmaddsub_ps_mm512_mask3_fmaddsub_ps__builtin_ia32_vfmaddsubps512_mask3_mm512_mask_fmaddsub_ps_mm512_fmaddsub_ps_mm512_maskz_fmaddsub_pd_mm512_mask3_fmaddsub_pd__builtin_ia32_vfmaddsubpd512_mask3_mm512_mask_fmaddsub_pd_mm512_fmaddsub_pd_mm512_maskz_fmsub_ps__builtin_ia32_vfmsubps512_maskz_mm512_mask3_fmsub_ps__builtin_ia32_vfmsubps512_mask3_mm512_mask_fmsub_ps__builtin_ia32_vfmsubps512_mask_mm512_fmsub_ps_mm512_maskz_fmsub_pd__builtin_ia32_vfmsubpd512_maskz_mm512_mask3_fmsub_pd__builtin_ia32_vfmsubpd512_mask3_mm512_mask_fmsub_pd__builtin_ia32_vfmsubpd512_mask_mm512_fmsub_pd_mm512_maskz_fmadd_ps__builtin_ia32_vfmaddps512_maskz_mm512_mask3_fmadd_ps__builtin_ia32_vfmaddps512_mask3_mm512_mask_fmadd_ps__builtin_ia32_vfmaddps512_mask_mm512_fmadd_ps_mm512_maskz_fmadd_pd__builtin_ia32_vfmaddpd512_maskz_mm512_mask3_fmadd_pd__builtin_ia32_vfmaddpd512_mask3_mm512_mask_fmadd_pd__builtin_ia32_vfmaddpd512_mask_mm512_fmadd_pd_mm_scalef_ss__builtin_ia32_scalefss_mask_round_mm_scalef_sd__builtin_ia32_scalefsd_mask_round_mm512_maskz_scalef_ps__builtin_ia32_scalefps512_mask_mm512_mask_scalef_ps_mm512_scalef_ps_mm512_maskz_scalef_pd__builtin_ia32_scalefpd512_mask_mm512_mask_scalef_pd_mm512_scalef_pd_mm_maskz_min_ss__builtin_ia32_minss_mask_round_mm_mask_min_ss_mm_maskz_min_sd__builtin_ia32_minsd_mask_round_mm_mask_min_sd_mm512_maskz_min_ps__builtin_ia32_minps512_mask_mm512_mask_min_ps_mm512_min_ps_mm512_maskz_min_pd__builtin_ia32_minpd512_mask_mm512_mask_min_pd_mm512_min_pd_mm_maskz_max_ss__builtin_ia32_maxss_mask_round_mm_mask_max_ss_mm_maskz_max_sd__builtin_ia32_maxsd_mask_round_mm_mask_max_sd_mm512_maskz_max_ps__builtin_ia32_maxps512_mask_mm512_mask_max_ps_mm512_max_ps_mm512_maskz_max_pd__builtin_ia32_maxpd512_mask_mm512_mask_max_pd_mm512_max_pd_mm_maskz_div_ss__builtin_ia32_divss_mask_round_mm_mask_div_ss_mm_maskz_div_sd__builtin_ia32_divsd_mask_round_mm_mask_div_sd_mm512_maskz_div_ps__builtin_ia32_divps512_mask_mm512_mask_div_ps_mm512_div_ps_mm512_maskz_div_pd__builtin_ia32_divpd512_mask_mm512_mask_div_pd_mm512_div_pd_mm_maskz_mul_ss__builtin_ia32_mulss_mask_round_mm_mask_mul_ss_mm_maskz_mul_sd__builtin_ia32_mulsd_mask_round_mm_mask_mul_sd_mm512_maskz_mul_ps__builtin_ia32_mulps512_mask_mm512_mask_mul_ps_mm512_mul_ps_mm512_maskz_mul_pd__builtin_ia32_mulpd512_mask_mm512_mask_mul_pd_mm512_mul_pd_mm_maskz_sub_ss__builtin_ia32_subss_mask_round_mm_mask_sub_ss_mm_maskz_sub_sd__builtin_ia32_subsd_mask_round_mm_mask_sub_sd_mm512_maskz_sub_ps__builtin_ia32_subps512_mask_mm512_mask_sub_ps_mm512_sub_ps_mm512_maskz_sub_pd__builtin_ia32_subpd512_mask_mm512_mask_sub_pd_mm512_sub_pd_mm_maskz_add_ss__builtin_ia32_addss_mask_round_mm_mask_add_ss_mm_maskz_add_sd__builtin_ia32_addsd_mask_round_mm_mask_add_sd_mm512_maskz_add_ps__builtin_ia32_addps512_mask_mm512_mask_add_ps_mm512_add_ps_mm512_maskz_add_pd__builtin_ia32_addpd512_mask_mm512_mask_add_pd_mm512_add_pd_mm512_maskz_sqrt_ps__builtin_ia32_sqrtps512_mask_mm512_mask_sqrt_ps_mm512_sqrt_ps_mm512_maskz_sqrt_pd__builtin_ia32_sqrtpd512_mask_mm512_mask_sqrt_pd_mm512_sqrt_pd_mm_comi_round_sd__builtin_ia32_vcomisd_mm_comi_round_ss__builtin_ia32_vcomiss_mm_maskz_fnmsub_round_ss__builtin_ia32_vfmaddss3_maskz_mm_maskz_fnmsub_round_sd__builtin_ia32_vfmaddsd3_maskz_mm_mask3_fnmsub_round_ss__builtin_ia32_vfmsubss3_mask3_mm_mask3_fnmsub_round_sd__builtin_ia32_vfmsubsd3_mask3_mm_mask_fnmsub_round_ss__builtin_ia32_vfmaddss3_mask_mm_mask_fnmsub_round_sd__builtin_ia32_vfmaddsd3_mask_mm_maskz_fnmadd_round_ss_mm_maskz_fnmadd_round_sd_mm_mask3_fnmadd_round_ss__builtin_ia32_vfmaddss3_mask3_mm_mask3_fnmadd_round_sd__builtin_ia32_vfmaddsd3_mask3_mm_mask_fnmadd_round_ss_mm_mask_fnmadd_round_sd_mm_maskz_fmsub_round_ss_mm_maskz_fmsub_round_sd_mm_mask3_fmsub_round_ss_mm_mask3_fmsub_round_sd_mm_mask_fmsub_round_ss_mm_mask_fmsub_round_sd_mm_maskz_fmadd_round_ss_mm_maskz_fmadd_round_sd_mm_mask3_fmadd_round_ss_mm_mask3_fmadd_round_sd_mm_mask_fmadd_round_ss_mm_mask_fmadd_round_sd_mm_maskz_fnmsub_ss_mm_maskz_fnmsub_sd_mm_mask3_fnmsub_ss_mm_mask3_fnmsub_sd_mm_mask_fnmsub_ss_mm_mask_fnmsub_sd_mm_maskz_fnmadd_ss_mm_maskz_fnmadd_sd_mm_mask3_fnmadd_ss_mm_mask3_fnmadd_sd_mm_mask_fnmadd_ss_mm_mask_fnmadd_sd_mm_maskz_fmsub_ss_mm_maskz_fmsub_sd_mm_mask3_fmsub_ss_mm_mask3_fmsub_sd_mm_mask_fmsub_ss_mm_mask_fmsub_sd_mm_maskz_fmadd_ss_mm_maskz_fmadd_sd_mm_mask3_fmadd_ss_mm_mask3_fmadd_sd_mm_mask_fmadd_ss_mm_mask_fmadd_sd_mm_fnmsub_round_ss__builtin_ia32_vfmaddss3_round_mm_fnmsub_round_sd__builtin_ia32_vfmaddsd3_round_mm_fnmadd_round_ss_mm_fnmadd_round_sd_mm_fmsub_round_ss_mm_fmsub_round_sd_mm_fmadd_round_ss_mm_fmadd_round_sd_mm512_mask_blend_epi32__builtin_ia32_blendmd_512_mask_mm512_mask_blend_epi64__builtin_ia32_blendmq_512_mask_mm512_mask_blend_ps__builtin_ia32_blendmps_512_mask_mm512_mask_blend_pd__builtin_ia32_blendmpd_512_mask_mm_maskz_min_round_ss_mm_mask_min_round_ss_mm_min_round_ss__builtin_ia32_minss_round_mm_maskz_min_round_sd_mm_mask_min_round_sd_mm_min_round_sd__builtin_ia32_minsd_round_mm_maskz_max_round_ss_mm_mask_max_round_ss_mm_max_round_ss__builtin_ia32_maxss_round_mm_maskz_max_round_sd_mm_mask_max_round_sd_mm_max_round_sd__builtin_ia32_maxsd_round_mm512_maskz_unpacklo_ps__builtin_ia32_unpcklps512_mask_mm512_mask_unpacklo_ps_mm512_unpacklo_ps_mm512_mask_min_epu32__builtin_ia32_pminud512_mask_mm512_maskz_min_epu32_mm512_min_epu32_mm512_mask_max_epu32__builtin_ia32_pmaxud512_mask_mm512_maskz_max_epu32_mm512_max_epu32_mm512_mask_min_epi32__builtin_ia32_pminsd512_mask_mm512_maskz_min_epi32_mm512_min_epi32_mm512_mask_max_epi32__builtin_ia32_pmaxsd512_mask_mm512_maskz_max_epi32_mm512_max_epi32_mm512_maskz_min_epu64__builtin_ia32_pminuq512_mask_mm512_mask_min_epu64_mm512_min_epu64_mm512_mask_max_epu64__builtin_ia32_pmaxuq512_mask_mm512_maskz_max_epu64_mm512_max_epu64_mm512_maskz_min_epi64__builtin_ia32_pminsq512_mask_mm512_mask_min_epi64_mm512_min_epi64_mm512_mask_max_epi64__builtin_ia32_pmaxsq512_mask_mm512_maskz_max_epi64_mm512_max_epi64_mm512_mask_insertf32x4__builtin_ia32_insertf32x4_mask_mm512_mask_inserti32x4__builtin_ia32_inserti32x4_mask_mm512_maskz_insertf32x4_mm512_maskz_inserti32x4_kunpackb_mask16__builtin_ia32_kunpckhi_mm512_kunpackb_mm512_knot__builtin_ia32_knothi_mm512_kxor__builtin_ia32_kxorhi_mm512_kxnor__builtin_ia32_kxnorhi_mm512_kortestc__builtin_ia32_kortestchi_mm512_kortestz__builtin_ia32_kortestzhi_mm512_kor__builtin_ia32_korhi_mm512_kandn__builtin_ia32_kandnhi_mm512_kand__builtin_ia32_kandhi_store_mask16__mmask16 *_load_mask16_cvtu32_mask16_cvtmask16_u32_kortestc_mask16_u8_kortestz_mask16_u8_kortest_mask16_u8_mm512_maskz_expandloadu_epi32__builtin_ia32_expandloadsi512_maskzconst __attribute((vector_size(64))) intconst __attribute((vector_size(64))) int *__attribute((vector_size(64))) int *const __v16siconst __v16si *_mm512_mask_expandloadu_epi32__builtin_ia32_expandloadsi512_mask_mm512_maskz_expand_epi32__builtin_ia32_expandsi512_maskz_mm512_mask_expand_epi32__builtin_ia32_expandsi512_mask_mm512_maskz_expandloadu_epi64__builtin_ia32_expandloaddi512_maskzconst __attribute((vector_size(64))) long longconst __attribute((vector_size(64))) long long *__attribute((vector_size(64))) long long *const __v8diconst __v8di *_mm512_mask_expandloadu_epi64__builtin_ia32_expandloaddi512_mask_mm512_maskz_expand_epi64__builtin_ia32_expanddi512_maskz_mm512_mask_expand_epi64__builtin_ia32_expanddi512_mask_mm512_maskz_expandloadu_ps__builtin_ia32_expandloadsf512_maskzconst __attribute((vector_size(64))) floatconst __attribute((vector_size(64))) float *__attribute((vector_size(64))) float *const __v16sfconst __v16sf *_mm512_mask_expandloadu_ps__builtin_ia32_expandloadsf512_mask_mm512_maskz_expand_ps__builtin_ia32_expandsf512_maskz_mm512_mask_expand_ps__builtin_ia32_expandsf512_mask_mm512_maskz_expandloadu_pd__builtin_ia32_expandloaddf512_maskzconst __attribute((vector_size(64))) doubleconst __attribute((vector_size(64))) double *__attribute((vector_size(64))) double *const __v8dfconst __v8df *_mm512_mask_expandloadu_pd__builtin_ia32_expandloaddf512_mask_mm512_maskz_expand_pd__builtin_ia32_expanddf512_maskz_mm512_mask_expand_pd__builtin_ia32_expanddf512_mask_mm512_mask_compressstoreu_epi32__builtin_ia32_compressstoresi512_mask__v16si *_mm512_maskz_compress_epi32__builtin_ia32_compresssi512_mask_mm512_mask_compress_epi32_mm512_mask_compressstoreu_epi64__builtin_ia32_compressstoredi512_mask__v8di *_mm512_maskz_compress_epi64__builtin_ia32_compressdi512_mask_mm512_mask_compress_epi64_mm512_mask_compressstoreu_ps__builtin_ia32_compressstoresf512_mask__v16sf *_mm512_maskz_compress_ps__builtin_ia32_compresssf512_mask_mm512_mask_compress_ps_mm512_mask_compressstoreu_pd__builtin_ia32_compressstoredf512_mask__v8df *_mm512_maskz_compress_pd__builtin_ia32_compressdf512_mask_mm512_mask_compress_pd_mm512_mask_i64scatter_epi64__builtin_ia32_scatterdiv8di_mm512_i64scatter_epi64(__mmask8) 0xFF_mm512_mask_i64scatter_epi32__builtin_ia32_scatterdiv16si__addr__v1_mm512_i64scatter_epi32_mm512_mask_i32scatter_epi64__builtin_ia32_scattersiv8di_mm512_i32scatter_epi64_mm512_mask_i32scatter_epi32__builtin_ia32_scattersiv16si_mm512_i32scatter_epi320xFFFF(__mmask16) 0xFFFF_mm512_mask_i64scatter_pd__builtin_ia32_scatterdiv8df_mm512_i64scatter_pd_mm512_mask_i64scatter_ps__builtin_ia32_scatterdiv16sf_mm512_i64scatter_ps_mm512_mask_i32scatter_pd__builtin_ia32_scattersiv8df_mm512_i32scatter_pd_mm512_mask_i32scatter_ps__builtin_ia32_scattersiv16sf_mm512_i32scatter_ps_mm512_mask_i64gather_epi64__builtin_ia32_gatherdiv8di_mm512_i64gather_epi64__v1_old_mm512_mask_i64gather_epi32__builtin_ia32_gatherdiv16si_mm512_i64gather_epi32_mm512_mask_i32gather_epi64__builtin_ia32_gathersiv8di_mm512_i32gather_epi64_mm512_mask_i32gather_epi32__builtin_ia32_gathersiv16si_mm512_i32gather_epi32_mm512_mask_i64gather_pd__builtin_ia32_gatherdiv8df_mm512_i64gather_pd_mm512_mask_i64gather_ps__builtin_ia32_gatherdiv16sf_mm512_i64gather_ps_mm512_mask_i32gather_pd__builtin_ia32_gathersiv8df_mm512_i32gather_pd_mm512_mask_i32gather_ps__builtin_ia32_gathersiv16sf_mm512_i32gather_ps_mm_mask_cmp_round_ss_mask_mm_cmp_round_ss_mask_mm_mask_cmp_round_sd_mask_mm_cmp_round_sd_mask_mm512_mask_cmp_round_ps_mask_mm512_mask_cmp_round_pd_mask_mm512_mask_cmp_epu32_mask_mm512_mask_cmp_epu64_mask_mm512_mask_cmp_epi32_mask__builtin_ia32_cmpd512_mask_mm512_mask_cmp_epi64_mask__builtin_ia32_cmpq512_mask_mm512_cmp_round_ps_mask_mm512_cmp_round_pd_mask_mm512_cmp_epu32_mask_mm512_cmp_epu64_mask_mm512_cmp_epi32_mask_mm512_cmp_epi64_mask_kshiftri_mask16__builtin_ia32_kshiftrihi_kshiftli_mask16__builtin_ia32_kshiftlihi_mm512_cmpneq_epu64_mask_mm512_mask_cmpneq_epu64_mask_mm512_cmpneq_epi64_mask_mm512_mask_cmpneq_epi64_mask_mm512_cmpneq_epu32_mask_mm512_mask_cmpneq_epu32_mask_mm512_mask_cmpneq_epi32_mask_mm512_cmpneq_epi32_mask_mm512_cmplt_epu64_mask_mm512_mask_cmplt_epu64_mask_mm512_cmplt_epi64_mask_mm512_mask_cmplt_epi64_mask_mm512_cmplt_epu32_mask_mm512_mask_cmplt_epu32_mask_mm512_cmplt_epi32_mask_mm512_mask_cmplt_epi32_mask_mm512_cmple_epu64_mask_mm512_mask_cmple_epu64_mask_mm512_cmple_epi64_mask_mm512_mask_cmple_epi64_mask_mm512_cmple_epu32_mask_mm512_mask_cmple_epu32_mask_mm512_cmple_epi32_mask_mm512_mask_cmple_epi32_mask_mm512_cmpge_epu64_mask_mm512_mask_cmpge_epu64_mask_mm512_cmpge_epi64_mask_mm512_mask_cmpge_epi64_mask_mm512_cmpge_epu32_mask_mm512_mask_cmpge_epu32_mask_mm512_mask_cmpge_epi32_mask_mm512_cmpge_epi32_mask_mm512_cmpgt_epi64_mask__builtin_ia32_pcmpgtq512_mask_mm512_mask_cmpgt_epi64_mask_mm512_mask_cmpgt_epi32_mask__builtin_ia32_pcmpgtd512_mask_mm512_cmpgt_epi32_mask_mm512_cmpeq_epi64_mask__builtin_ia32_pcmpeqq512_mask_mm512_mask_cmpeq_epi64_mask_mm512_mask_cmpeq_epi32_mask__builtin_ia32_pcmpeqd512_mask_mm512_cmpeq_epi32_mask_mm512_maskz_alignr_epi64__builtin_ia32_alignq512_mask_mm512_mask_alignr_epi64_mm512_alignr_epi64_mm512_maskz_alignr_epi32__builtin_ia32_alignd512_mask_mm512_mask_alignr_epi32_mm512_alignr_epi32_mm512_mask_ceil_pd_mm512_mask_ceil_ps_mm512_mask_floor_pd_mm512_mask_floor_ps_mm512_ceil_pd_mm512_ceil_ps_mm512_floor_pd_mm512_floor_ps_mm_maskz_roundscale_round_sd_mm_mask_roundscale_round_sd_mm_roundscale_round_sd_mm_maskz_roundscale_round_ss_mm_mask_roundscale_round_ss_mm_roundscale_round_ss_mm512_maskz_roundscale_round_pd_mm512_mask_roundscale_round_pd_mm512_roundscale_round_pd_mm512_maskz_roundscale_round_ps_mm512_mask_roundscale_round_ps_mm512_roundscale_round_ps_mm_maskz_getmant_round_ss_mm_mask_getmant_round_ss_mm_getmant_round_ss_mm_maskz_getmant_round_sd_mm_mask_getmant_round_sd_mm_getmant_round_sd_mm512_maskz_getmant_round_ps_mm512_mask_getmant_round_ps_mm512_getmant_round_ps_mm512_maskz_getmant_round_pd_mm512_mask_getmant_round_pd_mm512_getmant_round_pd_mm512_maskz_getexp_round_pd_mm512_mask_getexp_round_pd_mm512_getexp_round_pd_mm512_maskz_getexp_round_ps_mm512_mask_getexp_round_ps_mm512_getexp_round_ps_mm_maskz_getexp_round_sd_mm_mask_getexp_round_sd_mm_getexp_round_sd_mm_maskz_getexp_round_ss_mm_mask_getexp_round_ss_mm_getexp_round_ss_mm512_stream_load_si512__builtin_ia32_movntdqa512_mm512_stream_pd__builtin_ia32_movntpd512_mm512_stream_ps__builtin_ia32_movntps512_mm512_stream_si512__m512i *__builtin_ia32_movntdq512_mm_maskz_cvt_roundss_sd__builtin_ia32_cvtss2sd_mask_round_mm_mask_cvt_roundss_sd_mm_cvt_roundss_sd__builtin_ia32_cvtss2sd_round_mm_maskz_cvt_roundsd_ss__builtin_ia32_cvtsd2ss_mask_round_mm_mask_cvt_roundsd_ss_mm_cvt_roundsd_ss__builtin_ia32_cvtsd2ss_round_mm512_maskz_cvt_roundpd_ps_mm512_mask_cvt_roundpd_ps_mm512_cvt_roundpd_ps_mm512_maskz_cvtps_ph__builtin_ia32_vcvtps2ph512_mask_mm512_maskz_cvt_roundps_ph_mm512_mask_cvtps_ph_mm512_mask_cvt_roundps_ph_mm512_cvtps_ph_mm512_cvt_roundps_ph_mm512_maskz_cvt_roundph_ps_mm512_mask_cvt_roundph_ps_mm512_cvt_roundph_ps_mm512_maskz_cvt_roundps_pd_mm512_mask_cvt_roundps_pd_mm512_cvt_roundps_pd_mm512_maskz_unpackhi_ps__builtin_ia32_unpckhps512_mask_mm512_mask_unpackhi_ps_mm512_unpackhi_ps_mm512_maskz_unpackhi_pd__builtin_ia32_unpckhpd512_mask_mm512_mask_unpackhi_pd_mm512_unpackhi_pd_mm512_maskz_unpacklo_pd__builtin_ia32_unpcklpd512_mask_mm512_mask_unpacklo_pd_mm512_unpacklo_pd_mm512_maskz_movedup_pd__builtin_ia32_movddup512_mask_mm512_mask_movedup_pd_mm512_movedup_pd_mm_cvtt_roundsd_si32_mm_cvtt_roundsd_i32_mm_cvtt_roundsd_u32_mm_cvt_roundsd_i32__builtin_ia32_vcvtsd2si32_mm_cvt_roundsd_si32_mm_cvt_roundsd_u32_mm_cvtt_roundsd_i64_mm_cvtt_roundsd_si64_mm_cvtt_roundsd_u64_mm_cvt_roundsd_i64__builtin_ia32_vcvtsd2si64_mm_cvt_roundsd_si64_mm_cvt_roundsd_u64_mm_cvtt_roundss_si32_mm_cvtt_roundss_i32_mm_cvtt_roundss_u32_mm_cvt_roundss_i32__builtin_ia32_vcvtss2si32_mm_cvt_roundss_si32_mm_cvt_roundss_u32_mm_cvtt_roundss_si64_mm_cvtt_roundss_i64_mm_cvtt_roundss_u64_mm_cvt_roundss_i64__builtin_ia32_vcvtss2si64_mm_cvt_roundss_si64_mm_cvt_roundss_u64_mm512_maskz_unpacklo_epi64__builtin_ia32_punpcklqdq512_mask_mm512_mask_unpacklo_epi64_mm512_unpacklo_epi64_mm512_maskz_unpacklo_epi32__builtin_ia32_punpckldq512_mask_mm512_mask_unpacklo_epi32_mm512_unpacklo_epi32_mm512_maskz_unpackhi_epi64__builtin_ia32_punpckhqdq512_mask_mm512_mask_unpackhi_epi64_mm512_unpackhi_epi64_mm512_maskz_unpackhi_epi32__builtin_ia32_punpckhdq512_mask_mm512_mask_unpackhi_epi32_mm512_unpackhi_epi32_mm512_mask_abs_pd0x7fffffffffffffffLL_mm512_abs_pd_mm512_mask_abs_ps0x7fffffff_mm512_abs_ps_mm512_mask_testn_epi64_mask__builtin_ia32_ptestnmq512_mm512_testn_epi64_mask_mm512_mask_testn_epi32_mask__builtin_ia32_ptestnmd512_mm512_testn_epi32_mask_mm512_mask_test_epi64_mask__builtin_ia32_ptestmq512_mm512_test_epi64_mask_mm512_mask_test_epi32_mask__builtin_ia32_ptestmd512_mm512_test_epi32_mask_mm512_maskz_andnot_epi64__builtin_ia32_pandnq512_mask_mm512_mask_andnot_epi64_mm512_andnot_epi64_mm512_maskz_andnot_epi32__builtin_ia32_pandnd512_mask_mm512_mask_andnot_epi32_mm512_andnot_epi32_mm512_andnot_si512_mm512_maskz_and_epi64__builtin_ia32_pandq512_mask_mm512_mask_and_epi64_mm512_and_epi64__attribute((vector_size(64))) unsigned long long_mm512_maskz_and_epi32__builtin_ia32_pandd512_mask_mm512_mask_and_epi32_mm512_and_epi32__attribute((vector_size(64))) unsigned int_mm512_and_si512_mm512_maskz_ror_epi64__builtin_ia32_prorq512_mask_mm512_mask_ror_epi64_mm512_ror_epi64_mm512_maskz_rol_epi64__builtin_ia32_prolq512_mask_mm512_mask_rol_epi64_mm512_rol_epi64_mm512_maskz_ror_epi32__builtin_ia32_prord512_mask_mm512_mask_ror_epi32_mm512_ror_epi32_mm512_maskz_rol_epi32__builtin_ia32_prold512_mask_mm512_mask_rol_epi32_mm512_rol_epi32_mm512_maskz_xor_epi64__builtin_ia32_pxorq512_mask_mm512_mask_xor_epi64_mm512_xor_epi64_mm512_maskz_xor_epi32__builtin_ia32_pxord512_mask_mm512_mask_xor_epi32_mm512_xor_epi32_mm512_xor_si512_mm512_maskz_or_epi64__builtin_ia32_porq512_mask_mm512_mask_or_epi64_mm512_or_epi64_mm512_maskz_or_epi32__builtin_ia32_pord512_mask_mm512_mask_or_epi32_mm512_or_epi32_mm512_or_si512_mm512_maskz_moveldup_ps__builtin_ia32_movsldup512_mask_mm512_mask_moveldup_ps_mm512_moveldup_ps_mm512_maskz_movehdup_ps__builtin_ia32_movshdup512_mask_mm512_mask_movehdup_ps_mm512_movehdup_ps_mm_maskz_fixupimm_round_ss_mm_mask_fixupimm_round_ss_mm_fixupimm_round_ss_mm_maskz_fixupimm_round_sd_mm_mask_fixupimm_round_sd_mm_fixupimm_round_sd_mm512_maskz_fixupimm_round_ps_mm512_mask_fixupimm_round_ps_mm512_fixupimm_round_ps_mm512_maskz_fixupimm_round_pd_mm512_mask_fixupimm_round_pd_mm512_fixupimm_round_pd_mm512_maskz_shuffle_pd__builtin_ia32_shufpd512_mask_mm512_mask_shuffle_pd_mm512_shuffle_pd_mm512_maskz_shuffle_ps__builtin_ia32_shufps512_mask_mm512_mask_shuffle_ps_mm512_shuffle_ps_mm512_maskz_permutexvar_ps__builtin_ia32_permvarsf512_mask_mm512_mask_permutexvar_ps_mm512_permutexvar_ps_mm512_maskz_permutexvar_pd__builtin_ia32_permvardf512_mask_mm512_mask_permutexvar_pd_mm512_permutexvar_pd_mm512_mask_permutexvar_epi32__builtin_ia32_permvarsi512_mask_mm512_permutexvar_epi32_mm512_maskz_permutexvar_epi32_mm512_mask_permutexvar_epi64__builtin_ia32_permvardi512_mask_mm512_permutexvar_epi64_mm512_maskz_permutexvar_epi64_mm512_maskz_permutex_pd__builtin_ia32_permdf512_mask_mm512_mask_permutex_pd_mm512_permutex_pd_mm512_maskz_permutex_epi64__builtin_ia32_permdi512_mask_mm512_mask_permutex_epi64_mm512_permutex_epi64(__mmask8) (-1)_mm512_maskz_permute_ps__builtin_ia32_vpermilps512_mask_mm512_mask_permute_ps_mm512_permute_ps_mm512_maskz_permute_pd__builtin_ia32_vpermilpd512_mask_mm512_mask_permute_pd_mm512_permute_pd_mm512_maskz_permutex2var_ps__builtin_ia32_vpermt2varps512_maskz_mm512_mask2_permutex2var_ps__builtin_ia32_vpermi2varps512_mask_mm512_mask_permutex2var_ps__builtin_ia32_vpermt2varps512_mask_mm512_permutex2var_ps_mm512_maskz_permutex2var_pd__builtin_ia32_vpermt2varpd512_maskz_mm512_mask2_permutex2var_pd__builtin_ia32_vpermi2varpd512_mask_mm512_mask_permutex2var_pd__builtin_ia32_vpermt2varpd512_mask_mm512_permutex2var_pd_mm512_maskz_permutex2var_epi32__builtin_ia32_vpermt2vard512_maskz_mm512_mask2_permutex2var_epi32__builtin_ia32_vpermi2vard512_mask_mm512_mask_permutex2var_epi32__builtin_ia32_vpermt2vard512_mask_mm512_permutex2var_epi32_mm512_maskz_permutex2var_epi64__builtin_ia32_vpermt2varq512_maskz_mm512_mask2_permutex2var_epi64__builtin_ia32_vpermi2varq512_mask_mm512_mask_permutex2var_epi64__builtin_ia32_vpermt2varq512_mask_mm512_permutex2var_epi64_mm512_maskz_permutevar_ps__builtin_ia32_vpermilvarps512_mask_mm512_mask_permutevar_ps_mm512_permutevar_ps_mm512_maskz_permutevar_pd__builtin_ia32_vpermilvarpd512_mask_mm512_mask_permutevar_pd_mm512_permutevar_pd_mm512_mask_storeu_epi32__builtin_ia32_storedqusi512_mask_mm512_storeu_epi32__m512i_u *_mm512_storeu_si512_mm512_maskz_loadu_epi32__builtin_ia32_loaddqusi512_mask_mm512_mask_loadu_epi32_mm512_loadu_epi32_mm512_loadu_si512_mm512_mask_storeu_epi64__builtin_ia32_storedqudi512_mask_mm512_storeu_epi64_mm512_maskz_loadu_epi64__builtin_ia32_loaddqudi512_mask_mm512_mask_loadu_epi64_mm512_loadu_epi64_mm_mask_store_sd__builtin_ia32_storesd_mask_mm_mask_store_ss__builtin_ia32_storess_mask_mm_maskz_move_sd__builtin_ia32_movesd_mask_mm_mask_move_sd_mm_maskz_move_ss__builtin_ia32_movess_mask_mm_mask_move_ss_mm_maskz_load_sd__builtin_ia32_loadsd_mask_mm_mask_load_sd_mm_maskz_load_ss__builtin_ia32_loadss_mask_mm_mask_load_ss_mm512_mask_storeu_ps__builtin_ia32_storeups512_mask_mm512_storeu_ps__m512_u *_mm512_maskz_loadu_ps__builtin_ia32_loadups512_mask_mm512_mask_loadu_ps_mm512_loadu_ps_mm512_mask_storeu_pd__builtin_ia32_storeupd512_mask_mm512_storeu_pd__m512d_u *_mm512_maskz_loadu_pd__builtin_ia32_loadupd512_mask_mm512_mask_loadu_pd_mm512_loadu_pd_mm512_maskz_insertf64x4__builtin_ia32_insertf64x4_mask_mm512_mask_insertf64x4_mm512_insertf64x4_mm512_maskz_inserti64x4__builtin_ia32_inserti64x4_mask_mm512_mask_inserti64x4_mm512_inserti64x4_mm512_insertf32x4_mm512_inserti32x4_mm512_maskz_extracti32x4_epi32__builtin_ia32_extracti32x4_mask_mm512_mask_extracti32x4_epi32_mm512_extracti32x4_epi32_mm512_maskz_extracti64x4_epi64__builtin_ia32_extracti64x4_mask_mm512_mask_extracti64x4_epi64_mm512_extracti64x4_epi64_mm512_maskz_extractf32x4_ps__builtin_ia32_extractf32x4_mask_mm512_mask_extractf32x4_ps_mm512_extractf32x4_ps_mm512_maskz_extractf64x4_pd__builtin_ia32_extractf64x4_mask_mm512_mask_extractf64x4_pd_mm512_extractf64x4_pd_mm512_maskz_cvt_roundepu32_ps_mm512_mask_cvt_roundepu32_ps_mm512_cvt_roundepu32_ps_mm512_maskz_cvt_roundepi32_ps_mm512_mask_cvt_roundepi32_ps_mm512_cvt_roundepi32_ps_mm512_maskz_cvtepu32_pd__builtin_ia32_cvtudq2pd512_mask_mm512_mask_cvtepu32_pd_mm512_cvtepu32_pd_mm512_maskz_cvtepi32_pd__builtin_ia32_cvtdq2pd512_mask_mm512_mask_cvtepi32_pd_mm512_cvtepi32_pd_mm512_maskz_cvtusepi64_epi8__builtin_ia32_pmovusqb512_mask_mm512_mask_cvtusepi64_epi8_mm512_mask_cvtusepi64_storeu_epi8__builtin_ia32_pmovusqb512mem_mask_mm512_cvtusepi64_epi8_mm512_maskz_cvtsepi64_epi8__builtin_ia32_pmovsqb512_mask_mm512_mask_cvtsepi64_epi8_mm512_mask_cvtsepi64_storeu_epi8__builtin_ia32_pmovsqb512mem_mask_mm512_cvtsepi64_epi8_mm512_maskz_cvtepi64_epi8__builtin_ia32_pmovqb512_mask_mm512_mask_cvtepi64_epi8_mm512_mask_cvtepi64_storeu_epi8__builtin_ia32_pmovqb512mem_mask_mm512_cvtepi64_epi8_mm512_maskz_cvtusepi64_epi16__builtin_ia32_pmovusqw512_mask_mm512_mask_cvtusepi64_epi16_mm512_mask_cvtusepi64_storeu_epi16__builtin_ia32_pmovusqw512mem_mask__attribute((vector_size(16))) short *__v8hi *_mm512_cvtusepi64_epi16_mm512_maskz_cvtsepi64_epi16__builtin_ia32_pmovsqw512_mask_mm512_mask_cvtsepi64_epi16_mm512_mask_cvtsepi64_storeu_epi16__builtin_ia32_pmovsqw512mem_mask_mm512_cvtsepi64_epi16_mm512_maskz_cvtepi64_epi16__builtin_ia32_pmovqw512_mask_mm512_mask_cvtepi64_epi16_mm512_mask_cvtepi64_storeu_epi16__builtin_ia32_pmovqw512mem_mask_mm512_cvtepi64_epi16_mm512_maskz_cvtusepi64_epi32__builtin_ia32_pmovusqd512_mask_mm512_mask_cvtusepi64_epi32_mm512_mask_cvtusepi64_storeu_epi32__builtin_ia32_pmovusqd512mem_mask_mm512_cvtusepi64_epi32_mm512_maskz_cvtsepi64_epi32__builtin_ia32_pmovsqd512_mask_mm512_mask_cvtsepi64_epi32_mm512_mask_cvtsepi64_storeu_epi32__builtin_ia32_pmovsqd512mem_mask_mm512_cvtsepi64_epi32_mm512_maskz_cvtepi64_epi32__builtin_ia32_pmovqd512_mask_mm512_mask_cvtepi64_epi32_mm512_mask_cvtepi64_storeu_epi32__builtin_ia32_pmovqd512mem_mask_mm512_cvtepi64_epi32_mm512_maskz_cvtusepi32_epi16__builtin_ia32_pmovusdw512_mask_mm512_mask_cvtusepi32_epi16_mm512_mask_cvtusepi32_storeu_epi16__builtin_ia32_pmovusdw512mem_mask__attribute((vector_size(32))) short *__v16hi *_mm512_cvtusepi32_epi16_mm512_maskz_cvtsepi32_epi16__builtin_ia32_pmovsdw512_mask_mm512_mask_cvtsepi32_epi16_mm512_mask_cvtsepi32_storeu_epi16__builtin_ia32_pmovsdw512mem_mask_mm512_cvtsepi32_epi16_mm512_maskz_cvtepi32_epi16__builtin_ia32_pmovdw512_mask_mm512_mask_cvtepi32_epi16_mm512_mask_cvtepi32_storeu_epi16__builtin_ia32_pmovdw512mem_mask_mm512_cvtepi32_epi16_mm512_maskz_cvtusepi32_epi8__builtin_ia32_pmovusdb512_mask_mm512_mask_cvtusepi32_epi8_mm512_mask_cvtusepi32_storeu_epi8__builtin_ia32_pmovusdb512mem_mask__attribute((vector_size(16))) char *__v16qi *_mm512_cvtusepi32_epi8_mm512_maskz_cvtsepi32_epi8__builtin_ia32_pmovsdb512_mask_mm512_mask_cvtsepi32_epi8_mm512_mask_cvtsepi32_storeu_epi8__builtin_ia32_pmovsdb512mem_mask_mm512_cvtsepi32_epi8_mm512_maskz_cvtepi32_epi8__builtin_ia32_pmovdb512_mask_mm512_mask_cvtepi32_epi8_mm512_mask_cvtepi32_storeu_epi8__builtin_ia32_pmovdb512mem_mask_mm512_cvtepi32_epi8_mm_cvt_roundi64_ss__builtin_ia32_cvtsi2ss64_mm_cvt_roundsi64_ss_mm_cvt_roundu64_ss_mm_cvt_roundi32_ss__builtin_ia32_cvtsi2ss32_mm_cvt_roundsi32_ss_mm_cvt_roundu32_ss_mm_cvt_roundsi64_sd__builtin_ia32_cvtsi2sd64_mm_cvt_roundi64_sd_mm_cvt_roundu64_sd_mm_cvtu32_sd__builtin_ia32_cvtusi2sd32_mm512_maskz_cvt_roundps_epu32_mm512_mask_cvt_roundps_epu32_mm512_cvt_roundps_epu32_mm512_maskz_cvt_roundps_epi32_mm512_mask_cvt_roundps_epi32_mm512_cvt_roundps_epi32_mm512_maskz_cvtt_roundps_epu32_mm512_mask_cvtt_roundps_epu32_mm512_cvtt_roundps_epu32_mm512_maskz_cvtt_roundps_epi32_mm512_mask_cvtt_roundps_epi32_mm512_cvtt_roundps_epi32_mm512_maskz_cvt_roundpd_epu32_mm512_mask_cvt_roundpd_epu32_mm512_cvt_roundpd_epu32_mm512_maskz_cvt_roundpd_epi32_mm512_mask_cvt_roundpd_epi32_mm512_cvt_roundpd_epi32_mm512_maskz_cvtt_roundpd_epu32_mm512_mask_cvtt_roundpd_epu32_mm512_cvtt_roundpd_epu32_mm512_maskz_cvtt_roundpd_epi32_mm512_mask_cvtt_roundpd_epi32_mm512_cvtt_roundpd_epi32_mm512_maskz_rorv_epi64__builtin_ia32_prorvq512_mask_mm512_mask_rorv_epi64_mm512_rorv_epi64_mm512_maskz_rolv_epi64__builtin_ia32_prolvq512_mask_mm512_mask_rolv_epi64_mm512_rolv_epi64_mm512_maskz_rorv_epi32__builtin_ia32_prorvd512_mask_mm512_mask_rorv_epi32_mm512_rorv_epi32_mm512_maskz_rolv_epi32__builtin_ia32_prolvd512_mask_mm512_mask_rolv_epi32_mm512_rolv_epi32_mm512_maskz_shuffle_f32x4__builtin_ia32_shuf_f32x4_mask_mm512_mask_shuffle_f32x4_mm512_shuffle_f32x4_mm512_maskz_shuffle_f64x2__builtin_ia32_shuf_f64x2_mask_mm512_mask_shuffle_f64x2_mm512_shuffle_f64x2_mm512_maskz_shuffle_i32x4__builtin_ia32_shuf_i32x4_mask_mm512_mask_shuffle_i32x4_mm512_shuffle_i32x4_mm512_maskz_shuffle_i64x2__builtin_ia32_shuf_i64x2_mask_mm512_mask_shuffle_i64x2_mm512_shuffle_i64x2_mm512_maskz_shuffle_epi32__builtin_ia32_pshufd512_mask_mm512_mask_shuffle_epi32_mm512_shuffle_epi32_mm512_maskz_broadcast_i64x4__builtin_ia32_broadcasti64x4_512_mm512_mask_broadcast_i64x4_mm512_broadcast_i64x4_mm512_maskz_broadcast_f64x4__builtin_ia32_broadcastf64x4_512_mm512_mask_broadcast_f64x4_mm512_broadcast_f64x4_mm512_maskz_broadcast_i32x4__builtin_ia32_broadcasti32x4_512_mm512_mask_broadcast_i32x4_mm512_broadcast_i32x4_mm512_maskz_broadcast_f32x4__builtin_ia32_broadcastf32x4_512_mm512_mask_broadcast_f32x4_mm512_broadcast_f32x4_mm512_maskz_set1_epi64__builtin_ia32_pbroadcastq512_gpr_mask_mm512_mask_set1_epi64_mm512_set1_epi64_mm512_maskz_broadcastq_epi64__builtin_ia32_pbroadcastq512_mm512_mask_broadcastq_epi64_mm512_broadcastq_epi64_mm512_maskz_set1_epi32__builtin_ia32_pbroadcastd512_gpr_mask_mm512_mask_set1_epi32_mm512_set1_epi32_mm512_maskz_broadcastd_epi32__builtin_ia32_pbroadcastd512_mm512_mask_broadcastd_epi32_mm512_broadcastd_epi32_mm512_maskz_broadcastsd_pd__builtin_ia32_broadcastsd512_mm512_mask_broadcastsd_pd_mm512_broadcastsd_pd_mm512_maskz_broadcastss_ps__builtin_ia32_broadcastss512_mm512_mask_broadcastss_ps_mm512_broadcastss_ps_mm512_maskz_abs_epi32__builtin_ia32_pabsd512_mask_mm512_mask_abs_epi32_mm512_abs_epi32_mm512_maskz_abs_epi64__builtin_ia32_pabsq512_mask_mm512_mask_abs_epi64_mm512_abs_epi64_mm512_maskz_fnmsub_round_ps_mm512_mask3_fnmsub_round_ps_mm512_mask_fnmsub_round_ps_mm512_fnmsub_round_ps_mm512_maskz_fnmsub_round_pd_mm512_mask3_fnmsub_round_pd_mm512_mask_fnmsub_round_pd_mm512_fnmsub_round_pd_mm512_maskz_fnmadd_round_ps_mm512_mask3_fnmadd_round_ps_mm512_mask_fnmadd_round_ps_mm512_fnmadd_round_ps_mm512_maskz_fnmadd_round_pd_mm512_mask3_fnmadd_round_pd_mm512_mask_fnmadd_round_pd_mm512_fnmadd_round_pd_mm512_maskz_fmsubadd_round_ps_mm512_mask3_fmsubadd_round_ps_mm512_mask_fmsubadd_round_ps_mm512_fmsubadd_round_ps_mm512_maskz_fmsubadd_round_pd_mm512_mask3_fmsubadd_round_pd_mm512_mask_fmsubadd_round_pd_mm512_fmsubadd_round_pd_mm512_maskz_fmaddsub_round_ps_mm512_mask3_fmaddsub_round_ps_mm512_mask_fmaddsub_round_ps_mm512_fmaddsub_round_ps_mm512_maskz_fmaddsub_round_pd_mm512_mask3_fmaddsub_round_pd_mm512_mask_fmaddsub_round_pd_mm512_fmaddsub_round_pd_mm512_maskz_fmsub_round_ps_mm512_mask3_fmsub_round_ps_mm512_mask_fmsub_round_ps_mm512_fmsub_round_ps_mm512_maskz_fmsub_round_pd_mm512_mask3_fmsub_round_pd_mm512_mask_fmsub_round_pd_mm512_fmsub_round_pd_mm512_maskz_fmadd_round_ps_mm512_mask3_fmadd_round_ps_mm512_mask_fmadd_round_ps_mm512_fmadd_round_ps_mm512_maskz_fmadd_round_pd_mm512_mask3_fmadd_round_pd_mm512_mask_fmadd_round_pd_mm512_fmadd_round_pd_mm_maskz_scalef_round_ss_mm_mask_scalef_round_ss_mm_scalef_round_ss_mm_maskz_scalef_round_sd_mm_mask_scalef_round_sd_mm_scalef_round_sd_mm512_maskz_scalef_round_ps_mm512_mask_scalef_round_ps_mm512_scalef_round_ps_mm512_maskz_scalef_round_pd_mm512_mask_scalef_round_pd_mm512_scalef_round_pd_mm512_maskz_min_round_ps_mm512_mask_min_round_ps_mm512_min_round_ps_mm512_maskz_min_round_pd_mm512_mask_min_round_pd_mm512_min_round_pd_mm512_maskz_max_round_ps_mm512_mask_max_round_ps_mm512_max_round_ps_mm512_maskz_max_round_pd_mm512_mask_max_round_pd_mm512_max_round_pd_mm_maskz_div_round_ss_mm_mask_div_round_ss_mm_div_round_ss__builtin_ia32_divss_round_mm_maskz_div_round_sd_mm_mask_div_round_sd_mm_div_round_sd__builtin_ia32_divsd_round_mm_maskz_mul_round_ss_mm_mask_mul_round_ss_mm_mul_round_ss__builtin_ia32_mulss_round_mm_maskz_mul_round_sd_mm_mask_mul_round_sd_mm_mul_round_sd__builtin_ia32_mulsd_round_mm512_maskz_div_round_ps_mm512_mask_div_round_ps_mm512_div_round_ps_mm512_maskz_div_round_pd_mm512_mask_div_round_pd_mm512_div_round_pd_mm512_maskz_mul_round_ps_mm512_mask_mul_round_ps_mm512_mul_round_ps_mm512_maskz_mul_round_pd_mm512_mask_mul_round_pd_mm512_mul_round_pd_mm512_maskz_sub_round_ps_mm512_mask_sub_round_ps_mm512_sub_round_ps_mm512_maskz_sub_round_pd_mm512_mask_sub_round_pd_mm512_sub_round_pd_mm512_maskz_add_round_ps_mm512_mask_add_round_ps_mm512_add_round_ps_mm512_maskz_add_round_pd_mm512_mask_add_round_pd_mm512_add_round_pd_mm512_maskz_cvtepu32_epi64__builtin_ia32_pmovzxdq512_mask_mm512_mask_cvtepu32_epi64_mm512_cvtepu32_epi64_mm512_maskz_cvtepu16_epi64__builtin_ia32_pmovzxwq512_mask_mm512_mask_cvtepu16_epi64_mm512_cvtepu16_epi64_mm512_maskz_cvtepu16_epi32__builtin_ia32_pmovzxwd512_mask_mm512_mask_cvtepu16_epi32_mm512_cvtepu16_epi32_mm512_maskz_cvtepu8_epi64__builtin_ia32_pmovzxbq512_mask_mm512_mask_cvtepu8_epi64_mm512_cvtepu8_epi64_mm512_maskz_cvtepu8_epi32__builtin_ia32_pmovzxbd512_mask_mm512_mask_cvtepu8_epi32_mm512_cvtepu8_epi32_mm512_maskz_cvtepi32_epi64__builtin_ia32_pmovsxdq512_mask_mm512_mask_cvtepi32_epi64_mm512_cvtepi32_epi64_mm512_maskz_cvtepi16_epi64__builtin_ia32_pmovsxwq512_mask_mm512_mask_cvtepi16_epi64_mm512_cvtepi16_epi64_mm512_maskz_cvtepi16_epi32__builtin_ia32_pmovsxwd512_mask_mm512_mask_cvtepi16_epi32_mm512_cvtepi16_epi32_mm512_maskz_cvtepi8_epi64__builtin_ia32_pmovsxbq512_mask_mm512_mask_cvtepi8_epi64_mm512_cvtepi8_epi64_mm512_maskz_cvtepi8_epi32__builtin_ia32_pmovsxbd512_mask_mm512_mask_cvtepi8_epi32_mm512_cvtepi8_epi32_mm_maskz_sqrt_round_ss__builtin_ia32_sqrtss_mask_round_mm_mask_sqrt_round_ss_mm_sqrt_round_ss_mm_maskz_sqrt_round_sd__builtin_ia32_sqrtsd_mask_round_mm_mask_sqrt_round_sd_mm_sqrt_round_sd_mm512_maskz_sqrt_round_ps_mm512_mask_sqrt_round_ps_mm512_sqrt_round_ps_mm512_maskz_sqrt_round_pd_mm512_mask_sqrt_round_pd_mm512_sqrt_round_pd_mm_maskz_rsqrt14_ss__builtin_ia32_rsqrt14ss_mask_mm_mask_rsqrt14_ss_mm_rsqrt14_ss__builtin_ia32_rsqrt14ss_mm_maskz_rsqrt14_sd__builtin_ia32_rsqrt14sd_mask_mm_mask_rsqrt14_sd_mm_rsqrt14_sd__builtin_ia32_rsqrt14sd_mm512_maskz_rsqrt14_ps__builtin_ia32_rsqrt14ps512_mask_mm512_mask_rsqrt14_ps_mm512_rsqrt14_ps_mm512_maskz_rsqrt14_pd__builtin_ia32_rsqrt14pd512_mask_mm512_mask_rsqrt14_pd_mm512_rsqrt14_pd_mm_maskz_rcp14_ss__builtin_ia32_rcp14ss_mask_mm_mask_rcp14_ss_mm_rcp14_ss__builtin_ia32_rcp14ss_mm_maskz_rcp14_sd__builtin_ia32_rcp14sd_mask_mm_mask_rcp14_sd_mm_rcp14_sd__builtin_ia32_rcp14sd_mm512_maskz_rcp14_ps__builtin_ia32_rcp14ps512_mask_mm512_mask_rcp14_ps_mm512_rcp14_ps_mm512_maskz_rcp14_pd__builtin_ia32_rcp14pd512_mask_mm512_mask_rcp14_pd_mm512_rcp14_pd_mm512_maskz_ternarylogic_epi32__builtin_ia32_pternlogd512_maskz_mm512_mask_ternarylogic_epi32__builtin_ia32_pternlogd512_mask_mm512_ternarylogic_epi32_mm512_maskz_ternarylogic_epi64__builtin_ia32_pternlogq512_maskz_mm512_mask_ternarylogic_epi64__builtin_ia32_pternlogq512_mask_mm512_ternarylogic_epi64_mm_maskz_sub_round_ss_mm_mask_sub_round_ss_mm_sub_round_ss__builtin_ia32_subss_round_mm_maskz_sub_round_sd_mm_mask_sub_round_sd_mm_sub_round_sd__builtin_ia32_subsd_round_mm_maskz_add_round_ss_mm_mask_add_round_ss_mm_add_round_ss__builtin_ia32_addss_round_mm_maskz_add_round_sd_mm_mask_add_round_sd_mm_add_round_sd__builtin_ia32_addsd_round_mm512_maskz_sra_epi32__builtin_ia32_psrad512_mask_mm512_mask_sra_epi32_mm512_sra_epi32_mm512_maskz_srai_epi32__builtin_ia32_psradi512_mask_mm512_mask_srai_epi32_mm512_srai_epi32_mm512_maskz_srl_epi32__builtin_ia32_psrld512_mask_mm512_mask_srl_epi32_mm512_srl_epi32_mm512_maskz_srli_epi32__builtin_ia32_psrldi512_mask_mm512_mask_srli_epi32_mm512_srli_epi32_mm512_maskz_sll_epi32__builtin_ia32_pslld512_mask_mm512_mask_sll_epi32_mm512_sll_epi32_mm512_maskz_slli_epi32__builtin_ia32_pslldi512_mask_mm512_mask_slli_epi32_mm512_slli_epi32_mm512_maskz_sra_epi64__builtin_ia32_psraq512_mask_mm512_mask_sra_epi64_mm512_sra_epi64_mm512_maskz_srai_epi64__builtin_ia32_psraqi512_mask_mm512_mask_srai_epi64_mm512_srai_epi64_mm512_maskz_srl_epi64__builtin_ia32_psrlq512_mask_mm512_mask_srl_epi64_mm512_srl_epi64_mm512_maskz_srli_epi64__builtin_ia32_psrlqi512_mask_mm512_mask_srli_epi64_mm512_srli_epi64_mm512_maskz_sll_epi64__builtin_ia32_psllq512_mask_mm512_mask_sll_epi64_mm512_sll_epi64_mm512_maskz_slli_epi64__builtin_ia32_psllqi512_mask_mm512_mask_slli_epi64_mm512_slli_epi64_mm512_maskz_mul_epu32__builtin_ia32_pmuludq512_mask_mm512_mask_mul_epu32_mm512_mul_epu32_mm512_maskz_sub_epi32__builtin_ia32_psubd512_mask_mm512_mask_sub_epi32_mm512_sub_epi32_mm512_maskz_mul_epi32__builtin_ia32_pmuldq512_mask_mm512_mask_mul_epi32_mm512_mul_epi32_mm512_maskz_add_epi32__builtin_ia32_paddd512_mask_mm512_mask_add_epi32_mm512_add_epi32_mm512_maskz_srlv_epi64__builtin_ia32_psrlv8di_mask_mm512_mask_srlv_epi64_mm512_srlv_epi64_mm512_maskz_srav_epi64__builtin_ia32_psrav8di_mask_mm512_mask_srav_epi64_mm512_srav_epi64_mm512_maskz_sllv_epi64__builtin_ia32_psllv8di_mask_mm512_mask_sllv_epi64_mm512_sllv_epi64_mm512_maskz_sub_epi64__builtin_ia32_psubq512_mask_mm512_mask_sub_epi64_mm512_sub_epi64_mm512_maskz_add_epi64__builtin_ia32_paddq512_mask_mm512_mask_add_epi64_mm512_add_epi64_mm512_maskz_srlv_epi32__builtin_ia32_psrlv16si_mask_mm512_mask_srlv_epi32_mm512_srlv_epi32_mm512_maskz_srav_epi32__builtin_ia32_psrav16si_mask_mm512_mask_srav_epi32_mm512_srav_epi32_mm512_maskz_sllv_epi32__builtin_ia32_psllv16si_mask_mm512_mask_sllv_epi32_mm512_sllv_epi32_mm512_mask_mullox_epi64_mm512_mullox_epi64_mm512_mask_mullo_epi32__builtin_ia32_pmulld512_mask_mm512_maskz_mullo_epi32_mm512_mullo_epi32_mm512_mask_store_epi32__builtin_ia32_movdqa32store512_mask_mm512_store_epi32_mm512_store_si512_mm512_maskz_load_epi32__builtin_ia32_movdqa32load512_mask_mm512_mask_load_epi32_mm512_load_epi32_mm512_load_si512_mm512_maskz_mov_epi32__builtin_ia32_movdqa32_512_mask_mm512_mask_mov_epi32_mm512_mask_store_epi64__builtin_ia32_movdqa64store512_mask_mm512_store_epi64_mm512_maskz_load_epi64__builtin_ia32_movdqa64load512_mask_mm512_mask_load_epi64_mm512_load_epi64_mm512_maskz_mov_epi64__builtin_ia32_movdqa64_512_mask_mm512_mask_mov_epi64_mm512_mask_store_ps__builtin_ia32_storeaps512_mask_mm512_store_ps__m512 *_mm512_maskz_load_ps__builtin_ia32_loadaps512_mask_mm512_mask_load_ps_mm512_load_ps_mm512_mask_store_pd__builtin_ia32_storeapd512_mask_mm512_store_pd__m512d *_mm512_maskz_load_pd__builtin_ia32_loadapd512_mask_mm512_mask_load_pd_mm512_load_pd_mm512_maskz_mov_ps__builtin_ia32_movaps512_mask_mm512_mask_mov_ps_mm512_maskz_mov_pd__builtin_ia32_movapd512_mask_mm512_mask_mov_pd_mm512_setzero_si512_mm512_setzero_epi32_mm512_setzero_pd_mm512_setzero_mm512_setzero_ps_mm512_set4_ps_mm512_set4_pd_mm512_set4_epi64_mm512_set4_epi32_mm512_set1_ps_mm512_set1_pd_mm512_set1_epi16_mm512_set1_epi8_mm512_undefined_epi32_mm512_undefined_pd_mm512_undefined_ps_mm512_set_ps_mm512_set_pd_mm512_set_epi8__J__K__q63__q62__q61__q60__q59__q58__q57__q56__q55__q54__q53__q52__q51__q50__q49__q48__q47__q46__q45__q44__q43__q42__q41__q40__q39__q38__q37__q36__q35__q34__q33__q32_mm512_set_epi16_mm512_set_epi32_mm512_set_epi64_mm512_mask2int_mm512_int2mask_MM_MANTISSA_SIGN_ENUM_MM_MANT_SIGN_src_MM_MANT_SIGN_zero_MM_MANT_SIGN_nan_MM_MANTISSA_NORM_ENUM_MM_MANT_NORM_1_2_MM_MANT_NORM_p5_2_MM_MANT_NORM_p5_1_MM_MANT_NORM_p75_1p5_MM_PERM_ENUM_MM_PERM_AAAA_MM_PERM_AAAB_MM_PERM_AAAC_MM_PERM_AAAD_MM_PERM_AABA_MM_PERM_AABB_MM_PERM_AABC_MM_PERM_AABD_MM_PERM_AACA_MM_PERM_AACB_MM_PERM_AACC_MM_PERM_AACD_MM_PERM_AADA_MM_PERM_AADB_MM_PERM_AADC_MM_PERM_AADD_MM_PERM_ABAA_MM_PERM_ABAB_MM_PERM_ABAC_MM_PERM_ABAD_MM_PERM_ABBA_MM_PERM_ABBB_MM_PERM_ABBC_MM_PERM_ABBD_MM_PERM_ABCA_MM_PERM_ABCB_MM_PERM_ABCC0x1A_MM_PERM_ABCD0x1B_MM_PERM_ABDA_MM_PERM_ABDB0x1D_MM_PERM_ABDC_MM_PERM_ABDD0x1F_MM_PERM_ACAA_MM_PERM_ACAB0x21_MM_PERM_ACAC0x22_MM_PERM_ACAD0x23_MM_PERM_ACBA0x24_MM_PERM_ACBB0x25_MM_PERM_ACBC_MM_PERM_ACBD_MM_PERM_ACCA0x28_MM_PERM_ACCB0x29_MM_PERM_ACCC0x2A_MM_PERM_ACCD0x2B_MM_PERM_ACDA0x2C_MM_PERM_ACDB0x2D_MM_PERM_ACDC0x2E_MM_PERM_ACDD0x2F_MM_PERM_ADAA_MM_PERM_ADAB0x31_MM_PERM_ADAC0x32_MM_PERM_ADAD0x33_MM_PERM_ADBA0x34_MM_PERM_ADBB_MM_PERM_ADBC_MM_PERM_ADBD0x37_MM_PERM_ADCA0x38_MM_PERM_ADCB0x39_MM_PERM_ADCC0x3A_MM_PERM_ADCD0x3B_MM_PERM_ADDA0x3C_MM_PERM_ADDB0x3D_MM_PERM_ADDC0x3E_MM_PERM_ADDD0x3F_MM_PERM_BAAA_MM_PERM_BAAB0x41_MM_PERM_BAAC0x42_MM_PERM_BAAD0x43_MM_PERM_BABA0x44_MM_PERM_BABB0x45_MM_PERM_BABC0x46_MM_PERM_BABD0x47_MM_PERM_BACA_MM_PERM_BACB0x49_MM_PERM_BACC0x4A_MM_PERM_BACD0x4B_MM_PERM_BADA0x4C_MM_PERM_BADB0x4D_MM_PERM_BADC0x4E_MM_PERM_BADD0x4F_MM_PERM_BBAA0x50_MM_PERM_BBAB0x51_MM_PERM_BBAC0x52_MM_PERM_BBAD0x53_MM_PERM_BBBA0x54_MM_PERM_BBBB0x55_MM_PERM_BBBC0x56_MM_PERM_BBBD0x57_MM_PERM_BBCA0x58_MM_PERM_BBCB0x59_MM_PERM_BBCC0x5A_MM_PERM_BBCD0x5B_MM_PERM_BBDA0x5C_MM_PERM_BBDB0x5D_MM_PERM_BBDC0x5E_MM_PERM_BBDD0x5F_MM_PERM_BCAA0x60_MM_PERM_BCAB0x61_MM_PERM_BCAC0x62_MM_PERM_BCAD0x63_MM_PERM_BCBA0x64_MM_PERM_BCBB0x65_MM_PERM_BCBC0x66_MM_PERM_BCBD0x67_MM_PERM_BCCA0x68_MM_PERM_BCCB0x69_MM_PERM_BCCC0x6A_MM_PERM_BCCD0x6B_MM_PERM_BCDA0x6C_MM_PERM_BCDB0x6D_MM_PERM_BCDC0x6E_MM_PERM_BCDD0x6F_MM_PERM_BDAA_MM_PERM_BDAB0x71_MM_PERM_BDAC0x72_MM_PERM_BDAD0x73_MM_PERM_BDBA0x74_MM_PERM_BDBB0x75_MM_PERM_BDBC0x76_MM_PERM_BDBD0x77_MM_PERM_BDCA0x78_MM_PERM_BDCB0x79_MM_PERM_BDCC0x7A_MM_PERM_BDCD0x7B_MM_PERM_BDDA0x7C_MM_PERM_BDDB0x7D_MM_PERM_BDDC0x7E_MM_PERM_BDDD_MM_PERM_CAAA_MM_PERM_CAAB0x81_MM_PERM_CAAC0x82_MM_PERM_CAAD0x83_MM_PERM_CABA0x84_MM_PERM_CABB0x85_MM_PERM_CABC0x86_MM_PERM_CABD0x87_MM_PERM_CACA0x88_MM_PERM_CACB0x89_MM_PERM_CACC0x8A_MM_PERM_CACD0x8B_MM_PERM_CADA0x8C_MM_PERM_CADB0x8D_MM_PERM_CADC0x8E_MM_PERM_CADD0x8F_MM_PERM_CBAA0x90_MM_PERM_CBAB0x91_MM_PERM_CBAC0x92_MM_PERM_CBAD0x93_MM_PERM_CBBA0x94_MM_PERM_CBBB0x95_MM_PERM_CBBC0x96_MM_PERM_CBBD0x97_MM_PERM_CBCA0x98_MM_PERM_CBCB0x99_MM_PERM_CBCC0x9A_MM_PERM_CBCD1550x9B_MM_PERM_CBDA1560x9C_MM_PERM_CBDB1570x9D_MM_PERM_CBDC1580x9E_MM_PERM_CBDD1590x9F_MM_PERM_CCAA1600xA0_MM_PERM_CCAB1610xA1_MM_PERM_CCAC1620xA2_MM_PERM_CCAD1630xA3_MM_PERM_CCBA1640xA4_MM_PERM_CCBB1650xA5_MM_PERM_CCBC1660xA6_MM_PERM_CCBD1670xA7_MM_PERM_CCCA1680xA8_MM_PERM_CCCB1690xA9_MM_PERM_CCCC1700xAA_MM_PERM_CCCD1710xAB_MM_PERM_CCDA1720xAC_MM_PERM_CCDB1730xAD_MM_PERM_CCDC1740xAE_MM_PERM_CCDD1750xAF_MM_PERM_CDAA1760xB0_MM_PERM_CDAB1770xB1_MM_PERM_CDAC1780xB2_MM_PERM_CDAD1790xB3_MM_PERM_CDBA1800xB4_MM_PERM_CDBB1810xB5_MM_PERM_CDBC1820xB6_MM_PERM_CDBD1830xB7_MM_PERM_CDCA1840xB8_MM_PERM_CDCB1850xB9_MM_PERM_CDCC1860xBA_MM_PERM_CDCD1870xBB_MM_PERM_CDDA1880xBC_MM_PERM_CDDB1890xBD_MM_PERM_CDDC1900xBE_MM_PERM_CDDD1910xBF_MM_PERM_DAAA_MM_PERM_DAAB1930xC1_MM_PERM_DAAC1940xC2_MM_PERM_DAAD1950xC3_MM_PERM_DABA1960xC4_MM_PERM_DABB1970xC5_MM_PERM_DABC1980xC6_MM_PERM_DABD1990xC7_MM_PERM_DACA2000xC8_MM_PERM_DACB2010xC9_MM_PERM_DACC2020xCA_MM_PERM_DACD2030xCB_MM_PERM_DADA2040xCC_MM_PERM_DADB2050xCD_MM_PERM_DADC2060xCE_MM_PERM_DADD2070xCF_MM_PERM_DBAA2080xD0_MM_PERM_DBAB2090xD1_MM_PERM_DBAC2100xD2_MM_PERM_DBAD2110xD3_MM_PERM_DBBA2120xD4_MM_PERM_DBBB2130xD5_MM_PERM_DBBC2140xD6_MM_PERM_DBBD2150xD7_MM_PERM_DBCA2160xD8_MM_PERM_DBCB2170xD9_MM_PERM_DBCC2180xDA_MM_PERM_DBCD2190xDB_MM_PERM_DBDA2200xDC_MM_PERM_DBDB2210xDD_MM_PERM_DBDC2220xDE_MM_PERM_DBDD2230xDF_MM_PERM_DCAA2240xE0_MM_PERM_DCAB2250xE1_MM_PERM_DCAC2260xE2_MM_PERM_DCAD2270xE3_MM_PERM_DCBA2280xE4_MM_PERM_DCBB2290xE5_MM_PERM_DCBC2300xE6_MM_PERM_DCBD2310xE7_MM_PERM_DCCA_MM_PERM_DCCB_MM_PERM_DCCC2340xEA_MM_PERM_DCCD_MM_PERM_DCDA2360xEC_MM_PERM_DCDB2370xED_MM_PERM_DCDC2380xEE_MM_PERM_DCDD2390xEF_MM_PERM_DDAA_MM_PERM_DDAB2410xF1_MM_PERM_DDAC2420xF2_MM_PERM_DDAD2430xF3_MM_PERM_DDBA2440xF4_MM_PERM_DDBB2450xF5_MM_PERM_DDBC2460xF6_MM_PERM_DDBD2470xF7_MM_PERM_DDCA_MM_PERM_DDCB2490xF9_MM_PERM_DDCC2500xFA_MM_PERM_DDCD2510xFB_MM_PERM_DDDA_MM_PERM_DDDB2530xFD_MM_PERM_DDDC_MM_PERM_DDDD_MM_TERNLOG_ENUM_MM_TERNLOG_A_MM_TERNLOG_B_MM_TERNLOG_C__mmask16__mmask8__m512d_u__m512i_u__m512_u__m512d__m512i__m512__attribute((vector_size(64))) unsigned char__v64qu__attribute((vector_size(64))) char__v64qi__attribute((vector_size(64))) unsigned short__v32hu__attribute((vector_size(64))) short__v32hi__v16su__v16si__v8du__v8di__v16sf__v8df__DISABLE_AVX512F____MM512_REDUCE_OP__MM512_REDUCE_OP(op)__m256d __T1 = (__m256d) _mm512_extractf64x4_pd (__A, 1); __m256d __T2 = (__m256d) _mm512_extractf64x4_pd (__A, 0); __m256d __T3 = _mm256_ ## op (__T1, __T2); __m128d __T4 = _mm256_extractf128_pd (__T3, 1); __m128d __T5 = _mm256_extractf128_pd (__T3, 0); __m128d __T6 = _mm_ ## op (__T4, __T5); __m128d __T7 = (__m128d) __builtin_shuffle (__T6, (__v2di) { 1, 0 }); __m128d __T8 = _mm_ ## op (__T6, __T7); return __T8[0]__m256d __T1 = (__m256d) _mm512_extractf64x4_pd (__A, 1); __m256d __T2 = (__m256d) _mm512_extractf64x4_pd (__A, 0); __m256d __T3 = __T1 op __T2; __m128d __T4 = _mm256_extractf128_pd (__T3, 1); __m128d __T5 = _mm256_extractf128_pd (__T3, 0); __m128d __T6 = __T4 op __T5; return __T6[0] op __T6[1]__m512i __T1 = _mm512_shuffle_i64x2 (__A, __A, 0x4e); __m512i __T2 = _mm512_ ## op (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_ ## op (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_ ## op (__T4, __T5); return __T6[0]__v4di __T1 = (__v4di) _mm512_extracti64x4_epi64 (__A, 1); __v4di __T2 = (__v4di) _mm512_extracti64x4_epi64 (__A, 0); __m256i __T3 = (__m256i) (__T1 op __T2); __v2di __T4 = (__v2di) _mm256_extracti128_si256 (__T3, 1); __v2di __T5 = (__v2di) _mm256_extracti128_si256 (__T3, 0); __v2di __T6 = __T4 op __T5; return __T6[0] op __T6[1]__m256 __T1 = (__m256) _mm512_extractf64x4_pd ((__m512d) __A, 1); __m256 __T2 = (__m256) _mm512_extractf64x4_pd ((__m512d) __A, 0); __m256 __T3 = _mm256_ ## op (__T1, __T2); __m128 __T4 = _mm256_extractf128_ps (__T3, 1); __m128 __T5 = _mm256_extractf128_ps (__T3, 0); __m128 __T6 = _mm_ ## op (__T4, __T5); __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = _mm_ ## op (__T6, __T7); __m128 __T9 = __builtin_shuffle (__T8, (__v4si) { 1, 0, 1, 0 }); __m128 __T10 = _mm_ ## op (__T8, __T9); return __T10[0]__m256 __T1 = (__m256) _mm512_extractf64x4_pd ((__m512d) __A, 1); __m256 __T2 = (__m256) _mm512_extractf64x4_pd ((__m512d) __A, 0); __m256 __T3 = __T1 op __T2; __m128 __T4 = _mm256_extractf128_ps (__T3, 1); __m128 __T5 = _mm256_extractf128_ps (__T3, 0); __m128 __T6 = __T4 op __T5; __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = __T6 op __T7; return __T8[0] op __T8[1]__m256i __T1 = (__m256i) _mm512_extracti64x4_epi64 (__A, 1); __m256i __T2 = (__m256i) _mm512_extracti64x4_epi64 (__A, 0); __m256i __T3 = _mm256_ ## op (__T1, __T2); __m128i __T4 = (__m128i) _mm256_extracti128_si256 (__T3, 1); __m128i __T5 = (__m128i) _mm256_extracti128_si256 (__T3, 0); __m128i __T6 = _mm_ ## op (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_ ## op (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_ ## op (__T8, __T9); return __T10[0]__v8si __T1 = (__v8si) _mm512_extracti64x4_epi64 (__A, 1); __v8si __T2 = (__v8si) _mm512_extracti64x4_epi64 (__A, 0); __m256i __T3 = (__m256i) (__T1 op __T2); __v4si __T4 = (__v4si) _mm256_extracti128_si256 (__T3, 1); __v4si __T5 = (__v4si) _mm256_extracti128_si256 (__T3, 0); __v4si __T6 = __T4 op __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 op __T7; return __T8[0] op __T8[1]_kxor_mask16_kxnor_mask16_kor_mask16_knot_mask16_kandn_mask16_kand_mask16_MM_CMPINT_GT0x6_MM_CMPINT_NLE_MM_CMPINT_GE0x5_MM_CMPINT_NLT_MM_CMPINT_NE_MM_CMPINT_UNUSED_MM_CMPINT_LE0x2_MM_CMPINT_LT0x1_MM_CMPINT_EQ0x0_mm_maskz_cvtsd_ss(U,A,B)_mm_maskz_cvt_roundsd_ss ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_cvtsd_ss(W,U,A,B)_mm_mask_cvt_roundsd_ss ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_cvtss_sd(U,A,B)_mm_maskz_cvt_roundss_sd ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_cvtss_sd(W,U,A,B)_mm_mask_cvt_roundss_sd ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_scalef_ss(U,A,B)_mm_maskz_scalef_round_ss ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_scalef_ss(W,U,A,B)_mm_mask_scalef_round_ss ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_scalef_sd(U,A,B)_mm_maskz_scalef_round_sd ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_scalef_sd(W,U,A,B)_mm_mask_scalef_round_sd ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_sqrt_ss(U,A,B)_mm_maskz_sqrt_round_ss ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_sqrt_ss(W,U,A,B)_mm_mask_sqrt_round_ss ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_sqrt_sd(U,A,B)_mm_maskz_sqrt_round_sd ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_sqrt_sd(W,U,A,B)_mm_mask_sqrt_round_sd ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm512_setr4_ps(e0,e1,e2,e3)_mm512_set4_ps(e3,e2,e1,e0)_mm512_setr4_pd(e0,e1,e2,e3)_mm512_set4_pd(e3,e2,e1,e0)_mm512_setr4_epi32(e0,e1,e2,e3)_mm512_set4_epi32(e3,e2,e1,e0)_mm512_setr4_epi64(e0,e1,e2,e3)_mm512_set4_epi64(e3,e2,e1,e0)_mm512_undefined_si512_mm512_undefined_mm512_setr_ps(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15)_mm512_set_ps(e15,e14,e13,e12,e11,e10,e9,e8,e7,e6,e5,e4,e3,e2,e1,e0)_mm512_setr_pd(e0,e1,e2,e3,e4,e5,e6,e7)_mm512_set_pd(e7,e6,e5,e4,e3,e2,e1,e0)_mm512_setr_epi32(e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15)_mm512_set_epi32(e15,e14,e13,e12,e11,e10,e9,e8,e7,e6,e5,e4,e3,e2,e1,e0)_mm512_setr_epi64(e0,e1,e2,e3,e4,e5,e6,e7)_mm512_set_epi64(e7,e6,e5,e4,e3,e2,e1,e0)_AVX512FINTRIN_H_INCLUDED__AVX512F__GCC target("avx512f")__LONG_LONG_MAX____INT_MAX__/* _AVX512FINTRIN_H_INCLUDED *//* __DISABLE_AVX512F__ *//* Mask arithmetic operations *//* DEST = NaN if sign(SRC) = 1 *//* sign = 0             *//* sign = sign(SRC)     *//* interval [0.75, 1.5) *//* interval [0.5, 1)    *//* interval [0.5, 2)    *//* interval [1, 2)      *//* Constants for mantissa extraction *//* idx *//* Constant helper to represent the ternary logic operations among
   vector A, B and C.  *//* Create the vector [A B C D A B C D A B C D A B C D].  *//* Create the vector [A B C D E F G H I J K L M N O P].  *//* __AVX512F__ */_mm_maskz_rsqrt28_round_ss__builtin_ia32_rsqrt28ss_mask_round_mm_mask_rsqrt28_round_ss_mm_rsqrt28_round_ss__builtin_ia32_rsqrt28ss_round_mm_maskz_rsqrt28_round_sd__builtin_ia32_rsqrt28sd_mask_round_mm_mask_rsqrt28_round_sd_mm_rsqrt28_round_sd__builtin_ia32_rsqrt28sd_round_mm512_maskz_rsqrt28_round_ps__builtin_ia32_rsqrt28ps_mask_mm512_mask_rsqrt28_round_ps_mm512_rsqrt28_round_ps_mm512_maskz_rsqrt28_round_pd__builtin_ia32_rsqrt28pd_mask_mm512_mask_rsqrt28_round_pd_mm512_rsqrt28_round_pd_mm_maskz_rcp28_round_ss__builtin_ia32_rcp28ss_mask_round_mm_mask_rcp28_round_ss_mm_rcp28_round_ss__builtin_ia32_rcp28ss_round_mm_maskz_rcp28_round_sd__builtin_ia32_rcp28sd_mask_round_mm_mask_rcp28_round_sd_mm_rcp28_round_sd__builtin_ia32_rcp28sd_round_mm512_maskz_rcp28_round_ps__builtin_ia32_rcp28ps_mask_mm512_mask_rcp28_round_ps_mm512_rcp28_round_ps_mm512_maskz_rcp28_round_pd__builtin_ia32_rcp28pd_mask_mm512_mask_rcp28_round_pd_mm512_rcp28_round_pd_mm512_maskz_exp2a23_round_ps__builtin_ia32_exp2ps_mask_mm512_mask_exp2a23_round_ps_mm512_exp2a23_round_ps_mm512_maskz_exp2a23_round_pd__builtin_ia32_exp2pd_mask_mm512_mask_exp2a23_round_pd_mm512_exp2a23_round_pd__DISABLE_AVX512ER___mm_rsqrt28_ss(A,B)__builtin_ia32_rsqrt28ss_round(B, A, _MM_FROUND_CUR_DIRECTION)_mm_rsqrt28_sd(A,B)__builtin_ia32_rsqrt28sd_round(B, A, _MM_FROUND_CUR_DIRECTION)_mm_rcp28_ss(A,B)__builtin_ia32_rcp28ss_round(B, A, _MM_FROUND_CUR_DIRECTION)_mm_rcp28_sd(A,B)__builtin_ia32_rcp28sd_round(B, A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_rsqrt28_ps(U,A)_mm512_maskz_rsqrt28_round_ps(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_rsqrt28_ps(W,U,A)_mm512_mask_rsqrt28_round_ps(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_rsqrt28_ps(A)_mm512_rsqrt28_round_ps(A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_rsqrt28_pd(U,A)_mm512_maskz_rsqrt28_round_pd(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_rsqrt28_pd(W,U,A)_mm512_mask_rsqrt28_round_pd(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_rsqrt28_pd(A)_mm512_rsqrt28_round_pd(A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_rcp28_ps(U,A)_mm512_maskz_rcp28_round_ps(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_rcp28_ps(W,U,A)_mm512_mask_rcp28_round_ps(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_rcp28_ps(A)_mm512_rcp28_round_ps(A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_rcp28_pd(U,A)_mm512_maskz_rcp28_round_pd(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_rcp28_pd(W,U,A)_mm512_mask_rcp28_round_pd(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_rcp28_pd(A)_mm512_rcp28_round_pd(A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_exp2a23_ps(U,A)_mm512_maskz_exp2a23_round_ps(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_exp2a23_ps(W,U,A)_mm512_mask_exp2a23_round_ps(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_exp2a23_ps(A)_mm512_exp2a23_round_ps(A, _MM_FROUND_CUR_DIRECTION)_mm512_maskz_exp2a23_pd(U,A)_mm512_maskz_exp2a23_round_pd(U, A, _MM_FROUND_CUR_DIRECTION)_mm512_mask_exp2a23_pd(W,U,A)_mm512_mask_exp2a23_round_pd(W, U, A, _MM_FROUND_CUR_DIRECTION)_mm512_exp2a23_pd(A)_mm512_exp2a23_round_pd(A, _MM_FROUND_CUR_DIRECTION)_mm_maskz_rsqrt28_ss(U,A,B)_mm_maskz_rsqrt28_round_ss ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_rsqrt28_ss(W,U,A,B)_mm_mask_rsqrt28_round_ss ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_rsqrt28_sd(U,A,B)_mm_maskz_rsqrt28_round_sd ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_rsqrt28_sd(W,U,A,B)_mm_mask_rsqrt28_round_sd ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_rcp28_ss(U,A,B)_mm_maskz_rcp28_round_ss ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_rcp28_ss(W,U,A,B)_mm_mask_rcp28_round_ss ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_maskz_rcp28_sd(U,A,B)_mm_maskz_rcp28_round_sd ((U), (A), (B), _MM_FROUND_CUR_DIRECTION)_mm_mask_rcp28_sd(W,U,A,B)_mm_mask_rcp28_round_sd ((W), (U), (A), (B), _MM_FROUND_CUR_DIRECTION)_AVX512ERINTRIN_H_INCLUDED__AVX512ER__GCC target("avx512er")/* _AVX512ERINTRIN_H_INCLUDED *//* __DISABLE_AVX512ER__ *//* __AVX512ER__ */_mm512_mask_prefetch_i64scatter_ps__builtin_ia32_scatterpfqps_mm512_mask_prefetch_i64scatter_pd__builtin_ia32_scatterpfqpd_mm512_prefetch_i64scatter_ps_mm512_prefetch_i64scatter_pd_mm512_mask_prefetch_i32scatter_ps__builtin_ia32_scatterpfdps_mm512_mask_prefetch_i32scatter_pd__builtin_ia32_scatterpfdpd_mm512_prefetch_i32scatter_ps_mm512_prefetch_i32scatter_pd_mm512_mask_prefetch_i64gather_ps__builtin_ia32_gatherpfqps_mm512_mask_prefetch_i64gather_pd__builtin_ia32_gatherpfqpd_mm512_prefetch_i64gather_ps_mm512_prefetch_i64gather_pd_mm512_mask_prefetch_i32gather_ps__builtin_ia32_gatherpfdps_mm512_mask_prefetch_i32gather_pd__builtin_ia32_gatherpfdpd_mm512_prefetch_i32gather_ps_mm512_prefetch_i32gather_pd__DISABLE_AVX512PF___AVX512PFINTRIN_H_INCLUDED__AVX512PF__GCC target("avx512pf")/* _AVX512PFINTRIN_H_INCLUDED *//* __DISABLE_AVX512PF__ *//* __AVX512PF__ */__hint_mm512_broadcastmw_epi32__builtin_ia32_broadcastmw512_mm512_broadcastmb_epi64__builtin_ia32_broadcastmb512_mm512_maskz_lzcnt_epi32__builtin_ia32_vplzcntd_512_mask_mm512_mask_lzcnt_epi32_mm512_lzcnt_epi32_mm512_maskz_lzcnt_epi64__builtin_ia32_vplzcntq_512_mask_mm512_mask_lzcnt_epi64_mm512_lzcnt_epi64_mm512_maskz_conflict_epi64__builtin_ia32_vpconflictdi_512_mask_mm512_mask_conflict_epi64_mm512_conflict_epi64_mm512_maskz_conflict_epi32__builtin_ia32_vpconflictsi_512_mask_mm512_mask_conflict_epi32_mm512_conflict_epi32__DISABLE_AVX512CD___AVX512CDINTRIN_H_INCLUDED__AVX512CD__GCC target("avx512cd")/* _AVX512CDINTRIN_H_INCLUDED *//* __DISABLE_AVX512CD__ *//* __AVX512CD__ */_mm256_permutex_pd__builtin_ia32_permdf256_mask_mm_mask_cmp_ps_mask__builtin_ia32_cmpps128_mask_mm_mask_cmp_pd_mask__builtin_ia32_cmppd128_mask_mm_mask_cmp_epu32_mask__builtin_ia32_ucmpd128_mask_mm_mask_cmp_epu64_mask__builtin_ia32_ucmpq128_mask_mm_mask_cmp_epi32_mask__builtin_ia32_cmpd128_mask_mm_mask_cmp_epi64_mask__builtin_ia32_cmpq128_mask_mm_cmp_ps_mask_mm_cmp_pd_mask_mm_cmp_epu32_mask_mm_cmp_epu64_mask_mm_cmp_epi32_mask_mm_cmp_epi64_mask_mm256_mask_cmp_ps_mask__builtin_ia32_cmpps256_mask_mm256_mask_cmp_pd_mask__builtin_ia32_cmppd256_mask_mm256_mask_cmp_epu32_mask__builtin_ia32_ucmpd256_mask_mm256_mask_cmp_epu64_mask__builtin_ia32_ucmpq256_mask_mm256_mask_cmp_epi32_mask__builtin_ia32_cmpd256_mask_mm256_mask_cmp_epi64_mask__builtin_ia32_cmpq256_mask_mm256_cmp_ps_mask_mm256_cmp_pd_mask_mm256_cmp_epu32_mask_mm256_cmp_epu64_mask_mm256_cmp_epi32_mask_mm256_cmp_epi64_mask_mm_mask_blend_epi32__builtin_ia32_blendmd_128_mask_mm_mask_blend_epi64__builtin_ia32_blendmq_128_mask_mm_mask_blend_ps__builtin_ia32_blendmps_128_mask_mm_mask_blend_pd__builtin_ia32_blendmpd_128_mask_mm256_mask_blend_epi32__builtin_ia32_blendmd_256_mask_mm256_mask_blend_epi64__builtin_ia32_blendmq_256_mask_mm256_mask_blend_ps__builtin_ia32_blendmps_256_mask_mm256_mask_blend_pd__builtin_ia32_blendmpd_256_mask_mm_maskz_permute_ps__builtin_ia32_vpermilps_mask_mm_mask_permute_ps_mm256_maskz_permute_ps__builtin_ia32_vpermilps256_mask_mm256_mask_permute_ps_mm_maskz_permute_pd__builtin_ia32_vpermilpd_mask_mm_mask_permute_pd_mm256_maskz_permute_pd__builtin_ia32_vpermilpd256_mask_mm256_mask_permute_pd_mm256_maskz_permutex_pd_mm256_mask_permutex_pd_mm256_maskz_slli_epi64__builtin_ia32_psllqi256_mask_mm256_mask_slli_epi64_mm256_maskz_slli_epi32__builtin_ia32_pslldi256_mask_mm256_mask_slli_epi32_mm_maskz_slli_epi64__builtin_ia32_psllqi128_mask_mm_mask_slli_epi64_mm_maskz_slli_epi32__builtin_ia32_pslldi128_mask_mm_mask_slli_epi32_mm_maskz_srai_epi64__builtin_ia32_psraqi128_mask_mm_mask_srai_epi64_mm_srai_epi64_mm256_maskz_srai_epi64__builtin_ia32_psraqi256_mask_mm256_mask_srai_epi64_mm256_srai_epi64_mm_maskz_srai_epi32__builtin_ia32_psradi128_mask_mm_mask_srai_epi32_mm256_maskz_srai_epi32__builtin_ia32_psradi256_mask_mm256_mask_srai_epi32_mm256_maskz_cvtps_ph__builtin_ia32_vcvtps2ph256_mask_mm256_mask_cvtps_ph_mm_maskz_cvtps_ph__builtin_ia32_vcvtps2ph_mask_mm_mask_cvtps_ph_mm256_maskz_alignr_epi64__builtin_ia32_alignq256_mask_mm256_mask_alignr_epi64_mm256_alignr_epi64_mm256_maskz_alignr_epi32__builtin_ia32_alignd256_mask_mm256_mask_alignr_epi32_mm256_alignr_epi32_mm_maskz_alignr_epi64__builtin_ia32_alignq128_mask_mm_mask_alignr_epi64_mm_alignr_epi64_mm_maskz_alignr_epi32__builtin_ia32_alignd128_mask_mm_mask_alignr_epi32_mm_alignr_epi32_mm_maskz_ror_epi64__builtin_ia32_prorq128_mask_mm_mask_ror_epi64_mm_ror_epi64_mm256_maskz_ror_epi64__builtin_ia32_prorq256_mask_mm256_mask_ror_epi64_mm256_ror_epi64_mm_maskz_rol_epi64__builtin_ia32_prolq128_mask_mm_mask_rol_epi64_mm_rol_epi64_mm256_maskz_rol_epi64__builtin_ia32_prolq256_mask_mm256_mask_rol_epi64_mm256_rol_epi64_mm_maskz_ror_epi32__builtin_ia32_prord128_mask_mm_mask_ror_epi32_mm_ror_epi32_mm256_maskz_ror_epi32__builtin_ia32_prord256_mask_mm256_mask_ror_epi32_mm256_ror_epi32_mm_maskz_rol_epi32__builtin_ia32_prold128_mask_mm_mask_rol_epi32_mm_rol_epi32_mm256_maskz_rol_epi32__builtin_ia32_prold256_mask_mm256_mask_rol_epi32_mm256_rol_epi32_mm_maskz_shuffle_epi32__builtin_ia32_pshufd128_mask_mm_mask_shuffle_epi32_mm256_maskz_shuffle_epi32__builtin_ia32_pshufd256_mask_mm256_mask_shuffle_epi32_mm_mask_i64scatter_epi64__builtin_ia32_scatterdiv2di_mm_i64scatter_epi64_mm256_mask_i64scatter_epi64__builtin_ia32_scatterdiv4di_mm256_i64scatter_epi64_mm_mask_i64scatter_epi32__builtin_ia32_scatterdiv4si_mm_i64scatter_epi32_mm256_mask_i64scatter_epi32__builtin_ia32_scatterdiv8si_mm256_i64scatter_epi32_mm_mask_i32scatter_epi64__builtin_ia32_scattersiv2di_mm_i32scatter_epi64_mm256_mask_i32scatter_epi64__builtin_ia32_scattersiv4di_mm256_i32scatter_epi64_mm_mask_i32scatter_epi32__builtin_ia32_scattersiv4si_mm_i32scatter_epi32_mm256_mask_i32scatter_epi32__builtin_ia32_scattersiv8si_mm256_i32scatter_epi32_mm_mask_i64scatter_pd__builtin_ia32_scatterdiv2df_mm_i64scatter_pd_mm256_mask_i64scatter_pd__builtin_ia32_scatterdiv4df_mm256_i64scatter_pd_mm_mask_i64scatter_ps__builtin_ia32_scatterdiv4sf_mm_i64scatter_ps_mm256_mask_i64scatter_ps__builtin_ia32_scatterdiv8sf_mm256_i64scatter_ps_mm_mask_i32scatter_pd__builtin_ia32_scattersiv2df_mm_i32scatter_pd_mm256_mask_i32scatter_pd__builtin_ia32_scattersiv4df_mm256_i32scatter_pd_mm_mask_i32scatter_ps__builtin_ia32_scattersiv4sf_mm_i32scatter_ps_mm256_mask_i32scatter_ps__builtin_ia32_scattersiv8sf_mm256_i32scatter_ps_mm_mmask_i64gather_epi64__builtin_ia32_gather3div2di_mm256_mmask_i64gather_epi64__builtin_ia32_gather3div4di_mm_mmask_i64gather_epi32__builtin_ia32_gather3div4si_mm256_mmask_i64gather_epi32__builtin_ia32_gather3div8si_mm_mmask_i32gather_epi64__builtin_ia32_gather3siv2di_mm256_mmask_i32gather_epi64__builtin_ia32_gather3siv4di_mm_mmask_i32gather_epi32__builtin_ia32_gather3siv4si_mm256_mmask_i32gather_epi32__builtin_ia32_gather3siv8si_mm_mmask_i64gather_pd__builtin_ia32_gather3div2df_mm256_mmask_i64gather_pd__builtin_ia32_gather3div4df_mm_mmask_i64gather_ps__builtin_ia32_gather3div4sf_mm256_mmask_i64gather_ps__builtin_ia32_gather3div8sf_mm_mmask_i32gather_pd__builtin_ia32_gather3siv2df_mm256_mmask_i32gather_pd__builtin_ia32_gather3siv4df_mm_mmask_i32gather_ps__builtin_ia32_gather3siv4sf_mm256_mmask_i32gather_ps__builtin_ia32_gather3siv8sf_mm_maskz_getmant_pd__builtin_ia32_getmantpd128_mask_mm_mask_getmant_pd_mm_getmant_pd_mm256_maskz_getmant_pd__builtin_ia32_getmantpd256_mask_mm256_mask_getmant_pd_mm256_getmant_pd_mm_maskz_getmant_ps__builtin_ia32_getmantps128_mask_mm_mask_getmant_ps_mm_getmant_ps_mm256_maskz_getmant_ps__builtin_ia32_getmantps256_mask_mm256_mask_getmant_ps_mm256_getmant_ps_mm_maskz_roundscale_pd__builtin_ia32_rndscalepd_128_mask_mm_mask_roundscale_pd_mm_roundscale_pd_mm_maskz_roundscale_ps__builtin_ia32_rndscaleps_128_mask_mm_mask_roundscale_ps_mm_roundscale_ps_mm256_maskz_roundscale_pd__builtin_ia32_rndscalepd_256_mask_mm256_mask_roundscale_pd_mm256_roundscale_pd_mm256_maskz_roundscale_ps__builtin_ia32_rndscaleps_256_mask_mm256_mask_roundscale_ps_mm256_roundscale_ps_mm_maskz_ternarylogic_epi32__builtin_ia32_pternlogd128_maskz_mm_mask_ternarylogic_epi32__builtin_ia32_pternlogd128_mask_mm_ternarylogic_epi32_mm_maskz_ternarylogic_epi64__builtin_ia32_pternlogq128_maskz_mm_mask_ternarylogic_epi64__builtin_ia32_pternlogq128_mask_mm_ternarylogic_epi64_mm256_maskz_ternarylogic_epi32__builtin_ia32_pternlogd256_maskz_mm256_mask_ternarylogic_epi32__builtin_ia32_pternlogd256_mask_mm256_ternarylogic_epi32_mm256_maskz_ternarylogic_epi64__builtin_ia32_pternlogq256_maskz_mm256_mask_ternarylogic_epi64__builtin_ia32_pternlogq256_mask_mm256_ternarylogic_epi64_mm_maskz_srli_epi64__builtin_ia32_psrlqi128_mask_mm_mask_srli_epi64_mm256_maskz_srli_epi64__builtin_ia32_psrlqi256_mask_mm256_mask_srli_epi64_mm_maskz_srli_epi32__builtin_ia32_psrldi128_mask_mm_mask_srli_epi32_mm256_maskz_srli_epi32__builtin_ia32_psrldi256_mask_mm256_mask_srli_epi32_mm_maskz_fixupimm_ps__builtin_ia32_fixupimmps128_maskz_mm_mask_fixupimm_ps__builtin_ia32_fixupimmps128_mask_mm_fixupimm_ps_mm_maskz_fixupimm_pd__builtin_ia32_fixupimmpd128_maskz_mm_mask_fixupimm_pd__builtin_ia32_fixupimmpd128_mask_mm_fixupimm_pd_mm256_maskz_fixupimm_ps__builtin_ia32_fixupimmps256_maskz_mm256_mask_fixupimm_ps__builtin_ia32_fixupimmps256_mask_mm256_fixupimm_ps_mm256_maskz_fixupimm_pd__builtin_ia32_fixupimmpd256_maskz_mm256_mask_fixupimm_pd__builtin_ia32_fixupimmpd256_mask_mm256_fixupimm_pd_mm256_maskz_shuffle_f32x4__builtin_ia32_shuf_f32x4_256_mask_mm256_mask_shuffle_f32x4_mm256_shuffle_f32x4_mm256_maskz_shuffle_f64x2__builtin_ia32_shuf_f64x2_256_mask_mm256_mask_shuffle_f64x2_mm256_shuffle_f64x2_mm256_maskz_shuffle_i32x4__builtin_ia32_shuf_i32x4_256_mask_mm256_mask_shuffle_i32x4_mm256_shuffle_i32x4_mm256_maskz_shuffle_i64x2__builtin_ia32_shuf_i64x2_256_mask_mm256_mask_shuffle_i64x2_mm256_shuffle_i64x2_mm256_maskz_extractf32x4_ps__builtin_ia32_extractf32x4_256_mask_mm256_mask_extractf32x4_ps_mm256_extractf32x4_ps_mm256_maskz_extracti32x4_epi32__builtin_ia32_extracti32x4_256_mask_mm256_mask_extracti32x4_epi32_mm256_extracti32x4_epi32_mm256_maskz_insertf32x4__builtin_ia32_insertf32x4_256_mask_mm256_mask_insertf32x4_mm256_insertf32x4_mm256_maskz_inserti32x4__builtin_ia32_inserti32x4_256_mask_mm256_mask_inserti32x4_mm256_inserti32x4_mm_maskz_shuffle_ps__builtin_ia32_shufps128_mask_mm_mask_shuffle_ps_mm256_maskz_shuffle_ps__builtin_ia32_shufps256_mask_mm256_mask_shuffle_ps_mm_maskz_shuffle_pd__builtin_ia32_shufpd128_mask_mm_mask_shuffle_pd_mm256_maskz_shuffle_pd__builtin_ia32_shufpd256_mask_mm256_mask_shuffle_pd_mm256_maskz_permutex_epi64__builtin_ia32_permdi256_mask_mm256_mask_permutex_epi64_mm256_permutex_epi64_mm_cmple_epi64_mask_mm_mask_cmple_epi64_mask_mm_cmpge_epi64_mask_mm_mask_cmpge_epi64_mask_mm_cmplt_epi64_mask_mm_mask_cmplt_epi64_mask_mm_cmpneq_epi64_mask_mm_mask_cmpneq_epi64_mask_mm_cmple_epi32_mask_mm_mask_cmple_epi32_mask_mm_cmpge_epi32_mask_mm_mask_cmpge_epi32_mask_mm_cmplt_epi32_mask_mm_mask_cmplt_epi32_mask_mm_cmpneq_epi32_mask_mm_mask_cmpneq_epi32_mask_mm_cmple_epu64_mask_mm_mask_cmple_epu64_mask_mm_cmpge_epu64_mask_mm_mask_cmpge_epu64_mask_mm_cmplt_epu64_mask_mm_mask_cmplt_epu64_mask_mm_cmpneq_epu64_mask_mm_mask_cmpneq_epu64_mask_mm_cmple_epu32_mask_mm_mask_cmple_epu32_mask_mm_cmpge_epu32_mask_mm_mask_cmpge_epu32_mask_mm_cmplt_epu32_mask_mm_mask_cmplt_epu32_mask_mm_cmpneq_epu32_mask_mm_mask_cmpneq_epu32_mask_mm256_cmple_epi64_mask_mm256_mask_cmple_epi64_mask_mm256_cmpge_epi64_mask_mm256_mask_cmpge_epi64_mask_mm256_cmplt_epi64_mask_mm256_mask_cmplt_epi64_mask_mm256_cmpneq_epi64_mask_mm256_mask_cmpneq_epi64_mask_mm256_cmple_epi32_mask_mm256_mask_cmple_epi32_mask_mm256_cmpge_epi32_mask_mm256_mask_cmpge_epi32_mask_mm256_cmplt_epi32_mask_mm256_mask_cmplt_epi32_mask_mm256_cmpneq_epi32_mask_mm256_mask_cmpneq_epi32_mask_mm256_cmple_epu64_mask_mm256_mask_cmple_epu64_mask_mm256_cmpge_epu64_mask_mm256_mask_cmpge_epu64_mask_mm256_cmplt_epu64_mask_mm256_mask_cmplt_epu64_mask_mm256_cmpneq_epu64_mask_mm256_mask_cmpneq_epu64_mask_mm256_cmple_epu32_mask_mm256_mask_cmple_epu32_mask_mm256_cmpge_epu32_mask_mm256_mask_cmpge_epu32_mask_mm256_cmplt_epu32_mask_mm256_mask_cmplt_epu32_mask_mm256_cmpneq_epu32_mask_mm256_mask_cmpneq_epu32_mask_mm256_mask_permutexvar_epi32__builtin_ia32_permvarsi256_mask_mm256_permutexvar_epi32_mm_maskz_mul_epu32__builtin_ia32_pmuludq128_mask_mm_mask_mul_epu32_mm256_maskz_mul_epu32__builtin_ia32_pmuludq256_mask_mm256_maskz_permutexvar_epi32_mm256_mask_mul_epu32_mm256_mask_permutexvar_epi64__builtin_ia32_permvardi256_mask_mm256_permutexvar_epi64_mm_maskz_mul_epi32__builtin_ia32_pmuldq128_mask_mm_mask_mul_epi32_mm256_maskz_mul_epi32__builtin_ia32_pmuldq256_mask_mm256_mask_mul_epi32_mm_mask_mullo_epi32__builtin_ia32_pmulld128_mask_mm_maskz_mullo_epi32_mm256_mask_mullo_epi32__builtin_ia32_pmulld256_mask_mm256_maskz_permutexvar_epi64_mm256_maskz_mullo_epi32_mm_maskz_permutevar_ps__builtin_ia32_vpermilvarps_mask_mm_mask_permutevar_ps_mm_maskz_permutevar_pd__builtin_ia32_vpermilvarpd_mask_mm_mask_permutevar_pd_mm256_maskz_permutevar_ps__builtin_ia32_vpermilvarps256_mask_mm256_mask_permutevar_ps_mm256_maskz_permutevar_pd__builtin_ia32_vpermilvarpd256_mask_mm256_mask_permutevar_pd_mm256_maskz_permutexvar_pd__builtin_ia32_permvardf256_mask_mm256_mask_permutexvar_pd_mm256_permutexvar_pd_mm256_maskz_permutexvar_ps__builtin_ia32_permvarsf256_mask_mm256_mask_permutexvar_ps_mm256_maskz_sll_epi64__builtin_ia32_psllq256_mask_mm256_mask_sll_epi64_mm256_maskz_sll_epi32__builtin_ia32_pslld256_mask_mm256_mask_sll_epi32_mm_maskz_sll_epi64__builtin_ia32_psllq128_mask_mm_mask_sll_epi64_mm_maskz_sll_epi32__builtin_ia32_pslld128_mask_mm_mask_sll_epi32_mm_maskz_sra_epi64__builtin_ia32_psraq128_mask_mm_mask_sra_epi64_mm_sra_epi64_mm256_maskz_sra_epi64__builtin_ia32_psraq256_mask_mm256_mask_sra_epi64_mm256_sra_epi64_mm_maskz_sra_epi32__builtin_ia32_psrad128_mask_mm_mask_sra_epi32_mm256_maskz_sra_epi32__builtin_ia32_psrad256_mask_mm256_mask_sra_epi32_mm_maskz_unpacklo_ps__builtin_ia32_unpcklps128_mask_mm_mask_unpacklo_ps_mm256_maskz_cvtph_ps__builtin_ia32_vcvtph2ps256_mask_mm256_mask_cvtph_ps_mm256_maskz_unpacklo_ps__builtin_ia32_unpcklps256_mask_mm_maskz_cvtph_ps__builtin_ia32_vcvtph2ps_mask_mm_mask_cvtph_ps_mm_maskz_unpackhi_ps__builtin_ia32_unpckhps128_mask_mm_mask_unpackhi_ps_mm256_maskz_unpackhi_ps__builtin_ia32_unpckhps256_mask_mm256_mask_unpackhi_ps_mm_maskz_unpackhi_pd__builtin_ia32_unpckhpd128_mask_mm_mask_unpackhi_pd_mm256_maskz_unpackhi_pd__builtin_ia32_unpckhpd256_mask_mm256_mask_unpackhi_pd_mm256_mask_unpacklo_ps_mm_maskz_unpacklo_pd__builtin_ia32_unpcklpd128_mask_mm_mask_unpacklo_pd_mm256_maskz_unpacklo_pd__builtin_ia32_unpcklpd256_mask_mm256_mask_unpacklo_pd_mm_maskz_conflict_epi32__builtin_ia32_vpconflictsi_128_mask_mm_mask_conflict_epi32_mm_conflict_epi32_mm_maskz_conflict_epi64__builtin_ia32_vpconflictdi_128_mask_mm_mask_conflict_epi64_mm_conflict_epi64_mm_maskz_lzcnt_epi64__builtin_ia32_vplzcntq_128_mask_mm_mask_lzcnt_epi64_mm_lzcnt_epi64_mm_maskz_lzcnt_epi32__builtin_ia32_vplzcntd_128_mask_mm_mask_lzcnt_epi32_mm_lzcnt_epi32_mm256_maskz_conflict_epi32__builtin_ia32_vpconflictsi_256_mask_mm256_mask_conflict_epi32_mm256_conflict_epi32_mm256_maskz_conflict_epi64__builtin_ia32_vpconflictdi_256_mask_mm256_mask_conflict_epi64_mm256_conflict_epi64_mm256_maskz_lzcnt_epi64__builtin_ia32_vplzcntq_256_mask_mm256_mask_lzcnt_epi64_mm256_lzcnt_epi64_mm256_maskz_lzcnt_epi32__builtin_ia32_vplzcntd_256_mask_mm256_mask_lzcnt_epi32_mm256_lzcnt_epi32_mm256_broadcastmw_epi32__builtin_ia32_broadcastmw256_mm_broadcastmw_epi32__builtin_ia32_broadcastmw128_mm256_broadcastmb_epi64__builtin_ia32_broadcastmb256_mm_broadcastmb_epi64__builtin_ia32_broadcastmb128_mm_mask_min_epu32__builtin_ia32_pminud128_mask_mm_maskz_min_epu32_mm_mask_max_epu32__builtin_ia32_pmaxud128_mask_mm_maskz_max_epu32_mm_mask_min_epi32__builtin_ia32_pminsd128_mask_mm_maskz_min_epi32_mm_mask_max_epi32__builtin_ia32_pmaxsd128_mask_mm_maskz_max_epi32_mm_maskz_min_epu64__builtin_ia32_pminuq128_mask_mm_mask_min_epu64_mm_min_epu64_mm_mask_max_epu64__builtin_ia32_pmaxuq128_mask_mm_max_epu64_mm_max_epi64__builtin_ia32_pmaxsq128_mask_mm_maskz_max_epu64_mm_maskz_min_epi64__builtin_ia32_pminsq128_mask_mm_mask_min_epi64_mm_min_epi64_mm_mask_max_epi64_mm_maskz_max_epi64_mm256_mask_min_epu32__builtin_ia32_pminud256_mask_mm256_maskz_min_epu32_mm256_mask_max_epu32__builtin_ia32_pmaxud256_mask_mm256_maskz_max_epu32_mm256_mask_min_epi32__builtin_ia32_pminsd256_mask_mm256_maskz_min_epi32_mm256_mask_max_epi32__builtin_ia32_pmaxsd256_mask_mm256_maskz_max_epi32_mm256_maskz_min_epu64__builtin_ia32_pminuq256_mask_mm256_mask_min_epu64_mm256_min_epu64_mm256_mask_max_epu64__builtin_ia32_pmaxuq256_mask_mm256_max_epu64_mm256_max_epi64__builtin_ia32_pmaxsq256_mask_mm256_maskz_max_epu64_mm256_maskz_min_epi64__builtin_ia32_pminsq256_mask_mm256_mask_min_epi64_mm256_min_epi64_mm256_mask_max_epi64_mm256_maskz_max_epi64_mm256_maskz_mul_pd__builtin_ia32_mulpd256_mask_mm256_mask_mul_pd_mm256_maskz_mul_ps__builtin_ia32_mulps256_mask_mm256_mask_mul_ps_mm_maskz_mul_pd__builtin_ia32_mulpd_mask_mm_mask_mul_pd_mm_maskz_max_pd__builtin_ia32_maxpd_mask_mm_mask_max_pd_mm_maskz_min_pd__builtin_ia32_minpd_mask_mm_mask_min_pd_mm_maskz_max_ps__builtin_ia32_maxps_mask_mm_mask_max_ps_mm_maskz_mul_ps__builtin_ia32_mulps_mask_mm_maskz_min_ps__builtin_ia32_minps_mask_mm_mask_mul_ps_mm_mask_min_ps_mm256_maskz_div_ps__builtin_ia32_divps256_mask_mm256_maskz_min_ps__builtin_ia32_minps256_mask_mm256_mask_div_ps_mm256_maskz_div_pd__builtin_ia32_divpd256_mask_mm256_mask_min_ps_mm256_maskz_min_pd__builtin_ia32_minpd256_mask_mm256_mask_div_pd_mm256_mask_min_pd_mm_maskz_div_pd__builtin_ia32_divpd_mask_mm_mask_div_pd_mm_maskz_div_ps__builtin_ia32_divps_mask_mm_mask_div_ps_mm256_maskz_max_ps__builtin_ia32_maxps256_mask_mm256_mask_max_ps_mm256_maskz_max_pd__builtin_ia32_maxpd256_mask_mm256_mask_max_pd_mm_xor_epi64_mm_maskz_xor_epi64__builtin_ia32_pxorq128_mask_mm_mask_xor_epi64_mm256_xor_epi64_mm256_maskz_xor_epi64__builtin_ia32_pxorq256_mask_mm256_mask_xor_epi64_mm_or_epi64_mm_maskz_or_epi64__builtin_ia32_porq128_mask_mm_mask_or_epi64_mm256_or_epi64_mm256_maskz_or_epi64__builtin_ia32_porq256_mask_mm256_mask_or_epi64_mm_maskz_andnot_epi64__builtin_ia32_pandnq128_mask_mm_mask_andnot_epi64_mm256_maskz_andnot_epi64__builtin_ia32_pandnq256_mask_mm256_mask_andnot_epi64_mm_maskz_and_epi64__builtin_ia32_pandq128_mask_mm_mask_and_epi64_mm256_maskz_and_epi64__builtin_ia32_pandq256_mask_mm256_mask_and_epi64_mm256_maskz_srav_epi64__builtin_ia32_psravq256_mask_mm256_mask_srav_epi64_mm256_srav_epi64_mm_maskz_rorv_epi64__builtin_ia32_prorvq128_mask_mm_mask_rorv_epi64_mm_rorv_epi64_mm256_maskz_rorv_epi64__builtin_ia32_prorvq256_mask_mm256_mask_rorv_epi64_mm256_rorv_epi64_mm_maskz_rolv_epi64__builtin_ia32_prolvq128_mask_mm_mask_rolv_epi64_mm_rolv_epi64_mm256_maskz_rolv_epi64__builtin_ia32_prolvq256_mask_mm256_mask_rolv_epi64_mm256_rolv_epi64_mm_maskz_rorv_epi32__builtin_ia32_prorvd128_mask_mm_mask_rorv_epi32_mm_rorv_epi32_mm256_maskz_rorv_epi32__builtin_ia32_prorvd256_mask_mm256_mask_rorv_epi32_mm256_rorv_epi32_mm_maskz_rolv_epi32__builtin_ia32_prolvd128_mask_mm_mask_rolv_epi32_mm_rolv_epi32_mm256_maskz_rolv_epi32__builtin_ia32_prolvd256_mask_mm256_mask_rolv_epi32_mm256_rolv_epi32_mm_maskz_srlv_epi64__builtin_ia32_psrlv2di_mask_mm_mask_srlv_epi64_mm256_maskz_srlv_epi64__builtin_ia32_psrlv4di_mask_mm256_mask_srlv_epi64_mm_maskz_srlv_epi32__builtin_ia32_psrlv4si_mask_mm_mask_srlv_epi32_mm256_maskz_srlv_epi32__builtin_ia32_psrlv8si_mask_mm256_mask_srlv_epi32_mm_maskz_srav_epi32__builtin_ia32_psrav4si_mask_mm_mask_srav_epi32_mm256_maskz_srav_epi32__builtin_ia32_psrav8si_mask_mm256_mask_srav_epi32_mm_maskz_sllv_epi64__builtin_ia32_psllv2di_mask_mm_mask_sllv_epi64_mm256_maskz_sllv_epi64__builtin_ia32_psllv4di_mask_mm256_mask_sllv_epi64_mm_maskz_sllv_epi32__builtin_ia32_psllv4si_mask_mm_mask_sllv_epi32_mm256_maskz_sllv_epi32__builtin_ia32_psllv8si_mask_mm256_mask_sllv_epi32_mm_maskz_srav_epi64__builtin_ia32_psravq128_mask_mm_mask_srav_epi64_mm_srav_epi64_mm_maskz_permutex2var_ps__builtin_ia32_vpermt2varps128_maskz_mm_mask2_permutex2var_ps__builtin_ia32_vpermi2varps128_mask_mm_mask_permutex2var_ps__builtin_ia32_vpermt2varps128_mask_mm_permutex2var_ps_mm_maskz_permutex2var_pd__builtin_ia32_vpermt2varpd128_maskz_mm_mask2_permutex2var_pd__builtin_ia32_vpermi2varpd128_mask_mm_mask_permutex2var_pd__builtin_ia32_vpermt2varpd128_mask_mm_permutex2var_pd_mm256_maskz_permutex2var_epi32__builtin_ia32_vpermt2vard256_maskz_mm256_mask2_permutex2var_epi32__builtin_ia32_vpermi2vard256_mask_mm256_mask_permutex2var_epi32__builtin_ia32_vpermt2vard256_mask_mm256_permutex2var_epi32_mm256_maskz_permutex2var_epi64__builtin_ia32_vpermt2varq256_maskz_mm256_mask2_permutex2var_epi64__builtin_ia32_vpermi2varq256_mask_mm256_mask_permutex2var_epi64__builtin_ia32_vpermt2varq256_mask_mm256_permutex2var_epi64_mm_maskz_permutex2var_epi32__builtin_ia32_vpermt2vard128_maskz_mm_mask2_permutex2var_epi32__builtin_ia32_vpermi2vard128_mask_mm_mask_permutex2var_epi32__builtin_ia32_vpermt2vard128_mask_mm_permutex2var_epi32_mm_maskz_permutex2var_epi64__builtin_ia32_vpermt2varq128_maskz_mm_mask2_permutex2var_epi64__builtin_ia32_vpermi2varq128_mask_mm_mask_permutex2var_epi64__builtin_ia32_vpermt2varq128_mask_mm_permutex2var_epi64_mm256_maskz_permutex2var_ps__builtin_ia32_vpermt2varps256_maskz_mm256_mask2_permutex2var_ps__builtin_ia32_vpermi2varps256_mask_mm256_mask_permutex2var_ps__builtin_ia32_vpermt2varps256_mask_mm256_permutex2var_ps_mm256_maskz_permutex2var_pd__builtin_ia32_vpermt2varpd256_maskz_mm256_mask2_permutex2var_pd__builtin_ia32_vpermi2varpd256_mask_mm256_mask_permutex2var_pd__builtin_ia32_vpermt2varpd256_mask_mm256_permutex2var_pd_mm_maskz_expandloadu_epi32__builtin_ia32_expandloadsi128_maskz_mm_mask_expandloadu_epi32__builtin_ia32_expandloadsi128_mask_mm_maskz_expand_epi32__builtin_ia32_expandsi128_maskz_mm_mask_expand_epi32__builtin_ia32_expandsi128_mask_mm256_maskz_expandloadu_epi32__builtin_ia32_expandloadsi256_maskz_mm256_mask_expandloadu_epi32__builtin_ia32_expandloadsi256_mask_mm256_maskz_expand_epi32__builtin_ia32_expandsi256_maskz_mm256_mask_expand_epi32__builtin_ia32_expandsi256_mask_mm_maskz_expandloadu_epi64__builtin_ia32_expandloaddi128_maskz_mm_mask_expandloadu_epi64__builtin_ia32_expandloaddi128_mask_mm_maskz_expand_epi64__builtin_ia32_expanddi128_maskz_mm_mask_expand_epi64__builtin_ia32_expanddi128_mask_mm256_maskz_expandloadu_epi64__builtin_ia32_expandloaddi256_maskz_mm256_mask_expandloadu_epi64__builtin_ia32_expandloaddi256_mask_mm256_maskz_expand_epi64__builtin_ia32_expanddi256_maskz_mm256_mask_expand_epi64__builtin_ia32_expanddi256_mask_mm_maskz_expandloadu_ps__builtin_ia32_expandloadsf128_maskz_mm_mask_expandloadu_ps__builtin_ia32_expandloadsf128_mask_mm_maskz_expand_ps__builtin_ia32_expandsf128_maskz_mm_mask_expand_ps__builtin_ia32_expandsf128_mask_mm256_maskz_expandloadu_ps__builtin_ia32_expandloadsf256_maskz_mm256_mask_expandloadu_ps__builtin_ia32_expandloadsf256_mask_mm256_maskz_expand_ps__builtin_ia32_expandsf256_maskz_mm256_mask_expand_ps__builtin_ia32_expandsf256_mask_mm_maskz_expandloadu_pd__builtin_ia32_expandloaddf128_maskz_mm_mask_expandloadu_pd__builtin_ia32_expandloaddf128_mask_mm_maskz_expand_pd__builtin_ia32_expanddf128_maskz_mm_mask_expand_pd__builtin_ia32_expanddf128_mask_mm256_maskz_expandloadu_pd__builtin_ia32_expandloaddf256_maskz_mm256_mask_expandloadu_pd__builtin_ia32_expandloaddf256_mask_mm256_maskz_expand_pd__builtin_ia32_expanddf256_maskz_mm256_mask_expand_pd__builtin_ia32_expanddf256_mask_mm_mask_compressstoreu_epi32__builtin_ia32_compressstoresi128_mask_mm_maskz_compress_epi32__builtin_ia32_compresssi128_mask_mm_mask_compress_epi32_mm256_mask_compressstoreu_epi32__builtin_ia32_compressstoresi256_mask_mm256_maskz_compress_epi32__builtin_ia32_compresssi256_mask_mm256_mask_compress_epi32_mm_mask_compressstoreu_epi64__builtin_ia32_compressstoredi128_mask_mm_maskz_compress_epi64__builtin_ia32_compressdi128_mask_mm_mask_compress_epi64_mm256_mask_compressstoreu_epi64__builtin_ia32_compressstoredi256_mask_mm256_maskz_compress_epi64__builtin_ia32_compressdi256_mask_mm256_mask_compress_epi64_mm_mask_compressstoreu_ps__builtin_ia32_compressstoresf128_mask_mm_maskz_compress_ps__builtin_ia32_compresssf128_mask_mm_mask_compress_ps_mm256_mask_compressstoreu_ps__builtin_ia32_compressstoresf256_mask_mm256_maskz_compress_ps__builtin_ia32_compresssf256_mask_mm256_mask_compress_ps_mm_mask_compressstoreu_pd__builtin_ia32_compressstoredf128_mask_mm_maskz_compress_pd__builtin_ia32_compressdf128_mask_mm_mask_compress_pd_mm256_mask_compressstoreu_pd__builtin_ia32_compressstoredf256_mask_mm256_maskz_compress_pd__builtin_ia32_compressdf256_mask_mm256_mask_compress_pd_mm256_mask_testn_epi64_mask__builtin_ia32_ptestnmq256_mm256_testn_epi64_mask_mm_mask_testn_epi64_mask__builtin_ia32_ptestnmq128_mm_testn_epi64_mask_mm256_mask_testn_epi32_mask__builtin_ia32_ptestnmd256_mm256_testn_epi32_mask_mm_mask_testn_epi32_mask__builtin_ia32_ptestnmd128_mm_testn_epi32_mask_mm256_mask_test_epi64_mask__builtin_ia32_ptestmq256_mm256_test_epi64_mask_mm_mask_test_epi64_mask__builtin_ia32_ptestmq128_mm_test_epi64_mask_mm256_mask_test_epi32_mask__builtin_ia32_ptestmd256_mm256_test_epi32_mask_mm_mask_test_epi32_mask__builtin_ia32_ptestmd128_mm_test_epi32_mask_mm256_mask_cmpgt_epi64_mask__builtin_ia32_pcmpgtq256_mask_mm256_mask_cmpgt_epu64_mask_mm256_cmpgt_epi64_mask_mm256_cmpgt_epu64_mask_mm_mask_cmpgt_epi64_mask__builtin_ia32_pcmpgtq128_mask_mm_mask_cmpgt_epu64_mask_mm_cmpgt_epi64_mask_mm_cmpgt_epu64_mask_mm256_mask_cmpgt_epi32_mask__builtin_ia32_pcmpgtd256_mask_mm256_mask_cmpgt_epu32_mask_mm256_cmpgt_epi32_mask_mm256_cmpgt_epu32_mask_mm_mask_cmpgt_epi32_mask__builtin_ia32_pcmpgtd128_mask_mm_mask_cmpgt_epu32_mask_mm_cmpgt_epi32_mask_mm_cmpgt_epu32_mask_mm256_mask_cmpeq_epi64_mask__builtin_ia32_pcmpeqq256_mask_mm256_mask_cmpeq_epu64_mask_mm256_cmpeq_epi64_mask_mm256_cmpeq_epu64_mask_mm_mask_cmpeq_epi64_mask__builtin_ia32_pcmpeqq128_mask_mm_mask_cmpeq_epu64_mask_mm_cmpeq_epi64_mask_mm_cmpeq_epu64_mask_mm256_mask_cmpeq_epi32_mask__builtin_ia32_pcmpeqd256_mask_mm256_mask_cmpeq_epu32_mask_mm256_cmpeq_epi32_mask_mm256_cmpeq_epu32_mask_mm_mask_cmpeq_epi32_mask__builtin_ia32_pcmpeqd128_mask_mm_mask_cmpeq_epu32_mask_mm_cmpeq_epi32_mask_mm_cmpeq_epu32_mask_mm256_maskz_unpacklo_epi64__builtin_ia32_punpcklqdq256_mask_mm256_mask_unpacklo_epi64_mm_maskz_unpacklo_epi64__builtin_ia32_punpcklqdq128_mask_mm_mask_unpacklo_epi64_mm256_maskz_unpacklo_epi32__builtin_ia32_punpckldq256_mask_mm256_mask_unpacklo_epi32_mm_maskz_unpacklo_epi32__builtin_ia32_punpckldq128_mask_mm_mask_unpacklo_epi32_mm256_maskz_unpackhi_epi64__builtin_ia32_punpckhqdq256_mask_mm256_mask_unpackhi_epi64_mm_maskz_unpackhi_epi64__builtin_ia32_punpckhqdq128_mask_mm_mask_unpackhi_epi64_mm256_maskz_unpackhi_epi32__builtin_ia32_punpckhdq256_mask_mm256_mask_unpackhi_epi32_mm_maskz_unpackhi_epi32__builtin_ia32_punpckhdq128_mask_mm_mask_unpackhi_epi32_mm_maskz_moveldup_ps__builtin_ia32_movsldup128_mask_mm_mask_moveldup_ps_mm256_maskz_moveldup_ps__builtin_ia32_movsldup256_mask_mm256_mask_moveldup_ps_mm_maskz_movehdup_ps__builtin_ia32_movshdup128_mask_mm_mask_movehdup_ps_mm256_maskz_movehdup_ps__builtin_ia32_movshdup256_mask_mm256_mask_movehdup_ps_mm_maskz_movedup_pd__builtin_ia32_movddup128_mask_mm_mask_movedup_pd_mm256_maskz_movedup_pd__builtin_ia32_movddup256_mask_mm256_mask_movedup_pd_mm_maskz_cvtps_epu32__builtin_ia32_cvtps2udq128_mask_mm_mask_cvtps_epu32_mm_cvtps_epu32_mm256_maskz_cvtps_epu32__builtin_ia32_cvtps2udq256_mask_mm256_mask_cvtps_epu32_mm256_cvtps_epu32_mm_maskz_cvtps_epi32__builtin_ia32_cvtps2dq128_mask_mm_mask_cvtps_epi32_mm256_maskz_cvtps_epi32__builtin_ia32_cvtps2dq256_mask_mm256_mask_cvtps_epi32_mm256_maskz_cvtpd_ps__builtin_ia32_cvtpd2ps256_mask_mm256_mask_cvtpd_ps_mm_maskz_cvtpd_ps__builtin_ia32_cvtpd2ps_mask_mm_mask_cvtpd_ps_mm_xor_epi32_mm_maskz_xor_epi32__builtin_ia32_pxord128_mask_mm_mask_xor_epi32_mm256_xor_epi32_mm256_maskz_xor_epi32__builtin_ia32_pxord256_mask_mm256_mask_xor_epi32_mm_or_epi32_mm_maskz_or_epi32__builtin_ia32_pord128_mask_mm_mask_or_epi32_mm256_or_epi32_mm256_maskz_or_epi32__builtin_ia32_pord256_mask_mm256_mask_or_epi32_mm_maskz_andnot_epi32__builtin_ia32_pandnd128_mask_mm_mask_andnot_epi32_mm256_maskz_andnot_epi32__builtin_ia32_pandnd256_mask_mm256_mask_andnot_epi32_mm_maskz_and_epi32__builtin_ia32_pandd128_mask_mm_mask_and_epi32_mm_maskz_fnmsub_ps__builtin_ia32_vfnmsubps128_maskz_mm_mask3_fnmsub_ps__builtin_ia32_vfnmsubps128_mask3_mm_mask_fnmsub_ps__builtin_ia32_vfnmsubps128_mask_mm256_maskz_fnmsub_ps__builtin_ia32_vfnmsubps256_maskz_mm256_mask3_fnmsub_ps__builtin_ia32_vfnmsubps256_mask3_mm256_mask_fnmsub_ps__builtin_ia32_vfnmsubps256_mask_mm_maskz_fnmsub_pd__builtin_ia32_vfnmsubpd128_maskz_mm_mask3_fnmsub_pd__builtin_ia32_vfnmsubpd128_mask3_mm_mask_fnmsub_pd__builtin_ia32_vfnmsubpd128_mask_mm256_maskz_fnmsub_pd__builtin_ia32_vfnmsubpd256_maskz_mm256_mask3_fnmsub_pd__builtin_ia32_vfnmsubpd256_mask3_mm256_mask_fnmsub_pd__builtin_ia32_vfnmsubpd256_mask_mm_maskz_fnmadd_ps__builtin_ia32_vfnmaddps128_maskz_mm_mask3_fnmadd_ps__builtin_ia32_vfnmaddps128_mask3_mm_mask_fnmadd_ps__builtin_ia32_vfnmaddps128_mask_mm256_maskz_fnmadd_ps__builtin_ia32_vfnmaddps256_maskz_mm256_mask3_fnmadd_ps__builtin_ia32_vfnmaddps256_mask3_mm256_mask_fnmadd_ps__builtin_ia32_vfnmaddps256_mask_mm_maskz_fnmadd_pd__builtin_ia32_vfnmaddpd128_maskz_mm_mask3_fnmadd_pd__builtin_ia32_vfnmaddpd128_mask3_mm_mask_fnmadd_pd__builtin_ia32_vfnmaddpd128_mask_mm256_maskz_fnmadd_pd__builtin_ia32_vfnmaddpd256_maskz_mm256_mask3_fnmadd_pd__builtin_ia32_vfnmaddpd256_mask3_mm256_mask_fnmadd_pd__builtin_ia32_vfnmaddpd256_mask_mm_maskz_fmsubadd_ps__builtin_ia32_vfmaddsubps128_maskz_mm_mask3_fmsubadd_ps__builtin_ia32_vfmsubaddps128_mask3_mm_mask_fmsubadd_ps__builtin_ia32_vfmaddsubps128_mask_mm256_maskz_fmsubadd_ps__builtin_ia32_vfmaddsubps256_maskz_mm256_mask3_fmsubadd_ps__builtin_ia32_vfmsubaddps256_mask3_mm256_mask_fmsubadd_ps__builtin_ia32_vfmaddsubps256_mask_mm_maskz_fmsubadd_pd__builtin_ia32_vfmaddsubpd128_maskz_mm_mask3_fmsubadd_pd__builtin_ia32_vfmsubaddpd128_mask3_mm_mask_fmsubadd_pd__builtin_ia32_vfmaddsubpd128_mask_mm256_maskz_fmsubadd_pd__builtin_ia32_vfmaddsubpd256_maskz_mm256_mask3_fmsubadd_pd__builtin_ia32_vfmsubaddpd256_mask3_mm256_mask_fmsubadd_pd__builtin_ia32_vfmaddsubpd256_mask_mm_maskz_fmaddsub_ps_mm_mask3_fmaddsub_ps__builtin_ia32_vfmaddsubps128_mask3_mm_mask_fmaddsub_ps_mm256_maskz_fmaddsub_ps_mm256_mask3_fmaddsub_ps__builtin_ia32_vfmaddsubps256_mask3_mm256_mask_fmaddsub_ps_mm_maskz_fmaddsub_pd_mm_mask3_fmaddsub_pd__builtin_ia32_vfmaddsubpd128_mask3_mm_mask_fmaddsub_pd_mm256_maskz_fmaddsub_pd_mm256_mask3_fmaddsub_pd__builtin_ia32_vfmaddsubpd256_mask3_mm256_mask_fmaddsub_pd_mm_maskz_fmsub_ps__builtin_ia32_vfmsubps128_maskz_mm_mask3_fmsub_ps__builtin_ia32_vfmsubps128_mask3_mm_mask_fmsub_ps__builtin_ia32_vfmsubps128_mask_mm256_maskz_fmsub_ps__builtin_ia32_vfmsubps256_maskz_mm256_mask3_fmsub_ps__builtin_ia32_vfmsubps256_mask3_mm256_mask_fmsub_ps__builtin_ia32_vfmsubps256_mask_mm_maskz_fmsub_pd__builtin_ia32_vfmsubpd128_maskz_mm_mask3_fmsub_pd__builtin_ia32_vfmsubpd128_mask3_mm_mask_fmsub_pd__builtin_ia32_vfmsubpd128_mask_mm256_maskz_fmsub_pd__builtin_ia32_vfmsubpd256_maskz_mm256_mask3_fmsub_pd__builtin_ia32_vfmsubpd256_mask3_mm256_mask_fmsub_pd__builtin_ia32_vfmsubpd256_mask_mm_maskz_fmadd_ps__builtin_ia32_vfmaddps128_maskz_mm_mask3_fmadd_ps__builtin_ia32_vfmaddps128_mask3_mm_mask_fmadd_ps__builtin_ia32_vfmaddps128_mask_mm256_maskz_fmadd_ps__builtin_ia32_vfmaddps256_maskz_mm256_mask3_fmadd_ps__builtin_ia32_vfmaddps256_mask3_mm256_mask_fmadd_ps__builtin_ia32_vfmaddps256_mask_mm_maskz_fmadd_pd__builtin_ia32_vfmaddpd128_maskz_mm_mask3_fmadd_pd__builtin_ia32_vfmaddpd128_mask3_mm_mask_fmadd_pd__builtin_ia32_vfmaddpd128_mask_mm256_maskz_fmadd_pd__builtin_ia32_vfmaddpd256_maskz_mm256_mask3_fmadd_pd__builtin_ia32_vfmaddpd256_mask3_mm256_mask_fmadd_pd__builtin_ia32_vfmaddpd256_mask_mm_maskz_scalef_ps__builtin_ia32_scalefps128_mask_mm_mask_scalef_ps_mm_scalef_ps_mm_maskz_scalef_pd__builtin_ia32_scalefpd128_mask_mm_mask_scalef_pd_mm_scalef_pd_mm256_maskz_scalef_ps__builtin_ia32_scalefps256_mask_mm256_mask_scalef_ps_mm256_scalef_ps_mm256_maskz_scalef_pd__builtin_ia32_scalefpd256_mask_mm256_mask_scalef_pd_mm256_scalef_pd_mm256_maskz_and_epi32__builtin_ia32_pandd256_mask_mm256_mask_and_epi32_mm_maskz_srl_epi64__builtin_ia32_psrlq128_mask_mm_mask_srl_epi64_mm256_maskz_srl_epi64__builtin_ia32_psrlq256_mask_mm256_mask_srl_epi64_mm_maskz_srl_epi32__builtin_ia32_psrld128_mask_mm_mask_srl_epi32_mm256_maskz_srl_epi32__builtin_ia32_psrld256_mask_mm256_mask_srl_epi32_mm_maskz_getexp_pd__builtin_ia32_getexppd128_mask_mm_mask_getexp_pd_mm_getexp_pd_mm_maskz_getexp_ps__builtin_ia32_getexpps128_mask_mm_mask_getexp_ps_mm_getexp_ps_mm256_maskz_getexp_pd__builtin_ia32_getexppd256_mask_mm256_mask_getexp_pd_mm256_getexp_pd_mm256_maskz_getexp_ps__builtin_ia32_getexpps256_mask_mm256_mask_getexp_ps_mm256_getexp_ps_mm_maskz_sub_epi64__builtin_ia32_psubq128_mask_mm_mask_sub_epi64_mm_maskz_sub_epi32__builtin_ia32_psubd128_mask_mm_mask_sub_epi32_mm_maskz_add_epi64__builtin_ia32_paddq128_mask_mm_mask_add_epi64_mm_maskz_add_epi32__builtin_ia32_paddd128_mask_mm_mask_add_epi32_mm256_maskz_sub_epi64__builtin_ia32_psubq256_mask_mm256_mask_sub_epi64_mm256_maskz_sub_epi32__builtin_ia32_psubd256_mask_mm256_mask_sub_epi32_mm256_maskz_add_epi64__builtin_ia32_paddq256_mask_mm256_mask_add_epi64_mm256_maskz_add_epi32__builtin_ia32_paddd256_mask_mm256_mask_add_epi32_mm_maskz_sqrt_ps__builtin_ia32_sqrtps128_mask_mm_mask_sqrt_ps_mm256_maskz_sqrt_ps__builtin_ia32_sqrtps256_mask_mm256_mask_sqrt_ps_mm_maskz_sqrt_pd__builtin_ia32_sqrtpd128_mask_mm_mask_sqrt_pd_mm256_maskz_sqrt_pd__builtin_ia32_sqrtpd256_mask_mm256_mask_sqrt_pd_mm_maskz_rsqrt14_ps__builtin_ia32_rsqrt14ps128_mask_mm_mask_rsqrt14_ps_mm_rsqrt14_ps_mm256_maskz_rsqrt14_ps__builtin_ia32_rsqrt14ps256_mask_mm256_mask_rsqrt14_ps_mm256_rsqrt14_ps_mm_maskz_rsqrt14_pd__builtin_ia32_rsqrt14pd128_mask_mm_mask_rsqrt14_pd_mm_rsqrt14_pd_mm256_maskz_rsqrt14_pd__builtin_ia32_rsqrt14pd256_mask_mm256_mask_rsqrt14_pd_mm256_rsqrt14_pd_mm_maskz_rcp14_ps__builtin_ia32_rcp14ps128_mask_mm_mask_rcp14_ps_mm_rcp14_ps_mm256_maskz_rcp14_ps__builtin_ia32_rcp14ps256_mask_mm256_mask_rcp14_ps_mm256_rcp14_ps_mm_maskz_rcp14_pd__builtin_ia32_rcp14pd128_mask_mm_mask_rcp14_pd_mm_rcp14_pd_mm256_maskz_rcp14_pd__builtin_ia32_rcp14pd256_mask_mm256_mask_rcp14_pd_mm256_rcp14_pd_mm_maskz_cvtepu32_epi64__builtin_ia32_pmovzxdq128_mask_mm_mask_cvtepu32_epi64_mm256_maskz_cvtepu32_epi64__builtin_ia32_pmovzxdq256_mask_mm256_mask_cvtepu32_epi64_mm_maskz_cvtepu16_epi64__builtin_ia32_pmovzxwq128_mask_mm_mask_cvtepu16_epi64_mm256_maskz_cvtepu16_epi64__builtin_ia32_pmovzxwq256_mask_mm256_mask_cvtepu16_epi64_mm_maskz_cvtepu16_epi32__builtin_ia32_pmovzxwd128_mask_mm_mask_cvtepu16_epi32_mm256_maskz_cvtepu16_epi32__builtin_ia32_pmovzxwd256_mask_mm256_mask_cvtepu16_epi32_mm_maskz_cvtepu8_epi64__builtin_ia32_pmovzxbq128_mask_mm_mask_cvtepu8_epi64_mm256_maskz_cvtepu8_epi64__builtin_ia32_pmovzxbq256_mask_mm256_mask_cvtepu8_epi64_mm_maskz_cvtepu8_epi32__builtin_ia32_pmovzxbd128_mask_mm_mask_cvtepu8_epi32_mm256_maskz_cvtepu8_epi32__builtin_ia32_pmovzxbd256_mask_mm256_mask_cvtepu8_epi32_mm_maskz_cvtepi32_epi64__builtin_ia32_pmovsxdq128_mask_mm_mask_cvtepi32_epi64_mm256_maskz_cvtepi32_epi64__builtin_ia32_pmovsxdq256_mask_mm256_mask_cvtepi32_epi64_mm_maskz_cvtepi16_epi64__builtin_ia32_pmovsxwq128_mask_mm_mask_cvtepi16_epi64_mm256_maskz_cvtepi16_epi64__builtin_ia32_pmovsxwq256_mask_mm256_mask_cvtepi16_epi64_mm_maskz_cvtepi16_epi32__builtin_ia32_pmovsxwd128_mask_mm_mask_cvtepi16_epi32_mm256_maskz_cvtepi16_epi32__builtin_ia32_pmovsxwd256_mask_mm256_mask_cvtepi16_epi32_mm_maskz_cvtepi8_epi64__builtin_ia32_pmovsxbq128_mask_mm_mask_cvtepi8_epi64_mm256_maskz_cvtepi8_epi64__builtin_ia32_pmovsxbq256_mask_mm256_mask_cvtepi8_epi64_mm_maskz_cvtepi8_epi32__builtin_ia32_pmovsxbd128_mask_mm_mask_cvtepi8_epi32_mm256_maskz_cvtepi8_epi32__builtin_ia32_pmovsxbd256_mask_mm256_mask_cvtepi8_epi32_mm256_maskz_broadcast_i32x4__builtin_ia32_broadcasti32x4_256_mask_mm256_mask_broadcast_i32x4_mm256_broadcast_i32x4_mm256_maskz_broadcast_f32x4__builtin_ia32_broadcastf32x4_256_mask_mm256_mask_broadcast_f32x4_mm256_broadcast_f32x4_mm_maskz_set1_epi64__builtin_ia32_pbroadcastq128_gpr_mask_mm_mask_set1_epi64_mm_maskz_broadcastq_epi64__builtin_ia32_pbroadcastq128_mask_mm_mask_broadcastq_epi64_mm256_maskz_set1_epi64__builtin_ia32_pbroadcastq256_gpr_mask_mm256_mask_set1_epi64_mm256_maskz_broadcastq_epi64__builtin_ia32_pbroadcastq256_mask_mm256_mask_broadcastq_epi64_mm_maskz_set1_epi32__builtin_ia32_pbroadcastd128_gpr_mask_mm_mask_set1_epi32_mm_maskz_broadcastd_epi32__builtin_ia32_pbroadcastd128_mask_mm_mask_broadcastd_epi32_mm256_maskz_set1_epi32__builtin_ia32_pbroadcastd256_gpr_mask_mm256_mask_set1_epi32_mm256_maskz_broadcastd_epi32__builtin_ia32_pbroadcastd256_mask_mm256_mask_broadcastd_epi32_mm256_maskz_broadcastsd_pd__builtin_ia32_broadcastsd256_mask_mm256_mask_broadcastsd_pd_mm_maskz_broadcastss_ps__builtin_ia32_broadcastss128_mask_mm_mask_broadcastss_ps_mm256_maskz_broadcastss_ps__builtin_ia32_broadcastss256_mask_mm256_mask_broadcastss_ps_mm256_maskz_cvtusepi64_epi32__builtin_ia32_pmovusqd256_mask_mm256_mask_cvtusepi64_epi32_mm256_mask_cvtusepi64_storeu_epi32__builtin_ia32_pmovusqd256mem_mask_mm256_cvtusepi64_epi32_mm_maskz_cvtusepi64_epi32__builtin_ia32_pmovusqd128_mask_mm_mask_cvtusepi64_epi32_mm_mask_cvtusepi64_storeu_epi32__builtin_ia32_pmovusqd128mem_mask_mm_cvtusepi64_epi32_mm256_maskz_cvtsepi64_epi32__builtin_ia32_pmovsqd256_mask_mm256_mask_cvtsepi64_epi32_mm256_mask_cvtsepi64_storeu_epi32__builtin_ia32_pmovsqd256mem_mask_mm256_cvtsepi64_epi32_mm_maskz_cvtsepi64_epi32__builtin_ia32_pmovsqd128_mask_mm_mask_cvtsepi64_epi32_mm_mask_cvtsepi64_storeu_epi32__builtin_ia32_pmovsqd128mem_mask_mm_cvtsepi64_epi32_mm256_maskz_cvtepi64_epi32__builtin_ia32_pmovqd256_mask_mm256_mask_cvtepi64_epi32_mm256_mask_cvtepi64_storeu_epi32__builtin_ia32_pmovqd256mem_mask_mm256_cvtepi64_epi32_mm_maskz_cvtepi64_epi32__builtin_ia32_pmovqd128_mask_mm_mask_cvtepi64_epi32_mm_mask_cvtepi64_storeu_epi32__builtin_ia32_pmovqd128mem_mask_mm_cvtepi64_epi32_mm256_maskz_cvtusepi64_epi16__builtin_ia32_pmovusqw256_mask_mm256_mask_cvtusepi64_epi16_mm256_mask_cvtusepi64_storeu_epi16__builtin_ia32_pmovusqw256mem_mask_mm256_cvtusepi64_epi16_mm_maskz_cvtusepi64_epi16__builtin_ia32_pmovusqw128_mask_mm_mask_cvtusepi64_epi16_mm_mask_cvtusepi64_storeu_epi16__builtin_ia32_pmovusqw128mem_mask_mm_cvtusepi64_epi16_mm256_maskz_cvtsepi64_epi16__builtin_ia32_pmovsqw256_mask_mm256_mask_cvtsepi64_epi16_mm256_mask_cvtsepi64_storeu_epi16__builtin_ia32_pmovsqw256mem_mask_mm256_cvtsepi64_epi16_mm_maskz_cvtsepi64_epi16__builtin_ia32_pmovsqw128_mask_mm_mask_cvtsepi64_epi16_mm_mask_cvtsepi64_storeu_epi16__builtin_ia32_pmovsqw128mem_mask_mm_cvtsepi64_epi16_mm256_maskz_cvtepi64_epi16__builtin_ia32_pmovqw256_mask_mm256_mask_cvtepi64_epi16_mm256_mask_cvtepi64_storeu_epi16__builtin_ia32_pmovqw256mem_mask_mm256_cvtepi64_epi16_mm_maskz_cvtepi64_epi16__builtin_ia32_pmovqw128_mask_mm_mask_cvtepi64_epi16_mm_mask_cvtepi64_storeu_epi16__builtin_ia32_pmovqw128mem_mask_mm_cvtepi64_epi16_mm256_maskz_cvtusepi64_epi8__builtin_ia32_pmovusqb256_mask_mm256_mask_cvtusepi64_epi8_mm256_mask_cvtusepi64_storeu_epi8__builtin_ia32_pmovusqb256mem_mask_mm256_cvtusepi64_epi8_mm_maskz_cvtusepi64_epi8__builtin_ia32_pmovusqb128_mask_mm_mask_cvtusepi64_epi8_mm_mask_cvtusepi64_storeu_epi8__builtin_ia32_pmovusqb128mem_mask_mm_cvtusepi64_epi8_mm256_maskz_cvtsepi64_epi8__builtin_ia32_pmovsqb256_mask_mm256_mask_cvtsepi64_epi8_mm256_mask_cvtsepi64_storeu_epi8__builtin_ia32_pmovsqb256mem_mask_mm256_cvtsepi64_epi8_mm_maskz_cvtsepi64_epi8__builtin_ia32_pmovsqb128_mask_mm_mask_cvtsepi64_epi8_mm_mask_cvtsepi64_storeu_epi8__builtin_ia32_pmovsqb128mem_mask_mm_cvtsepi64_epi8_mm256_maskz_cvtepi64_epi8__builtin_ia32_pmovqb256_mask_mm256_mask_cvtepi64_epi8_mm256_mask_cvtepi64_storeu_epi8__builtin_ia32_pmovqb256mem_mask_mm256_cvtepi64_epi8_mm_maskz_cvtepi64_epi8__builtin_ia32_pmovqb128_mask_mm_mask_cvtepi64_epi8_mm_mask_cvtepi64_storeu_epi8__builtin_ia32_pmovqb128mem_mask_mm_cvtepi64_epi8_mm256_maskz_cvtusepi32_epi16__builtin_ia32_pmovusdw256_mask_mm256_mask_cvtusepi32_epi16_mm256_mask_cvtusepi32_storeu_epi16__builtin_ia32_pmovusdw256mem_mask_mm256_cvtusepi32_epi16_mm_maskz_cvtusepi32_epi16__builtin_ia32_pmovusdw128_mask_mm_mask_cvtusepi32_epi16_mm_mask_cvtusepi32_storeu_epi16__builtin_ia32_pmovusdw128mem_mask_mm_cvtusepi32_epi16_mm256_maskz_cvtsepi32_epi16__builtin_ia32_pmovsdw256_mask_mm256_mask_cvtsepi32_epi16_mm256_mask_cvtsepi32_storeu_epi16__builtin_ia32_pmovsdw256mem_mask_mm256_cvtsepi32_epi16_mm_maskz_cvtsepi32_epi16__builtin_ia32_pmovsdw128_mask_mm_mask_cvtsepi32_epi16_mm_mask_cvtsepi32_storeu_epi16__builtin_ia32_pmovsdw128mem_mask_mm_cvtsepi32_epi16_mm256_maskz_cvtepi32_epi16__builtin_ia32_pmovdw256_mask_mm256_mask_cvtepi32_epi16_mm256_mask_cvtepi32_storeu_epi16__builtin_ia32_pmovdw256mem_mask_mm256_cvtepi32_epi16_mm_maskz_cvtepi32_epi16__builtin_ia32_pmovdw128_mask_mm_mask_cvtepi32_epi16_mm_mask_cvtepi32_storeu_epi16__builtin_ia32_pmovdw128mem_mask_mm_cvtepi32_epi16_mm256_maskz_cvtusepi32_epi8__builtin_ia32_pmovusdb256_mask_mm256_mask_cvtusepi32_epi8_mm256_mask_cvtusepi32_storeu_epi8__builtin_ia32_pmovusdb256mem_mask_mm256_cvtusepi32_epi8_mm_maskz_cvtusepi32_epi8__builtin_ia32_pmovusdb128_mask_mm_mask_cvtusepi32_epi8_mm_mask_cvtusepi32_storeu_epi8__builtin_ia32_pmovusdb128mem_mask_mm_cvtusepi32_epi8_mm256_maskz_cvtsepi32_epi8__builtin_ia32_pmovsdb256_mask_mm256_mask_cvtsepi32_epi8_mm256_mask_cvtsepi32_storeu_epi8__builtin_ia32_pmovsdb256mem_mask_mm256_cvtsepi32_epi8_mm_maskz_cvtsepi32_epi8__builtin_ia32_pmovsdb128_mask_mm_mask_cvtsepi32_epi8_mm_mask_cvtsepi32_storeu_epi8__builtin_ia32_pmovsdb128mem_mask_mm_cvtsepi32_epi8_mm256_maskz_cvtepi32_epi8__builtin_ia32_pmovdb256_mask_mm256_mask_cvtepi32_storeu_epi8__builtin_ia32_pmovdb256mem_mask_mm256_mask_cvtepi32_epi8_mm256_cvtepi32_epi8_mm_maskz_cvtepi32_epi8__builtin_ia32_pmovdb128_mask_mm_mask_cvtepi32_epi8_mm_mask_cvtepi32_storeu_epi8__builtin_ia32_pmovdb128mem_mask_mm_cvtepi32_epi8_mm_maskz_cvtps_pd__builtin_ia32_cvtps2pd128_mask_mm_mask_cvtps_pd_mm256_maskz_cvtps_pd__builtin_ia32_cvtps2pd256_mask_mm256_mask_cvtps_pd_mm_maskz_cvtepu32_ps__builtin_ia32_cvtudq2ps128_mask_mm_mask_cvtepu32_ps_mm_cvtepu32_ps_mm256_maskz_cvtepu32_ps__builtin_ia32_cvtudq2ps256_mask_mm256_mask_cvtepu32_ps_mm256_cvtepu32_ps_mm_maskz_cvtepi32_ps__builtin_ia32_cvtdq2ps128_mask_mm_mask_cvtepi32_ps_mm256_maskz_cvtepi32_ps__builtin_ia32_cvtdq2ps256_mask_mm256_mask_cvtepi32_ps_mm_maskz_cvtepu32_pd__builtin_ia32_cvtudq2pd128_mask_mm_mask_cvtepu32_pd_mm_cvtepu32_pd_mm256_maskz_cvtepu32_pd__builtin_ia32_cvtudq2pd256_mask_mm256_mask_cvtepu32_pd_mm256_cvtepu32_pd_mm_maskz_cvtepi32_pd__builtin_ia32_cvtdq2pd128_mask_mm_mask_cvtepi32_pd_mm256_maskz_cvtepi32_pd__builtin_ia32_cvtdq2pd256_mask_mm256_mask_cvtepi32_pd_mm_maskz_cvtpd_epi32__builtin_ia32_cvtpd2dq128_mask_mm_mask_cvtpd_epi32_mm256_maskz_cvtpd_epi32__builtin_ia32_cvtpd2dq256_mask_mm256_mask_cvtpd_epi32_mm_maskz_cvttpd_epu32__builtin_ia32_cvttpd2udq128_mask_mm_mask_cvttpd_epu32_mm_cvttpd_epu32_mm256_maskz_cvttpd_epu32__builtin_ia32_cvttpd2udq256_mask_mm256_mask_cvttpd_epu32_mm256_cvttpd_epu32_mm_maskz_cvttpd_epi32__builtin_ia32_cvttpd2dq128_mask_mm_mask_cvttpd_epi32_mm256_maskz_cvttpd_epi32__builtin_ia32_cvttpd2dq256_mask_mm256_mask_cvttpd_epi32_mm_maskz_cvttps_epu32__builtin_ia32_cvttps2udq128_mask_mm_mask_cvttps_epu32_mm_cvttps_epu32_mm256_maskz_cvttps_epu32__builtin_ia32_cvttps2udq256_mask_mm256_mask_cvttps_epu32_mm256_cvttps_epu32_mm_maskz_cvttps_epi32__builtin_ia32_cvttps2dq128_mask_mm_mask_cvttps_epi32_mm256_maskz_cvttps_epi32__builtin_ia32_cvttps2dq256_mask_mm256_mask_cvttps_epi32_mm_maskz_cvtpd_epu32__builtin_ia32_cvtpd2udq128_mask_mm_mask_cvtpd_epu32_mm_cvtpd_epu32_mm256_maskz_cvtpd_epu32__builtin_ia32_cvtpd2udq256_mask_mm256_mask_cvtpd_epu32_mm256_cvtpd_epu32_mm_maskz_abs_epi64__builtin_ia32_pabsq128_mask_mm_mask_abs_epi64_mm_abs_epi64_mm256_maskz_abs_epi64__builtin_ia32_pabsq256_mask_mm256_mask_abs_epi64_mm256_abs_epi64_mm_maskz_abs_epi32__builtin_ia32_pabsd128_mask_mm_mask_abs_epi32_mm256_maskz_abs_epi32__builtin_ia32_pabsd256_mask_mm256_mask_abs_epi32_mm_mask_storeu_epi32__builtin_ia32_storedqusi128_mask_mm_storeu_epi32_mm256_mask_storeu_epi32__builtin_ia32_storedqusi256_mask_mm256_storeu_epi32_mm_maskz_loadu_epi32__builtin_ia32_loaddqusi128_mask_mm_mask_loadu_epi32_mm_loadu_epi32__v4si_u *_mm256_maskz_loadu_epi32__builtin_ia32_loaddqusi256_mask_mm256_mask_loadu_epi32_mm256_loadu_epi32__v8si_u *_mm_mask_storeu_epi64__builtin_ia32_storedqudi128_mask_mm_storeu_epi64_mm256_mask_storeu_epi64__builtin_ia32_storedqudi256_mask_mm256_storeu_epi64_mm_maskz_loadu_epi64__builtin_ia32_loaddqudi128_mask_mm_mask_loadu_epi64_mm_loadu_epi64__v2di_u *_mm256_maskz_loadu_epi64__builtin_ia32_loaddqudi256_mask_mm256_mask_loadu_epi64_mm256_loadu_epi64__v4di_u *_mm_mask_storeu_ps__builtin_ia32_storeups128_mask_mm256_mask_storeu_ps__builtin_ia32_storeups256_mask_mm_maskz_loadu_ps__builtin_ia32_loadups128_mask_mm_mask_loadu_ps_mm256_maskz_loadu_ps__builtin_ia32_loadups256_mask_mm256_mask_loadu_ps_mm_mask_storeu_pd__builtin_ia32_storeupd128_mask_mm256_mask_storeu_pd__builtin_ia32_storeupd256_mask_mm_maskz_loadu_pd__builtin_ia32_loadupd128_mask_mm_mask_loadu_pd_mm256_maskz_loadu_pd__builtin_ia32_loadupd256_mask_mm256_mask_loadu_pd_mm_store_epi64_mm256_store_epi64_mm256_maskz_sub_ps__builtin_ia32_subps256_mask_mm256_mask_sub_ps_mm_maskz_sub_ps__builtin_ia32_subps128_mask_mm_mask_sub_ps_mm256_maskz_sub_pd__builtin_ia32_subpd256_mask_mm256_mask_sub_pd_mm_maskz_sub_pd__builtin_ia32_subpd128_mask_mm_mask_sub_pd_mm256_maskz_add_ps__builtin_ia32_addps256_mask_mm256_mask_add_ps_mm_maskz_add_ps__builtin_ia32_addps128_mask_mm_mask_add_ps_mm256_maskz_add_pd__builtin_ia32_addpd256_mask_mm256_mask_add_pd_mm_maskz_add_pd__builtin_ia32_addpd128_mask_mm_mask_add_pd_mm_mask_store_epi32__builtin_ia32_movdqa32store128_mask_mm_store_epi32_mm256_mask_store_epi32__builtin_ia32_movdqa32store256_mask_mm256_store_epi32_mm_maskz_load_epi32__builtin_ia32_movdqa32load128_mask_mm_mask_load_epi32_mm_load_epi32_mm256_maskz_load_epi32__builtin_ia32_movdqa32load256_mask_mm256_mask_load_epi32_mm256_load_epi32_mm_maskz_mov_epi32__builtin_ia32_movdqa32_128_mask_mm_mask_mov_epi32_mm256_maskz_mov_epi32__builtin_ia32_movdqa32_256_mask_mm256_mask_mov_epi32_mm_mask_store_epi64__builtin_ia32_movdqa64store128_mask_mm256_mask_store_epi64__builtin_ia32_movdqa64store256_mask_mm_maskz_load_epi64__builtin_ia32_movdqa64load128_mask_mm_mask_load_epi64_mm_load_epi64_mm256_maskz_load_epi64__builtin_ia32_movdqa64load256_mask_mm256_mask_load_epi64_mm256_load_epi64_mm_maskz_mov_epi64__builtin_ia32_movdqa64_128_mask_mm_mask_mov_epi64_mm256_maskz_mov_epi64__builtin_ia32_movdqa64_256_mask_mm256_mask_mov_epi64_mm_mask_store_ps__builtin_ia32_storeaps128_mask_mm256_mask_store_ps__builtin_ia32_storeaps256_mask_mm_maskz_load_ps__builtin_ia32_loadaps128_mask_mm_mask_load_ps_mm256_maskz_load_ps__builtin_ia32_loadaps256_mask_mm256_mask_load_ps_mm_maskz_mov_ps__builtin_ia32_movaps128_mask_mm_mask_mov_ps_mm256_maskz_mov_ps__builtin_ia32_movaps256_mask_mm256_mask_mov_ps_mm_mask_store_pd__builtin_ia32_storeapd128_mask_mm256_mask_store_pd__builtin_ia32_storeapd256_mask_mm_maskz_load_pd__builtin_ia32_loadapd128_mask_mm_mask_load_pd_mm256_maskz_load_pd__builtin_ia32_loadapd256_mask_mm256_mask_load_pd_mm_maskz_mov_pd__builtin_ia32_movapd128_mask_mm_mask_mov_pd_mm256_maskz_mov_pd__builtin_ia32_movapd256_mask_mm256_mask_mov_pd__v4di_u__v2di_u__v8si_u__v4si_u__mmask32__DISABLE_AVX512VL___mm_maskz_cvt_roundps_ph(A,B,C)_mm_maskz_cvtps_ph ((A), (B), (C))_mm_mask_cvt_roundps_ph(A,B,C,D)_mm_mask_cvtps_ph ((A), (B), (C), (D))_mm256_maskz_cvt_roundps_ph(A,B,C)_mm256_maskz_cvtps_ph ((A), (B), (C))_mm256_mask_cvt_roundps_ph(A,B,C,D)_mm256_mask_cvtps_ph ((A), (B), (C), (D))_mm256_permutexvar_ps(A,B)_mm256_permutevar8x32_ps ((B), (A))__DISABLE_AVX512VLCD___AVX512VLINTRIN_H_INCLUDED__AVX512VL__GCC target("avx512vl")GCC target("avx512vl,avx512cd")/* _AVX512VLINTRIN_H_INCLUDED *//* __DISABLE_AVX512VL__ *//* __AVX512VL__ */_mm512_bsrli_epi128__builtin_ia32_psrldq512_mm512_bslli_epi128__builtin_ia32_pslldq512_mm512_cmp_epu8_mask__builtin_ia32_ucmpb512_mask18446744073709551615(__mmask64) -1_mm512_mask_cmp_epu8_mask_mm512_cmp_epu16_mask__builtin_ia32_ucmpw512_mask(__mmask32) -1_mm512_mask_cmp_epu16_mask_mm512_cmp_epi8_mask__builtin_ia32_cmpb512_mask_mm512_mask_cmp_epi8_mask_mm512_cmp_epi16_mask__builtin_ia32_cmpw512_mask_mm512_mask_cmp_epi16_mask_mm512_mask_blend_epi8__builtin_ia32_blendmb_512_mask_mm512_mask_blend_epi16__builtin_ia32_blendmw_512_mask_mm512_maskz_srai_epi16__builtin_ia32_psrawi512_mask_mm512_mask_srai_epi16_mm512_srai_epi16_mm512_maskz_shufflelo_epi16__builtin_ia32_pshuflw512_mask_mm512_mask_shufflelo_epi16_mm512_shufflelo_epi16_mm512_maskz_shufflehi_epi16__builtin_ia32_pshufhw512_mask_mm512_mask_shufflehi_epi16_mm512_shufflehi_epi16_mm512_maskz_slli_epi16__builtin_ia32_psllwi512_mask_mm512_mask_slli_epi16_mm512_slli_epi16_mm512_maskz_srli_epi16__builtin_ia32_psrlwi512_mask_mm512_mask_srli_epi16_mm512_srli_epi16_mm512_maskz_dbsad_epu8__builtin_ia32_dbpsadbw512_mask_mm512_mask_dbsad_epu8_mm512_dbsad_epu8_mm512_maskz_alignr_epi8__builtin_ia32_palignr512_mask_mm512_mask_alignr_epi8_mm512_alignr_epi8__builtin_ia32_palignr512_kshiftri_mask64__builtin_ia32_kshiftridi_kshiftri_mask32__builtin_ia32_kshiftrisi_kshiftli_mask64__builtin_ia32_kshiftlidi_kshiftli_mask32__builtin_ia32_kshiftlisi_mm512_mask_packus_epi32__builtin_ia32_packusdw512_mask_mm512_maskz_packus_epi32_mm512_packus_epi32_mm512_mask_packs_epi32__builtin_ia32_packssdw512_mask_mm512_maskz_packs_epi32_mm512_packs_epi32_mm512_cmple_epi16_mask_mm512_cmpge_epi16_mask_mm512_cmplt_epi16_mask_mm512_cmpneq_epi16_mask_mm512_cmple_epi8_mask_mm512_cmpge_epi8_mask_mm512_cmplt_epi8_mask_mm512_cmpneq_epi8_mask_mm512_cmple_epu16_mask_mm512_cmpge_epu16_mask_mm512_cmplt_epu16_mask_mm512_cmpneq_epu16_mask_mm512_cmple_epu8_mask_mm512_cmpge_epu8_mask_mm512_cmplt_epu8_mask_mm512_cmpneq_epu8_mask_mm512_mask_cmple_epi16_mask_mm512_mask_cmpge_epi16_mask_mm512_mask_cmplt_epi16_mask_mm512_mask_cmpneq_epi16_mask_mm512_mask_cmple_epi8_mask_mm512_mask_cmpge_epi8_mask_mm512_mask_cmplt_epi8_mask_mm512_mask_cmpneq_epi8_mask_mm512_mask_cmple_epu16_mask_mm512_mask_cmpge_epu16_mask_mm512_mask_cmplt_epu16_mask_mm512_mask_cmpneq_epu16_mask_mm512_mask_cmple_epu8_mask_mm512_mask_cmpge_epu8_mask_mm512_mask_cmplt_epu8_mask_mm512_mask_cmpneq_epu8_mask_mm512_maskz_abs_epi16__builtin_ia32_pabsw512_mask_mm512_mask_abs_epi16_mm512_abs_epi16_mm512_maskz_abs_epi8__builtin_ia32_pabsb512_mask_mm512_mask_abs_epi8_mm512_abs_epi8_mm512_maskz_packus_epi16__builtin_ia32_packuswb512_mask_mm512_mask_packus_epi16_mm512_packus_epi16_mm512_maskz_packs_epi16__builtin_ia32_packsswb512_mask_mm512_mask_packs_epi16_mm512_maskz_sllv_epi16__builtin_ia32_psllv32hi_mask_mm512_mask_sllv_epi16_mm512_sllv_epi16_mm512_maskz_srlv_epi16__builtin_ia32_psrlv32hi_mask_mm512_mask_srlv_epi16_mm512_srlv_epi16_mm512_maskz_srav_epi16__builtin_ia32_psrav32hi_mask_mm512_mask_srav_epi16_mm512_srav_epi16_mm512_maskz_sra_epi16__builtin_ia32_psraw512_mask_mm512_mask_sra_epi16_mm512_sra_epi16_mm512_mask_max_epu16__builtin_ia32_pmaxuw512_mask_mm512_maskz_max_epu16_mm512_max_epu16_mm512_mask_max_epi16__builtin_ia32_pmaxsw512_mask_mm512_maskz_max_epi16_mm512_max_epi16_mm512_mask_min_epi8__builtin_ia32_pminsb512_mask_mm512_maskz_min_epi8_mm512_min_epi8_mm512_mask_min_epu8__builtin_ia32_pminub512_mask_mm512_maskz_min_epu8_mm512_min_epu8_mm512_mask_max_epi8__builtin_ia32_pmaxsb512_mask_mm512_maskz_max_epi8_mm512_max_epi8_mm512_mask_max_epu8__builtin_ia32_pmaxub512_mask_mm512_maskz_max_epu8_mm512_max_epu8_mm512_mask_min_epi16__builtin_ia32_pminsw512_mask_mm512_maskz_min_epi16_mm512_min_epi16_mm512_mask_min_epu16__builtin_ia32_pminuw512_mask_mm512_maskz_min_epu16_mm512_min_epu16_mm512_maskz_shuffle_epi8__builtin_ia32_pshufb512_mask_mm512_mask_shuffle_epi8_mm512_shuffle_epi8_mm512_mask_testn_epi16_mask__builtin_ia32_ptestnmw512_mm512_testn_epi16_mask_mm512_mask_testn_epi8_mask__builtin_ia32_ptestnmb512_mm512_testn_epi8_mask_mm512_mask_test_epi16_mask__builtin_ia32_ptestmw512_mm512_test_epi16_mask_mm512_mask_test_epi8_mask__builtin_ia32_ptestmb512_mm512_test_epi8_mask_mm512_movm_epi16__builtin_ia32_cvtmask2w512_mm512_movm_epi8__builtin_ia32_cvtmask2b512_mm512_movepi16_mask__builtin_ia32_cvtw2mask512_mm512_movepi8_mask__builtin_ia32_cvtb2mask512_mm512_mask_cmpgt_epi16_mask__builtin_ia32_pcmpgtw512_mask_mm512_mask_cmpgt_epu16_mask_mm512_cmpgt_epi16_mask_mm512_cmpgt_epu16_mask_mm512_mask_cmpgt_epi8_mask__builtin_ia32_pcmpgtb512_mask_mm512_mask_cmpgt_epu8_mask_mm512_cmpgt_epi8_mask_mm512_cmpgt_epu8_mask_mm512_mask_cmpeq_epi16_mask__builtin_ia32_pcmpeqw512_mask_mm512_mask_cmpeq_epu16_mask_mm512_cmpeq_epi16_mask_mm512_cmpeq_epu16_mask_mm512_mask_cmpeq_epi8_mask__builtin_ia32_pcmpeqb512_mask_mm512_mask_cmpeq_epu8_mask_mm512_cmpeq_epi8_mask_mm512_cmpeq_epu8_mask_mm512_maskz_unpacklo_epi16__builtin_ia32_punpcklwd512_mask_mm512_mask_unpacklo_epi16_mm512_unpacklo_epi16_mm512_maskz_unpacklo_epi8__builtin_ia32_punpcklbw512_mask_mm512_mask_unpacklo_epi8_mm512_unpacklo_epi8_mm512_maskz_unpackhi_epi16__builtin_ia32_punpckhwd512_mask_mm512_mask_unpackhi_epi16_mm512_unpackhi_epi16_mm512_maskz_unpackhi_epi8__builtin_ia32_punpckhbw512_mask_mm512_mask_unpackhi_epi8_mm512_unpackhi_epi8_mm512_maskz_madd_epi16__builtin_ia32_pmaddwd512_mask_mm512_mask_madd_epi16_mm512_madd_epi16_mm512_maskz_maddubs_epi16__builtin_ia32_pmaddubsw512_mask_mm512_mask_maddubs_epi16_mm512_maddubs_epi16_mm512_maskz_sll_epi16__builtin_ia32_psllw512_mask_mm512_mask_sll_epi16_mm512_sll_epi16_mm512_packs_epi16_mm512_maskz_srl_epi16__builtin_ia32_psrlw512_mask_mm512_mask_srl_epi16_mm512_srl_epi16_mm512_maskz_adds_epu16__builtin_ia32_paddusw512_mask_mm512_mask_adds_epu16_mm512_adds_epu16_mm512_maskz_adds_epi16__builtin_ia32_paddsw512_mask_mm512_mask_adds_epi16_mm512_adds_epi16_mm512_maskz_add_epi16__builtin_ia32_paddw512_mask_mm512_mask_add_epi16_mm512_add_epi16_mm512_maskz_subs_epu16__builtin_ia32_psubusw512_mask_mm512_mask_subs_epu16_mm512_subs_epu16_mm512_maskz_subs_epi16__builtin_ia32_psubsw512_mask_mm512_mask_subs_epi16_mm512_subs_epi16_mm512_maskz_sub_epi16__builtin_ia32_psubw512_mask_mm512_mask_sub_epi16_mm512_sub_epi16_mm512_maskz_adds_epu8__builtin_ia32_paddusb512_mask_mm512_mask_adds_epu8_mm512_adds_epu8_mm512_maskz_adds_epi8__builtin_ia32_paddsb512_mask_mm512_mask_adds_epi8_mm512_adds_epi8_mm512_maskz_subs_epu8__builtin_ia32_psubusb512_mask_mm512_mask_subs_epu8_mm512_subs_epu8_mm512_maskz_subs_epi8__builtin_ia32_psubsb512_mask_mm512_mask_subs_epi8_mm512_subs_epi8_mm512_maskz_avg_epu16__builtin_ia32_pavgw512_mask_mm512_mask_avg_epu16_mm512_avg_epu16_mm512_maskz_sub_epi8__builtin_ia32_psubb512_mask_mm512_mask_sub_epi8_mm512_sub_epi8_mm512_maskz_add_epi8__builtin_ia32_paddb512_mask_mm512_mask_add_epi8_mm512_add_epi8_mm512_maskz_avg_epu8__builtin_ia32_pavgb512_mask_mm512_mask_avg_epu8_mm512_avg_epu8_mm512_maskz_permutex2var_epi16__builtin_ia32_vpermt2varhi512_maskz_mm512_mask2_permutex2var_epi16__builtin_ia32_vpermi2varhi512_mask_mm512_mask_permutex2var_epi16__builtin_ia32_vpermt2varhi512_mask_mm512_permutex2var_epi16_mm512_mask_permutexvar_epi16__builtin_ia32_permvarhi512_mask_mm512_maskz_permutexvar_epi16_mm512_permutexvar_epi16_mm512_maskz_cvtepu8_epi16__builtin_ia32_pmovzxbw512_mask_mm512_mask_cvtepu8_epi16_mm512_cvtepu8_epi16_mm512_maskz_cvtepi8_epi16__builtin_ia32_pmovsxbw512_mask_mm512_mask_cvtepi8_epi16_mm512_cvtepi8_epi16_mm512_maskz_mullo_epi16__builtin_ia32_pmullw512_mask_mm512_mask_mullo_epi16_mm512_mullo_epi16_mm512_maskz_mulhi_epu16__builtin_ia32_pmulhuw512_mask_mm512_mask_mulhi_epu16_mm512_mulhi_epu16_mm512_maskz_mulhi_epi16__builtin_ia32_pmulhw512_mask_mm512_mask_mulhi_epi16_mm512_mulhi_epi16_mm512_maskz_mulhrs_epi16__builtin_ia32_pmulhrsw512_mask_mm512_mask_mulhrs_epi16_mm512_mulhrs_epi16_mm512_maskz_set1_epi16__builtin_ia32_pbroadcastw512_gpr_mask_mm512_mask_set1_epi16_mm512_maskz_broadcastw_epi16__builtin_ia32_pbroadcastw512_mask_mm512_mask_broadcastw_epi16_mm512_broadcastw_epi16_mm512_maskz_set1_epi8__builtin_ia32_pbroadcastb512_gpr_mask_mm512_mask_set1_epi8_mm512_maskz_broadcastb_epi8__builtin_ia32_pbroadcastb512_mask_mm512_mask_broadcastb_epi8_mm512_broadcastb_epi8_mm512_maskz_cvtusepi16_epi8__builtin_ia32_pmovuswb512_mask_mm512_mask_cvtusepi16_storeu_epi8__builtin_ia32_pmovuswb512mem_mask__attribute((vector_size(32))) char *__v32qi *_mm512_mask_cvtusepi16_epi8_mm512_cvtusepi16_epi8_mm512_maskz_cvtsepi16_epi8__builtin_ia32_pmovswb512_mask_mm512_mask_cvtsepi16_epi8_mm512_mask_cvtsepi16_storeu_epi8__builtin_ia32_pmovswb512mem_mask_mm512_cvtsepi16_epi8_mm512_maskz_cvtepi16_epi8__builtin_ia32_pmovwb512_mask_mm512_mask_cvtepi16_epi8_mm512_mask_cvtepi16_storeu_epi8__builtin_ia32_pmovwb512mem_mask_mm512_cvtepi16_epi8_mm512_sad_epu8__builtin_ia32_psadbw512_mm512_mask_storeu_epi8__builtin_ia32_storedquqi512_mask_mm512_storeu_epi8__v64qi_u *__attribute((vector_size(64))) char *_mm512_maskz_loadu_epi8__builtin_ia32_loaddquqi512_mask_mm512_mask_loadu_epi8_mm512_loadu_epi8_kunpackd_mask64__builtin_ia32_kunpckdi_mm512_kunpackd_kunpackw_mask32__builtin_ia32_kunpcksi_mm512_kunpackw_mm512_maskz_mov_epi8__builtin_ia32_movdquqi512_mask_mm512_mask_mov_epi8_mm512_mask_storeu_epi16__builtin_ia32_storedquhi512_maskshort *_mm512_storeu_epi16__v32hi_u *__attribute((vector_size(64))) short *_mm512_maskz_loadu_epi16__builtin_ia32_loaddquhi512_maskconst shortconst short *_mm512_mask_loadu_epi16_mm512_loadu_epi16_mm512_maskz_mov_epi16__builtin_ia32_movdquhi512_mask_mm512_mask_mov_epi16_kandn_mask64__builtin_ia32_kandndi_kandn_mask32__builtin_ia32_kandnsi_kand_mask64__builtin_ia32_kanddi_kand_mask32__builtin_ia32_kandsi_kxor_mask64__builtin_ia32_kxordi_kxor_mask32__builtin_ia32_kxorsi_kxnor_mask64__builtin_ia32_kxnordi_kxnor_mask32__builtin_ia32_kxnorsi_kor_mask64__builtin_ia32_kordi_kor_mask32__builtin_ia32_korsi_knot_mask64__builtin_ia32_knotdi_knot_mask32__builtin_ia32_knotsi_store_mask64__mmask64 *__builtin_ia32_kmovq_store_mask32__mmask32 *__builtin_ia32_kmovd_load_mask64_load_mask32_cvtu64_mask64_cvtu32_mask32_cvtmask64_u64_cvtmask32_u32_kadd_mask64__builtin_ia32_kadddi_kadd_mask32__builtin_ia32_kaddsi_kortestc_mask64_u8__builtin_ia32_kortestcdi_kortestc_mask32_u8__builtin_ia32_kortestcsi_kortestz_mask64_u8__builtin_ia32_kortestzdi_kortestz_mask32_u8__builtin_ia32_kortestzsi_kortest_mask64_u8_kortest_mask32_u8_ktestc_mask64_u8__builtin_ia32_ktestcdi_ktestc_mask32_u8__builtin_ia32_ktestcsi_ktestz_mask64_u8__builtin_ia32_ktestzdi_ktestz_mask32_u8__builtin_ia32_ktestzsi_ktest_mask64_u8_ktest_mask32_u8__mmask64__v64qi_u__v32hi_u__DISABLE_AVX512BW___AVX512BWINTRIN_H_INCLUDED__AVX512BW__GCC target("avx512bw")/* _AVX512BWINTRIN_H_INCLUDED *//* __DISABLE_AVX512BW__ *//* __AVX512BW__ */_mm512_fpclass_ps_mask__builtin_ia32_fpclassps512_mask_mm512_mask_fpclass_ps_mask_mm512_fpclass_pd_mask__builtin_ia32_fpclasspd512_mask_mm512_mask_fpclass_pd_mask_mm512_maskz_insertf64x2__builtin_ia32_insertf64x2_512_mask_mm512_mask_insertf64x2_mm512_insertf64x2_mm512_maskz_inserti64x2__builtin_ia32_inserti64x2_512_mask_mm512_mask_inserti64x2_mm512_inserti64x2_mm512_maskz_insertf32x8__builtin_ia32_insertf32x8_mask_mm512_mask_insertf32x8_mm512_insertf32x8_mm512_maskz_inserti32x8__builtin_ia32_inserti32x8_mask_mm512_mask_inserti32x8_mm512_inserti32x8_mm512_maskz_range_round_ps__builtin_ia32_rangeps512_mask_mm512_mask_range_round_ps_mm512_range_round_ps_mm512_maskz_range_round_pd__builtin_ia32_rangepd512_mask_mm512_mask_range_round_pd_mm512_range_round_pd_mm512_maskz_extracti64x2_epi64__builtin_ia32_extracti64x2_512_mask_mm512_mask_extracti64x2_epi64_mm512_extracti64x2_epi64_mm512_maskz_extracti32x8_epi32__builtin_ia32_extracti32x8_mask_mm512_mask_extracti32x8_epi32_mm512_extracti32x8_epi32_mm512_maskz_extractf64x2_pd__builtin_ia32_extractf64x2_512_mask_mm512_mask_extractf64x2_pd_mm512_extractf64x2_pd_mm512_maskz_extractf32x8_ps__builtin_ia32_extractf32x8_mask_mm512_mask_extractf32x8_ps_mm512_extractf32x8_ps_mm512_maskz_reduce_round_ps__builtin_ia32_reduceps512_mask_round_mm512_maskz_reduce_ps__builtin_ia32_reduceps512_mask_mm512_mask_reduce_round_ps_mm512_mask_reduce_ps_mm512_reduce_round_ps_mm512_reduce_ps_mm512_maskz_reduce_round_pd__builtin_ia32_reducepd512_mask_round_mm512_maskz_reduce_pd__builtin_ia32_reducepd512_mask_mm512_mask_reduce_round_pd_mm512_mask_reduce_pd_mm512_reduce_round_pd_mm512_reduce_pd_mm512_maskz_cvt_roundepu64_pd__builtin_ia32_cvtuqq2pd512_mask_mm512_mask_cvt_roundepu64_pd_mm512_cvt_roundepu64_pd_mm512_maskz_cvt_roundepi64_pd__builtin_ia32_cvtqq2pd512_mask_mm512_mask_cvt_roundepi64_pd_mm512_cvt_roundepi64_pd_mm512_maskz_cvt_roundepu64_ps__builtin_ia32_cvtuqq2ps512_mask_mm512_mask_cvt_roundepu64_ps_mm512_cvt_roundepu64_ps_mm512_maskz_cvt_roundepi64_ps__builtin_ia32_cvtqq2ps512_mask_mm512_mask_cvt_roundepi64_ps_mm512_cvt_roundepi64_ps_mm512_maskz_cvt_roundps_epu64__builtin_ia32_cvtps2uqq512_mask_mm512_mask_cvt_roundps_epu64_mm512_cvt_roundps_epu64_mm512_maskz_cvt_roundps_epi64__builtin_ia32_cvtps2qq512_mask_mm512_mask_cvt_roundps_epi64_mm512_cvt_roundps_epi64_mm512_maskz_cvt_roundpd_epu64__builtin_ia32_cvtpd2uqq512_mask_mm512_mask_cvt_roundpd_epu64_mm512_cvt_roundpd_epu64_mm512_maskz_cvt_roundpd_epi64__builtin_ia32_cvtpd2qq512_mask_mm512_mask_cvt_roundpd_epi64_mm512_cvt_roundpd_epi64_mm512_maskz_cvtt_roundps_epu64__builtin_ia32_cvttps2uqq512_mask_mm512_mask_cvtt_roundps_epu64_mm512_cvtt_roundps_epu64_mm512_maskz_cvtt_roundps_epi64__builtin_ia32_cvttps2qq512_mask_mm512_mask_cvtt_roundps_epi64_mm512_cvtt_roundps_epi64_mm512_maskz_cvtt_roundpd_epu64__builtin_ia32_cvttpd2uqq512_mask_mm512_mask_cvtt_roundpd_epu64_mm512_cvtt_roundpd_epu64_mm512_maskz_cvtt_roundpd_epi64__builtin_ia32_cvttpd2qq512_mask_mm512_mask_cvtt_roundpd_epi64_mm512_cvtt_roundpd_epi64_mm_mask_fpclass_sd_mask__builtin_ia32_fpclasssd_mask_mm_mask_fpclass_ss_mask__builtin_ia32_fpclassss_mask_mm_fpclass_sd_mask_mm_fpclass_ss_mask_mm_maskz_range_round_ss__builtin_ia32_rangess128_mask_round_mm_mask_range_round_ss_mm_range_round_ss_mm_maskz_range_round_sd__builtin_ia32_rangesd128_mask_round_mm_mask_range_round_sd_mm_range_round_sd_mm_maskz_range_ss_mm_mask_range_ss_mm_range_ss_mm_maskz_range_sd_mm_mask_range_sd_mm_range_sd_mm_maskz_reduce_round_ss__builtin_ia32_reducess_mask_round_mm_maskz_reduce_ss__builtin_ia32_reducess_mask_mm_mask_reduce_round_ss_mm_mask_reduce_ss_mm_reduce_round_ss_mm_reduce_ss_mm_maskz_reduce_round_sd__builtin_ia32_reducesd_mask_round_mm_maskz_reduce_sd__builtin_ia32_reducesd_mask_mm_mask_reduce_round_sd_mm_mask_reduce_sd_mm_reduce_round_sd_mm_reduce_sd_mm512_maskz_range_ps_mm512_mask_range_ps_mm512_range_ps_mm512_maskz_range_pd_mm512_mask_range_pd_mm512_range_pd_kshiftri_mask8__builtin_ia32_kshiftriqi_kshiftli_mask8__builtin_ia32_kshiftliqi_mm512_maskz_cvtepu64_pd_mm512_mask_cvtepu64_pd_mm512_cvtepu64_pd_mm512_maskz_cvtepi64_pd_mm512_mask_cvtepi64_pd_mm512_cvtepi64_pd_mm512_maskz_cvtepu64_ps_mm512_mask_cvtepu64_ps_mm512_cvtepu64_ps_mm512_maskz_cvtepi64_ps_mm512_mask_cvtepi64_ps_mm512_cvtepi64_ps_mm512_maskz_cvtps_epu64_mm512_mask_cvtps_epu64_mm512_cvtps_epu64_mm512_maskz_cvtps_epi64_mm512_mask_cvtps_epi64_mm512_cvtps_epi64_mm512_maskz_cvtpd_epu64_mm512_mask_cvtpd_epu64_mm512_cvtpd_epu64_mm512_maskz_cvtpd_epi64_mm512_mask_cvtpd_epi64_mm512_cvtpd_epi64_mm512_maskz_cvttps_epu64_mm512_mask_cvttps_epu64_mm512_cvttps_epu64_mm512_maskz_cvttps_epi64_mm512_mask_cvttps_epi64_mm512_cvttps_epi64_mm512_maskz_cvttpd_epu64_mm512_mask_cvttpd_epu64_mm512_cvttpd_epu64_mm512_maskz_cvttpd_epi64_mm512_mask_cvttpd_epi64_mm512_cvttpd_epi64_mm512_movm_epi64__builtin_ia32_cvtmask2q512_mm512_movm_epi32__builtin_ia32_cvtmask2d512_mm512_movepi64_mask__builtin_ia32_cvtq2mask512_mm512_movepi32_mask__builtin_ia32_cvtd2mask512_mm512_maskz_andnot_ps__builtin_ia32_andnps512_mask_mm512_mask_andnot_ps_mm512_andnot_ps_mm512_maskz_andnot_pd__builtin_ia32_andnpd512_mask_mm512_mask_andnot_pd_mm512_andnot_pd_mm512_maskz_and_ps__builtin_ia32_andps512_mask_mm512_mask_and_ps_mm512_and_ps_mm512_maskz_and_pd__builtin_ia32_andpd512_mask_mm512_mask_and_pd_mm512_and_pd_mm512_maskz_or_ps__builtin_ia32_orps512_mask_mm512_mask_or_ps_mm512_or_ps_mm512_maskz_or_pd__builtin_ia32_orpd512_mask_mm512_mask_or_pd_mm512_or_pd_mm512_maskz_xor_ps__builtin_ia32_xorps512_mask_mm512_mask_xor_ps_mm512_xor_ps_mm512_maskz_xor_pd__builtin_ia32_xorpd512_mask_mm512_mask_xor_pd_mm512_xor_pd_mm512_maskz_mullo_epi64__builtin_ia32_pmullq512_mask_mm512_mask_mullo_epi64_mm512_mullo_epi64_mm512_maskz_broadcast_i32x8__builtin_ia32_broadcasti32x8_512_mask_mm512_mask_broadcast_i32x8_mm512_broadcast_i32x8_mm512_maskz_broadcast_f32x8__builtin_ia32_broadcastf32x8_512_mask_mm512_mask_broadcast_f32x8_mm512_broadcast_f32x8_mm512_maskz_broadcast_i32x2__builtin_ia32_broadcasti32x2_512_mask_mm512_mask_broadcast_i32x2_mm512_broadcast_i32x2_mm512_maskz_broadcast_f32x2__builtin_ia32_broadcastf32x2_512_mask_mm512_mask_broadcast_f32x2_mm512_broadcast_f32x2_mm512_maskz_broadcast_i64x2__builtin_ia32_broadcasti64x2_512_mask_mm512_mask_broadcast_i64x2_mm512_broadcast_i64x2_mm512_maskz_broadcast_f64x2__builtin_ia32_broadcastf64x2_512_mask_mm512_mask_broadcast_f64x2_mm512_broadcast_f64x2_kandn_mask8__builtin_ia32_kandnqi_kand_mask8__builtin_ia32_kandqi_kxor_mask8__builtin_ia32_kxorqi_kxnor_mask8__builtin_ia32_kxnorqi_kor_mask8__builtin_ia32_korqi_knot_mask8__builtin_ia32_knotqi_store_mask8__mmask8 *__builtin_ia32_kmovb_load_mask8_cvtu32_mask8_cvtmask8_u32_kadd_mask16__builtin_ia32_kaddhi_kadd_mask8__builtin_ia32_kaddqi_kortestc_mask8_u8__builtin_ia32_kortestcqi_kortestz_mask8_u8__builtin_ia32_kortestzqi_kortest_mask8_u8_ktestc_mask16_u8__builtin_ia32_ktestchi_ktestz_mask16_u8__builtin_ia32_ktestzhi_ktest_mask16_u8_ktestc_mask8_u8__builtin_ia32_ktestcqi_ktestz_mask8_u8__builtin_ia32_ktestzqi_ktest_mask8_u8__DISABLE_AVX512DQ___AVX512DQINTRIN_H_INCLUDED__AVX512DQ__GCC target("avx512dq")/* _AVX512DQINTRIN_H_INCLUDED *//* __DISABLE_AVX512DQ__ *//* __AVX512DQ__ */_mm256_mask_cmple_epi16_mask__builtin_ia32_cmpw256_mask_mm256_mask_cmpge_epi16_mask_mm256_mask_cmplt_epi16_mask_mm256_mask_cmpneq_epi16_mask_mm256_mask_cmple_epi8_mask__builtin_ia32_cmpb256_mask_mm256_mask_cmpge_epi8_mask_mm256_mask_cmplt_epi8_mask_mm256_mask_cmpneq_epi8_mask_mm256_mask_cmple_epu16_mask__builtin_ia32_ucmpw256_mask_mm256_mask_cmpge_epu16_mask_mm256_mask_cmplt_epu16_mask_mm256_mask_cmpneq_epu16_mask_mm256_mask_cmple_epu8_mask__builtin_ia32_ucmpb256_mask_mm256_mask_cmpge_epu8_mask_mm256_mask_cmplt_epu8_mask_mm256_mask_cmpneq_epu8_mask_mm_mask_cmple_epi16_mask__builtin_ia32_cmpw128_mask_mm_mask_cmpge_epi16_mask_mm_mask_cmplt_epi16_mask_mm_mask_cmpneq_epi16_mask_mm_mask_cmple_epi8_mask__builtin_ia32_cmpb128_mask_mm_mask_cmpge_epi8_mask_mm_mask_cmplt_epi8_mask_mm_mask_cmpneq_epi8_mask_mm_mask_cmple_epu16_mask__builtin_ia32_ucmpw128_mask_mm_mask_cmpge_epu16_mask_mm_mask_cmplt_epu16_mask_mm_mask_cmpneq_epu16_mask_mm_mask_cmple_epu8_mask__builtin_ia32_ucmpb128_mask_mm_mask_cmpge_epu8_mask_mm_mask_cmplt_epu8_mask_mm_mask_cmpneq_epu8_mask_mm_mask_packs_epi32__builtin_ia32_packssdw128_mask_mm_maskz_packs_epi32_mm256_mask_packs_epi32__builtin_ia32_packssdw256_mask_mm256_maskz_packs_epi32_mm_mask_packus_epi32__builtin_ia32_packusdw128_mask_mm_maskz_packus_epi32_mm256_mask_packus_epi32__builtin_ia32_packusdw256_mask_mm256_maskz_packus_epi32_mm256_maskz_sll_epi16__builtin_ia32_psllw256_mask_mm256_mask_sll_epi16_mm_maskz_sll_epi16__builtin_ia32_psllw128_mask_mm_mask_sll_epi16_mm_maskz_sllv_epi16__builtin_ia32_psllv8hi_mask_mm_mask_sllv_epi16_mm_sllv_epi16_mm256_maskz_sllv_epi16__builtin_ia32_psllv16hi_mask_mm256_mask_sllv_epi16_mm256_sllv_epi16_mm_maskz_srlv_epi16__builtin_ia32_psrlv8hi_mask_mm_mask_srlv_epi16_mm_srlv_epi16_mm256_maskz_srlv_epi16__builtin_ia32_psrlv16hi_mask_mm256_mask_srlv_epi16_mm256_srlv_epi16_mm_maskz_srav_epi16__builtin_ia32_psrav8hi_mask_mm_mask_srav_epi16_mm_srav_epi16_mm256_maskz_srav_epi16__builtin_ia32_psrav16hi_mask_mm256_mask_srav_epi16_mm256_srav_epi16_mm_maskz_cvtepi16_epi8__builtin_ia32_pmovwb128_mask_mm_mask_cvtepi16_epi8_mm_mask_cvtepi16_storeu_epi8__builtin_ia32_pmovwb128mem_mask_mm_cvtepi16_epi8_mm_maskz_adds_epi8__builtin_ia32_paddsb128_mask_mm_mask_adds_epi8_mm_maskz_sub_epi16__builtin_ia32_psubw128_mask_mm_mask_sub_epi16_mm_maskz_sub_epi8__builtin_ia32_psubb128_mask_mm_mask_sub_epi8_mm_maskz_adds_epu16__builtin_ia32_paddusw128_mask_mm_mask_adds_epu16_mm_maskz_adds_epu8__builtin_ia32_paddusb128_mask_mm_mask_adds_epu8_mm_maskz_adds_epi16__builtin_ia32_paddsw128_mask_mm_maskz_sra_epi16__builtin_ia32_psraw128_mask_mm_mask_sra_epi16_mm256_maskz_sra_epi16__builtin_ia32_psraw256_mask_mm256_mask_sra_epi16_mm_maskz_srl_epi16__builtin_ia32_psrlw128_mask_mm_mask_srl_epi16_mm256_maskz_srl_epi16__builtin_ia32_psrlw256_mask_mm256_mask_srl_epi16_mm_maskz_subs_epu16__builtin_ia32_psubusw128_mask_mm_mask_subs_epu16_mm_maskz_subs_epu8__builtin_ia32_psubusb128_mask_mm_mask_subs_epu8_mm_maskz_subs_epi16__builtin_ia32_psubsw128_mask_mm_mask_subs_epi16_mm_maskz_subs_epi8__builtin_ia32_psubsb128_mask_mm_mask_subs_epi8_mm_mask_adds_epi16_mm_mask_storeu_epi16__builtin_ia32_storedquhi128_mask_mm_storeu_epi16__v8hi_u *_mm256_mask_storeu_epi16__builtin_ia32_storedquhi256_mask_mm256_storeu_epi16__v16hi_u *_mm256_cmple_epu16_mask_mm256_cmpge_epu16_mask_mm256_cmplt_epu16_mask_mm256_cmpneq_epu16_mask_mm256_cmple_epu8_mask_mm256_cmpge_epu8_mask_mm256_cmplt_epu8_mask_mm256_cmpneq_epu8_mask_mm_maskz_abs_epi16__builtin_ia32_pabsw128_mask_mm_mask_abs_epi16_mm256_maskz_abs_epi16__builtin_ia32_pabsw256_mask_mm256_mask_abs_epi16_mm_maskz_abs_epi8__builtin_ia32_pabsb128_mask_mm_mask_abs_epi8_mm256_maskz_abs_epi8__builtin_ia32_pabsb256_mask_mm256_mask_abs_epi8_mm_mask_packus_epi16__builtin_ia32_packuswb128_mask_mm_maskz_packus_epi16_mm256_mask_packus_epi16__builtin_ia32_packuswb256_mask_mm256_maskz_packus_epi16_mm_mask_packs_epi16__builtin_ia32_packsswb128_mask_mm_maskz_packs_epi16_mm256_mask_packs_epi16__builtin_ia32_packsswb256_mask_mm256_maskz_packs_epi16_mm_maskz_shuffle_epi8__builtin_ia32_pshufb128_mask_mm_mask_shuffle_epi8_mm256_maskz_shuffle_epi8__builtin_ia32_pshufb256_mask_mm256_mask_shuffle_epi8_mm256_mask_testn_epi16_mask__builtin_ia32_ptestnmw256_mm256_testn_epi16_mask_mm_mask_testn_epi16_mask__builtin_ia32_ptestnmw128_mm_testn_epi16_mask_mm256_mask_testn_epi8_mask__builtin_ia32_ptestnmb256_mm256_testn_epi8_mask_mm_mask_testn_epi8_mask__builtin_ia32_ptestnmb128_mm_testn_epi8_mask_mm256_mask_cmpgt_epi16_mask__builtin_ia32_pcmpgtw256_mask_mm256_mask_cmpgt_epu16_mask_mm256_cmpgt_epi16_mask_mm256_cmpgt_epu16_mask_mm_mask_cmpgt_epi16_mask__builtin_ia32_pcmpgtw128_mask_mm_mask_cmpgt_epu16_mask_mm_cmpgt_epi16_mask_mm_cmpgt_epu16_mask_mm256_mask_cmpgt_epi8_mask__builtin_ia32_pcmpgtb256_mask_mm256_mask_cmpgt_epu8_mask_mm256_cmpgt_epi8_mask_mm256_cmpgt_epu8_mask_mm_mask_cmpgt_epi8_mask__builtin_ia32_pcmpgtb128_mask_mm_mask_cmpgt_epu8_mask_mm_cmpgt_epi8_mask_mm_cmpgt_epu8_mask_mm256_mask_cmpeq_epi16_mask__builtin_ia32_pcmpeqw256_mask_mm256_mask_cmpeq_epu16_mask_mm256_cmpeq_epi16_mask_mm256_cmpeq_epu16_mask_mm_mask_cmpeq_epi16_mask__builtin_ia32_pcmpeqw128_mask_mm_mask_cmpeq_epu16_mask_mm_cmpeq_epi16_mask_mm_cmpeq_epu16_mask_mm256_mask_cmpeq_epi8_mask__builtin_ia32_pcmpeqb256_mask_mm256_mask_cmpeq_epu8_mask_mm256_cmpeq_epi8_mask_mm256_cmpeq_epu8_mask_mm_mask_cmpeq_epi8_mask__builtin_ia32_pcmpeqb128_mask_mm_mask_cmpeq_epu8_mask_mm_cmpeq_epu8_mask_mm_cmpeq_epi8_mask_mm_maskz_unpacklo_epi16__builtin_ia32_punpcklwd128_mask_mm_mask_unpacklo_epi16_mm256_maskz_unpacklo_epi16__builtin_ia32_punpcklwd256_mask_mm256_mask_unpacklo_epi16_mm_maskz_unpacklo_epi8__builtin_ia32_punpcklbw128_mask_mm_mask_unpacklo_epi8_mm256_maskz_unpacklo_epi8__builtin_ia32_punpcklbw256_mask_mm256_mask_unpacklo_epi8_mm_maskz_unpackhi_epi16__builtin_ia32_punpckhwd128_mask_mm_mask_unpackhi_epi16_mm256_maskz_unpackhi_epi16__builtin_ia32_punpckhwd256_mask_mm256_mask_unpackhi_epi16_mm_maskz_unpackhi_epi8__builtin_ia32_punpckhbw128_mask_mm_mask_unpackhi_epi8_mm256_maskz_unpackhi_epi8__builtin_ia32_punpckhbw256_mask_mm256_mask_unpackhi_epi8_mm_maskz_add_epi16__builtin_ia32_paddw128_mask_mm_mask_add_epi16_mm_maskz_add_epi8__builtin_ia32_paddb128_mask_mm_mask_add_epi8_mm256_maskz_subs_epu16__builtin_ia32_psubusw256_mask_mm256_mask_subs_epu16_mm256_maskz_subs_epu8__builtin_ia32_psubusb256_mask_mm256_mask_subs_epu8_mm256_maskz_subs_epi16__builtin_ia32_psubsw256_mask_mm256_mask_subs_epi16_mm256_maskz_subs_epi8__builtin_ia32_psubsb256_mask_mm256_mask_subs_epi8_mm256_maskz_sub_epi16__builtin_ia32_psubw256_mask_mm256_mask_sub_epi16_mm256_maskz_sub_epi8__builtin_ia32_psubb256_mask_mm256_mask_sub_epi8_mm256_maskz_adds_epu16__builtin_ia32_paddusw256_mask_mm256_mask_adds_epu16_mm256_maskz_adds_epu8__builtin_ia32_paddusb256_mask_mm256_mask_adds_epu8_mm256_maskz_adds_epi16__builtin_ia32_paddsw256_mask_mm256_mask_adds_epi16_mm256_maskz_adds_epi8__builtin_ia32_paddsb256_mask_mm256_mask_adds_epi8_mm256_maskz_add_epi16__builtin_ia32_paddw256_mask_mm256_mask_add_epi16_mm256_maskz_add_epi8__builtin_ia32_paddb256_mask_mm256_mask_add_epi8_mm_maskz_avg_epu16__builtin_ia32_pavgw128_mask_mm_mask_avg_epu16_mm256_maskz_avg_epu16__builtin_ia32_pavgw256_mask_mm256_mask_avg_epu16_mm_maskz_avg_epu8__builtin_ia32_pavgb128_mask_mm_mask_avg_epu8_mm256_maskz_avg_epu8__builtin_ia32_pavgb256_mask_mm256_mask_avg_epu8_mm_maskz_cvtepu8_epi16__builtin_ia32_pmovzxbw128_mask_mm_mask_cvtepu8_epi16_mm256_maskz_cvtepu8_epi16__builtin_ia32_pmovzxbw256_mask_mm256_mask_cvtepu8_epi16_mm_maskz_cvtepi8_epi16__builtin_ia32_pmovsxbw128_mask_mm_mask_cvtepi8_epi16_mm256_maskz_cvtepi8_epi16__builtin_ia32_pmovsxbw256_mask_mm256_mask_cvtepi8_epi16_mm_maskz_mullo_epi16__builtin_ia32_pmullw128_mask_mm_mask_mullo_epi16_mm256_maskz_mullo_epi16__builtin_ia32_pmullw256_mask_mm256_mask_mullo_epi16_mm_maskz_mulhrs_epi16__builtin_ia32_pmulhrsw128_mask_mm_mask_mulhrs_epi16_mm_maskz_mulhi_epu16__builtin_ia32_pmulhuw128_mask_mm_mask_mulhi_epu16_mm_maskz_mulhi_epi16__builtin_ia32_pmulhw128_mask_mm_mask_mulhi_epi16_mm256_maskz_mulhi_epi16__builtin_ia32_pmulhw256_mask_mm256_mask_mulhi_epi16_mm256_maskz_mulhi_epu16__builtin_ia32_pmulhuw256_mask_mm256_mask_mulhi_epu16_mm256_maskz_mulhrs_epi16__builtin_ia32_pmulhrsw256_mask_mm256_mask_mulhrs_epi16_mm_cmple_epi16_mask_mm_cmpge_epi16_mask_mm_cmplt_epi16_mask_mm_cmpneq_epi16_mask_mm_cmple_epi8_mask_mm_cmpge_epi8_mask_mm_cmplt_epi8_mask_mm_cmpneq_epi8_mask_mm_cmple_epu16_mask_mm_cmpge_epu16_mask_mm_cmplt_epu16_mask_mm_cmpneq_epu16_mask_mm_cmple_epu8_mask_mm_cmpge_epu8_mask_mm_cmplt_epu8_mask_mm_cmpneq_epu8_mask_mm256_cmple_epi16_mask_mm256_cmpge_epi16_mask_mm256_cmplt_epi16_mask_mm256_cmpneq_epi16_mask_mm256_cmple_epi8_mask_mm256_cmpge_epi8_mask_mm256_cmplt_epi8_mask_mm256_cmpneq_epi8_mask_mm_maskz_slli_epi16__builtin_ia32_psllwi128_mask_mm_mask_slli_epi16_mm256_maskz_slli_epi16__builtin_ia32_psllwi256_mask_mm256_mask_slli_epi16_mm_maskz_srai_epi16__builtin_ia32_psrawi128_mask_mm_mask_srai_epi16_mm256_maskz_srai_epi16__builtin_ia32_psrawi256_mask_mm256_mask_srai_epi16_mm_maskz_shufflelo_epi16__builtin_ia32_pshuflw128_mask_mm_mask_shufflelo_epi16_mm256_maskz_shufflelo_epi16__builtin_ia32_pshuflw256_mask_mm256_mask_shufflelo_epi16_mm_maskz_shufflehi_epi16__builtin_ia32_pshufhw128_mask_mm_mask_shufflehi_epi16_mm256_maskz_shufflehi_epi16__builtin_ia32_pshufhw256_mask_mm256_mask_shufflehi_epi16_mm_maskz_srli_epi16__builtin_ia32_psrlwi128_mask_mm_mask_srli_epi16_mm256_maskz_srli_epi16__builtin_ia32_psrlwi256_mask_mm256_mask_srli_epi16_mm256_cmp_epu8_mask_mm256_mask_cmp_epu8_mask_mm_cmp_epu8_mask_mm_mask_cmp_epu8_mask_mm256_cmp_epu16_mask_mm256_mask_cmp_epu16_mask_mm_cmp_epu16_mask_mm_mask_cmp_epu16_mask_mm256_cmp_epi8_mask_mm256_mask_cmp_epi8_mask_mm_cmp_epi8_mask_mm_mask_cmp_epi8_mask_mm256_cmp_epi16_mask_mm256_mask_cmp_epi16_mask_mm_cmp_epi16_mask_mm_mask_cmp_epi16_mask_mm256_mask_blend_epi8__builtin_ia32_blendmb_256_mask_mm256_mask_blend_epi16__builtin_ia32_blendmw_256_mask_mm_mask_blend_epi8__builtin_ia32_blendmb_128_mask_mm_mask_blend_epi16__builtin_ia32_blendmw_128_mask_mm_maskz_dbsad_epu8__builtin_ia32_dbpsadbw128_mask_mm_mask_dbsad_epu8_mm_dbsad_epu8_mm256_maskz_dbsad_epu8__builtin_ia32_dbpsadbw256_mask_mm256_mask_dbsad_epu8_mm256_dbsad_epu8_mm_maskz_alignr_epi8__builtin_ia32_palignr128_mask_mm_mask_alignr_epi8_mm256_maskz_alignr_epi8__builtin_ia32_palignr256_mask_mm256_mask_alignr_epi8_mm_mask_min_epi16__builtin_ia32_pminsw128_mask_mm_maskz_min_epi16_mm_mask_max_epu16__builtin_ia32_pmaxuw128_mask_mm_maskz_max_epu16_mm256_mask_max_epu16__builtin_ia32_pmaxuw256_mask_mm256_maskz_max_epu16_mm_mask_max_epi16__builtin_ia32_pmaxsw128_mask_mm_maskz_max_epi16_mm256_mask_max_epi16__builtin_ia32_pmaxsw256_mask_mm256_maskz_max_epi16_mm_mask_min_epi8__builtin_ia32_pminsb128_mask_mm_maskz_min_epi8_mm256_mask_min_epi8__builtin_ia32_pminsb256_mask_mm256_maskz_min_epi8_mm_mask_min_epu8__builtin_ia32_pminub128_mask_mm_maskz_min_epu8_mm256_mask_min_epu8__builtin_ia32_pminub256_mask_mm256_maskz_min_epu8_mm_mask_max_epi8__builtin_ia32_pmaxsb128_mask_mm_maskz_max_epi8_mm256_mask_max_epi8__builtin_ia32_pmaxsb256_mask_mm256_maskz_max_epi8_mm_mask_max_epu8__builtin_ia32_pmaxub128_mask_mm_maskz_max_epu8_mm256_mask_max_epu8__builtin_ia32_pmaxub256_mask_mm256_maskz_max_epu8_mm256_mask_min_epi16__builtin_ia32_pminsw256_mask_mm256_maskz_min_epi16_mm_mask_min_epu16__builtin_ia32_pminuw128_mask_mm_maskz_min_epu16_mm256_mask_min_epu16__builtin_ia32_pminuw256_mask_mm256_maskz_min_epu16_mm256_mask_test_epi16_mask__builtin_ia32_ptestmw256_mm256_test_epi16_mask_mm_mask_test_epi16_mask__builtin_ia32_ptestmw128_mm_test_epi16_mask_mm256_mask_test_epi8_mask__builtin_ia32_ptestmb256_mm256_test_epi8_mask_mm_mask_test_epi8_mask__builtin_ia32_ptestmb128_mm_test_epi8_mask_mm256_movm_epi16__builtin_ia32_cvtmask2w256_mm_movm_epi16__builtin_ia32_cvtmask2w128_mm256_movm_epi8__builtin_ia32_cvtmask2b256_mm_movm_epi8__builtin_ia32_cvtmask2b128_mm256_movepi16_mask__builtin_ia32_cvtw2mask256_mm_movepi16_mask__builtin_ia32_cvtw2mask128_mm256_movepi8_mask__builtin_ia32_cvtb2mask256_mm_movepi8_mask__builtin_ia32_cvtb2mask128_mm_maskz_madd_epi16__builtin_ia32_pmaddwd128_mask_mm_mask_madd_epi16_mm256_maskz_madd_epi16__builtin_ia32_pmaddwd256_mask_mm256_mask_madd_epi16_mm_maskz_maddubs_epi16__builtin_ia32_pmaddubsw128_mask_mm_mask_maddubs_epi16_mm256_maskz_maddubs_epi16__builtin_ia32_pmaddubsw256_mask_mm256_mask_maddubs_epi16_mm_maskz_permutex2var_epi16__builtin_ia32_vpermt2varhi128_maskz_mm_mask2_permutex2var_epi16__builtin_ia32_vpermi2varhi128_mask_mm_mask_permutex2var_epi16__builtin_ia32_vpermt2varhi128_mask_mm_permutex2var_epi16_mm256_maskz_permutex2var_epi16__builtin_ia32_vpermt2varhi256_maskz_mm256_mask2_permutex2var_epi16__builtin_ia32_vpermi2varhi256_mask_mm256_mask_permutex2var_epi16__builtin_ia32_vpermt2varhi256_mask_mm256_permutex2var_epi16_mm_mask_permutexvar_epi16__builtin_ia32_permvarhi128_mask_mm_maskz_permutexvar_epi16_mm_permutexvar_epi16_mm256_mask_permutexvar_epi16__builtin_ia32_permvarhi256_mask_mm256_maskz_permutexvar_epi16_mm256_permutexvar_epi16_mm_maskz_set1_epi16__builtin_ia32_pbroadcastw128_gpr_mask_mm_mask_set1_epi16_mm_maskz_broadcastw_epi16__builtin_ia32_pbroadcastw128_mask_mm_mask_broadcastw_epi16_mm256_maskz_set1_epi16__builtin_ia32_pbroadcastw256_gpr_mask_mm256_mask_set1_epi16_mm256_maskz_broadcastw_epi16__builtin_ia32_pbroadcastw256_mask_mm256_mask_broadcastw_epi16_mm_maskz_set1_epi8__builtin_ia32_pbroadcastb128_gpr_mask_mm_mask_set1_epi8_mm_maskz_broadcastb_epi8__builtin_ia32_pbroadcastb128_mask_mm_mask_broadcastb_epi8_mm256_maskz_set1_epi8__builtin_ia32_pbroadcastb256_gpr_mask_mm256_mask_set1_epi8_mm256_maskz_broadcastb_epi8__builtin_ia32_pbroadcastb256_mask_mm256_mask_broadcastb_epi8_mm256_maskz_cvtusepi16_epi8__builtin_ia32_pmovuswb256_mask_mm256_mask_cvtusepi16_epi8_mm256_mask_cvtusepi16_storeu_epi8__builtin_ia32_pmovuswb256mem_mask_mm256_cvtusepi16_epi8_mm_maskz_cvtusepi16_epi8__builtin_ia32_pmovuswb128_mask_mm_mask_cvtusepi16_epi8_mm_mask_cvtusepi16_storeu_epi8__builtin_ia32_pmovuswb128mem_mask_mm_cvtusepi16_epi8_mm256_maskz_cvtsepi16_epi8__builtin_ia32_pmovswb256_mask_mm256_mask_cvtsepi16_epi8_mm256_mask_cvtsepi16_storeu_epi8__builtin_ia32_pmovswb256mem_mask_mm256_cvtsepi16_epi8_mm_maskz_cvtsepi16_epi8__builtin_ia32_pmovswb128_mask_mm_mask_cvtsepi16_epi8_mm_mask_cvtsepi16_storeu_epi8__builtin_ia32_pmovswb128mem_mask_mm_cvtsepi16_epi8_mm256_maskz_cvtepi16_epi8__builtin_ia32_pmovwb256_mask_mm256_mask_cvtepi16_epi8_mm256_mask_cvtepi16_storeu_epi8__builtin_ia32_pmovwb256mem_mask_mm256_cvtepi16_epi8_mm_maskz_loadu_epi8__builtin_ia32_loaddquqi128_mask_mm_mask_loadu_epi8_mm_loadu_epi8__v16qi_u *_mm256_maskz_loadu_epi8__builtin_ia32_loaddquqi256_mask_mm256_mask_loadu_epi8_mm256_loadu_epi8__v32qi_u *_mm_maskz_mov_epi16__builtin_ia32_movdquhi128_mask_mm_mask_mov_epi16_mm256_maskz_mov_epi16__builtin_ia32_movdquhi256_mask_mm256_mask_mov_epi16_mm_maskz_loadu_epi16__builtin_ia32_loaddquhi128_mask_mm_mask_loadu_epi16_mm_loadu_epi16_mm256_maskz_loadu_epi16__builtin_ia32_loaddquhi256_mask_mm256_mask_loadu_epi16_mm256_loadu_epi16_mm_mask_storeu_epi8__builtin_ia32_storedquqi128_mask_mm_storeu_epi8_mm256_mask_storeu_epi8__builtin_ia32_storedquqi256_mask_mm256_storeu_epi8_mm_maskz_mov_epi8__builtin_ia32_movdquqi128_mask_mm_mask_mov_epi8_mm256_maskz_mov_epi8__builtin_ia32_movdquqi256_mask_mm256_mask_mov_epi8__v16qi_u__v32qi_u__v8hi_u__v16hi_u__DISABLE_AVX512VLBW___AVX512VLBWINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512BW__)GCC target("avx512vl,avx512bw")/* _AVX512VLBWINTRIN_H_INCLUDED *//* __DISABLE_AVX512VLBW__ *//* __AVX512VLBW__ */_mm256_maskz_insertf64x2__builtin_ia32_insertf64x2_256_mask_mm256_mask_insertf64x2_mm256_insertf64x2_mm256_maskz_inserti64x2__builtin_ia32_inserti64x2_256_mask_mm256_mask_inserti64x2_mm256_inserti64x2_mm_fpclass_ps_mask__builtin_ia32_fpclassps128_mask_mm_mask_fpclass_ps_mask_mm_fpclass_pd_mask__builtin_ia32_fpclasspd128_mask_mm_mask_fpclass_pd_mask_mm256_fpclass_ps_mask__builtin_ia32_fpclassps256_mask_mm256_mask_fpclass_ps_mask_mm256_fpclass_pd_mask__builtin_ia32_fpclasspd256_mask_mm256_mask_fpclass_pd_mask_mm_maskz_range_ps__builtin_ia32_rangeps128_mask_mm_mask_range_ps_mm_range_ps_mm256_maskz_range_ps__builtin_ia32_rangeps256_mask_mm256_mask_range_ps_mm256_range_ps_mm_maskz_range_pd__builtin_ia32_rangepd128_mask_mm_mask_range_pd_mm_range_pd_mm256_maskz_range_pd__builtin_ia32_rangepd256_mask_mm256_mask_range_pd_mm256_range_pd_mm_maskz_reduce_ps__builtin_ia32_reduceps128_mask_mm_mask_reduce_ps_mm_reduce_ps_mm256_maskz_reduce_ps__builtin_ia32_reduceps256_mask_mm256_mask_reduce_ps_mm256_reduce_ps_mm_maskz_reduce_pd__builtin_ia32_reducepd128_mask_mm_mask_reduce_pd_mm_reduce_pd_mm256_maskz_reduce_pd__builtin_ia32_reducepd256_mask_mm256_mask_reduce_pd_mm256_reduce_pd_mm256_maskz_extracti64x2_epi64__builtin_ia32_extracti64x2_256_mask_mm256_mask_extracti64x2_epi64_mm256_extracti64x2_epi64_mm256_maskz_extractf64x2_pd__builtin_ia32_extractf64x2_256_mask_mm256_mask_extractf64x2_pd_mm256_extractf64x2_pd_mm256_movepi64_mask__builtin_ia32_cvtq2mask256_mm_movepi64_mask__builtin_ia32_cvtq2mask128_mm256_movepi32_mask__builtin_ia32_cvtd2mask256_mm_movepi32_mask__builtin_ia32_cvtd2mask128_mm256_movm_epi64__builtin_ia32_cvtmask2q256_mm_movm_epi64__builtin_ia32_cvtmask2q128_mm256_movm_epi32__builtin_ia32_cvtmask2d256_mm_movm_epi32__builtin_ia32_cvtmask2d128_mm_maskz_or_ps__builtin_ia32_orps128_mask_mm_mask_or_ps_mm256_maskz_or_ps__builtin_ia32_orps256_mask_mm256_mask_or_ps_mm_maskz_or_pd__builtin_ia32_orpd128_mask_mm_mask_or_pd_mm256_maskz_or_pd__builtin_ia32_orpd256_mask_mm256_mask_or_pd_mm_maskz_xor_ps__builtin_ia32_xorps128_mask_mm_mask_xor_ps_mm256_maskz_xor_ps__builtin_ia32_xorps256_mask_mm256_mask_xor_ps_mm_maskz_xor_pd__builtin_ia32_xorpd128_mask_mm_mask_xor_pd_mm256_maskz_xor_pd__builtin_ia32_xorpd256_mask_mm256_mask_xor_pd_mm_maskz_cvtepu64_pd__builtin_ia32_cvtuqq2pd128_mask_mm_mask_cvtepu64_pd_mm_cvtepu64_pd_mm_maskz_and_ps__builtin_ia32_andps128_mask_mm_mask_and_ps_mm256_maskz_and_ps__builtin_ia32_andps256_mask_mm256_mask_and_ps_mm_maskz_and_pd__builtin_ia32_andpd128_mask_mm_mask_and_pd_mm256_maskz_and_pd__builtin_ia32_andpd256_mask_mm256_mask_and_pd_mm256_maskz_cvtepu64_pd__builtin_ia32_cvtuqq2pd256_mask_mm256_mask_cvtepu64_pd_mm256_cvtepu64_pd_mm_maskz_cvtepi64_pd__builtin_ia32_cvtqq2pd128_mask_mm_mask_cvtepi64_pd_mm_cvtepi64_pd_mm256_maskz_cvtepi64_pd__builtin_ia32_cvtqq2pd256_mask_mm256_mask_cvtepi64_pd_mm256_cvtepi64_pd_mm_maskz_cvtepu64_ps__builtin_ia32_cvtuqq2ps128_mask_mm_mask_cvtepu64_ps_mm_cvtepu64_ps_mm256_maskz_cvtepu64_ps__builtin_ia32_cvtuqq2ps256_mask_mm256_mask_cvtepu64_ps_mm256_cvtepu64_ps_mm_maskz_cvtepi64_ps__builtin_ia32_cvtqq2ps128_mask_mm_mask_cvtepi64_ps_mm_cvtepi64_ps_mm256_maskz_cvtepi64_ps__builtin_ia32_cvtqq2ps256_mask_mm256_mask_cvtepi64_ps_mm256_cvtepi64_ps_mm_maskz_cvtps_epu64__builtin_ia32_cvtps2uqq128_mask_mm_mask_cvtps_epu64_mm_cvtps_epu64_mm256_maskz_cvtps_epu64__builtin_ia32_cvtps2uqq256_mask_mm256_mask_cvtps_epu64_mm256_cvtps_epu64_mm_maskz_cvtps_epi64__builtin_ia32_cvtps2qq128_mask_mm_mask_cvtps_epi64_mm_cvtps_epi64_mm256_maskz_cvtps_epi64__builtin_ia32_cvtps2qq256_mask_mm256_mask_cvtps_epi64_mm256_cvtps_epi64_mm_maskz_andnot_ps__builtin_ia32_andnps128_mask_mm_mask_andnot_ps_mm256_maskz_andnot_ps__builtin_ia32_andnps256_mask_mm256_mask_andnot_ps_mm_maskz_andnot_pd__builtin_ia32_andnpd128_mask_mm_mask_andnot_pd_mm256_maskz_andnot_pd__builtin_ia32_andnpd256_mask_mm256_mask_andnot_pd_mm_maskz_mullo_epi64__builtin_ia32_pmullq128_mask_mm_mask_mullo_epi64_mm_mullo_epi64_mm256_maskz_mullo_epi64__builtin_ia32_pmullq256_mask_mm256_mask_mullo_epi64_mm256_mullo_epi64_mm_maskz_broadcast_i32x2__builtin_ia32_broadcasti32x2_128_mask_mm_mask_broadcast_i32x2_mm_broadcast_i32x2_mm256_maskz_broadcast_i32x2__builtin_ia32_broadcasti32x2_256_mask_mm256_mask_broadcast_i32x2_mm256_broadcast_i32x2_mm256_maskz_broadcast_f32x2__builtin_ia32_broadcastf32x2_256_mask_mm256_mask_broadcast_f32x2_mm256_broadcast_f32x2_mm256_maskz_broadcast_i64x2__builtin_ia32_broadcasti64x2_256_mask_mm256_mask_broadcast_i64x2_mm256_broadcast_i64x2_mm256_maskz_broadcast_f64x2__builtin_ia32_broadcastf64x2_256_mask_mm256_mask_broadcast_f64x2_mm256_broadcast_f64x2_mm_maskz_cvttps_epu64__builtin_ia32_cvttps2uqq128_mask_mm_mask_cvttps_epu64_mm_cvttps_epu64_mm256_maskz_cvttps_epu64__builtin_ia32_cvttps2uqq256_mask_mm256_mask_cvttps_epu64_mm256_cvttps_epu64_mm_maskz_cvttps_epi64__builtin_ia32_cvttps2qq128_mask_mm_mask_cvttps_epi64_mm_cvttps_epi64_mm256_maskz_cvttps_epi64__builtin_ia32_cvttps2qq256_mask_mm256_mask_cvttps_epi64_mm256_cvttps_epi64_mm_maskz_cvtpd_epu64__builtin_ia32_cvtpd2uqq128_mask_mm_mask_cvtpd_epu64_mm_cvtpd_epu64_mm256_maskz_cvtpd_epu64__builtin_ia32_cvtpd2uqq256_mask_mm256_mask_cvtpd_epu64_mm256_cvtpd_epu64_mm_maskz_cvtpd_epi64__builtin_ia32_cvtpd2qq128_mask_mm_mask_cvtpd_epi64_mm_cvtpd_epi64_mm256_maskz_cvtpd_epi64__builtin_ia32_cvtpd2qq256_mask_mm256_mask_cvtpd_epi64_mm256_cvtpd_epi64_mm_maskz_cvttpd_epu64__builtin_ia32_cvttpd2uqq128_mask_mm_mask_cvttpd_epu64_mm_cvttpd_epu64_mm256_maskz_cvttpd_epu64__builtin_ia32_cvttpd2uqq256_mask_mm256_mask_cvttpd_epu64_mm256_cvttpd_epu64_mm_maskz_cvttpd_epi64__builtin_ia32_cvttpd2qq128_mask_mm_mask_cvttpd_epi64_mm_cvttpd_epi64_mm256_maskz_cvttpd_epi64__builtin_ia32_cvttpd2qq256_mask_mm256_mask_cvttpd_epi64_mm256_cvttpd_epi64__DISABLE_AVX512VLDQ___AVX512VLDQINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512DQ__)GCC target("avx512vl,avx512dq")/* _AVX512VLDQINTRIN_H_INCLUDED *//* __DISABLE_AVX512VLDQ__ *//* __AVX512VLDQ__ */_mm512_maskz_madd52hi_epu64__builtin_ia32_vpmadd52huq512_maskz_mm512_maskz_madd52lo_epu64__builtin_ia32_vpmadd52luq512_maskz_mm512_mask_madd52hi_epu64__builtin_ia32_vpmadd52huq512_mask_mm512_mask_madd52lo_epu64__builtin_ia32_vpmadd52luq512_mask_mm512_madd52hi_epu64_mm512_madd52lo_epu64__DISABLE_AVX512IFMA___AVX512IFMAINTRIN_H_INCLUDED__AVX512IFMA__GCC target("avx512ifma")/* _AVX512IFMAINTRIN_H_INCLUDED *//* __DISABLE_AVX512IFMA__ *//* __AVX512IFMA__ */_mm256_maskz_madd52hi_epu64__builtin_ia32_vpmadd52huq256_maskz_mm256_maskz_madd52lo_epu64__builtin_ia32_vpmadd52luq256_maskz_mm_maskz_madd52hi_epu64__builtin_ia32_vpmadd52huq128_maskz_mm_maskz_madd52lo_epu64__builtin_ia32_vpmadd52luq128_maskz_mm256_mask_madd52hi_epu64__builtin_ia32_vpmadd52huq256_mask_mm256_mask_madd52lo_epu64__builtin_ia32_vpmadd52luq256_mask_mm_mask_madd52hi_epu64__builtin_ia32_vpmadd52huq128_mask_mm_mask_madd52lo_epu64__builtin_ia32_vpmadd52luq128_mask_mm256_madd52hi_epu64_mm256_madd52lo_epu64_mm_madd52hi_epu64_mm_madd52lo_epu64__DISABLE_AVX512IFMAVL___AVX512IFMAVLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512IFMA__)GCC target("avx512ifma,avx512vl")/* _AVX512IFMAVLINTRIN_H_INCLUDED *//* __DISABLE_AVX512IFMAVL__ *//* __AVX512IFMAVL__ */_mm512_maskz_permutex2var_epi8__builtin_ia32_vpermt2varqi512_maskz_mm512_mask2_permutex2var_epi8__builtin_ia32_vpermi2varqi512_mask_mm512_mask_permutex2var_epi8__builtin_ia32_vpermt2varqi512_mask_mm512_permutex2var_epi8_mm512_mask_permutexvar_epi8__builtin_ia32_permvarqi512_mask_mm512_maskz_permutexvar_epi8_mm512_permutexvar_epi8_mm512_multishift_epi64_epi8__builtin_ia32_vpmultishiftqb512_mask_mm512_maskz_multishift_epi64_epi8_mm512_mask_multishift_epi64_epi8__DISABLE_AVX512VBMI___AVX512VBMIINTRIN_H_INCLUDED__AVX512VBMI__GCC target("avx512vbmi")/* _AVX512VBMIINTRIN_H_INCLUDED *//* __DISABLE_AVX512VBMI__ *//* __AVX512VBMI__ */_mm_maskz_permutex2var_epi8__builtin_ia32_vpermt2varqi128_maskz_mm_mask2_permutex2var_epi8__builtin_ia32_vpermi2varqi128_mask_mm_mask_permutex2var_epi8__builtin_ia32_vpermt2varqi128_mask_mm_permutex2var_epi8_mm256_maskz_permutex2var_epi8__builtin_ia32_vpermt2varqi256_maskz_mm256_mask2_permutex2var_epi8__builtin_ia32_vpermi2varqi256_mask_mm256_mask_permutex2var_epi8__builtin_ia32_vpermt2varqi256_mask_mm256_permutex2var_epi8_mm_mask_permutexvar_epi8__builtin_ia32_permvarqi128_mask_mm_maskz_permutexvar_epi8_mm_permutexvar_epi8_mm256_mask_permutexvar_epi8__builtin_ia32_permvarqi256_mask_mm256_maskz_permutexvar_epi8_mm256_permutexvar_epi8_mm_multishift_epi64_epi8__builtin_ia32_vpmultishiftqb128_mask_mm_maskz_multishift_epi64_epi8_mm_mask_multishift_epi64_epi8_mm256_multishift_epi64_epi8__builtin_ia32_vpmultishiftqb256_mask_mm256_maskz_multishift_epi64_epi8_mm256_mask_multishift_epi64_epi8__DISABLE_AVX512VBMIVL___AVX512VBMIVLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512VBMI__)GCC target("avx512vbmi,avx512vl")/* _AVX512VBMIVLINTRIN_H_INCLUDED *//* __DISABLE_AVX512VBMIVL__ *//* __AVX512VBMIVL__ */_mm_maskz_4fnmadd_ss__builtin_ia32_4fnmaddss_mask_mm_mask_4fnmadd_ss_mm_4fnmadd_ss__builtin_ia32_4fnmaddss_mm512_maskz_4fnmadd_ps__builtin_ia32_4fnmaddps_mask_mm512_mask_4fnmadd_ps_mm512_4fnmadd_ps__builtin_ia32_4fnmaddps_mm_maskz_4fmadd_ss__builtin_ia32_4fmaddss_mask_mm_mask_4fmadd_ss_mm_4fmadd_ss__builtin_ia32_4fmaddss_mm512_maskz_4fmadd_ps__builtin_ia32_4fmaddps_mask_mm512_mask_4fmadd_ps_mm512_4fmadd_ps__builtin_ia32_4fmaddps__DISABLE_AVX5124FMAPS___AVX5124FMAPSINTRIN_H_INCLUDED!defined _IMMINTRIN_H_INCLUDED__AVX5124FMAPS__GCC target("avx5124fmaps")/* _AVX5124FMAPSINTRIN_H_INCLUDED *//* __DISABLE_AVX5124FMAPS__ *//* __AVX5124FMAPS__ */_mm512_maskz_4dpwssds_epi32__builtin_ia32_vp4dpwssds_mask_mm512_mask_4dpwssds_epi32_mm512_4dpwssds_epi32__builtin_ia32_vp4dpwssds_mm512_maskz_4dpwssd_epi32__builtin_ia32_vp4dpwssd_mask_mm512_mask_4dpwssd_epi32_mm512_4dpwssd_epi32__builtin_ia32_vp4dpwssd__DISABLE_AVX5124VNNIW___AVX5124VNNIWINTRIN_H_INCLUDED__AVX5124VNNIW__GCC target("avx5124vnniw")/* _AVX5124VNNIWINTRIN_H_INCLUDED *//* __DISABLE_AVX5124VNNIW__ *//* __AVX5124VNNIW__ */_mm512_maskz_popcnt_epi64__builtin_ia32_vpopcountq_v8di_mask_mm512_mask_popcnt_epi64_mm512_popcnt_epi64__builtin_ia32_vpopcountq_v8di_mm512_maskz_popcnt_epi32__builtin_ia32_vpopcountd_v16si_mask_mm512_mask_popcnt_epi32_mm512_popcnt_epi32__builtin_ia32_vpopcountd_v16si__DISABLE_AVX512VPOPCNTDQ___AVX512VPOPCNTDQINTRIN_H_INCLUDED__AVX512VPOPCNTDQ__GCC target("avx512vpopcntdq")/* _AVX512VPOPCNTDQINTRIN_H_INCLUDED *//* __DISABLE_AVX512VPOPCNTDQ__ *//* __AVX512VPOPCNTDQ__ */_mm512_maskz_shldv_epi16__builtin_ia32_vpshldv_v32hi_maskz_mm512_mask_shldv_epi16__builtin_ia32_vpshldv_v32hi_mask_mm512_maskz_shrdv_epi16__builtin_ia32_vpshrdv_v32hi_maskz_mm512_mask_shrdv_epi16__builtin_ia32_vpshrdv_v32hi_mask_mm512_maskz_shldi_epi16__builtin_ia32_vpshld_v32hi_mask_mm512_mask_shldi_epi16_mm512_maskz_shrdi_epi16__builtin_ia32_vpshrd_v32hi_mask_mm512_mask_shrdi_epi16_mm512_maskz_expandloadu_epi16__builtin_ia32_expandloadhi512_maskzconst __attribute((vector_size(64))) shortconst __attribute((vector_size(64))) short *const __v32hiconst __v32hi *_mm512_mask_expandloadu_epi16__builtin_ia32_expandloadhi512_mask_mm512_maskz_expand_epi16__builtin_ia32_expandhi512_maskz_mm512_mask_expand_epi16__builtin_ia32_expandhi512_mask_mm512_maskz_expandloadu_epi8__builtin_ia32_expandloadqi512_maskzconst __attribute((vector_size(64))) charconst __attribute((vector_size(64))) char *const __v64qiconst __v64qi *_mm512_mask_expandloadu_epi8__builtin_ia32_expandloadqi512_mask_mm512_maskz_expand_epi8__builtin_ia32_expandqi512_maskz_mm512_mask_expand_epi8__builtin_ia32_expandqi512_mask_mm512_mask_compressstoreu_epi16__builtin_ia32_compressstoreuhi512_mask__v32hi *_mm512_maskz_compress_epi16__builtin_ia32_compresshi512_mask_mm512_mask_compress_epi16_mm512_mask_compressstoreu_epi8__builtin_ia32_compressstoreuqi512_mask__v64qi *_mm512_maskz_compress_epi8__builtin_ia32_compressqi512_mask_mm512_mask_compress_epi8_mm512_maskz_shldv_epi64__builtin_ia32_vpshldv_v8di_maskz_mm512_mask_shldv_epi64__builtin_ia32_vpshldv_v8di_mask_mm512_shldv_epi64__builtin_ia32_vpshldv_v8di_mm512_maskz_shldv_epi32__builtin_ia32_vpshldv_v16si_maskz_mm512_mask_shldv_epi32__builtin_ia32_vpshldv_v16si_mask_mm512_shldv_epi32__builtin_ia32_vpshldv_v16si_mm512_shldv_epi16__builtin_ia32_vpshldv_v32hi_mm512_maskz_shrdv_epi64__builtin_ia32_vpshrdv_v8di_maskz_mm512_mask_shrdv_epi64__builtin_ia32_vpshrdv_v8di_mask_mm512_shrdv_epi64__builtin_ia32_vpshrdv_v8di_mm512_maskz_shrdv_epi32__builtin_ia32_vpshrdv_v16si_maskz_mm512_mask_shrdv_epi32__builtin_ia32_vpshrdv_v16si_mask_mm512_shrdv_epi32__builtin_ia32_vpshrdv_v16si_mm512_shrdv_epi16__builtin_ia32_vpshrdv_v32hi_mm512_maskz_shldi_epi64__builtin_ia32_vpshld_v8di_mask_mm512_mask_shldi_epi64_mm512_shldi_epi64__builtin_ia32_vpshld_v8di_mm512_maskz_shldi_epi32__builtin_ia32_vpshld_v16si_mask_mm512_mask_shldi_epi32_mm512_shldi_epi32__builtin_ia32_vpshld_v16si_mm512_shldi_epi16__builtin_ia32_vpshld_v32hi_mm512_maskz_shrdi_epi64__builtin_ia32_vpshrd_v8di_mask_mm512_mask_shrdi_epi64_mm512_shrdi_epi64__builtin_ia32_vpshrd_v8di_mm512_maskz_shrdi_epi32__builtin_ia32_vpshrd_v16si_mask_mm512_mask_shrdi_epi32_mm512_shrdi_epi32__builtin_ia32_vpshrd_v16si_mm512_shrdi_epi16__builtin_ia32_vpshrd_v32hi__DISABLE_AVX512VBMI2BW____DISABLE_AVX512VBMI2____AVX512VBMI2INTRIN_H_INCLUDED!defined(__AVX512VBMI2__)GCC target("avx512vbmi2")!defined(__AVX512VBMI2__) || !defined(__AVX512BW__)GCC target("avx512vbmi2,avx512bw")/* __AVX512VBMI2INTRIN_H_INCLUDED *//* __DISABLE_AVX512VBMI2BW__ *//* __AVX512VBMI2BW__ *//* __DISABLE_AVX512VBMI2__ *//* __AVX512VBMI2__ */_mm256_maskz_expandloadu_epi8__builtin_ia32_expandloadqi256_maskzconst __attribute((vector_size(32))) charconst __attribute((vector_size(32))) char *const __v32qiconst __v32qi *_mm256_mask_expandloadu_epi8__builtin_ia32_expandloadqi256_mask_mm256_maskz_expand_epi8__builtin_ia32_expandqi256_maskz_mm256_mask_expand_epi8__builtin_ia32_expandqi256_mask_mm256_mask_compressstoreu_epi8__builtin_ia32_compressstoreuqi256_mask_mm256_maskz_compress_epi8__builtin_ia32_compressqi256_mask_mm256_mask_compress_epi8_mm_maskz_shldv_epi64__builtin_ia32_vpshldv_v2di_maskz_mm_mask_shldv_epi64__builtin_ia32_vpshldv_v2di_mask_mm_shldv_epi64__builtin_ia32_vpshldv_v2di_mm_maskz_shldv_epi32__builtin_ia32_vpshldv_v4si_maskz_mm_mask_shldv_epi32__builtin_ia32_vpshldv_v4si_mask_mm_shldv_epi32__builtin_ia32_vpshldv_v4si_mm_maskz_shldv_epi16__builtin_ia32_vpshldv_v8hi_maskz_mm_mask_shldv_epi16__builtin_ia32_vpshldv_v8hi_mask_mm_shldv_epi16__builtin_ia32_vpshldv_v8hi_mm256_maskz_shldv_epi64__builtin_ia32_vpshldv_v4di_maskz_mm256_mask_shldv_epi64__builtin_ia32_vpshldv_v4di_mask_mm256_shldv_epi64__builtin_ia32_vpshldv_v4di_mm256_maskz_shldv_epi32__builtin_ia32_vpshldv_v8si_maskz_mm256_mask_shldv_epi32__builtin_ia32_vpshldv_v8si_mask_mm256_shldv_epi32__builtin_ia32_vpshldv_v8si_mm256_maskz_shldv_epi16__builtin_ia32_vpshldv_v16hi_maskz_mm256_mask_shldv_epi16__builtin_ia32_vpshldv_v16hi_mask_mm256_shldv_epi16__builtin_ia32_vpshldv_v16hi_mm_maskz_shrdv_epi64__builtin_ia32_vpshrdv_v2di_maskz_mm_mask_shrdv_epi64__builtin_ia32_vpshrdv_v2di_mask_mm_shrdv_epi64__builtin_ia32_vpshrdv_v2di_mm_maskz_shrdv_epi32__builtin_ia32_vpshrdv_v4si_maskz_mm_mask_shrdv_epi32__builtin_ia32_vpshrdv_v4si_mask_mm_shrdv_epi32__builtin_ia32_vpshrdv_v4si_mm_maskz_shrdv_epi16__builtin_ia32_vpshrdv_v8hi_maskz_mm_mask_shrdv_epi16__builtin_ia32_vpshrdv_v8hi_mask_mm_shrdv_epi16__builtin_ia32_vpshrdv_v8hi_mm256_maskz_shrdv_epi64__builtin_ia32_vpshrdv_v4di_maskz_mm256_mask_shrdv_epi64__builtin_ia32_vpshrdv_v4di_mask_mm256_shrdv_epi64__builtin_ia32_vpshrdv_v4di_mm256_maskz_shrdv_epi32__builtin_ia32_vpshrdv_v8si_maskz_mm256_mask_shrdv_epi32__builtin_ia32_vpshrdv_v8si_mask_mm256_shrdv_epi32__builtin_ia32_vpshrdv_v8si_mm256_maskz_shrdv_epi16__builtin_ia32_vpshrdv_v16hi_maskz_mm256_mask_shrdv_epi16__builtin_ia32_vpshrdv_v16hi_mask_mm256_shrdv_epi16__builtin_ia32_vpshrdv_v16hi_mm_shldi_epi64__builtin_ia32_vpshld_v2di_mm_maskz_shldi_epi64__builtin_ia32_vpshld_v2di_mask_mm_mask_shldi_epi64_mm_shldi_epi32__builtin_ia32_vpshld_v4si_mm_maskz_shldi_epi32__builtin_ia32_vpshld_v4si_mask_mm_mask_shldi_epi32_mm_shldi_epi16__builtin_ia32_vpshld_v8hi_mm_maskz_shldi_epi16__builtin_ia32_vpshld_v8hi_mask_mm_mask_shldi_epi16_mm256_shldi_epi64__builtin_ia32_vpshld_v4di_mm256_maskz_shldi_epi64__builtin_ia32_vpshld_v4di_mask_mm256_mask_shldi_epi64_mm256_shldi_epi32__builtin_ia32_vpshld_v8si_mm256_maskz_shldi_epi32__builtin_ia32_vpshld_v8si_mask_mm256_mask_shldi_epi32_mm256_maskz_shldi_epi16__builtin_ia32_vpshld_v16hi_mask_mm256_mask_shldi_epi16_mm256_shldi_epi16__builtin_ia32_vpshld_v16hi_mm_shrdi_epi64__builtin_ia32_vpshrd_v2di_mm_maskz_shrdi_epi64__builtin_ia32_vpshrd_v2di_mask_mm_mask_shrdi_epi64_mm_shrdi_epi32__builtin_ia32_vpshrd_v4si_mm_maskz_shrdi_epi32__builtin_ia32_vpshrd_v4si_mask_mm_mask_shrdi_epi32_mm_shrdi_epi16__builtin_ia32_vpshrd_v8hi_mm_maskz_shrdi_epi16__builtin_ia32_vpshrd_v8hi_mask_mm_mask_shrdi_epi16_mm256_shrdi_epi64__builtin_ia32_vpshrd_v4di_mm256_maskz_shrdi_epi64__builtin_ia32_vpshrd_v4di_mask_mm256_mask_shrdi_epi64_mm256_shrdi_epi32__builtin_ia32_vpshrd_v8si_mm256_maskz_shrdi_epi32__builtin_ia32_vpshrd_v8si_mask_mm256_mask_shrdi_epi32_mm256_maskz_shrdi_epi16__builtin_ia32_vpshrd_v16hi_mask_mm256_mask_shrdi_epi16_mm256_shrdi_epi16__builtin_ia32_vpshrd_v16hi_mm256_maskz_expandloadu_epi16__builtin_ia32_expandloadhi256_maskzconst __attribute((vector_size(32))) shortconst __attribute((vector_size(32))) short *const __v16hiconst __v16hi *_mm256_mask_expandloadu_epi16__builtin_ia32_expandloadhi256_mask_mm256_maskz_expand_epi16__builtin_ia32_expandhi256_maskz_mm256_mask_expand_epi16__builtin_ia32_expandhi256_mask_mm_maskz_expandloadu_epi16__builtin_ia32_expandloadhi128_maskzconst __attribute((vector_size(16))) shortconst __attribute((vector_size(16))) short *const __v8hiconst __v8hi *_mm_mask_expandloadu_epi16__builtin_ia32_expandloadhi128_mask_mm_maskz_expand_epi16__builtin_ia32_expandhi128_maskz_mm_mask_expand_epi16__builtin_ia32_expandhi128_mask_mm_maskz_expandloadu_epi8__builtin_ia32_expandloadqi128_maskzconst __attribute((vector_size(16))) charconst __attribute((vector_size(16))) char *const __v16qiconst __v16qi *_mm_mask_expandloadu_epi8__builtin_ia32_expandloadqi128_mask_mm_maskz_expand_epi8__builtin_ia32_expandqi128_maskz_mm_mask_expand_epi8__builtin_ia32_expandqi128_mask_mm_mask_compressstoreu_epi16__builtin_ia32_compressstoreuhi128_mask_mm_mask_compressstoreu_epi8__builtin_ia32_compressstoreuqi128_mask_mm256_maskz_compress_epi16__builtin_ia32_compresshi256_mask_mm256_mask_compress_epi16_mm_maskz_compress_epi16__builtin_ia32_compresshi128_mask_mm_mask_compress_epi16_mm256_mask_compressstoreu_epi16__builtin_ia32_compressstoreuhi256_mask_mm_maskz_compress_epi8__builtin_ia32_compressqi128_mask_mm_mask_compress_epi8__DISABLE_AVX512VBMI2VLBW____DISABLE_AVX512VBMI2VL___AVX512VBMI2VLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512VBMI2__)GCC target("avx512vbmi2,avx512vl")!defined(__AVX512VL__) || !defined(__AVX512VBMI2__) || \GCC target("avx512vbmi2,avx512vl,avx512bw")/* __DISABLE_AVX512VBMIVLBW__ *//* __AVX512VBMIVLBW__ */_mm512_maskz_dpwssds_epi32__builtin_ia32_vpdpwssds_v16si_maskz_mm512_mask_dpwssds_epi32__builtin_ia32_vpdpwssds_v16si_mask_mm512_dpwssds_epi32__builtin_ia32_vpdpwssds_v16si_mm512_maskz_dpwssd_epi32__builtin_ia32_vpdpwssd_v16si_maskz_mm512_mask_dpwssd_epi32__builtin_ia32_vpdpwssd_v16si_mask_mm512_dpwssd_epi32__builtin_ia32_vpdpwssd_v16si_mm512_maskz_dpbusds_epi32__builtin_ia32_vpdpbusds_v16si_maskz_mm512_mask_dpbusds_epi32__builtin_ia32_vpdpbusds_v16si_mask_mm512_dpbusds_epi32__builtin_ia32_vpdpbusds_v16si_mm512_maskz_dpbusd_epi32__builtin_ia32_vpdpbusd_v16si_maskz_mm512_mask_dpbusd_epi32__builtin_ia32_vpdpbusd_v16si_mask_mm512_dpbusd_epi32__builtin_ia32_vpdpbusd_v16si__DISABLE_AVX512VNNI____AVX512VNNIINTRIN_H_INCLUDED!defined(__AVX512VNNI__)GCC target("avx512vnni")/* __AVX512VNNIINTRIN_H_INCLUDED *//* __DISABLE_AVX512VNNI__ *//* __AVX512VNNI__ */_mm_maskz_dpwssds_epi32__builtin_ia32_vpdpwssds_v4si_maskz_mm_mask_dpwssds_epi32__builtin_ia32_vpdpwssds_v4si_mask_mm256_maskz_dpwssds_epi32__builtin_ia32_vpdpwssds_v8si_maskz_mm256_mask_dpwssds_epi32__builtin_ia32_vpdpwssds_v8si_mask_mm_maskz_dpwssd_epi32__builtin_ia32_vpdpwssd_v4si_maskz_mm_mask_dpwssd_epi32__builtin_ia32_vpdpwssd_v4si_mask_mm256_maskz_dpwssd_epi32__builtin_ia32_vpdpwssd_v8si_maskz_mm256_mask_dpwssd_epi32__builtin_ia32_vpdpwssd_v8si_mask_mm_maskz_dpbusds_epi32__builtin_ia32_vpdpbusds_v4si_maskz_mm_mask_dpbusds_epi32__builtin_ia32_vpdpbusds_v4si_mask_mm256_maskz_dpbusds_epi32__builtin_ia32_vpdpbusds_v8si_maskz_mm256_mask_dpbusds_epi32__builtin_ia32_vpdpbusds_v8si_mask_mm_maskz_dpbusd_epi32__builtin_ia32_vpdpbusd_v4si_maskz_mm_mask_dpbusd_epi32__builtin_ia32_vpdpbusd_v4si_mask_mm256_maskz_dpbusd_epi32__builtin_ia32_vpdpbusd_v8si_maskz_mm256_mask_dpbusd_epi32__builtin_ia32_vpdpbusd_v8si_mask__DISABLE_AVX512VNNIVL___mm_dpwssds_epi32(A,B,C)((__m128i) __builtin_ia32_vpdpwssds_v4si ((__v4si) (A), (__v4si) (B), (__v4si) (C)))_mm256_dpwssds_epi32(A,B,C)((__m256i) __builtin_ia32_vpdpwssds_v8si ((__v8si) (A), (__v8si) (B), (__v8si) (C)))_mm_dpwssd_epi32(A,B,C)((__m128i) __builtin_ia32_vpdpwssd_v4si ((__v4si) (A), (__v4si) (B), (__v4si) (C)))_mm256_dpwssd_epi32(A,B,C)((__m256i) __builtin_ia32_vpdpwssd_v8si ((__v8si) (A), (__v8si) (B), (__v8si) (C)))_mm_dpbusds_epi32(A,B,C)((__m128i) __builtin_ia32_vpdpbusds_v4si ((__v4si) (A), (__v4si) (B), (__v4si) (C)))_mm256_dpbusds_epi32(A,B,C)((__m256i) __builtin_ia32_vpdpbusds_v8si ((__v8si) (A), (__v8si) (B), (__v8si) (C)))_mm_dpbusd_epi32(A,B,C)((__m128i) __builtin_ia32_vpdpbusd_v4si ((__v4si) (A), (__v4si) (B), (__v4si) (C)))_mm256_dpbusd_epi32(A,B,C)((__m256i) __builtin_ia32_vpdpbusd_v8si ((__v8si) (A), (__v8si) (B), (__v8si) (C)))_AVX512VNNIVLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512VNNI__)GCC target("avx512vnni,avx512vl")/* __DISABLE_AVX512VNNIVL__ *//* __AVX512VNNIVL__ */_mm256_maskz_popcnt_epi64__builtin_ia32_vpopcountq_v4di_mask_mm256_mask_popcnt_epi64_mm256_popcnt_epi64__builtin_ia32_vpopcountq_v4di_mm_maskz_popcnt_epi64__builtin_ia32_vpopcountq_v2di_mask_mm_mask_popcnt_epi64_mm_popcnt_epi64__builtin_ia32_vpopcountq_v2di_mm256_maskz_popcnt_epi32__builtin_ia32_vpopcountd_v8si_mask_mm256_mask_popcnt_epi32_mm256_popcnt_epi32__builtin_ia32_vpopcountd_v8si_mm_maskz_popcnt_epi32__builtin_ia32_vpopcountd_v4si_mask_mm_mask_popcnt_epi32_mm_popcnt_epi32__builtin_ia32_vpopcountd_v4si__DISABLE_AVX512VPOPCNTDQVL___AVX512VPOPCNTDQVLINTRIN_H_INCLUDED!defined(__AVX512VPOPCNTDQ__) || !defined(__AVX512VL__)GCC target("avx512vpopcntdq,avx512vl")/* _AVX512VPOPCNTDQVLINTRIN_H_INCLUDED *//* __DISABLE_AVX512VPOPCNTDQVL__ *//* __AVX512VPOPCNTDQVL__ */_mm_maskz_popcnt_epi16__builtin_ia32_vpopcountw_v8hi_mask_mm_mask_popcnt_epi16_mm_maskz_popcnt_epi8__builtin_ia32_vpopcountb_v16qi_mask_mm_mask_popcnt_epi8_mm256_maskz_popcnt_epi16__builtin_ia32_vpopcountw_v16hi_mask_mm256_mask_popcnt_epi16_mm_popcnt_epi16__builtin_ia32_vpopcountw_v8hi_mm_popcnt_epi8__builtin_ia32_vpopcountb_v16qi_mm256_popcnt_epi16__builtin_ia32_vpopcountw_v16hi_mm256_popcnt_epi8__builtin_ia32_vpopcountb_v32qi_mm_mask_bitshuffle_epi64_mask__builtin_ia32_vpshufbitqmb128_mask_mm_bitshuffle_epi64_mask_mm256_mask_bitshuffle_epi64_mask__builtin_ia32_vpshufbitqmb256_mask_mm256_bitshuffle_epi64_mask_mm256_maskz_popcnt_epi8__builtin_ia32_vpopcountb_v32qi_mask_mm256_mask_popcnt_epi8_mm512_mask_bitshuffle_epi64_mask__builtin_ia32_vpshufbitqmb512_mask_mm512_bitshuffle_epi64_mask_mm512_maskz_popcnt_epi16__builtin_ia32_vpopcountw_v32hi_mask_mm512_mask_popcnt_epi16_mm512_maskz_popcnt_epi8__builtin_ia32_vpopcountb_v64qi_mask_mm512_mask_popcnt_epi8_mm512_popcnt_epi16__builtin_ia32_vpopcountw_v32hi_mm512_popcnt_epi8__builtin_ia32_vpopcountb_v64qi__DISABLE_AVX512BITALGVL____DISABLE_AVX512BITALGVLBW____DISABLE_AVX512BITALGBW____DISABLE_AVX512BITALG___AVX512BITALGINTRIN_H_INCLUDED__AVX512BITALG__GCC target("avx512bitalg")!defined(__AVX512BITALG__) || !defined(__AVX512BW__)GCC target("avx512bitalg,avx512bw")!defined(__AVX512BITALG__) || !defined(__AVX512VL__) || !defined(__AVX512BW__)GCC target("avx512bitalg,avx512vl,avx512bw")!defined(__AVX512BITALG__) || !defined(__AVX512VL__)GCC target("avx512bitalg,avx512vl")/* _AVX512BITALGINTRIN_H_INCLUDED *//* __DISABLE_AVX512BITALGBW__ *//* __DISABLE_AVX512BITALGVLBW__ *//* __DISABLE_AVX512BITALG__ *//* __AVX512BITALG__ */_mm512_2intersect_epi64__builtin_ia32_2intersectq512_mm512_2intersect_epi32__builtin_ia32_2intersectd512__DISABLE_AVX512VP2INTERSECT___AVX512VP2INTERSECTINTRIN_H_INCLUDED!defined(__AVX512VP2INTERSECT__)GCC target("avx512vp2intersect")/* _AVX512VP2INTERSECTINTRIN_H_INCLUDED *//* __DISABLE_AVX512VP2INTERSECT__ *//* __AVX512VP2INTERSECT__ */_mm256_2intersect_epi64__builtin_ia32_2intersectq256_mm_2intersect_epi64__builtin_ia32_2intersectq128_mm256_2intersect_epi32__builtin_ia32_2intersectd256_mm_2intersect_epi32__builtin_ia32_2intersectd128__DISABLE_AVX512VP2INTERSECTVL___AVX512VP2INTERSECTVLINTRIN_H_INCLUDED!defined(__AVX512VP2INTERSECT__) || !defined(__AVX512VL__)GCC target("avx512vp2intersect,avx512vl")/* _AVX512VP2INTERSECTVLINTRIN_H_INCLUDED *//* __DISABLE_AVX512VP2INTERSECTVL__ *//* __AVX512VP2INTERSECTVL__ */_mm512_set1_pch__u_mm512_permutexvar_ph(__mmask32)-1_mm512_permutex2var_ph_mm512_mask_blend_ph_mm512_reduce_max_phmax_mm512_reduce_min_phmin_mm512_reduce_mul_ph__attribute((vector_size(32))) _Float16__attribute((vector_size(16))) _Float16_mm512_reduce_add_ph_mm_maskz_fmul_round_sch__builtin_ia32_vfmulcsh_mask_round_mm_mask_fmul_round_sch_mm_fmul_round_sch__builtin_ia32_vfmulcsh_round_mm_maskz_fcmul_round_sch__builtin_ia32_vfcmulcsh_mask_round_mm_mask_fcmul_round_sch_mm_fcmul_round_sch__builtin_ia32_vfcmulcsh_round_mm_maskz_fmul_sch_mm_mask_fmul_sch_mm_fmul_sch_mm_maskz_fcmul_sch_mm_mask_fcmul_sch_mm_fcmul_sch_mm_fmadd_round_sch__builtin_ia32_vfmaddcsh_round_mm_maskz_fmadd_round_sch__builtin_ia32_vfmaddcsh_maskz_round_mm_mask3_fmadd_round_sch__builtin_ia32_vfmaddcsh_mask3_round_mm_mask_fmadd_round_sch__builtin_ia32_vfmaddcsh_mask_round_mm_fcmadd_round_sch__builtin_ia32_vfcmaddcsh_round_mm_maskz_fcmadd_round_sch__builtin_ia32_vfcmaddcsh_maskz_round_mm_mask3_fcmadd_round_sch__builtin_ia32_vfcmaddcsh_mask3_round_mm_mask_fcmadd_round_sch__builtin_ia32_vfcmaddcsh_mask_round_mm_fmadd_sch_mm_maskz_fmadd_sch_mm_mask3_fmadd_sch_mm_mask_fmadd_sch_mm_fcmadd_sch_mm_maskz_fcmadd_sch_mm_mask3_fcmadd_sch_mm_mask_fcmadd_sch_mm512_maskz_fmul_round_pch__builtin_ia32_vfmulcph512_mask_round__attribute((vector_size(64))) _Float16_mm512_mask_fmul_round_pch_mm512_fmul_round_pch__builtin_ia32_vfmulcph512_round_mm512_maskz_fcmul_round_pch__builtin_ia32_vfcmulcph512_mask_round_mm512_mask_fcmul_round_pch_mm512_fcmul_round_pch__builtin_ia32_vfcmulcph512_round_mm512_maskz_fmul_pch_mm512_mask_fmul_pch_mm512_fmul_pch_mm512_maskz_fcmul_pch_mm512_mask_fcmul_pch_mm512_fcmul_pch_mm512_maskz_fmadd_round_pch__builtin_ia32_vfmaddcph512_maskz_round_mm512_mask3_fmadd_round_pch__builtin_ia32_vfmaddcph512_mask3_round_mm512_mask_fmadd_round_pch__builtin_ia32_vfmaddcph512_mask_round_mm512_fmadd_round_pch__builtin_ia32_vfmaddcph512_round_mm512_maskz_fcmadd_round_pch__builtin_ia32_vfcmaddcph512_maskz_round_mm512_mask3_fcmadd_round_pch__builtin_ia32_vfcmaddcph512_mask3_round_mm512_mask_fcmadd_round_pch__builtin_ia32_vfcmaddcph512_mask_round_mm512_fcmadd_round_pch__builtin_ia32_vfcmaddcph512_round_mm512_maskz_fmadd_pch_mm512_mask3_fmadd_pch_mm512_mask_fmadd_pch_mm512_fmadd_pch_mm512_maskz_fcmadd_pch_mm512_mask3_fcmadd_pch_mm512_mask_fcmadd_pch_mm512_fcmadd_pch_mm_maskz_fnmsub_round_sh__builtin_ia32_vfmaddsh3_maskz_mm_mask3_fnmsub_round_sh__builtin_ia32_vfmsubsh3_mask3_mm_mask_fnmsub_round_sh__builtin_ia32_vfmaddsh3_mask_mm_fnmsub_round_sh_mm_maskz_fnmsub_sh_mm_mask3_fnmsub_sh_mm_mask_fnmsub_sh_mm_fnmsub_sh_mm_maskz_fmsub_round_sh_mm_mask3_fmsub_round_sh_mm_mask_fmsub_round_sh_mm_fmsub_round_sh_mm_maskz_fmsub_sh_mm_mask3_fmsub_sh_mm_mask_fmsub_sh_mm_fmsub_sh_mm_maskz_fnmadd_round_sh__builtin_ia32_vfnmaddsh3_maskz_mm_mask3_fnmadd_round_sh__builtin_ia32_vfnmaddsh3_mask3_mm_mask_fnmadd_round_sh__builtin_ia32_vfnmaddsh3_mask_mm_fnmadd_round_sh_mm_maskz_fnmadd_sh_mm_mask3_fnmadd_sh_mm_mask_fnmadd_sh_mm_fnmadd_sh_mm_maskz_fmadd_round_sh_mm_mask3_fmadd_round_sh__builtin_ia32_vfmaddsh3_mask3_mm_mask_fmadd_round_sh_mm_fmadd_round_sh_mm_maskz_fmadd_sh_mm_mask3_fmadd_sh_mm_mask_fmadd_sh_mm_fmadd_sh_mm512_maskz_fnmsub_round_ph__builtin_ia32_vfnmsubph512_maskz_mm512_mask3_fnmsub_round_ph__builtin_ia32_vfnmsubph512_mask3_mm512_mask_fnmsub_round_ph__builtin_ia32_vfnmsubph512_mask_mm512_fnmsub_round_ph_mm512_maskz_fnmsub_ph_mm512_mask3_fnmsub_ph_mm512_mask_fnmsub_ph_mm512_fnmsub_ph_mm512_maskz_fmsub_round_ph__builtin_ia32_vfmsubph512_maskz_mm512_mask3_fmsub_round_ph__builtin_ia32_vfmsubph512_mask3_mm512_mask_fmsub_round_ph__builtin_ia32_vfmsubph512_mask_mm512_fmsub_round_ph_mm512_maskz_fmsub_ph_mm512_mask3_fmsub_ph_mm512_mask_fmsub_ph_mm512_fmsub_ph_mm512_maskz_fnmadd_round_ph__builtin_ia32_vfnmaddph512_maskz_mm512_mask3_fnmadd_round_ph__builtin_ia32_vfnmaddph512_mask3_mm512_mask_fnmadd_round_ph__builtin_ia32_vfnmaddph512_mask_mm512_fnmadd_round_ph_mm512_maskz_fnmadd_ph_mm512_mask3_fnmadd_ph_mm512_mask_fnmadd_ph_mm512_fnmadd_ph_mm512_maskz_fmadd_round_ph__builtin_ia32_vfmaddph512_maskz_mm512_mask3_fmadd_round_ph__builtin_ia32_vfmaddph512_mask3_mm512_mask_fmadd_round_ph__builtin_ia32_vfmaddph512_mask_mm512_fmadd_round_ph_mm512_maskz_fmadd_ph_mm512_mask3_fmadd_ph_mm512_mask_fmadd_ph_mm512_fmadd_ph_mm512_maskz_fmsubadd_round_ph__builtin_ia32_vfmsubaddph512_maskz_mm512_mask3_fmsubadd_round_ph__builtin_ia32_vfmsubaddph512_mask3_mm512_mask_fmsubadd_round_ph__builtin_ia32_vfmsubaddph512_mask_mm512_fmsubadd_round_ph_mm512_maskz_fmsubadd_ph_mm512_mask3_fmsubadd_ph_mm512_mask_fmsubadd_ph_mm512_fmsubadd_ph_mm512_maskz_fmaddsub_round_ph__builtin_ia32_vfmaddsubph512_maskz_mm512_mask3_fmaddsub_round_ph__builtin_ia32_vfmaddsubph512_mask3_mm512_mask_fmaddsub_round_ph__builtin_ia32_vfmaddsubph512_mask_mm512_fmaddsub_round_ph_mm512_maskz_fmaddsub_ph_mm512_mask3_fmaddsub_ph_mm512_mask_fmaddsub_ph_mm512_fmaddsub_ph_mm_maskz_cvt_roundsd_sh__builtin_ia32_vcvtsd2sh_mask_round_mm_mask_cvt_roundsd_sh_mm_cvt_roundsd_sh_mm_maskz_cvt_roundss_sh__builtin_ia32_vcvtss2sh_mask_round_mm_mask_cvt_roundss_sh_mm_cvt_roundss_sh_mm_maskz_cvtsd_sh_mm_mask_cvtsd_sh_mm_cvtsd_sh_mm_maskz_cvtss_sh_mm_mask_cvtss_sh_mm_cvtss_sh_mm_maskz_cvt_roundsh_sd__builtin_ia32_vcvtsh2sd_mask_round_mm_mask_cvt_roundsh_sd_mm_cvt_roundsh_sd_mm_maskz_cvt_roundsh_ss__builtin_ia32_vcvtsh2ss_mask_round_mm_mask_cvt_roundsh_ss_mm_cvt_roundsh_ss_mm_maskz_cvtsh_sd_mm_mask_cvtsh_sd_mm_cvtsh_sd_mm_maskz_cvtsh_ss_mm_mask_cvtsh_ss_mm_cvtsh_ss_mm512_maskz_cvt_roundpd_ph__builtin_ia32_vcvtpd2ph512_mask_round_mm512_mask_cvt_roundpd_ph_mm512_cvt_roundpd_ph_mm512_maskz_cvtpd_ph_mm512_mask_cvtpd_ph_mm512_cvtpd_ph_mm512_maskz_cvtx_roundps_ph__builtin_ia32_vcvtps2phx512_mask_round_mm512_mask_cvtx_roundps_ph_mm512_cvtx_roundps_ph_mm512_maskz_cvtxps_ph_mm512_mask_cvtxps_ph_mm512_cvtxps_ph_mm512_maskz_cvtx_roundph_ps__builtin_ia32_vcvtph2psx512_mask_round_mm512_mask_cvtx_roundph_ps_mm512_cvtx_roundph_ps_mm512_maskz_cvtxph_ps_mm512_mask_cvtxph_ps_mm512_cvtxph_ps_mm512_maskz_cvt_roundph_pd__builtin_ia32_vcvtph2pd512_mask_round_mm512_mask_cvt_roundph_pd_mm512_cvt_roundph_pd_mm512_maskz_cvtph_pd_mm512_mask_cvtph_pd_mm512_cvtph_pd_mm_cvt_roundu64_sh__builtin_ia32_vcvtusi2sh64_round_mm_cvt_roundi64_sh__builtin_ia32_vcvtsi2sh64_round_mm_cvtu64_sh_mm_cvti64_sh_mm_cvt_roundu32_sh__builtin_ia32_vcvtusi2sh32_round_mm_cvt_roundi32_sh__builtin_ia32_vcvtsi2sh32_round_mm_cvtu32_sh_mm_cvti32_sh_mm_cvtt_roundsh_u64__builtin_ia32_vcvttsh2usi64_round_mm_cvtt_roundsh_i64__builtin_ia32_vcvttsh2si64_round_mm_cvttsh_u64_mm_cvttsh_i64_mm_cvtt_roundsh_u32__builtin_ia32_vcvttsh2usi32_round_mm_cvtt_roundsh_i32__builtin_ia32_vcvttsh2si32_round_mm_cvttsh_u32_mm_cvttsh_i32_mm_cvt_roundsh_u64__builtin_ia32_vcvtsh2usi64_round_mm_cvt_roundsh_i64__builtin_ia32_vcvtsh2si64_round_mm_cvtsh_u64_mm_cvtsh_i64_mm_cvt_roundsh_u32__builtin_ia32_vcvtsh2usi32_round_mm_cvt_roundsh_i32__builtin_ia32_vcvtsh2si32_round_mm_cvtsh_u32_mm_cvtsh_i32_mm512_maskz_cvt_roundepu16_ph__builtin_ia32_vcvtuw2ph512_mask_round_mm512_mask_cvt_roundepu16_ph_mm512_cvt_roundepu16_ph_mm512_maskz_cvtepu16_ph_mm512_mask_cvtepu16_ph_mm512_cvtepu16_ph_mm512_maskz_cvt_roundepi16_ph__builtin_ia32_vcvtw2ph512_mask_round_mm512_mask_cvt_roundepi16_ph_mm512_cvt_roundepi16_ph_mm512_maskz_cvtepi16_ph_mm512_mask_cvtepi16_ph_mm512_cvtepi16_ph_mm512_maskz_cvtt_roundph_epu16__builtin_ia32_vcvttph2uw512_mask_round_mm512_mask_cvtt_roundph_epu16_mm512_cvtt_roundph_epu16_mm512_maskz_cvttph_epu16_mm512_mask_cvttph_epu16_mm512_cvttph_epu16_mm512_maskz_cvtt_roundph_epi16__builtin_ia32_vcvttph2w512_mask_round_mm512_mask_cvtt_roundph_epi16_mm512_cvtt_roundph_epi16_mm512_maskz_cvttph_epi16_mm512_mask_cvttph_epi16_mm512_cvttph_epi16_mm512_maskz_cvt_roundph_epu16__builtin_ia32_vcvtph2uw512_mask_round_mm512_mask_cvt_roundph_epu16_mm512_cvt_roundph_epu16_mm512_maskz_cvtph_epu16_mm512_mask_cvtph_epu16_mm512_cvtph_epu16_mm512_maskz_cvt_roundph_epi16__builtin_ia32_vcvtph2w512_mask_round_mm512_mask_cvt_roundph_epi16_mm512_cvt_roundph_epi16_mm512_maskz_cvtph_epi16_mm512_mask_cvtph_epi16_mm512_cvtph_epi16_mm512_maskz_cvt_roundepu64_ph__builtin_ia32_vcvtuqq2ph512_mask_round_mm512_mask_cvt_roundepu64_ph_mm512_cvt_roundepu64_ph_mm512_maskz_cvtepu64_ph_mm512_mask_cvtepu64_ph_mm512_cvtepu64_ph_mm512_maskz_cvt_roundepi64_ph__builtin_ia32_vcvtqq2ph512_mask_round_mm512_mask_cvt_roundepi64_ph_mm512_cvt_roundepi64_ph_mm512_maskz_cvtepi64_ph_mm512_mask_cvtepi64_ph_mm512_cvtepi64_ph_mm512_maskz_cvtt_roundph_epu64__builtin_ia32_vcvttph2uqq512_mask_round_mm512_mask_cvtt_roundph_epu64_mm512_cvtt_roundph_epu64_mm512_maskz_cvttph_epu64_mm512_mask_cvttph_epu64_mm512_cvttph_epu64_mm512_maskz_cvtt_roundph_epi64__builtin_ia32_vcvttph2qq512_mask_round_mm512_mask_cvtt_roundph_epi64_mm512_cvtt_roundph_epi64_mm512_maskz_cvttph_epi64_mm512_mask_cvttph_epi64_mm512_cvttph_epi64_mm512_maskz_cvt_roundph_epu64__builtin_ia32_vcvtph2uqq512_mask_round_mm512_mask_cvt_roundph_epu64_mm512_cvt_roundph_epu64_mm512_maskz_cvtph_epu64_mm512_mask_cvtph_epu64_mm512_cvtph_epu64_mm512_maskz_cvt_roundph_epi64__builtin_ia32_vcvtph2qq512_mask_round_mm512_mask_cvt_roundph_epi64_mm512_cvt_roundph_epi64_mm512_maskz_cvtph_epi64_mm512_mask_cvtph_epi64_mm512_cvtph_epi64_mm512_maskz_cvt_roundepu32_ph__builtin_ia32_vcvtudq2ph512_mask_round_mm512_mask_cvt_roundepu32_ph_mm512_cvt_roundepu32_ph_mm512_maskz_cvtepu32_ph_mm512_mask_cvtepu32_ph_mm512_cvtepu32_ph_mm512_maskz_cvt_roundepi32_ph__builtin_ia32_vcvtdq2ph512_mask_round_mm512_mask_cvt_roundepi32_ph_mm512_cvt_roundepi32_ph_mm512_maskz_cvtepi32_ph_mm512_mask_cvtepi32_ph_mm512_cvtepi32_ph_mm512_maskz_cvtt_roundph_epu32__builtin_ia32_vcvttph2udq512_mask_round_mm512_mask_cvtt_roundph_epu32_mm512_cvtt_roundph_epu32_mm512_maskz_cvttph_epu32_mm512_mask_cvttph_epu32_mm512_cvttph_epu32_mm512_maskz_cvtt_roundph_epi32__builtin_ia32_vcvttph2dq512_mask_round_mm512_mask_cvtt_roundph_epi32_mm512_cvtt_roundph_epi32_mm512_maskz_cvttph_epi32_mm512_mask_cvttph_epi32_mm512_cvttph_epi32_mm512_maskz_cvt_roundph_epu32__builtin_ia32_vcvtph2udq512_mask_round_mm512_mask_cvt_roundph_epu32_mm512_cvt_roundph_epu32_mm512_maskz_cvtph_epu32_mm512_mask_cvtph_epu32_mm512_cvtph_epu32_mm512_maskz_cvt_roundph_epi32__builtin_ia32_vcvtph2dq512_mask_round_mm512_mask_cvt_roundph_epi32_mm512_cvt_roundph_epi32_mm512_maskz_cvtph_epi32_mm512_mask_cvtph_epi32_mm512_cvtph_epi32_mm_maskz_move_sh__builtin_ia32_vmovsh_mask_mm_mask_move_sh_mm_move_sh_mm_mask_store_shconst _Float16const _Float16 *_Float16 *__builtin_ia32_storesh_mask_mm_maskz_load_sh__builtin_ia32_loadsh_mask_mm_mask_load_sh_mm_cvtsi128_si16_mm_cvtsi16_si128_mm512_maskz_getmant_round_ph__builtin_ia32_getmantph512_mask_mm512_mask_getmant_round_ph_mm512_getmant_round_ph_mm_maskz_getmant_round_sh__builtin_ia32_getmantsh_mask_round_mm_mask_getmant_round_sh_mm_getmant_round_sh_mm512_maskz_getmant_ph_mm512_mask_getmant_ph_mm512_getmant_ph_mm_maskz_getmant_sh_mm_mask_getmant_sh_mm_getmant_sh_mm512_maskz_getexp_round_ph__builtin_ia32_getexpph512_mask_mm512_mask_getexp_round_ph_mm512_getexp_round_ph_mm_maskz_getexp_round_sh__builtin_ia32_getexpsh_mask_round_mm_mask_getexp_round_sh_mm_getexp_round_sh_mm512_maskz_getexp_ph_mm512_mask_getexp_ph_mm512_getexp_ph_mm_maskz_getexp_sh_mm_mask_getexp_sh_mm_getexp_sh_mm512_fpclass_ph_mask__builtin_ia32_fpclassph512_mask_mm512_mask_fpclass_ph_mask_mm_mask_fpclass_sh_mask__builtin_ia32_fpclasssh_mask_mm_fpclass_sh_mask_mm_maskz_roundscale_round_sh__builtin_ia32_rndscalesh_mask_round_mm_mask_roundscale_round_sh_mm_roundscale_round_sh_mm_maskz_roundscale_sh_mm_mask_roundscale_sh_mm_roundscale_sh_mm512_maskz_roundscale_round_ph__builtin_ia32_rndscaleph512_mask_round_mm512_mask_roundscale_round_ph_mm512_roundscale_round_ph_mm512_maskz_roundscale_ph_mm512_mask_roundscale_ph_mm512_roundscale_ph_mm_maskz_reduce_round_sh__builtin_ia32_reducesh_mask_round_mm_mask_reduce_round_sh_mm_reduce_round_sh_mm_maskz_reduce_sh_mm_mask_reduce_sh_mm_reduce_sh_mm512_maskz_reduce_round_ph__builtin_ia32_reduceph512_mask_round_mm512_mask_reduce_round_ph_mm512_reduce_round_ph_mm512_maskz_reduce_ph_mm512_mask_reduce_ph_mm512_reduce_ph_mm_maskz_scalef_round_sh__builtin_ia32_scalefsh_mask_round_mm_mask_scalef_round_sh_mm_scalef_round_sh_mm_maskz_scalef_sh_mm_mask_scalef_sh_mm_scalef_sh_mm512_maskz_scalef_round_ph__builtin_ia32_scalefph512_mask_round_mm512_mask_scalef_round_ph_mm512_scalef_round_ph_mm512_maskz_scalef_ph_mm512_mask_scalef_ph_mm512_scalef_ph_mm_maskz_rcp_sh__builtin_ia32_rcpsh_mask_mm_mask_rcp_sh_mm_rcp_sh_mm512_maskz_rcp_ph__builtin_ia32_rcpph512_mask_mm512_mask_rcp_ph_mm512_rcp_ph_mm_maskz_sqrt_round_sh__builtin_ia32_sqrtsh_mask_round_mm_mask_sqrt_round_sh_mm_sqrt_round_sh_mm_maskz_sqrt_sh_mm_mask_sqrt_sh_mm_sqrt_sh_mm_maskz_rsqrt_sh__builtin_ia32_rsqrtsh_mask_mm_mask_rsqrt_sh_mm_rsqrt_sh_mm512_maskz_rsqrt_ph__builtin_ia32_rsqrtph512_mask_mm512_mask_rsqrt_ph_mm512_rsqrt_ph_mm512_maskz_sqrt_round_ph__builtin_ia32_sqrtph512_mask_round_mm512_mask_sqrt_round_ph_mm512_sqrt_round_ph_mm512_maskz_sqrt_ph_mm512_mask_sqrt_ph_mm512_sqrt_ph_mm_comi_round_sh__builtin_ia32_cmpsh_mask_round_mm_comi_sh_mm_ucomineq_sh_mm_ucomige_sh_mm_ucomigt_sh_mm_ucomile_sh_mm_ucomilt_sh_mm_ucomieq_sh_mm_comineq_sh_mm_comige_sh_mm_comigt_sh_mm_comile_sh_mm_comilt_sh_mm_comieq_sh_mm_mask_cmp_round_sh_mask_mm_cmp_round_sh_mask_mm_mask_cmp_sh_mask_mm_cmp_sh_mask_mm_maskz_min_round_sh__builtin_ia32_minsh_mask_round_mm_mask_min_round_sh_mm_min_round_sh_mm_maskz_max_round_sh__builtin_ia32_maxsh_mask_round_mm_mask_max_round_sh_mm_max_round_sh_mm_maskz_min_sh__builtin_ia32_minsh_mask_mm_mask_min_sh_mm_min_sh_mm_maskz_max_sh__builtin_ia32_maxsh_mask_mm_mask_max_sh_mm_max_sh_mm512_maskz_min_round_ph__builtin_ia32_minph512_mask_round_mm512_mask_min_round_ph_mm512_min_round_ph_mm512_maskz_max_round_ph__builtin_ia32_maxph512_mask_round_mm512_mask_max_round_ph_mm512_max_round_ph_mm512_maskz_min_ph__builtin_ia32_minph512_mask_mm512_mask_min_ph_mm512_min_ph_mm512_maskz_max_ph__builtin_ia32_maxph512_mask_mm512_mask_max_ph_mm512_max_ph_mm_maskz_div_round_sh__builtin_ia32_divsh_mask_round_mm_mask_div_round_sh_mm_div_round_sh_mm_maskz_mul_round_sh__builtin_ia32_mulsh_mask_round_mm_mask_mul_round_sh_mm_mul_round_sh_mm_maskz_sub_round_sh__builtin_ia32_subsh_mask_round_mm_mask_sub_round_sh_mm_sub_round_sh_mm_maskz_add_round_sh__builtin_ia32_addsh_mask_round_mm_mask_add_round_sh_mm_add_round_sh_mm_maskz_div_sh__builtin_ia32_divsh_mask_mm_mask_div_sh_mm_div_sh_mm_maskz_mul_sh__builtin_ia32_mulsh_mask_mm_mask_mul_sh_mm_mul_sh_mm_maskz_sub_sh__builtin_ia32_subsh_mask_mm_mask_sub_sh_mm_sub_sh_mm_maskz_add_sh__builtin_ia32_addsh_mask_mm_mask_add_sh_mm_add_sh_mm512_maskz_conj_pch_mm512_mask_conj_pch_mm512_conj_pch1<<31_mm512_maskz_div_round_ph__builtin_ia32_divph512_mask_round_mm512_mask_div_round_ph_mm512_div_round_ph_mm512_maskz_mul_round_ph__builtin_ia32_mulph512_mask_round_mm512_mask_mul_round_ph_mm512_mul_round_ph_mm512_maskz_sub_round_ph__builtin_ia32_subph512_mask_round_mm512_mask_sub_round_ph_mm512_sub_round_ph_mm512_maskz_add_round_ph__builtin_ia32_addph512_mask_round_mm512_mask_add_round_ph_mm512_add_round_ph_mm512_maskz_div_ph__builtin_ia32_divph512_mask_mm512_mask_div_ph_mm512_div_ph_mm512_maskz_mul_ph__builtin_ia32_mulph512_mask_mm512_mask_mul_ph_mm512_mul_ph_mm512_maskz_sub_ph__builtin_ia32_subph512_mask_mm512_mask_sub_ph_mm512_sub_ph_mm512_maskz_add_ph__builtin_ia32_addph512_mask_mm512_mask_add_ph_mm512_add_ph_mm512_abs_ph21474508790x7FFF7FFF_mm_storeu_ph__m128h_u *__attribute((vector_size(16))) _Float16 *_mm256_storeu_ph__m256h_u *__attribute((vector_size(32))) _Float16 *_mm512_storeu_ph__m512h_u *__attribute((vector_size(64))) _Float16 *_mm_store_ph__m128h *_mm256_store_ph__m256h *_mm512_store_ph__m512h *_mm_store_sh_mm_loadu_phconst __m128h_uconst __m128h_u *_mm256_loadu_phconst __m256h_uconst __m256h_u *_mm512_loadu_phconst __m512h_uconst __m512h_u *_mm_load_phconst __m128hconst __m128h *_mm256_load_phconst __m256hconst __m256h *_mm512_load_phconst __m512hconst __m512h *_mm_load_sh_mm_set_sh_mm512_castsi512_ph_mm512_castpd_ph_mm512_castps_ph_mm512_zextph256_ph512_mm512_zextph128_ph512_mm512_castph256_ph512__m256h[2]__attribute((vector_size(32))) _Float16[2]_mm512_castph128_ph512__m128h[4]__attribute((vector_size(16))) _Float16[4]_mm512_castph512_ph256_mm512_castph512_ph128_mm512_castph_si512_mm512_castph_pd_mm512_castph_ps_mm512_cvtsh_h_mm256_cvtsh_h_mm_cvtsh_h_mm512_undefined_ph_mm256_undefined_ph_mm_undefined_ph_mm512_setzero_ph_mm256_setzero_ph_mm_setzero_ph_mm512_set1_ph_mm256_set1_ph_mm_set1_ph_mm512_setr_ph_mm256_setr_ph_mm_setr_ph_mm512_set_ph_mm256_set_ph_mm_set_ph__m512h_u__m256h_u__m128h_u__m512h__m256h__m128h__v32hf__v16hf__v8hf__v__DISABLE_AVX512FP16___mm_maskz_cmul_round_sch(U,A,B,R)_mm_maskz_fcmul_round_sch ((U), (A), (B), (R))_mm_mask_cmul_round_sch(W,U,A,B,R)_mm_mask_fcmul_round_sch ((W), (U), (A), (B), (R))_mm_cmul_round_sch(A,B,R)_mm_fcmul_round_sch ((A), (B), (R))_mm_maskz_cmul_sch(U,A,B)_mm_maskz_fcmul_sch ((U), (A), (B))_mm_mask_cmul_sch(W,U,A,B)_mm_mask_fcmul_sch ((W), (U), (A), (B))_mm_cmul_sch(A,B)_mm_fcmul_sch ((A), (B))_mm_maskz_mul_round_sch(U,A,B,R)_mm_maskz_fmul_round_sch ((U), (A), (B), (R))_mm_mask_mul_round_sch(W,U,A,B,R)_mm_mask_fmul_round_sch ((W), (U), (A), (B), (R))_mm_mul_round_sch(A,B,R)_mm_fmul_round_sch ((A), (B), (R))_mm_maskz_mul_sch(U,A,B)_mm_maskz_fmul_sch ((U), (A), (B))_mm_mask_mul_sch(W,U,A,B)_mm_mask_fmul_sch ((W), (U), (A), (B))_mm_mul_sch(A,B)_mm_fmul_sch ((A), (B))_mm512_maskz_cmul_round_pch(U,A,B,R)_mm512_maskz_fcmul_round_pch ((U), (A), (B), (R))_mm512_mask_cmul_round_pch(W,U,A,B,R)_mm512_mask_fcmul_round_pch ((W), (U), (A), (B), (R))_mm512_cmul_round_pch(A,B,R)_mm512_fcmul_round_pch ((A), (B), (R))_mm512_maskz_cmul_pch(U,A,B)_mm512_maskz_fcmul_pch ((U), (A), (B))_mm512_mask_cmul_pch(W,U,A,B)_mm512_mask_fcmul_pch ((W), (U), (A), (B))_mm512_cmul_pch(A,B)_mm512_fcmul_pch ((A), (B))_mm512_maskz_mul_round_pch(U,A,B,R)_mm512_maskz_fmul_round_pch ((U), (A), (B), (R))_mm512_mask_mul_round_pch(W,U,A,B,R)_mm512_mask_fmul_round_pch ((W), (U), (A), (B), (R))_mm512_mul_round_pch(A,B,R)_mm512_fmul_round_pch ((A), (B), (R))_mm512_maskz_mul_pch(U,A,B)_mm512_maskz_fmul_pch ((U), (A), (B))_mm512_mask_mul_pch(W,U,A,B)_mm512_mask_fmul_pch ((W), (U), (A), (B))_mm512_mul_pch(A,B)_mm512_fmul_pch ((A), (B))_MM512_REDUCE_OP_MM512_REDUCE_OP(op)__m512h __T1 = (__m512h) __builtin_shuffle ((__m512d) __A, (__v8di) { 4, 5, 6, 7, 0, 0, 0, 0 }); __m512h __T2 = _mm512_ ## op ## _ph (__A, __T1); __m512h __T3 = (__m512h) __builtin_shuffle ((__m512d) __T2, (__v8di) { 2, 3, 0, 0, 0, 0, 0, 0 }); __m512h __T4 = _mm512_ ## op ## _ph (__T2, __T3); __m512h __T5 = (__m512h) __builtin_shuffle ((__m512d) __T4, (__v8di) { 1, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T6 = _mm512_ ## op ## _ph (__T4, __T5); __m512h __T7 = (__m512h) __builtin_shuffle ((__m512) __T6, (__v16si) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T8 = _mm512_ ## op ## _ph (__T6, __T7); __m512h __T9 = (__m512h) __builtin_shuffle (__T8, (__v32hi) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T10 = _mm512_ ## op ## _ph (__T8, __T9); return __T10[0]__m256h __T1 = (__m256h) _mm512_extractf64x4_pd ((__m512d) __A, 0); __m256h __T2 = (__m256h) _mm512_extractf64x4_pd ((__m512d) __A, 1); __m256h __T3 = (__T1 op __T2); __m128h __T4 = (__m128h) _mm256_extractf128_pd ((__m256d) __T3, 0); __m128h __T5 = (__m128h) _mm256_extractf128_pd ((__m256d) __T3, 1); __m128h __T6 = (__T4 op __T5); __m128h __T7 = (__m128h) __builtin_shuffle ((__m128h)__T6, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T8 = (__T6 op __T7); __m128h __T9 = (__m128h) __builtin_shuffle ((__m128h)__T8, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T10 = __T8 op __T9; return __T10[0] op __T10[1]_mm512_mask_cmp_round_ph_mask(A,B,C,D,E)(__builtin_ia32_cmpph512_mask_round ((B), (C), (D), (A), (E)))_mm512_cmp_round_ph_mask(A,B,C,D)(__builtin_ia32_cmpph512_mask_round ((A), (B), (C), (-1), (D)))_mm512_mask_cmp_ph_mask(A,B,C,D)(__builtin_ia32_cmpph512_mask ((B), (C), (D), (A)))_mm512_cmp_ph_mask(A,B,C)(__builtin_ia32_cmpph512_mask ((A), (B), (C), (-1)))__AVX512FP16INTRIN_H_INCLUDED__AVX512FP16__GCC target("avx512fp16")__OPTIMIZE/* __AVX512FP16INTRIN_H_INCLUDED *//* __DISABLE_AVX512FP16__ */// intrinsics below are alias for f*mul_*ch// TODO reduce/* Intrinsics vf[,c]mulcsh.  *//* Intrinsics vf[,c]maddcsh.  *//* Intrinsics vf[,c]mulcph.  *//* Intrinsics vf[,c]maddcph.  *//* Intrinsics vfnmsub[132,213,231]sh.  *//* Intrinsics vfmsub[132,213,231]sh.  *//* Intrinsics vfnmadd[132,213,231]sh.  *//* Intrinsics vfmadd[132,213,231]sh.  *//* Intrinsics vfnmsub[132,213,231]ph.  *//* Intrinsics vfmsub[132,213,231]ph.  *//* Intrinsics vfnmadd[132,213,231]ph.  *//* Intrinsics vfmadd[132,213,231]ph.  *//* Intrinsics vfmsubadd[132,213,231]ph.  *//* Intrinsics vfmaddsub[132,213,231]ph.  *//* Intrinsics vcvtss2sh, vcvtsd2sh.  *//* Intrinsics vcvtsh2ss, vcvtsh2sd.  *//* Intrinsics vcvtpd2ph.  *//* Intrinsics vcvtps2ph.  *//* Intrinsics vcvtph2psx.  *//* Intrinsics vcvtph2pd.  *//* Intrinsics vcvtsi2sh, vcvtusi2sh.  *//* Intrinsics vcvttsh2si, vcvttsh2us.  *//* Intrinsics vcvtsh2si, vcvtsh2us.  *//* Intrinsics vcvtuw2ph.  *//* Intrinsics vcvtw2ph.  *//* Intrinsics vcvttph2uw.  *//* Intrinsics vcvttph2w.  *//* Intrinsics vcvtph2uw.  *//* Intrinsics vcvtph2w.  *//* Intrinsics vcvtuqq2ph.  *//* Intrinsics vcvtqq2ph.  *//* Intrinsics vcvttph2uqq.  *//* Intrinsics vcvttph2qq.  *//* Intrinsics vcvtph2uqq.  *//* Intrinsics vcvtph2qq.  *//* Intrinsics vcvtudq2ph.  *//* Intrinsics vcvtdq2ph.  *//* Intrinsics vcvttph2udq.  *//* Intrinsics vcvttph2dq.  *//* Intrinsics vcvtph2udq.  *//* Intrinsics vcvtph2dq.  *//* Intrinsics vmovsh.  *//* Intrinsics vmovw.  *//* Intrinsics vgetmantph, vgetmantsh.  *//* Intrinsics vgetexpph, vgetexpsh.  *//* __OPIMTIZE__ *//* Intrinsics vfpclassph.  *//* Intrinsics vfpclasssh.  *//* Intrinsics vrndscalesh.  *//* Intrinsics vrndscaleph.  *//* Intrinsics vreducesh.  *//* Intrinsics vreduceph.  *//* Intrinsics vscalefsh.  *//* Intrinsics vscalefph.  *//* Intrinsics vrcpsh.  *//* Intrinsics vrcpph.  *//* Intrinsics vsqrtsh.  *//* Intrinsics vrsqrtsh.  *//* Intrinsics vrsqrtph.  *//* Intrinsics vsqrtph.  *//* __OPTIMIZE__  *//* Intrinsics vcomish.  *//* Intrinsics vcmpsh.  *//* vcmpph *//* Intrinsic vmaxsh vminsh.  *//* Intrinsic vmaxph vminph.  *//* Intrinsics of v[add,sub,mul,div]sh.  *//* Intrinsics v[add,sub,mul,div]ph.  *//* Stores the lower _Float16 value.  *//* Create a vector with all zeros.  *//* Broadcast _Float16 to vector.  *//* Create vectors of elements in the reversed order from _mm_set_ph,
   _mm256_set_ph and _mm512_set_ph functions.  *//* __AVX512FP16__ */__A0__A1__A2__A3__A4__A5__A6__A7__A8__A9__A10__A11__A12__A13__A14__A15__A16__A17__A18__A19__A20__A21__A22__A23__A24__A25__A26__A27__A28__A29__A30__A31_mm_set1_pch_mm256_set1_pch_mm_permutexvar_ph(__mmask8)-1_mm_permutex2var_ph_mm_mask_blend_ph_mm256_permutexvar_ph(__mmask16)-1_mm256_permutex2var_ph_mm256_mask_blend_ph_mm_reduce_max_phmax_ph_mm_reduce_min_phmin_ph_mm_reduce_mul_ph_mm_reduce_add_ph_mm256_reduce_max_ph_mm256_reduce_min_ph_mm256_reduce_mul_ph_mm256_reduce_add_ph_mm256_maskz_fcmul_pch__builtin_ia32_vfcmulcph256_mask_mm256_mask_fcmul_pch_mm256_fcmul_pch__builtin_ia32_vfcmulcph256_mm_maskz_fcmul_pch__builtin_ia32_vfcmulcph128_mask_mm_mask_fcmul_pch_mm_fcmul_pch__builtin_ia32_vfcmulcph128_mm256_maskz_fmul_pch__builtin_ia32_vfmulcph256_mask_mm256_mask_fmul_pch_mm256_fmul_pch__builtin_ia32_vfmulcph256_mm_maskz_fmul_pch__builtin_ia32_vfmulcph128_mask_mm_mask_fmul_pch_mm_fmul_pch__builtin_ia32_vfmulcph128_mm256_maskz_fcmadd_pch__builtin_ia32_vfcmaddcph256_maskz_mm256_mask3_fcmadd_pch__builtin_ia32_vfcmaddcph256_mask3_mm256_mask_fcmadd_pch__builtin_ia32_vfcmaddcph256_mask_mm256_fcmadd_pch__builtin_ia32_vfcmaddcph256_mm_maskz_fcmadd_pch__builtin_ia32_vfcmaddcph128_maskz_mm_mask3_fcmadd_pch__builtin_ia32_vfcmaddcph128_mask3_mm_mask_fcmadd_pch__builtin_ia32_vfcmaddcph128_mask_mm_fcmadd_pch__builtin_ia32_vfcmaddcph128_mm256_maskz_fmadd_pch__builtin_ia32_vfmaddcph256_maskz_mm256_mask3_fmadd_pch__builtin_ia32_vfmaddcph256_mask3_mm256_mask_fmadd_pch__builtin_ia32_vfmaddcph256_mask_mm256_fmadd_pch__builtin_ia32_vfmaddcph256_mm_maskz_fmadd_pch__builtin_ia32_vfmaddcph128_maskz_mm_mask3_fmadd_pch__builtin_ia32_vfmaddcph128_mask3_mm_mask_fmadd_pch__builtin_ia32_vfmaddcph128_mask_mm_fmadd_pch__builtin_ia32_vfmaddcph128_mm_maskz_fnmsub_ph__builtin_ia32_vfnmsubph128_maskz_mm_mask3_fnmsub_ph__builtin_ia32_vfnmsubph128_mask3_mm_mask_fnmsub_ph__builtin_ia32_vfnmsubph128_mask_mm_fnmsub_ph_mm256_maskz_fnmsub_ph__builtin_ia32_vfnmsubph256_maskz_mm256_mask3_fnmsub_ph__builtin_ia32_vfnmsubph256_mask3_mm256_mask_fnmsub_ph__builtin_ia32_vfnmsubph256_mask_mm256_fnmsub_ph_mm_maskz_fmsub_ph__builtin_ia32_vfmsubph128_maskz_mm_mask3_fmsub_ph__builtin_ia32_vfmsubph128_mask3_mm_mask_fmsub_ph__builtin_ia32_vfmsubph128_mask_mm_fmsub_ph_mm256_maskz_fmsub_ph__builtin_ia32_vfmsubph256_maskz_mm256_mask3_fmsub_ph__builtin_ia32_vfmsubph256_mask3_mm256_mask_fmsub_ph__builtin_ia32_vfmsubph256_mask_mm256_fmsub_ph_mm_maskz_fnmadd_ph__builtin_ia32_vfnmaddph128_maskz_mm_mask3_fnmadd_ph__builtin_ia32_vfnmaddph128_mask3_mm_mask_fnmadd_ph__builtin_ia32_vfnmaddph128_mask_mm_fnmadd_ph_mm256_maskz_fnmadd_ph__builtin_ia32_vfnmaddph256_maskz_mm256_mask3_fnmadd_ph__builtin_ia32_vfnmaddph256_mask3_mm256_mask_fnmadd_ph__builtin_ia32_vfnmaddph256_mask_mm256_fnmadd_ph_mm_maskz_fmadd_ph__builtin_ia32_vfmaddph128_maskz_mm_mask3_fmadd_ph__builtin_ia32_vfmaddph128_mask3_mm_mask_fmadd_ph__builtin_ia32_vfmaddph128_mask_mm_fmadd_ph_mm256_maskz_fmadd_ph__builtin_ia32_vfmaddph256_maskz_mm256_mask3_fmadd_ph__builtin_ia32_vfmaddph256_mask3_mm256_mask_fmadd_ph__builtin_ia32_vfmaddph256_mask_mm256_fmadd_ph_mm_maskz_fmsubadd_ph__builtin_ia32_vfmsubaddph128_maskz_mm_mask3_fmsubadd_ph__builtin_ia32_vfmsubaddph128_mask3_mm_mask_fmsubadd_ph__builtin_ia32_vfmsubaddph128_mask_mm_fmsubadd_ph_mm256_maskz_fmsubadd_ph__builtin_ia32_vfmsubaddph256_maskz_mm256_mask3_fmsubadd_ph__builtin_ia32_vfmsubaddph256_mask3_mm256_mask_fmsubadd_ph__builtin_ia32_vfmsubaddph256_mask_mm256_fmsubadd_ph_mm_maskz_fmaddsub_ph__builtin_ia32_vfmaddsubph128_maskz_mm_mask3_fmaddsub_ph__builtin_ia32_vfmaddsubph128_mask3_mm_mask_fmaddsub_ph__builtin_ia32_vfmaddsubph128_mask_mm_fmaddsub_ph_mm256_maskz_fmaddsub_ph__builtin_ia32_vfmaddsubph256_maskz_mm256_mask3_fmaddsub_ph__builtin_ia32_vfmaddsubph256_mask3_mm256_mask_fmaddsub_ph__builtin_ia32_vfmaddsubph256_mask_mm256_fmaddsub_ph_mm256_maskz_cvtpd_ph__builtin_ia32_vcvtpd2ph256_mask_mm256_mask_cvtpd_ph_mm256_cvtpd_ph_mm_maskz_cvtpd_ph__builtin_ia32_vcvtpd2ph128_mask_mm_mask_cvtpd_ph_mm_cvtpd_ph_mm256_maskz_cvtxps_ph__builtin_ia32_vcvtps2phx256_mask_mm256_mask_cvtxps_ph_mm256_cvtxps_ph_mm_maskz_cvtxps_ph__builtin_ia32_vcvtps2phx128_mask_mm_mask_cvtxps_ph_mm_cvtxps_ph_mm256_maskz_cvtxph_ps__builtin_ia32_vcvtph2psx256_mask_mm256_mask_cvtxph_ps_mm256_cvtxph_ps_mm_maskz_cvtxph_ps__builtin_ia32_vcvtph2psx128_mask_mm_mask_cvtxph_ps_mm_cvtxph_ps_mm256_maskz_cvtph_pd__builtin_ia32_vcvtph2pd256_mask_mm256_mask_cvtph_pd_mm256_cvtph_pd_mm_maskz_cvtph_pd__builtin_ia32_vcvtph2pd128_mask_mm_mask_cvtph_pd_mm_cvtph_pd_mm256_maskz_cvtepu16_ph__builtin_ia32_vcvtuw2ph256_mask_mm256_mask_cvtepu16_ph_mm256_cvtepu16_ph_mm_maskz_cvtepu16_ph__builtin_ia32_vcvtuw2ph128_mask_mm_mask_cvtepu16_ph_mm_cvtepu16_ph_mm256_maskz_cvtepi16_ph__builtin_ia32_vcvtw2ph256_mask_mm256_mask_cvtepi16_ph_mm256_cvtepi16_ph_mm_maskz_cvtepi16_ph__builtin_ia32_vcvtw2ph128_mask_mm_mask_cvtepi16_ph_mm_cvtepi16_ph_mm256_maskz_cvttph_epu16__builtin_ia32_vcvttph2uw256_mask_mm256_mask_cvttph_epu16_mm256_cvttph_epu16_mm_maskz_cvttph_epu16__builtin_ia32_vcvttph2uw128_mask_mm_mask_cvttph_epu16_mm_cvttph_epu16_mm256_maskz_cvttph_epi16__builtin_ia32_vcvttph2w256_mask_mm256_mask_cvttph_epi16_mm256_cvttph_epi16_mm_maskz_cvttph_epi16__builtin_ia32_vcvttph2w128_mask_mm_mask_cvttph_epi16_mm_cvttph_epi16_mm256_maskz_cvtph_epu16__builtin_ia32_vcvtph2uw256_mask_mm256_mask_cvtph_epu16_mm256_cvtph_epu16_mm_maskz_cvtph_epu16__builtin_ia32_vcvtph2uw128_mask_mm_mask_cvtph_epu16_mm_cvtph_epu16_mm256_maskz_cvtph_epi16__builtin_ia32_vcvtph2w256_mask_mm256_mask_cvtph_epi16_mm256_cvtph_epi16_mm_maskz_cvtph_epi16__builtin_ia32_vcvtph2w128_mask_mm_mask_cvtph_epi16_mm_cvtph_epi16_mm256_maskz_cvtepu64_ph__builtin_ia32_vcvtuqq2ph256_mask_mm256_mask_cvtepu64_ph_mm256_cvtepu64_ph_mm_maskz_cvtepu64_ph__builtin_ia32_vcvtuqq2ph128_mask_mm_mask_cvtepu64_ph_mm_cvtepu64_ph_mm256_maskz_cvtepi64_ph__builtin_ia32_vcvtqq2ph256_mask_mm256_mask_cvtepi64_ph_mm256_cvtepi64_ph_mm_maskz_cvtepi64_ph__builtin_ia32_vcvtqq2ph128_mask_mm_mask_cvtepi64_ph_mm_cvtepi64_ph_mm256_maskz_cvttph_epu64__builtin_ia32_vcvttph2uqq256_mask_mm256_mask_cvttph_epu64_mm256_cvttph_epu64_mm_maskz_cvttph_epu64__builtin_ia32_vcvttph2uqq128_mask_mm_mask_cvttph_epu64_mm_cvttph_epu64_mm256_maskz_cvttph_epi64__builtin_ia32_vcvttph2qq256_mask_mm256_mask_cvttph_epi64_mm256_cvttph_epi64_mm_maskz_cvttph_epi64__builtin_ia32_vcvttph2qq128_mask_mm_mask_cvttph_epi64_mm_cvttph_epi64_mm256_maskz_cvtph_epu64__builtin_ia32_vcvtph2uqq256_mask_mm256_mask_cvtph_epu64_mm256_cvtph_epu64_mm_maskz_cvtph_epu64__builtin_ia32_vcvtph2uqq128_mask_mm_mask_cvtph_epu64_mm_cvtph_epu64_mm256_maskz_cvtph_epi64__builtin_ia32_vcvtph2qq256_mask_mm256_mask_cvtph_epi64_mm256_cvtph_epi64_mm_maskz_cvtph_epi64__builtin_ia32_vcvtph2qq128_mask_mm_mask_cvtph_epi64_mm_cvtph_epi64_mm256_maskz_cvtepu32_ph__builtin_ia32_vcvtudq2ph256_mask_mm256_mask_cvtepu32_ph_mm256_cvtepu32_ph_mm_maskz_cvtepu32_ph__builtin_ia32_vcvtudq2ph128_mask_mm_mask_cvtepu32_ph_mm_cvtepu32_ph_mm256_maskz_cvtepi32_ph__builtin_ia32_vcvtdq2ph256_mask_mm256_mask_cvtepi32_ph_mm256_cvtepi32_ph_mm_maskz_cvtepi32_ph__builtin_ia32_vcvtdq2ph128_mask_mm_mask_cvtepi32_ph_mm_cvtepi32_ph_mm256_maskz_cvttph_epu32__builtin_ia32_vcvttph2udq256_mask_mm256_mask_cvttph_epu32_mm256_cvttph_epu32_mm_maskz_cvttph_epu32__builtin_ia32_vcvttph2udq128_mask_mm_mask_cvttph_epu32_mm_cvttph_epu32_mm256_maskz_cvttph_epi32__builtin_ia32_vcvttph2dq256_mask_mm256_mask_cvttph_epi32_mm256_cvttph_epi32_mm_maskz_cvttph_epi32__builtin_ia32_vcvttph2dq128_mask_mm_mask_cvttph_epi32_mm_cvttph_epi32_mm256_maskz_cvtph_epu32__builtin_ia32_vcvtph2udq256_mask_mm256_mask_cvtph_epu32_mm256_cvtph_epu32_mm_maskz_cvtph_epu32__builtin_ia32_vcvtph2udq128_mask_mm_mask_cvtph_epu32_mm_cvtph_epu32_mm256_maskz_cvtph_epi32__builtin_ia32_vcvtph2dq256_mask_mm256_mask_cvtph_epi32_mm256_cvtph_epi32_mm_maskz_cvtph_epi32__builtin_ia32_vcvtph2dq128_mask_mm_mask_cvtph_epi32_mm_cvtph_epi32_mm_maskz_getmant_ph__builtin_ia32_getmantph128_mask_mm_mask_getmant_ph_mm_getmant_ph_mm256_maskz_getmant_ph__builtin_ia32_getmantph256_mask_mm256_mask_getmant_ph_mm256_getmant_ph_mm_maskz_getexp_ph__builtin_ia32_getexpph128_mask_mm_mask_getexp_ph_mm_getexp_ph_mm256_maskz_getexp_ph__builtin_ia32_getexpph256_mask_mm256_mask_getexp_ph_mm256_getexp_ph_mm256_fpclass_ph_mask__builtin_ia32_fpclassph256_mask_mm256_mask_fpclass_ph_mask_mm_fpclass_ph_mask__builtin_ia32_fpclassph128_mask_mm_mask_fpclass_ph_mask_mm256_maskz_roundscale_ph__builtin_ia32_rndscaleph256_mask_mm256_mask_roundscale_ph_mm256_roundscale_ph_mm_maskz_roundscale_ph__builtin_ia32_rndscaleph128_mask_mm_mask_roundscale_ph_mm_roundscale_ph_mm256_maskz_reduce_ph__builtin_ia32_reduceph256_mask_mm256_mask_reduce_ph_mm256_reduce_ph_mm_maskz_reduce_ph__builtin_ia32_reduceph128_mask_mm_mask_reduce_ph_mm_reduce_ph_mm256_maskz_scalef_ph__builtin_ia32_scalefph256_mask_mm_maskz_scalef_ph__builtin_ia32_scalefph128_mask_mm256_mask_scalef_ph_mm_mask_scalef_ph_mm256_scalef_ph_mm_scalef_ph_mm256_maskz_rcp_ph__builtin_ia32_rcpph256_mask_mm_maskz_rcp_ph__builtin_ia32_rcpph128_mask_mm256_mask_rcp_ph_mm_mask_rcp_ph_mm256_rcp_ph_mm_rcp_ph_mm256_maskz_rsqrt_ph__builtin_ia32_rsqrtph256_mask_mm_maskz_rsqrt_ph__builtin_ia32_rsqrtph128_mask_mm256_mask_rsqrt_ph_mm_mask_rsqrt_ph_mm256_rsqrt_ph_mm_rsqrt_ph_mm256_maskz_sqrt_ph__builtin_ia32_sqrtph256_mask_mm_maskz_sqrt_ph__builtin_ia32_sqrtph128_mask_mm256_mask_sqrt_ph_mm_mask_sqrt_ph_mm256_sqrt_ph_mm_sqrt_ph_mm256_abs_ph_mm_abs_ph_mm256_maskz_min_ph__builtin_ia32_minph256_mask_mm_maskz_min_ph__builtin_ia32_minph128_mask_mm256_mask_min_ph_mm_mask_min_ph_mm256_min_ph_mm_min_ph_mm256_maskz_max_ph__builtin_ia32_maxph256_mask_mm_maskz_max_ph__builtin_ia32_maxph128_mask_mm256_mask_max_ph_mm_mask_max_ph_mm256_max_ph_mm_max_ph_mm256_maskz_div_ph__builtin_ia32_divph256_mask_mm_maskz_div_ph__builtin_ia32_divph128_mask_mm256_mask_div_ph_mm_mask_div_ph_mm256_div_ph_mm_div_ph_mm256_maskz_mul_ph__builtin_ia32_mulph256_mask_mm_maskz_mul_ph__builtin_ia32_mulph128_mask_mm256_mask_mul_ph_mm_mask_mul_ph_mm256_mul_ph_mm_mul_ph_mm256_maskz_sub_ph__builtin_ia32_subph256_mask_mm_maskz_sub_ph__builtin_ia32_subph128_mask_mm256_mask_sub_ph_mm_mask_sub_ph_mm256_sub_ph_mm_sub_ph_mm256_maskz_add_ph__builtin_ia32_addph256_mask_mm_maskz_add_ph__builtin_ia32_addph128_mask_mm256_mask_add_ph_mm_mask_add_ph_mm256_add_ph_mm_add_ph_mm_maskz_conj_pch_mm_mask_conj_pch_mm_conj_pch_mm256_maskz_conj_pch_mm256_mask_conj_pch_mm256_conj_pch_mm256_zextph128_ph256_mm256_castph128_ph256__m128h[2]__attribute((vector_size(16))) _Float16[2]_mm256_castph256_ph128_mm256_castsi256_ph_mm_castsi128_ph_mm256_castpd_ph_mm_castpd_ph_mm256_castps_ph_mm_castps_ph_mm256_castph_si256_mm_castph_si128_mm256_castph_pd_mm_castph_pd_mm256_castph_ps_mm_castph_ps__DISABLE_AVX512FP16VL___mm256_maskz_cmul_pch(U,A,B)_mm256_maskz_fcmul_pch((U), (A), (B))_mm256_mask_cmul_pch(W,U,A,B)_mm256_mask_fcmul_pch ((W), (U), (A), (B))_mm256_cmul_pch(A,B)_mm256_fcmul_pch ((A), (B))_mm_maskz_cmul_pch(U,A,B)_mm_maskz_fcmul_pch ((U), (A), (B))_mm_mask_cmul_pch(W,U,A,B)_mm_mask_fcmul_pch ((W), (U), (A), (B))_mm_cmul_pch(A,B)_mm_fcmul_pch ((A), (B))_mm256_maskz_mul_pch(U,A,B)_mm256_maskz_fmul_pch ((U), (A), (B))_mm256_mask_mul_pch(W,U,A,B)_mm256_mask_fmul_pch ((W), (U), (A), (B))_mm256_mul_pch(A,B)_mm256_fmul_pch ((A), (B))_mm_maskz_mul_pch(U,A,B)_mm_maskz_fmul_pch ((U), (A), (B))_mm_mask_mul_pch(W,U,A,B)_mm_mask_fmul_pch ((W), (U), (A), (B))_mm_mul_pch(A,B)_mm_fmul_pch ((A), (B))_MM_REDUCE_OP_MM256_REDUCE_OP_MM_REDUCE_OP(op)__m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T2 = _mm_ ## op (__A, __T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 4, 5 }); __m128h __T4 = _mm_ ## op (__T2, __T3); __m128h __T5 = (__m128h) __builtin_shuffle (__T4, (__v8hi){ 1, 0 }); __m128h __T6 = _mm_ ## op (__T4, __T5); return __T6[0]__m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T2 = (__A) op (__T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T4 = __T2 op __T3; return __T4[0] op __T4[1]_MM256_REDUCE_OP(op)__m128h __T1 = (__m128h) _mm256_extractf128_pd ((__m256d) __A, 0); __m128h __T2 = (__m128h) _mm256_extractf128_pd ((__m256d) __A, 1); __m128h __T3 = _mm_ ## op (__T1, __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T5 = _mm_ ## op (__T3, __T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 4, 5 }); __m128h __T7 = _mm_ ## op (__T5, __T6); __m128h __T8 = (__m128h) __builtin_shuffle (__T7, (__v8hi) { 1, 0 }); __m128h __T9 = _mm_ ## op (__T7, __T8); return __T9[0]__m128h __T1 = (__m128h) _mm256_extractf128_pd ((__m256d) __A, 0); __m128h __T2 = (__m128h) _mm256_extractf128_pd ((__m256d) __A, 1); __m128h __T3 = (__T1 op __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T5 = (__T3) op (__T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T7 = __T5 op __T6; return __T7[0] op __T7[1]_mm256_mask_cmp_ph_mask(A,B,C,D)(__builtin_ia32_cmpph256_mask ((B), (C), (D), (A)))_mm256_cmp_ph_mask(A,B,C)(__builtin_ia32_cmpph256_mask ((A), (B), (C), (-1)))_mm_mask_cmp_ph_mask(A,B,C,D)(__builtin_ia32_cmpph128_mask ((B), (C), (D), (A)))_mm_cmp_ph_mask(A,B,C)(__builtin_ia32_cmpph128_mask ((A), (B), (C), (-1)))__AVX512FP16VLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512FP16__)GCC target("avx512fp16,avx512vl")/* __AVX512FP16VLINTRIN_H_INCLUDED *//* __DISABLE_AVX512FP16VL__ *//* Intrinsics vcvtxps2ph.  *//* Intrinsics vcvtph2ps.  *//* Intrinsics v[max,min]ph.  *//* __AVX512FP16VL__ */_mm_sha256rnds2_epu32__builtin_ia32_sha256rnds2_mm_sha256msg2_epu32__builtin_ia32_sha256msg2_mm_sha256msg1_epu32__builtin_ia32_sha256msg1_mm_sha1rnds4_epu32__builtin_ia32_sha1rnds4_mm_sha1nexte_epu32__builtin_ia32_sha1nexte_mm_sha1msg2_epu32__builtin_ia32_sha1msg2_mm_sha1msg1_epu32__builtin_ia32_sha1msg1__DISABLE_SHA___SHAINTRIN_H_INCLUDED__SHA__GCC target("sha")/* _SHAINTRIN_H_INCLUDED *//* __DISABLE_SHA__ *//* __SHA__ */_mm256_fmsubadd_ps__builtin_ia32_vfmaddsubps256_mm_fmsubadd_ps__builtin_ia32_vfmaddsubps_mm256_fmsubadd_pd__builtin_ia32_vfmaddsubpd256_mm_fmsubadd_pd__builtin_ia32_vfmaddsubpd_mm256_fmaddsub_ps_mm_fmaddsub_ps_mm256_fmaddsub_pd_mm_fmaddsub_pd_mm_fnmsub_ss__builtin_ia32_vfnmsubss3_mm_fnmsub_sd__builtin_ia32_vfnmsubsd3_mm256_fnmsub_ps__builtin_ia32_vfnmsubps256_mm_fnmsub_ps__builtin_ia32_vfnmsubps_mm256_fnmsub_pd__builtin_ia32_vfnmsubpd256_mm_fnmsub_pd__builtin_ia32_vfnmsubpd_mm_fnmadd_ss__builtin_ia32_vfnmaddss3_mm_fnmadd_sd__builtin_ia32_vfnmaddsd3_mm256_fnmadd_ps__builtin_ia32_vfnmaddps256_mm_fnmadd_ps__builtin_ia32_vfnmaddps_mm256_fnmadd_pd__builtin_ia32_vfnmaddpd256_mm_fnmadd_pd__builtin_ia32_vfnmaddpd_mm_fmsub_ss__builtin_ia32_vfmsubss3_mm_fmsub_sd__builtin_ia32_vfmsubsd3_mm256_fmsub_ps__builtin_ia32_vfmsubps256_mm_fmsub_ps__builtin_ia32_vfmsubps_mm256_fmsub_pd__builtin_ia32_vfmsubpd256_mm_fmsub_pd__builtin_ia32_vfmsubpd_mm_fmadd_ss__builtin_ia32_vfmaddss3_mm_fmadd_sd__builtin_ia32_vfmaddsd3_mm256_fmadd_ps__builtin_ia32_vfmaddps256_mm_fmadd_ps__builtin_ia32_vfmaddps_mm256_fmadd_pd__builtin_ia32_vfmaddpd256_mm_fmadd_pd__builtin_ia32_vfmaddpd__DISABLE_FMA___FMAINTRIN_H_INCLUDED__FMA__GCC target("fma")/* __DISABLE_FMA__ *//* __FMA__ */_mm256_cvtps_ph__builtin_ia32_vcvtps2ph256_mm_cvtps_ph__builtin_ia32_vcvtps2ph_cvtss_sh_mm256_cvtph_ps__builtin_ia32_vcvtph2ps256_mm_cvtph_ps__builtin_ia32_vcvtph2ps_cvtsh_ss__DISABLE_F16C___F16CINTRIN_H_INCLUDED!defined _X86INTRIN_H_INCLUDED && !defined _IMMINTRIN_H_INCLUDED__F16C__GCC target("f16c")/* _F16CINTRIN_H_INCLUDED *//* __DISABLE_F16C__ *//* __OPTIMIZE *//* __F16C__ */_mm512_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v64qi_mm512_maskz_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v64qi_mask_mm512_mask_gf2p8affine_epi64_epi8_mm512_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v64qi_mm512_maskz_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v64qi_mask_mm512_mask_gf2p8affineinv_epi64_epi8_mm512_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v64qi_mm512_maskz_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v64qi_mask_mm512_mask_gf2p8mul_epi8_mm256_maskz_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v32qi_mask_mm256_mask_gf2p8affine_epi64_epi8_mm256_maskz_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v32qi_mask_mm256_mask_gf2p8affineinv_epi64_epi8_mm256_maskz_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v32qi_mask_mm256_mask_gf2p8mul_epi8_mm_maskz_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v16qi_mask_mm_mask_gf2p8affine_epi64_epi8_mm_maskz_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v16qi_mask_mm_mask_gf2p8affineinv_epi64_epi8_mm_maskz_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v16qi_mask_mm_mask_gf2p8mul_epi8_mm256_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v32qi_mm256_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v32qi_mm256_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v32qi_mm_gf2p8affine_epi64_epi8__builtin_ia32_vgf2p8affineqb_v16qi_mm_gf2p8affineinv_epi64_epi8__builtin_ia32_vgf2p8affineinvqb_v16qi_mm_gf2p8mul_epi8__builtin_ia32_vgf2p8mulb_v16qi__DISABLE_GFNIAVX512FBW____DISABLE_GFNIAVX512VLBW____DISABLE_GFNIAVX512VL____DISABLE_GFNIAVX____DISABLE_GFNI___GFNIINTRIN_H_INCLUDED!defined(__GFNI__) || !defined(__SSE2__)GCC target("gfni,sse2")!defined(__GFNI__) || !defined(__AVX__)GCC target("gfni,avx")!defined(__GFNI__) || !defined(__AVX512VL__)GCC target("gfni,avx512vl")!defined(__GFNI__) || !defined(__AVX512VL__) || !defined(__AVX512BW__)GCC target("gfni,avx512vl,avx512bw")!defined(__GFNI__) || !defined(__AVX512F__) || !defined(__AVX512BW__)GCC target("gfni,avx512f,avx512bw")/* _GFNIINTRIN_H_INCLUDED *//* __GFNIAVX512FBW__ *//* __GFNIAVX512VLBW__ *//* __GFNIAVX512VL__ *//* __GFNIAVX__ *//* __DISABLE_GFNI__ *//* __GFNI__ */_mm512_aesenclast_epi128__builtin_ia32_vaesenclast_v64qi_mm512_aesenc_epi128__builtin_ia32_vaesenc_v64qi_mm512_aesdeclast_epi128__builtin_ia32_vaesdeclast_v64qi_mm512_aesdec_epi128__builtin_ia32_vaesdec_v64qi__builtin_ia32_vaesenclast_v32qi__builtin_ia32_vaesenc_v32qi__builtin_ia32_vaesdeclast_v32qi__builtin_ia32_vaesdec_v32qi__DISABLE_VAESF____DISABLE_VAES____VAESINTRIN_H_INCLUDED!defined(__VAES__) || !defined(__AVX__)GCC target("vaes,avx")!defined(__VAES__) || !defined(__AVX512F__)GCC target("vaes,avx512f")/* __VAESINTRIN_H_INCLUDED *//* __DISABLE_VAES__ *//* __VAES__ */_mm256_clmulepi64_epi128__builtin_ia32_vpclmulqdq_v4di_mm512_clmulepi64_epi128__builtin_ia32_vpclmulqdq_v8di__DISABLE_VPCLMULQDQ____DISABLE_VPCLMULQDQF___VPCLMULQDQINTRIN_H_INCLUDED!defined(__VPCLMULQDQ__) || !defined(__AVX512F__)GCC target("vpclmulqdq,avx512f")!defined(__VPCLMULQDQ__) || !defined(__AVX__)GCC target("vpclmulqdq,avx")/* _VPCLMULQDQINTRIN_H_INCLUDED *//* __DISABLE_VPCLMULQDQ__ *//* __VPCLMULQDQ__ *//* __DISABLE_VPCLMULQDQF__ *//* __VPCLMULQDQF__ */_mm256_mask_cvtpbh_ps_mm_mask_cvtpbh_ps_mm256_maskz_cvtpbh_ps_mm_maskz_cvtpbh_ps_mm256_cvtpbh_ps_mm_cvtpbh_ps_mm_cvtness_sbh__builtin_ia32_cvtneps2bf16_v4sf_mask_mm_maskz_dpbf16_ps__builtin_ia32_dpbf16ps_v4sf_maskz_mm_mask_dpbf16_ps__builtin_ia32_dpbf16ps_v4sf_mask_mm_dpbf16_ps__builtin_ia32_dpbf16ps_v4sf_mm256_maskz_dpbf16_ps__builtin_ia32_dpbf16ps_v8sf_maskz_mm256_mask_dpbf16_ps__builtin_ia32_dpbf16ps_v8sf_mask_mm256_dpbf16_ps__builtin_ia32_dpbf16ps_v8sf_mm_maskz_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v4sf_maskz_mm_mask_cvtneps_pbh_mm_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v4sf_mm256_maskz_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v8sf_maskz_mm256_mask_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v8sf_mask_mm256_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v8sf_mm_maskz_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v8hi_maskz_mm_mask_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v8hi_mask_mm_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v8hi_mm256_maskz_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v16hi_maskz_mm256_mask_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v16hi_mask_mm256_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v16hi__bfloat16__v8bh__v16bh__DISABLE_AVX512BF16VL___AVX512BF16VLINTRIN_H_INCLUDED!defined(__AVX512VL__) || !defined(__AVX512BF16__)GCC target("avx512bf16,avx512vl")/* _AVX512BF16VLINTRIN_H_INCLUDED *//* __DISABLE_AVX512BF16VL__ *//* vdpbf16ps *//* vcvtneps2bf16 *//* vcvtne2ps2bf16 *//* __AVX512BF16__ */__m128bh__m256bh_mm512_mask_cvtpbh_ps_mm512_maskz_cvtpbh_ps_mm512_cvtpbh_ps_mm512_maskz_dpbf16_ps__builtin_ia32_dpbf16ps_v16sf_maskz_mm512_mask_dpbf16_ps__builtin_ia32_dpbf16ps_v16sf_mask_mm512_dpbf16_ps__builtin_ia32_dpbf16ps_v16sf_mm512_maskz_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v16sf_maskz_mm512_mask_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v16sf_mask_mm512_cvtneps_pbh__builtin_ia32_cvtneps2bf16_v16sf_mm512_maskz_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v32hi_maskz_mm512_mask_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v32hi_mask_mm512_cvtne2ps_pbh__builtin_ia32_cvtne2ps2bf16_v32hi_mm_cvtsbh_ss__v32bh__DISABLE_AVX512BF16___AVX512BF16INTRIN_H_INCLUDED__AVX512BF16__GCC target("avx512bf16")/* _AVX512BF16INTRIN_H_INCLUDED *//* __DISABLE_AVX512BF16__ *//* Convert One BF16 Data to One Single Float Data.  */__m512bh_tile_release_tile_storeconfig_tile_loadconfig__DISABLE_AMX_TILE___tile_zero_internal(dst)__asm__ volatile ("tilezero\t%%tmm"#dst ::)_tile_zero(dst)_tile_zero_internal (dst)_tile_stored_internal(src,base,stride)__asm__ volatile ("{tilestored\t%%tmm"#src", (%0,%1,1)|tilestored\t[%0+%1*1], %%tmm"#src"}" :: "r" ((void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)) : "memory")_tile_stored(dst,base,stride)_tile_stored_internal (dst, base, stride)_tile_stream_loadd_internal(dst,base,stride)__asm__ volatile ("{tileloaddt1\t(%0,%1,1), %%tmm"#dst"|tileloaddt1\t%%tmm"#dst", [%0+%1*1]}" :: "r" ((const void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)))_tile_stream_loadd(dst,base,stride)_tile_stream_loadd_internal (dst, base, stride)_tile_loadd_internal(dst,base,stride)__asm__ volatile ("{tileloadd\t(%0,%1,1), %%tmm"#dst"|tileloadd\t%%tmm"#dst", [%0+%1*1]}" :: "r" ((const void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)))_tile_loadd(dst,base,stride)_tile_loadd_internal (dst, base, stride)_AMXTILEINTRIN_H_INCLUDED!defined(__AMX_TILE__)GCC target("amx-tile")defined(__x86_64__)/* _AMXTILEINTRIN_H_INCLUDED *//* __DISABLE_AMX_TILE__ *//* __AMX_TILE__ */__config__DISABLE_AMX_INT8___tile_dpbuud(dst,src1,src2)_tile_int8_dp_internal (tdpbuud, dst, src1, src2)_tile_dpbusd(dst,src1,src2)_tile_int8_dp_internal (tdpbusd, dst, src1, src2)_tile_dpbsud(dst,src1,src2)_tile_int8_dp_internal (tdpbsud, dst, src1, src2)_tile_dpbssd(dst,src1,src2)_tile_int8_dp_internal (tdpbssd, dst, src1, src2)_tile_int8_dp_internal(name,dst,src1,src2)__asm__ volatile ("{"#name"\t%%tmm"#src2", %%tmm"#src1", %%tmm"#dst"|"#name"\t%%tmm"#dst", %%tmm"#src1", %%tmm"#src2"}" ::)_AMXINT8INTRIN_H_INCLUDED!defined(__AMX_INT8__)GCC target("amx-int8")/* _AMXINT8INTRIN_H_INCLUDED *//* __DISABLE_AMX_INT8__ *//* __AMX_INT8__ */__DISABLE_AMX_BF16___tile_dpbf16ps(dst,src1,src2)_tile_dpbf16ps_internal (dst, src1, src2)_tile_dpbf16ps_internal(dst,src1,src2)__asm__ volatile ("{tdpbf16ps\t%%tmm"#src2", %%tmm"#src1", %%tmm"#dst"|tdpbf16ps\t%%tmm"#dst", %%tmm"#src1", %%tmm"#src2"}" ::)_AMXBF16INTRIN_H_INCLUDED!defined(__AMX_BF16__)GCC target("amx-bf16")/* _AMXBF16INTRIN_H_INCLUDED *//* __DISABLE_AMX_BF16__ *//* __AMX_BF16__ */_m_prefetchw_PRFCHWINTRIN_H_INCLUDED!defined _IMMINTRIN_H_INCLUDED && !defined _MM3DNOW_H_INCLUDED/* _PRFCHWINTRIN_H_INCLUDED *//* _MM_HINT_T0 */_mm_aesencwide256kl_u8const __m128i[8]__attribute((vector_size(16))) long long[8]__builtin_ia32_aesencwide256kl_u8_mm_aesencwide128kl_u8__m128i[8]__builtin_ia32_aesencwide128kl_u8_mm_aesdecwide256kl_u8__builtin_ia32_aesdecwide256kl_u8_mm_aesdecwide128kl_u8__builtin_ia32_aesdecwide128kl_u8_mm_aesenc256kl_u8__builtin_ia32_aesenc256kl_u8_mm_aesenc128kl_u8__builtin_ia32_aesenc128kl_u8_mm_aesdec256kl_u8__builtin_ia32_aesdec256kl_u8_mm_aesdec128kl_u8__builtin_ia32_aesdec128kl_u8_mm_encodekey256_u32__builtin_ia32_encodekey256_u32_mm_encodekey128_u32__builtin_ia32_encodekey128_u32_mm_loadiwkey__builtin_ia32_loadiwkey__DISABLE_WIDEKL____DISABLE_KL___KEYLOCKERINTRIN_H_INCLUDED__KL__GCC target("kl")__WIDEKL__GCC target("widekl")/* _KEYLOCKERINTRIN_H_INCLUDED *//* __DISABLE_WIDEKL__ *//* __WIDEKL__ *//* __DISABLE_KL__ *//* __KL__ */<keylockerintrin.h><prfchwintrin.h><amxbf16intrin.h><amxint8intrin.h><amxtileintrin.h><avx512bf16intrin.h><avx512bf16vlintrin.h><vpclmulqdqintrin.h><vaesintrin.h><gfniintrin.h><f16cintrin.h><fmaintrin.h><shaintrin.h><avx512fp16vlintrin.h><avx512fp16intrin.h><avx512vp2intersectvlintrin.h><avx512vp2intersectintrin.h><avx512bitalgintrin.h><avx512vpopcntdqvlintrin.h><avx512vnnivlintrin.h><avx512vnniintrin.h><avx512vbmi2vlintrin.h><avx512vbmi2intrin.h><avx512vpopcntdqintrin.h><avx5124vnniwintrin.h><avx5124fmapsintrin.h><avx512vbmivlintrin.h><avx512vbmiintrin.h><avx512ifmavlintrin.h><avx512ifmaintrin.h><avx512vldqintrin.h><avx512vlbwintrin.h><avx512dqintrin.h><avx512bwintrin.h><avx512vlintrin.h><avx512cdintrin.h><avx512pfintrin.h><avx512erintrin.h><avx512fintrin.h><avx2intrin.h><avxvnniintrin.h><avxintrin.h><smmintrin.h><x86gprintrin.h>/* _IMMINTRIN_H_INCLUDED *//home/atharvakale/390r-debugging-setup/p7zip/C/LzFind.c"LzHash.h""LzFind.h"printf("\n=== LzFind SSE41\n")printf("\n=== LzFind AVX2\n")const CLzRefconst CLzRef *num2cycPoshvHc5_MatchFinder_Skiph2h366560Hc4_MatchFinder_SkipBt5_MatchFinder_Skipcontinuepos1Bt4_MatchFinder_SkipBt3_MatchFinder_SkipBt2_MatchFinder_Skipconst UInt16const UInt16 *return distancesHc_GetMatchesSpecHc5_MatchFinder_GetMatchesmmmd2d3const ptrdiff_tdiffHc4_MatchFinder_GetMatchesBt5_MatchFinder_GetMatchesBt4_MatchFinder_GetMatchesBt3_MatchFinder_GetMatchesBt2_MatchFinder_GetMatchesMatchFinder_MovePosSkipMatchesSpecptr0ptr1len0len1cmCheckpairpbkEmptyHashValuepair0(ptrdiff_t)0MatchFinder_CheckLimitskMaxValForNormalizenumSonRefsK_NORM_ALIGN_BLOCK_SIZE(K_NORM_ALIGN_BLOCK_SIZE - 1)(size_t)K_NORM_ALIGN_MASK18446744073709551600~(size_t)K_NORM_ALIGN_MASKK_NORM_ALIGN_MASKLzFind_SaturSub_32LzFind_SaturSub_256"avx2"sub2LzFind_SaturSub_128"sse4.1"v128 *const v128const v128 *4 * 4CYC_TO_POS_OFFSETconst size_tMatchFinder_SetLimits(UInt32)(Int32)-1ksammnewCyclicBufferSizehs1 << 16(1 << 16) - 11 << 24(1 << 24)(1 << 24) - 1262144256 << kLzHash_CrcShift_2(256 << kLzHash_CrcShift_2)262143(256 << kLzHash_CrcShift_2) - 1numSonsNUM_REFS_ALIGN_MASK(size_t)NUM_REFS_ALIGN_MASK~(size_t)NUM_REFS_ALIGN_MASKGetBlockSizekBlockSizeMax(UInt32)kBlockSizeAlign4294901760(UInt32)0 - (UInt32)kBlockSizeAlignreserve(UInt32)1 << 30((UInt32)1 << 30)40961 << 12(1 << 12)kBlockMoveAlignkBlockSizeAlignkBlockSizeReserveMin(UInt32)(kBlockSizeAlign - 1)~(UInt32)(kBlockSizeAlign - 1)AllocRefssizeInBytessizeof(CLzRef)MatchFinder_FreeThisClassMemoryp->hash(UInt64)(Int64)-1MatchFinder_SetDefaultSettingskeepBefore(kBlockMoveAlign - 1)(size_t)kBlockMoveAlign(size_t)kBlockMoveAlign - 1((size_t)kBlockMoveAlign - 1)18446744073709551488~((size_t)kBlockMoveAlign - 1)MatchFinder_ReadBlockcurSizep->stream&sizeMatchFinder_GetNumAvailableBytesMatchFinder_GetPointerToCurrentPosLzInWindow_Create2LzInWindow_Freep->bufferBaseLZFIND_SATUR_SUB_CODE_FUNCv128g_LzFind_SaturSubHC_SKIP_FOOTERcur++; pos++; *son++ = curMatch; } while (--num2); p->buffer = cur; p->pos = pos; if (pos == p->posLimit) MatchFinder_CheckLimits(p); }} while(num);HC_SKIP_HEADER(minLen)do { if (p->lenLimit < minLen) { MatchFinder_MovePos(p); num--; continue; } { Byte *cur; UInt32 *hash; UInt32 *son; UInt32 pos = p->pos; UInt32 num2 = num; { const UInt32 rem = p->posLimit - pos; if (num2 > rem) num2 = rem; } num -= num2; { const UInt32 cycPos = p->cyclicBufferPos; son = p->son + cycPos; p->cyclicBufferPos = cycPos + num2; } cur = p->buffer; hash = p->hash; do { UInt32 curMatch; UInt32 hv;SET_mmmmmm = p->cyclicBufferSize; if (pos < mmm) mmm = pos;UPDATE_maxLen{ const ptrdiff_t diff = (ptrdiff_t)0 - (ptrdiff_t)d2; const Byte *c = cur + maxLen; const Byte *lim = cur + lenLimit; for (; c != lim; c++) if (*(c + diff) != *c) break; maxLen = (unsigned)(c - cur); }GET_MATCHES_FOOTER_HC(_maxLen_)GET_MATCHES_FOOTER_BASE(_maxLen_, Hc_GetMatchesSpec)GET_MATCHES_FOOTER_BT(_maxLen_)GET_MATCHES_FOOTER_BASE(_maxLen_, GetMatchesSpec1)GET_MATCHES_FOOTER_BASE(_maxLen_,func)distances = func(MF_PARAMS(p), distances, (UInt32)_maxLen_); MOVE_POS_RET;SKIP_FOOTERSkipMatchesSpec(MF_PARAMS(p)); MOVE_POS; } while (--num);MF_PARAMS(p)lenLimit, curMatch, p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValueSKIP_HEADER(minLen)do { GET_MATCHES_HEADER2(minLen, continue)GET_MATCHES_HEADER(minLen)GET_MATCHES_HEADER2(minLen, return distances)GET_MATCHES_HEADER2(minLen,ret_op)unsigned lenLimit; UInt32 hv; Byte *cur; UInt32 curMatch; lenLimit = (unsigned)p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} cur = p->buffer;MOVE_POS_RETMOVE_POS return distances;MOVE_POS++p->cyclicBufferPos; p->buffer++; { const UInt32 pos1 = p->pos + 1; p->pos = pos1; if (pos1 == p->posLimit) MatchFinder_CheckLimits(p); }(K_NORM_ALIGN_BLOCK_SIZE / 4 - 1)(1 << 6)DEFAULT_SaturSubSASUB_32(i)v = items[i]; if (v < subValue) v = subValue; items[i] = v - subValue;SASUB_256(i)*(__m256i *)(void *)(items + (i) * 8) = _mm256_sub_epi32(_mm256_max_epu32(*(const __m256i *)(const void *)(items + (i) * 8), sub2), sub2);SASUB_128(i)*(v128 *)(void *)(items + (i) * 4) = _mm_sub_epi32(_mm_max_epu32(*(const v128 *)(const void *)(items + (i) * 4), sub2), sub2);ATTRIB_AVX2__attribute__((__target__("avx2")))ATTRIB_SSE41__attribute__((__target__("sse4.1")))USE_AVX2USE_SATUR_SUB_128HASH_ZIP_CALChv = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;HASH5_CALC{ UInt32 temp = p->crc[cur[0]] ^ cur[1]; h2 = temp & (kHash2Size - 1); temp ^= ((UInt32)cur[2] << 8); h3 = temp & (kHash3Size - 1); temp ^= (p->crc[cur[3]] << kLzHash_CrcShift_1); hv = (temp ^ (p->crc[cur[4]] << kLzHash_CrcShift_2)) & p->hashMask; }HASH4_CALC{ UInt32 temp = p->crc[cur[0]] ^ cur[1]; h2 = temp & (kHash2Size - 1); temp ^= ((UInt32)cur[2] << 8); h3 = temp & (kHash3Size - 1); hv = (temp ^ (p->crc[cur[3]] << kLzHash_CrcShift_1)) & p->hashMask; }HASH3_CALC{ UInt32 temp = p->crc[cur[0]] ^ cur[1]; h2 = temp & (kHash2Size - 1); hv = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }HASH2_CALChv = GetUi16(cur);kFix5HashSizeGET_AVAIL_BYTES(p)((UInt32)0)(1 << 7)(kBlockSizeReserveMin < kBlockSizeAlign * 2)defined(__clang__) && (__clang_major__ >= 8) \(_MSC_VER >= 1600)(_MSC_VER >= 1900)_SHOW_HW_STATUSMY_CPU_ARM_OR_ARM64FORCE_SATUR_SUB_128defined(USE_SATUR_SUB_128) && !defined(FORCE_SATUR_SUB_128)// FORCE_SATUR_SUB_128// USE_SATUR_SUB_128// #pragma message ("=== LzFind AVX2")// #pragma message ("=== LzFind SSE41")// f = 0; // for debug// #pragma message ("=== LzFind NEON")// (hash + kFix4HashSize)[h4] =/* (p->pos == p->posLimit) is not allowed here !!! */// (hash + kFix4HashSize)[h4] = pos;// d4 = pos - (hash + kFix4HashSize)[h4];// distances[-2] = 3;/* we go here at the end of stream data, when (avail < num_hash_bytes)
     We don't update sons[cyclicBufferPos << btMode].
     So (sons) record will contain junk. And we cannot resume match searching
     to normal operation, even if we will provide more input data in buffer.
     p->sons[p->cyclicBufferPos << p->btMode] = 0;  // kEmptyHashValue
     if (p->btMode)
        p->sons[(p->cyclicBufferPos << p->btMode) + 1] = 0;  // kEmptyHashValue
  */// curMatch >= pos ||  // failure// curMatch = curMatch2;// if (curMatch2 >= curMatch) { *ptr0 = *ptr1 = kEmptyHashValue;  return NULL; }// const UInt32 curMatch2 = pair[1];// if (curMatch >= pos) { *ptr0 = *ptr1 = kEmptyHashValue; return NULL; }// if (curMatch2 >= curMatch) return NULL;/*
  son[_cyclicBufferPos] = curMatch;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
      return d;
    {
      const Byte *pb = cur - delta;
      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
      {
        UInt32 len = 0;
        while (++len != lenLimit)
          if (pb[len] != cur[len])
            break;
        if (maxLen < len)
        {
          maxLen = len;
          *d++ = len;
          *d++ = delta - 1;
          if (len == lenLimit)
            return d;
        }
      }
    }
  }
  *//*
  (lenLimit > maxLen)
*/// printf("\nMatchFinder_Normalize() subValue == 0x%x\n", subValue);// const UInt32 subValue = (1 << 15); // for debug/* & ~(UInt32)(kNormalizeAlign - 1) *//* we can reduce subValue to aligned value, if want to keep alignment
       of (p->pos) and (p->buffer) for speculated accesses. *//* after normalization we need (p->pos >= p->historySize + 1); */// MatchFinder_Normalize(p);/*
       if we disable normalization for last bytes of data, and
       if (data_size == 4 GiB), we don't call wastfull normalization,
       but (pos) will be wrapped over Zero (0) in that case.
       And we cannot resume later to normal operation
    */// optional optimization for last bytes of data.// we try to read only in exact state (p->keepSizeAfter == GET_AVAIL_BYTES(p))// !p->streamEndWasReached && p->result == SZ_OK &&// call MatchFinder_CheckLimits() only after (p->pos++) update// #define SASUB_32(i) v = items[i];  m = v - subValue;  if (v < subValue) m = kEmptyHashValue;  items[i] = m;// kEmptyHashValue must be zero// USE_AVX2// AVX2// avx// SSE 4.1// sse4.1// #define FORCE_SATUR_SUB_128// #define _SHOW_HW_STATUS/*
#ifndef ATTRIB_SSE41
  #define ATTRIB_SSE41
#endif
#ifndef ATTRIB_AVX2
  #define ATTRIB_AVX2
#endif
*/// #define ATTRIB_SSE41 __attribute__((__target__("fpu=crypto-neon-fp-armv8")))// #define ATTRIB_SSE41 __attribute__((__target__("")))// #elif defined(MY_CPU_ARM_OR_ARM64)// p->son[0] = p->son[1] = 0; // unused: we can init skipped record for speculated accesses.// p->cyclicBufferPos = 0; // smallest value// init with relation to (pos)/* if we init (cyclicBufferPos = pos), then we can use one variable
     instead of both (cyclicBufferPos) and (pos) : only before (cyclicBufferPos) wrapping */// if (readData)// #define CYC_TO_POS_OFFSET 1 // for debug// (CYC_TO_POS_OFFSET == 0) is expected by some optimized code// 0; // for debug// it's smallest optimal value. do not change it/* kEmptyHashValue = 0 (Zero) is used in hash tables as NO-VALUE marker.
       the code in CMatchFinderMt expects (pos = 1) */// k = 1; // non-optimized version : for debug// optimization : to reduce the number of checks// the limitation for (p->lenLimit) update// we must limit exactly to keepSizeAfter for ReadBlock// we allow (pos == 0) at start even with (kMaxValForNormalize == 0)// aligned size is not required here, but it can be better for some loops// it must be = (historySize + 1)// if (p->numHashBytes > 4) p->fixedHashSize += hs4; // kHash4Size;/*
      hs4 = (1 << 20);
      if (hs4 > hs)
        hs4 = hs;
      // hs4 = (1 << 16); // for test
      p->hash4Mask = hs4 - 1;
      */// bt5: we adjust the size with recommended minimum size/* don't change it! */// (hash_size >= (1 << 16)) : Required for (numHashBytes > 2)// hs = ((UInt32)1 << 25) - 1; // for test/* if (bigHash) mode, GetHeads4b() in LzFindMt.c needs (hs >= ((1 << 24) - 1))) */// we propagated 16 bits in (hs). Low 16 bits must be set later// UInt32 hs4;// do not change it// keepAddBufferAfter -= 2; // for debug/* we need (p->keepSizeAfter >= p->numHashBytes) */// keepAddBufferBefore = (UInt32)0xFFFFFFFF - (1 << 22); // for debug/* we need one additional byte in (p->keepSizeBefore),
     since we use MoveBlock() after (p->pos++) and before dictionary using */// printf("\n LzFind_blockSize = %d\n", blockSize >> 20);// printf("\n LzFind_blockSize = %x\n", blockSize);// we reject settings that will be slow// do not overflow 32-bit here// if 32-bit overflow// printf("\nhistorySize == 0x%x\n", historySize);/*
  if (historySize > kMaxHistorySize)
    return 0;
  *//* We call MoveBlock() before ReadBlock().
   So MoveBlock() can be wasteful operation, if the whole input data
   can fit in current block even without calling MoveBlock().
   in important case where (dataSize <= historySize)
     condition (p->blockSize > dataSize + p->keepSizeAfter) is met
     So there is no MoveBlock() in that case case.
*/// on exit: (p->result != SZ_OK || p->streamEndWasReached || GET_AVAIL_BYTES(p) > p->keepSizeAfter)/* here and in another (p->keepSizeAfter) checks we keep on 1 byte more than was requested by Create() function
         (GET_AVAIL_BYTES(p) >= p->keepSizeAfter) - minimal required size */// if (size > kRead) size = kRead; // for debug// #define kRead 3// p->result = SZ_ERROR_FAIL; // we can show error here/* we call ReadBlock() after NeedMove() and MoveBlock().
         NeedMove() and MoveBlock() povide more than (keepSizeAfter)
         to the end of (blockSize).
         So we don't execute this branch in normal code flow.
         We can go here, if we will call ReadBlock() before NeedMove(), MoveBlock().
      *//* We use (p->streamPos - p->pos) value.
     (p->streamPos < p->pos) is allowed. */// return 0; // for debug// printf("\nbufferBase = %p\n", p->bufferBase);/*
    #if defined _WIN64
    // we can allocate 4GiB, but still use UInt32 for (p->blockSize)
    // we use UInt32 type for (p->blockSize), because
    // we don't want to wrap over 4 GiB,
    // when we use (p->streamPos - p->pos) that is UInt32.
    if (blockSize >= (UInt32)0 - (UInt32)kBlockSizeAlign)
    {
      blockSizeT = ((size_t)1 << 32);
      printf("\nchanged to blockSizeT = 4GiB\n");
    }
    #endif
    */// printf("\nblockSize = 0x%x\n", blockSize);// blockSizeT = blockSize;// size_t blockSizeT;/* (kHash4Size - 1); *//* h4 = temp & p->hash4Mask; *//*
 HASH3_CALC:
   if (cur[0]) and (h2) match, then cur[1]            also match
   if (cur[0]) and (hv) match, then cur[1] and cur[2] also match
*/// (crc[0 ... 255] & 0xFF) provides one-to-one correspondence to [0 ... 255]/*
 HASH2_CALC:
   if (hv) match, then cur[0] and cur[1] also match
*/// #define kNormalizeAlign (1 << 7) // alignment for speculated accesses// #define kMaxValForNormalize ((UInt32)(1 << 20) + 0xFFF) // for debug// it's 1/256 from 4 GB dictinary// alignment for block allocation// alignment for memmove()/* LzFind.c -- Match finder for LZ algorithms
2021-11-29 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/LzFindMt.h/home/atharvakale/390r-debugging-setup/p7zip/C/Threads.h/usr/include/pthread.h/usr/include/sched.h/usr/include/bits/sched.h/usr/include/bits/types/struct_sched_param.h/usr/include/bits/cpu-set.h/usr/include/time.h/usr/include/bits/time.h/usr/include/bits/types/struct_tm.h/usr/include/bits/types/struct_itimerspec.h/usr/include/bits/setjmp.h/usr/include/bits/types/struct___jmp_buf_tag.h/usr/include/bits/pthread_stack_min-dynamic.h/usr/include/bits/pthread_stack_min.h/home/atharvakale/390r-debugging-setup/p7zip/C/LzFindMt.c"LzFindMt.h"MatchFinderMt_CreateVTableCMatchFinderMt *_CMatchFinderMt *(Mf_Mix_Matches)NULLMatchFinderMt3_SkipMatchFinderMt2_SkipMatchFinderMt0_SkipMatchFinderMt_GetMatchesbtavailBT_HASH_BYTES_MAX(BT_HASH_BYTES_MAX - 1)(BT_HASH_BYTES_MAX - 1) - 1v0v1MatchFinderMt2_GetMatchesbtLimMixMatches4c2c3matchMinPosMixMatches3MixMatches2MatchFinderMt_GetNumAvailableBytesMatchFinderMt_GetPointerToCurrentPosMatchFinderMt_GetNextBlock_BtbiUInt32[1]unsigned int[1]CMtSync *_CMtSync *kMtBtBlockSizekMtMaxValForNormalize(UInt32)kMtMaxValForNormalize(UInt32)kMtBtBlockSize4294901759(UInt32)kMtMaxValForNormalize - (UInt32)kMtBtBlockSizeMatchFinderMt_ReleaseStreamMatchFinderMt_InitmfMatchFinderMt_InitMtMtSync_Init(&p->hashSync, kMtHashNumBlocks)MtSync_Init(&p->hashSync, (1 << 1))kMtBtNumBlocksMatchFinderMt_Create((size_t)kHashBufferSize + (size_t)kBtBufferSize) * sizeof(UInt32)((size_t)(((UInt32)1 << 17) * (1 << 1)) + (size_t)(((UInt32)1 << 16) * (1 << 4))) * sizeof(UInt32)13107213107205242880kHashBufferSizekBtBufferSize(kHashBufferSize + kBtBufferSize)kMtHashBlockSizeMtSync_Create(&p->hashSync, HashThreadFunc2, p)MtSync_Create(&p->btSync, BtThreadFunc2, p)BtThreadFunc2Byte[384]unsigned char[384]3840x180allocaDummy(Byte)0HashThreadFunc2MatchFinderMt_Destructprintf("\nTree %9d * %7d iter = %9d = sum  :  bytes = %9d\n", (UInt32)(g_NumIters_Tree / 1000), (UInt32)(((UInt64)g_NumIters_Loop * 1000) / (g_NumIters_Tree + 1)), (UInt32)(g_NumIters_Loop / 1000), (UInt32)(g_NumIters_Bytes / 1000) )MatchFinderMt_FreeMemp->hashBufMatchFinderMt_ConstructBtThreadFuncprintf("  BT thread block = %d  pos = %d\n", (unsigned)blockIndex, mt->pos)&p->filledSemaphoreblockIndexCEvent *_CEvent *CAutoResetEvent *CSemaphore *_CSemaphore *BtFillBlocksyncCCriticalSection *_CCriticalSection *globalBlockIndexBtGetMatchesnumProcessedcurPosavailSumposResd_endGetMatchesSpecN_2HashThreadFuncprintf("\nHashThreadFunc : Event_Wait(&p->canStart)\n")printf("\nHashThreadFunc : Event_Wait(&p->canStart) : after \n")printf("\nHashThreadFunc : exit \n")mtprintf("Hash thread block = %d pos = %d\n", (unsigned)blockIndex, mt->MatchFinder->pos)blockIndex++beforePtrheads131070printf("\nHashThreadFunc\n")GetHeads5b5bcrc0crc1numHeadscrc0[p[0]] ^ crc1[p[4]] ^ GetUi24hi_from32(p)crc0[p[0]] ^ crc1[p[4]] ^ ((UInt32)(*(const UInt32 *)(const void *)(p)) >> 8)valueGetHeads5crc2crc0[p[0]] ^ crc1[p[3]] ^ crc2[p[4]] ^ (UInt32)GetUi16(p+1)crc0[p[0]] ^ crc1[p[3]] ^ crc2[p[4]] ^ (UInt32)(*(const UInt16 *)(const void *)(p+1))p+1GetHeads4b4bcrc0[p[0]] ^ GetUi24hi_from32(p)crc0[p[0]] ^ ((UInt32)(*(const UInt32 *)(const void *)(p)) >> 8)GetHeads4crc0[p[0]] ^ crc1[p[3]] ^ (UInt32)GetUi16(p+1)crc0[p[0]] ^ crc1[p[3]] ^ (UInt32)(*(const UInt16 *)(const void *)(p+1))GetHeads3b3bGetUi16(p) ^ ((UInt32)(p)[2] << 16)(*(const UInt16 *)(const void *)(p)) ^ ((UInt32)(p)[2] << 16)UNUSED_VAR(hashMask); UNUSED_VAR(crc);(void)hashMask;; (void)crc;;GetHeads3(crc[p[0]] ^ GetUi16(p + 1)) & hashMask(crc[p[0]] ^ (*(const UInt16 *)(const void *)(p + 1))) & hashMaskp + 1GetHeads2MtSync_Createconst WReswres134217728MtSync_Create_WResCriticalSection_Init(&p->cs)AutoResetEvent_CreateNotSignaled(&p->canStart)AutoResetEvent_CreateNotSignaled(&p->wasStopped)CThread *_CThread *MtSync_InitMtSync_Destruct&p->threadprintf("\nMtSync_Destruct %p\n", p)MtSync_StopWriting&p->freeSemaphoreprintf("\nMtSync_StopWriting %p\n", p)printf("\nMtSync_StopWriting %p : Event_Wait(&p->wasStopped)\n", p)printf("\nMtSync_StopWriting %p : Event_Wait() finsihed\n", p)MtSync_GetNextBlockMtSync_Construct&p->canStart&p->wasStoppedSKIP_FOOTER_MT} INCREASE_LZ_POS p->btBufPos += (size_t)*p->btBufPos + 1; } while (--num != 0);SKIP_HEADER_MT(n)SKIP_HEADER2_MT if (p->btNumAvailBytes-- >= (n)) { const Byte *cur = p->pointerToCurPos; UInt32 *hash = p->hash;SKIP_HEADER2_MTdo { GET_NEXT_BLOCK_IF_REQUIRED_USE_H2INCREASE_LZ_POSp->lzPos++; p->pointerToCurPos++;CHECK_FAILURE_LZ(_match_,_pos_)GET_NEXT_BLOCK_IF_REQUIREDif (p->btBufPos == p->btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);(kMtBtBlockSize * kMtBtNumBlocks)(kMtHashBlockSize * kMtHashNumBlocks)MFMT_GM_INLINEUSE_GetHeads_LOCAL_CRCDEF_GetHeads(name,v)DEF_GetHeads2(name, v, ;)DEF_GetHeads2(name,v,action)GetHeads_DECL(name) { action GetHeads_LOOP(v) }GetHeads_LOOP(v)for (; numHeads != 0; numHeads--) { const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++; }GetHeads_DECL(name)static void GetHeads ## name(const Byte *p, UInt32 pos, UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc)GetUi24hi_from32(p)((UInt32)GetUi32(p) >> 8)RINOK_THREAD(x)UNLOCK_BUFFER(p){ BUFFER_MUST_BE_LOCKED(p); CriticalSection_Leave(&(p)->cs); (p)->csWasEntered = False; }LOCK_BUFFER(p){ BUFFER_MUST_BE_UNLOCKED(p); CriticalSection_Enter(&(p)->cs); (p)->csWasEntered = True; }BUFFER_MUST_BE_UNLOCKED(p)if ( (p)->csWasEntered) exit(1);BUFFER_MUST_BE_LOCKED(p)if (!(p)->csWasEntered) exit(1);DEBUG_BUFFER_LOCKMT_HASH3_CALC{ UInt32 temp = MF_CRC[cur[0]] ^ cur[1]; h2 = temp & (kHash2Size - 1); h3 = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }MT_HASH2_CALCh2 = (MF_CRC[cur[0]] ^ cur[1]) & (kHash2Size - 1);MF_CRC(p->crc)MF(mt)((mt)->MatchFinder)GET_BT_BLOCK_OFFSET(i)(((i) & (kMtBtNumBlocks - 1)) * (size_t)kMtBtBlockSize)((UInt32)1 << 16)GET_HASH_BLOCK_OFFSET(i)(((i) & (kMtHashNumBlocks - 1)) * kMtHashBlockSize)kMtHashNumBlocks((UInt32)1 << 17)LOG_ITER(x)LOG_THREADLOG_ITERSstartAddressobj_USE_H4// (Mf_Skip_Func)MatchFinderMt4_Skip;// vTable->GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches_Bt4;// it's fast inline version of GetMatches()/*
// MatchFinderMt4_Skip() is similar to MatchFinderMt3_Skip().
// The difference is that MatchFinderMt3_Skip() updates hash for last 3 bytes of stream.

static void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
{
  SKIP_HEADER_MT(4)
      UInt32 h2, h3; // h4
      MT_HASH3_CALC
      // MT_HASH4_CALC
      // (hash + kFix4HashSize)[h4] =
      (hash + kFix3HashSize)[h3] =
      hash[                h2] =
        p->lzPos;
  SKIP_FOOTER_MT
}
*/// if (d) // check for failure/*
      first match pair from BinTree: (match_len, match_dist),
      (match_len >= numHashBytes).
      MixMatchesFunc() inserts only hash matches that are nearer than (match_dist)
    */// return d + 2;// d[0] = (cur[(ptrdiff_t)c2 - (ptrdiff_t)m + 3] == cur[3]) ? 4 : 3;// (hash + kFix4HashSize)[h4] = m;// c4 = (hash + kFix4HashSize)[h4];// MT_HASH4_CALC/* , c4 *//* h4, *//*
static
UInt32* MatchFinderMt_GetMatches_Bt4(CMatchFinderMt *p, UInt32 *d)
{
  const UInt32 *bt = p->btBufPos;
  const UInt32 len = *bt++;
  const UInt32 *btLim = bt + len;
  UInt32 matchMinPos;
  UInt32 avail = p->btNumAvailBytes - 1;
  p->btBufPos = btLim;

  {
    p->btNumAvailBytes = avail;

    #define BT_HASH_BYTES_MAX 5
      
    matchMinPos = p->lzPos;

    if (len != 0)
      matchMinPos -= bt[1];
    else if (avail < (BT_HASH_BYTES_MAX - 1) - 1)
    {
      INCREASE_LZ_POS
      return d;
    }
    else
    {
      const UInt32 hs = p->historySize;
      if (matchMinPos > hs)
        matchMinPos -= hs;
      else
        matchMinPos = 1;
    }
  }

  for (;;)
  {
  
  UInt32 h2, h3, c2, c3;
  UInt32 *hash = p->hash;
  const Byte *cur = p->pointerToCurPos;
  UInt32 m = p->lzPos;
  MT_HASH3_CALC

  c2 = hash[h2];
  c3 = (hash + kFix3HashSize)[h3];
 
  hash[h2] = m;
  (hash + kFix3HashSize)[h3] = m;

  if (c2 >= matchMinPos && cur[(ptrdiff_t)c2 - (ptrdiff_t)m] == cur[0])
  {
    d[1] = m - c2 - 1;
    if (cur[(ptrdiff_t)c2 - (ptrdiff_t)m + 2] == cur[2])
    {
      d[0] = 3;
      d += 2;
      break;
    }
    // else
    {
      d[0] = 2;
      d += 2;
    }
  }
  if (c3 >= matchMinPos && cur[(ptrdiff_t)c3 - (ptrdiff_t)m] == cur[0])
  {
    *d++ = 3;
    *d++ = m - c3 - 1;
  }
  break;
  }

  if (len != 0)
  {
    do
    {
      const UInt32 v0 = bt[0];
      const UInt32 v1 = bt[1];
      bt += 2;
      d[0] = v0;
      d[1] = v1;
      d += 2;
    }
    while (bt != btLim);
  }
  INCREASE_LZ_POS
  return d;
}
*/// #define CHECK_FAILURE_LZ(_match_, _pos_) if (_match_ >= _pos_) { p->failure_LZ_LZ = True;  return d; }// & ~(UInt32)(kNormalizeAlign - 1);/* we don't check (lzPos) over exact avail bytes in (btBuf).
         (fixedHashSize) is small, so normalization is fast *//* we don't want to decrease AvailBytes, that was load before.
            that can be unxepected for the code that have loaded anopther value before */// p->btNumAvailBytes = 0;/* p->MatchFinder->ReleaseStream(); */// Sleep(200); // for debug// Sleep(1); // for debug/* ReleaseStream is required to finish multithreading */// p->son[0] = p->son[1] = 0; // unused: to init skipped record for speculated accesses./* we must init (p->pos = mf->pos) for BT, because
     BT code needs (p->pos == delta_value_for_empty_hash_record == mf->pos) */// kNormalizeAlign; // for debug// 0; // for debug: ignores match to start// mf->streamPos = mf->pos = 1; // optimal smallest value/* (mf->pos) and (mf->streamPos) were already initialized to 1 in MatchFinder_Init_4() */// memcpy(p->crc, mf->crc, sizeof(mf->crc));// p->hash4Mask = mf->hash4Mask;// optimal smallest value// p->failure_LZ_LZ = False;/* Init without data reading. We don't want to read data in this thread */// 21.03/*
     HASH_THREAD can use CriticalSection(s) btSync.cs and hashSync.cs.
     So we must be sure that HASH_THREAD will not use CriticalSection(s)
     after deleting CriticalSection here.

     we call ReleaseStream(p)
       that calls StopWriting(btSync)
         that calls StopWriting(hashSync), if it's required to stop HASH_THREAD.
     after StopWriting() it's safe to destruct MtSync(s) in any order */// p->numBlocks_Sent = blockIndex;// we stop HASH_THREAD here// for faster stop : we check (p->stopWriting) after Wait(freeSemaphore)/* (p->exit == true) is possible after (p->canStart) at first loop iteration
         and is unexpected after more Wait(freeSemaphore) iterations *//* We suppose that we have called GetNextBlock() from start.
     So buffer is LOCKED */// d[1] = 0;// internal data failure// printf("\n == 2 BtGetMatches() p->failure_BT\n");/* here we suppose that we have space enough:
         (kMtBtBlockSize - curPos >= p->hashNumAvail) *//* (avail < p->numHashBytes)
         It means that stream was finished.
         And (avail) - is a number of remaining bytes,
         we fill (d) for (avail) bytes for LZ_THREAD (receiver).
         but we don't update (p->pos) and (p->cyclicBufferPos) here in BT_THREAD */// if (p->hashBufPos != p->hashBufPosLimit) exit(1);/* we must prevent UInt32 overflow for avail total value,
           if avail was increased with new hash block */// MatchFinderMt_GetNextBlock_Hash(p);// printf("\n == 1 BtGetMatches() p->failure_BT\n");/* GetMatchesSpec() functions don't create (len = 1)
     in [len, dist] match pairs, if (p->numHashBytes >= 2)
     Also we suppose here that (matchMaxLen >= 2).
     So the following code for (reserve) is not required
     UInt32 reserve = (p->matchMaxLen * 2);
     const UInt32 kNumHashBytes_Max = 5; // BT_HASH_BYTES_MAX
     if (reserve < kNumHashBytes_Max - 1)
        reserve = kNumHashBytes_Max - 1;
     const UInt32 limit = kMtBtBlockSize - (reserve);
  *//*
  we use size_t for (pos) instead of UInt32
  to eliminate "movsx" BUG in old MSVC x64 compiler.
*//* we use one variable instead of two (cyclicBufferPos == pos) before CyclicBuf wrap.
   here we define fixed offset of (p->pos) from (p->cyclicBufferPos) */// ---------- BT THREAD ----------// for() thread end// for() processing end// wrap over zero is allowed at the end of stream/* heads[1] contains the number of avail bytes:
             if (avail < mf->numHashBytes) :
             {
               it means that stream was finished
               HASH_THREAD and BT_TREAD must move position for heads[1] (avail) bytes.
               HASH_THREAD doesn't stop,
               HASH_THREAD fills only the header (2 numbers) for all next blocks:
               {2, NumHashBytes - 1}, {2,0}, {2,0}, ... , {2,0}
             }
             else
             {
               HASH_THREAD and BT_TREAD must move position for (heads[0] - 2) bytes;
             }
          */// exit is unexpected here. But we check it here for some failure case// crc1[i] = rotlFixed(v, 8) & hashMask;/*
GetHeads_DECL(4)
{
  unsigned sh = 0;
  UNUSED_VAR(crc)
  while ((hashMask & 0x80000000) == 0)
  {
    hashMask <<= 1;
    sh++;
  }
  GetHeads_LOOP((GetUi32(p) * 0xa54a1) >> sh)
}
#define GetHeads4b GetHeads4
*//*
GetHeads_DECL(3b)
{
  UNUSED_VAR(hashMask);
  UNUSED_VAR(crc);
  {
  const Byte *pLim = p + numHeads;
  if (numHeads == 0)
    return;
  pLim--;
  while (p < pLim)
  {
    UInt32 v1 = GetUi32(p);
    UInt32 v0 = v1 & 0xFFFFFF;
    UInt32 h0, h1;
    p += 2;
    v1 >>= 8;
    h0 = hash[v0]; hash[v0] = pos; heads[0] = pos - h0; pos++;
    h1 = hash[v1]; hash[v1] = pos; heads[1] = pos - h1; pos++;
    heads += 2;
  }
  if (p == pLim)
  {
    UInt32 v0 = GetUi16(p) ^ ((UInt32)(p)[2] << 16);
    *heads = pos - hash[v0];
    hash[v0] = pos;
  }
  }
}
*/// BT3 is not good for crc collisions for big hashMask values.// #define kMtMaxValForNormalize ((1 << 21)) // for debug// ---------- HASH THREAD ----------// return EINVAL; // for debug// return ERROR_TOO_MANY_POSTS; // for debug/* p->exit is unused before (canStart) Event.
     But in case of some unexpected code failure we will get fast exit from thread */// BUFFER_MUST_BE_UNLOCKED(p)// call it before each new file (when new starting is required):// we want to get real system error codes here instead of SZ_ERROR_THREAD// #define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }// we wait thread finishing// we send EXIT command to thread// if (p->needStart)  // it's (true)/* thread in Stopped state here : (p->needStart == true) *//* we want thread to be in Stopped state before sending EXIT command.
       note: stop(btSync) will stop (htSync) also *//* 21.03 : we don't restore samaphore counters here.
     We will recreate and reinit samaphores in next start */// check semaphore count !!!/* We send (p->stopWriting) message and release freeSemaphore
     to free current block.
     So the thread will see (p->stopWriting) at some
     iteration after Wait(freeSemaphore).
     The thread doesn't need to fill all avail free blocks,
     so we can get fast thread stop.
  *//* we don't use buffer in this thread after StopWriting().
       So we UNLOCK buffer.
       And we restore default UNLOCKED state for stopped thread *//* if Writing (Processing) thread was started, we must call MtSync_StopWriting() */// buffer is UNLOCKED here// we free current block// define it to debug lock state/*
#define MT_HASH3_CALC__NO_2 { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  h3 = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }

#define __MT_HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  h2 = temp & (kHash2Size - 1); \
  temp ^= ((UInt32)cur[2] << 8); \
  h3 = temp & (kHash3Size - 1); \
  h4 = (temp ^ (p->crc[cur[3]] << kLzHash_CrcShift_1)) & p->hash4Mask; }
  // (kHash4Size - 1);
*/// #define MF_CRC (p->MatchFinder.crc)// #define MF(mt) (&(mt)->MatchFinder)/*
  HASH functions:
  We use raw 8/16 bits from a[1] and a[2],
  xored with crc(a[0]) and crc(a[3]).
  We check a[0], a[3] only. We don't need to compare a[1] and a[2] in matches.
  our crc() function provides one-to-one correspondence for low 8-bit values:
    (crc[0...0xFF] & 0xFF) <-> [0...0xFF]
*/// #define LOG_THREAD// #define LOG_ITERS/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
2021-12-21 : Igor Pavlov : Public domain */_maxLen/home/atharvakale/390r-debugging-setup/p7zip/C/LzFindOpt.cg_NumIters_Tree++g_NumIters_Loop++g_NumIters_Bytes++cbs_distancespair1p0p1USE_LONG_MATCH_OPTUSE_SON_PREFETCH/*
typedef UInt32 uint32plus; // size_t

UInt32 * MY_FAST_CALL GetMatchesSpecN_3(uint32plus lenLimit, size_t pos, const Byte *cur, CLzRef *son,
    UInt32 _cutValue, UInt32 *d, uint32plus _maxLen, const UInt32 *hash, const UInt32 *limit, const UInt32 *size,
    size_t _cyclicBufferPos, UInt32 _cyclicBufferSize,
    UInt32 *posRes)
{
  do // while (hash != size)
  {
    UInt32 delta;

  #ifndef cbs
    UInt32 cbs;
  #endif

    if (hash == size)
      break;

    delta = *hash++;

    if (delta == 0)
      return NULL;

  #ifndef cbs
    cbs = _cyclicBufferSize;
    if ((UInt32)pos < cbs)
    {
      if (delta > (UInt32)pos)
        return NULL;
      cbs = (UInt32)pos;
    }
  #endif
    
    if (delta >= cbs)
    {
      CLzRef *ptr1 = son + ((size_t)_cyclicBufferPos << 1);
      *d++ = 0;
      ptr1[0] = kEmptyHashValue;
      ptr1[1] = kEmptyHashValue;
    }
else
{
  CLzRef *ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;
  CLzRef *ptr1 = son + ((size_t)_cyclicBufferPos << 1);
  UInt32 *_distances = ++d;
  uint32plus len0 = 0, len1 = 0;
  UInt32 cutValue = _cutValue;
  uint32plus maxLen = _maxLen;
  // lenLimit++; // const Byte *lenLimit = cur + _lenLimit;

  for (LOG_ITER(g_NumIters_Tree++);;)
  {
    LOG_ITER(g_NumIters_Loop++);
    {
      // const ptrdiff_t diff = (ptrdiff_t)0 - (ptrdiff_t)delta;
      CLzRef *pair = son + ((size_t)((ptrdiff_t)_cyclicBufferPos - delta
          + (ptrdiff_t)(UInt32)(_cyclicBufferPos < delta ? cbs : 0)
          ) << 1);
      const Byte *pb = cur - delta;
      uint32plus len = (len0 < len1 ? len0 : len1);

    #ifdef USE_SON_PREFETCH
      const UInt32 pair0 = *pair;
    #endif

      if (pb[len] == cur[len])
      {
        if (++len != lenLimit && pb[len] == cur[len])
          while (++len != lenLimit)
            if (pb[len] != cur[len])
              break;
        if (maxLen < len)
        {
          maxLen = len;
          *d++ = (UInt32)len;
          *d++ = delta - 1;
          if (len == lenLimit)
          {
            {
              const UInt32 pair1 = pair[1];
              *ptr0 = pair1;
              *ptr1 =
              #ifdef USE_SON_PREFETCH
                pair0;
              #else
                pair[0];
              #endif
            }

            _distances[-1] = (UInt32)(d - _distances);

            #ifdef USE_LONG_MATCH_OPT

                if (hash == size || *hash != delta || pb[lenLimit] != cur[lenLimit] || d >= limit)
                  break;

            {
              const ptrdiff_t diff = (ptrdiff_t)0 - (ptrdiff_t)delta;
              for (;;)
              {
                *d++ = 2;
                *d++ = (UInt32)lenLimit;
                *d++ = delta - 1;
                _cyclicBufferPos++;
                {
                  CLzRef *dest = son + ((size_t)_cyclicBufferPos << 1);
                  const CLzRef *src = dest + ((diff +
                      (ptrdiff_t)(UInt32)(_cyclicBufferPos < delta ? cbs : 0)) << 1);
                #if 0
                  *(UInt64 *)(void *)dest = *((const UInt64 *)(const void *)src);
                #else
                  const UInt32 p0 = src[0];
                  const UInt32 p1 = src[1];
                  dest[0] = p0;
                  dest[1] = p1;
                #endif
                }
                hash++;
                pos++;
                cur++;
                pb++;
                if (hash == size || *hash != delta || pb[lenLimit] != cur[lenLimit] || d >= limit)
                  break;
              }
            }
            #endif

            break;
          }
        }
      }
      {
        const UInt32 curMatch = (UInt32)pos - delta;
        if (pb[len] < cur[len])
        {
          delta = pair[1];
          *ptr1 = curMatch;
          ptr1 = pair + 1;
          len1 = len;
        }
        else
        {
          delta = *pair;
          *ptr0 = curMatch;
          ptr0 = pair;
          len0 = len;
        }

        {
          if (delta >= curMatch)
            return NULL;
          delta = (UInt32)pos - delta;
          if (delta >= cbs
              // delta >= _cyclicBufferSize || delta >= pos
              || --cutValue == 0)
          {
            *ptr0 = *ptr1 = kEmptyHashValue;
            _distances[-1] = (UInt32)(d - _distances);
            break;
          }
        }
      }
    }
  } // for (tree iterations)
}
    pos++;
    _cyclicBufferPos++;
    cur++;
  }
  while (d < limit);
  *posRes = (UInt32)pos;
  return d;
}
*/// for (tree iterations)// (UInt32)(pos + diff);// break from TREE iterations// for() end for long matches// CLzRef *ptr = son + ((size_t)(pos) << 1) - CYC_TO_POS_OFFSET * 2;// SPEC code// SPEC// if (cutValue == 0) { *ptr0 = *ptr1 = kEmptyHashValue; } else// while (hash != size)/*
  we use size_t for (pos) and (_cyclicBufferPos_ instead of UInt32
  to eliminate "movsx" BUG in old MSVC x64 compiler.
*/// #define cbs _cyclicBufferSize/* define cbs if you use 2 functions.
       GetMatchesSpecN_1() :  (pos <  _cyclicBufferSize)
       GetMatchesSpecN_2() :  (pos >= _cyclicBufferSize)

  do not define cbs if you use 1 function:
       GetMatchesSpecN_2()
*//*
MY_NO_INLINE
UInt32 * MY_FAST_CALL GetMatchesSpecN_1(const Byte *lenLimit, size_t pos, const Byte *cur, CLzRef *son,
    UInt32 _cutValue, UInt32 *d, size_t _maxLen, const UInt32 *hash, const UInt32 *limit, const UInt32 *size, UInt32 *posRes)
{
  do
  {
    UInt32 delta;
    if (hash == size)
      break;
    delta = *hash++;

    if (delta == 0 || delta > (UInt32)pos)
      return NULL;

    lenLimit++;

    if (delta == (UInt32)pos)
    {
      CLzRef *ptr1 = son + ((size_t)pos << 1) - CYC_TO_POS_OFFSET * 2;
      *d++ = 0;
      ptr1[0] = kEmptyHashValue;
      ptr1[1] = kEmptyHashValue;
    }
else
{
  UInt32 *_distances = ++d;

  CLzRef *ptr0 = son + ((size_t)(pos) << 1) - CYC_TO_POS_OFFSET * 2 + 1;
  CLzRef *ptr1 = son + ((size_t)(pos) << 1) - CYC_TO_POS_OFFSET * 2;

  const Byte *len0 = cur, *len1 = cur;
  UInt32 cutValue = _cutValue;
  const Byte *maxLen = cur + _maxLen;

  for (LOG_ITER(g_NumIters_Tree++);;)
  {
    LOG_ITER(g_NumIters_Loop++);
    {
      const ptrdiff_t diff = (ptrdiff_t)0 - (ptrdiff_t)delta;
      CLzRef *pair = son + ((size_t)(((ptrdiff_t)pos - CYC_TO_POS_OFFSET) + diff) << 1);
      const Byte *len = (len0 < len1 ? len0 : len1);

    #ifdef USE_SON_PREFETCH
      const UInt32 pair0 = *pair;
    #endif

      if (len[diff] == len[0])
      {
        if (++len != lenLimit && len[diff] == len[0])
          while (++len != lenLimit)
          {
            LOG_ITER(g_NumIters_Bytes++);
            if (len[diff] != len[0])
              break;
          }
        if (maxLen < len)
        {
          maxLen = len;
          *d++ = (UInt32)(len - cur);
          *d++ = delta - 1;
          
          if (len == lenLimit)
          {
            const UInt32 pair1 = pair[1];
            *ptr1 =
              #ifdef USE_SON_PREFETCH
                pair0;
              #else
                pair[0];
              #endif
            *ptr0 = pair1;

            _distances[-1] = (UInt32)(d - _distances);

            #ifdef USE_LONG_MATCH_OPT

                if (hash == size || *hash != delta || lenLimit[diff] != lenLimit[0] || d >= limit)
                  break;

            {
              for (;;)
              {
                hash++;
                pos++;
                cur++;
                lenLimit++;
                {
                  CLzRef *ptr = son + ((size_t)(pos) << 1) - CYC_TO_POS_OFFSET * 2;
                  #if 0
                  *(UInt64 *)(void *)ptr = ((const UInt64 *)(const void *)ptr)[diff];
                  #else
                  const UInt32 p0 = ptr[0 + (diff * 2)];
                  const UInt32 p1 = ptr[1 + (diff * 2)];
                  ptr[0] = p0;
                  ptr[1] = p1;
                  // ptr[0] = ptr[0 + (diff * 2)];
                  // ptr[1] = ptr[1 + (diff * 2)];
                  #endif
                }
                // PrintSon(son + 2, pos - 1);
                // printf("\npos = %x delta = %x\n", pos, delta);
                len++;
                *d++ = 2;
                *d++ = (UInt32)(len - cur);
                *d++ = delta - 1;
                if (hash == size || *hash != delta || lenLimit[diff] != lenLimit[0] || d >= limit)
                  break;
              }
            }
            #endif

            break;
          }
        }
      }

      {
        const UInt32 curMatch = (UInt32)pos - delta; // (UInt32)(pos + diff);
        if (len[diff] < len[0])
        {
          delta = pair[1];
          if (delta >= curMatch)
            return NULL;
          *ptr1 = curMatch;
          ptr1 = pair + 1;
          len1 = len;
        }
        else
        {
          delta = *pair;
          if (delta >= curMatch)
            return NULL;
          *ptr0 = curMatch;
          ptr0 = pair;
          len0 = len;
        }

        delta = (UInt32)pos - delta;
 
        if (--cutValue == 0 || delta >= pos)
        {
          *ptr0 = *ptr1 = kEmptyHashValue;
          _distances[-1] = (UInt32)(d - _distances);
          break;
        }
      }
    }
  } // for (tree iterations)
}
    pos++;
    cur++;
  }
  while (d < limit);
  *posRes = (UInt32)pos;
  return d;
}
*/// #define CYC_TO_POS_OFFSET 0// #define PRF(x)// #include "LzFindMt.h"/* LzFindOpt.c -- multithreaded Match finder for LZ algorithms
2021-07-13 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/LzmaDec.hLzmaDecodeSizeT *ELzmaStatus *enum <unnamed> *LzmaDec_DecodeToBufCLzmaDec *LzmaDec_DecodeToDicLzmaDec_FreeLzmaDec_AllocateLzmaDec_FreeProbsLzmaDec_AllocateProbsLzmaDec_InitLzmaProps_DecodeCLzmaProps *_CLzmaProps *ELzmaStatusLZMA_STATUS_NOT_SPECIFIEDLZMA_STATUS_FINISHED_WITH_MARKLZMA_STATUS_NOT_FINISHEDLZMA_STATUS_NEEDS_MORE_INPUTLZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARKELzmaFinishModeLZMA_FINISH_ANYLZMA_FINISH_ENDCLzmaDecCLzmaProps_CLzmaPropsCLzmaProbByte[20]unsigned char[20]LZMA_REQUIRED_INPUT_MAXtempBuftempBufSizenumProbsremainLenrepscheckDicSizeprocessedPosdicPosdicBufSizedicCLzmaProb *probs_1664propdicSize_pad_lplcLzmaDec_Construct(p){ (p)->dic = NULL; (p)->probs = NULL; }LZMA_PROPS_SIZE__LZMA_DEC_H_LZMA_PROB32/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
  SZ_ERROR_FAIL - Some unexpected error: internal error of code, memory corruption or hardware failure
*//* ---------- One Call Interface ---------- *//* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*//* ---------- Buffer Interface ---------- *//* LzmaDec_DecodeToDic
   
   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_FAIL - Some unexpected error: internal error of code, memory corruption or hardware failure
*//* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Construct()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*//* ---------- Dictionary Interface ---------- *//* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*//* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. *//* ---------- Interfaces ---------- *//* ELzmaStatus is used only as output value for function call *//* there is probability that stream was finished without end mark *//* you must provide more input bytes *//* stream was not finished *//* stream was finished with end mark. *//* use main error code instead *//* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. *//* block must be finished at the end *//* finish at any point *//* There are two types of LZMA streams:
     - Stream with end mark. That end mark adds about 6 bytes to compressed size.
     - Stream without end mark. You must know exact uncompressed size to decompress such stream. *//* Don't change this structure. ASM code can use it. *//* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; *//* ---------- LZMA Decoder state ---------- *//* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*//* ---------- LZMA Properties ---------- *//* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case *//* #define _LZMA_PROB32 *//* LzmaDec.h -- LZMA Decoder
2020-03-19 : Igor Pavlov : Public domain */destLensrcLenpropDatapropSizestatusdicLimitpropspropsSize/home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2Dec.h"LzmaDec.h"ELzma2ParseStatusLZMA2_PARSE_STATUS_NEW_BLOCKLZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK + 1LZMA2_PARSE_STATUS_NEW_CHUNKCLzma2DecdecoderunpackSizepackSizeisExtraModeneedInitLevelcontrolLzma2Dec_GetUnpackExtra(p)((p)->isExtraMode ? (p)->unpackSize : 0);Lzma2Dec_Free(p,alloc)LzmaDec_Free(&(p)->decoder, alloc)Lzma2Dec_FreeProbs(p,alloc)LzmaDec_FreeProbs(&(p)->decoder, alloc)Lzma2Dec_Construct(p)LzmaDec_Construct(&(p)->decoder)__LZMA2_DEC_HLzma2DecodeLzma2Dec_ParseCLzma2Dec *Lzma2Dec_DecodeToBufLzma2Dec_DecodeToDicLzma2Dec_InitLzma2Dec_AllocateLzma2Dec_AllocateProbs/*
finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - use smallest number of input bytes
  LZMA_FINISH_END - read EndOfStream marker after decoding

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*//*
LZMA2 parser doesn't decode LZMA chunks, so we must read
  full input LZMA chunk to decode some part of LZMA chunk.

Lzma2Dec_GetUnpackExtra() returns the value that shows
    max possible number of output bytes that can be output by decoder
    at current input positon.
*/// set (checkFinishBlock = 1), if it must read full input data, if decoder.dicPos reaches blockMax position.// output size/*
  LZMA_STATUS_NOT_SPECIFIED                 // data error
  LZMA_STATUS_FINISHED_WITH_MARK
  LZMA_STATUS_NOT_FINISHED                  //
  LZMA_STATUS_NEEDS_MORE_INPUT
  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK   // unused
*//*
Lzma2Dec_Parse() parses compressed data stream up to next independent block or next chunk data.
It can return LZMA_STATUS_* code or LZMA2_PARSE_STATUS_* code:
  - LZMA2_PARSE_STATUS_NEW_BLOCK - there is new block, and 1 additional byte (control byte of next block header) was read from input.
  - LZMA2_PARSE_STATUS_NEW_CHUNK - there is new chunk, and only lzma2 header of new chunk was read.
                                   CLzma2Dec::unpackSize contains unpack size of that chunk
*//* ---------- LZMA2 block and chunk parsing ---------- *//*
finishMode:
  It has meaning only if the decoding reaches output limit (*destLen or dicLimit).
  LZMA_FINISH_ANY - use smallest number of input bytes
  LZMA_FINISH_END - read EndOfStream marker after decoding

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
  SZ_ERROR_DATA - Data error
*//* ---------- State Interface ---------- *//* Lzma2Dec.h -- LZMA2 Decoder
2018-02-19 : Igor Pavlov : Public domain */outSizecheckFinishBlock/home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2Dec.c"Lzma2Dec.h"inSize&p&(&p)->decoderLzma2Dec_AllocateProbs(&p, prop, alloc)inCuroutCurcurFinishModeLZMA2_STATE_ERRORLZMA2_STATE_FINISHED(ELzma2ParseStatus)LZMA_STATUS_FINISHED_WITH_MARK(ELzma2ParseStatus)LZMA_STATUS_NOT_FINISHEDLZMA2_STATE_DATALZMA2_STATE_DATA_CONT(ELzma2ParseStatus)LZMA_STATUS_NEEDS_MORE_INPUTLZMA2_STATE_UNPACK0LZMA2_CONTROL_COPY_RESET_DICLZMA2_STATE_CONTROL(ELzma2ParseStatus)LZMA_STATUS_NOT_SPECIFIEDinitDicinitStateLzmaDec_InitDicAndStateLzmaDec_UpdateWithUncompressedLzma2Dec_UpdateStateprintf("\n %8X", (unsigned)p->decoder.dicPos)printf(" %02X", (unsigned)b)printf(" %7u", (unsigned)p->unpackSize)printf(" %5u", (unsigned)p->packSize)LZMA2_STATE_UNPACK1LZMA2_STATE_PACK0LZMA2_STATE_PACK1LZMA2_STATE_PROP9 * 59 * 5 * 5(9 * 5 * 5)LZMA2_LCLP_MAXByte[5]unsigned char[5]Lzma2Dec_GetOldProps(prop, props)Lzma2Dec_GetOldProps(Byte)LZMA2_LCLP_MAXELzma2StateLZMA2_DIC_SIZE_FROM_PROP(p)(((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11))LZMA2_IS_UNCOMPRESSED_STATE(p)(((p)->control & (1 << 7)) == 0)SHOW_DEBUG_INFO// first byte of lzma chunk must be Zero// break;// We can return LZMA_STATUS_NOT_SPECIFIED or LZMA_STATUS_NOT_FINISHED here// checkFinishBlock is true. So we expect that block must be finished,// It will be stopped later in LZMA2_STATE_DATA / LZMA2_STATE_DATA_CONT state.// It's not big problem, if we read additional input bytes.// The following code can be commented.// if (outSize == 0) return LZMA_STATUS_NOT_FINISHED;// if (p->decoder.dicPos != 0)// if (p->packSize < 5) return LZMA2_STATE_ERROR;// ELzma2State// p->decoder.dicPos = 0; // we can use it instead of full init/*
00000000  -  End of data
00000001 U U  -  Uncompressed, reset dic, need reset state and set new prop
00000010 U U  -  Uncompressed, no reset
100uuuuu U U P P  -  LZMA, no reset
101uuuuu U U P P  -  LZMA, reset state
110uuuuu U U P P S  -  LZMA, reset state + set new prop
111uuuuu U U P P S  -  LZMA, reset state + set new prop, reset dic

  u, U - Unpack Size
  P - Pack Size
  S - Props
*//* #define SHOW_DEBUG_INFO *//* Lzma2Dec.c -- LZMA2 Decoder
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2DecMt.hCLzma2DecMtHandleCLzma2DecMtPropsinBlockMaxoutBlockMaxinBufSize_MTnumThreadsoutStep_STinBufSize_ST__LZMA2_DEC_MT_H_7ZIP_STLzma2DecMt_ReadLzma2DecMt_Initconst CLzma2DecMtPropsconst CLzma2DecMtProps *const UInt64const UInt64 *Lzma2DecMt_DecodeLzma2DecMt_DestroyLzma2DecMt_CreateLzma2DecMtProps_InitCLzma2DecMtProps */* ---------- Read from CLzma2DecMtHandle Interface ---------- */// UInt64 *outProcessed,/* out: (*isMT == 0), if single thread decoding was used */// out variables:// const Byte *inData, size_t inDataSize,// Byte *outBuf, size_t *outBufSize,// 0 - partial unpacking is allowed, 1 - if lzma2 stream must be finished// NULL means undefined/* Lzma2DecMt_ * functions can return the following exit codes:
SRes:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - ISeqOutStream write callback error
  // SZ_ERROR_OUTPUT_EOF - output buffer overflow - version with (Byte *) output
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - error in multithreading functions (only for Mt version)
*//* ---------- CLzma2DecMtHandle Interface ---------- *//* init to single-thread mode *//* Lzma2DecMt.h -- LZMA2 Decoder Multi-thread
2018-02-17 : Igor Pavlov : Public domain */inStreamProcessedoutDataSizeinStreamoutStreaminProcessedisMTprogressallocMid<pthread.h>InterlockedIncrementvolatile LONGvolatile LONG *CriticalSection_LeaveCriticalSection_EnterCriticalSection_DeleteCriticalSection_InitSemaphore_CloseSemaphore_WaitSemaphore_ReleaseNSemaphore_OptCreateInitSemaphore_CreateEvent_CloseEvent_WaitEvent_ResetEvent_SetAutoResetEvent_CreateNotSignaledAutoResetEvent_CreateManualResetEvent_CreateNotSignaledCManualResetEvent *ManualResetEvent_CreateThread_Create_With_CpuSetconst CCpuSetconst CCpuSet *Thread_Wait_CloseThread_Create_With_AffinityThread_CreateThread_CloseCCriticalSection_CCriticalSectionCSemaphore_CSemaphoreCManualResetEventCAutoResetEventCEvent_CEventTHREAD_FUNC_TYPECCpuSetCAffinityMaskTHREAD_FUNC_RET_TYPECThread_CThread_mutex_cond_maxCount_count_created_state_manual_reset_tidSemaphore_Release1(p)Semaphore_ReleaseN(p, 1)Semaphore_IsCreated(p)((p)->_created)Semaphore_Construct(p)(p)->_created = 0Event_IsCreated(p)Event_Construct(p)THREAD_FUNC_DECLTHREAD_FUNC_ATTRIB_ALIGN_ARG THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPETHREAD_FUNC_ATTRIB_ALIGN_ARGTHREAD_FUNC_CALL_TYPECpuSet_IsSet(p,cpu)CPU_ISSET(cpu, p)CpuSet_Set(p,cpu)CPU_SET(cpu, p)CpuSet_Zero(p)CPU_ZERO(p)Thread_WasCreated(p)((p)->_created != 0)Thread_Construct(p){ (p)->_tid = 0; (p)->_created = 0; }_7ZIP_AFFINITY_SUPPORTED__7Z_THREADS_Hdefined(__linux__)!defined(__APPLE__) && !defined(_AIX) && !defined(__ANDROID__)_7ZIP_AFFINITY_DISABLEUSE_THREADS_CreateThreaddefined(_WIN32) && defined(__GNUC__)__linux__// #define THREAD_FUNC_ATTRIB_ALIGN_ARG // for debug : bad alignment in SSE functions/* GCC compiler for x86 32-bit uses the rule:
   the stack is 16-byte aligned before CALL instruction for function calling.
   But only root function main() contains instructions that
   set 16-byte alignment for stack pointer. And another functions
   just keep alignment, if it was set in some parent function.
   
   The problem:
    if we create new thread in MinGW (GCC) 32-bit x86 via _beginthreadex() or CreateThread(),
       the root function of thread doesn't set 16-byte alignment.
       And stack frames in all child functions also will be unaligned in that case.
   
   Here we set (force_align_arg_pointer) attribute for root function of new thread.
   Do we need (force_align_arg_pointer) also for another systems?  */// #define Thread_Wait Thread_Wait_Close// if (USE_THREADS_CreateThread is not definned), we use CreateThread()// if (USE_THREADS_CreateThread is      defined), we use _beginthreadex()// #define Thread_Wait(p) Handle_WaitObject(*(p))// #define _GNU_SOURCE// #pragma message(" ==== _7ZIP_AFFINITY_SUPPORTED")/* Threads.h -- multithreading library
2021-12-21 : Igor Pavlov : Public domain */addendcsinitCountmaxCountsignaledfuncparamcpuSetaffinity/home/atharvakale/390r-debugging-setup/p7zip/C/MtDec.h"Threads.h"MtDec_ReadCMtDec *_CMtDec *MtDec_PrepareReadMtDec_GetCrossBuffMtDec_CodeMtDec_DestructMtDec_ConstructMtDecThread_FreeInBufsCMtDecThread *MtProgress_SetErrorCMtProgress *MtProgress_GetErrorMtProgress_ProgressAddMtProgress_Progress_STMtProgress_InitCMtDec_CMtDecCMtDecThreadIMtDecCallback2CMtDecCallbackInfoEMtDecParseStateMTDEC_PARSE_CONTINUEMTDEC_PARSE_OVERFLOWMTDEC_PARSE_NEWMTDEC_PARSE_ENDCMtProgressallocaPtrcanWritecanReadthreadinDataSizeinDataSize_StartinBufmtDecCMtDecThread[32]struct <unnamed>[32]MTDEC__THREADS_MAXthreadsmtProgressinterruptIndexneedInterruptnumFilledThreadsfilledThreadStartreadWasFinishedreadProcessedcrossEndcrossStartcrossBlocknumStartedThreadsnumStartedThreads_LimitwasInterruptedcodeResreadResneedContinuethreadingErrorSResoverflowisAllocErrorexitThreadWResexitThreadallocatedBufsSizemtCallbackObjectIMtDecCallback2 *mtCallbackBoolInt *CodePreCodeCMtDecCallbackInfo *ParseoutPoscanCreateNewThreadsrcFinishedsrcSizestartCallnumThreadsMax_2numThreadsMaxinBufSizetotalOutSizetotalInSize__MT_DEC_H/*
MtDec_Code() returns:
  SZ_OK - in most cases
  MY_SRes_HRESULT_FROM_WRes(WRes_error) - in case of unexpected error in threading function
*/// CAutoResetEvent finishedEvent;/* internal variables */// size_t inDataSize;// const Byte *inData;// size_t inBlockMax;/* size of input block *//* input variables */// int srcFinished,/* Write() must be called, if Parse() was called
      set (needWrite) if
      {
         && (was not interrupted by progress)
         && (was not interrupted in previous block)
      }

    out:
      if (*needContinue), decoder still need to continue decoding with new iteration,
         even after MTDEC_PARSE_END
      if (*canRecode), we didn't flush current block data, so we still can decode current block later.
  */// stop - means stop another Code calls// (SRes_return_result != SZ_OK) means stop decoding, no need another blocks// PreCode() and Code():// check it (size_t)// out// out : it's allowed to return less that actually was used ?// in  : (srcSize == 0) is allowed// in// end of block threading. But we still can return to threading after Write(&needContinue)// new block// MT buffers overflow, need switch to single-thread// continue this block with more input data// total size of input data in all blocks// size of input data in start block/* MtDec.h -- Multi-thread Decoder
2020-03-05 : Igor Pavlov : Public domain */inLim/home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2DecMt.c"MtDec.h""Lzma2DecMt.h"CLzma2DecMt *p->inStreamp->inBuf&p->inLimtMode"----- decoding ST -----"printf("\n" "----- decoding ST -----" "\n") FalseLzma2Dec_Decode_STwrPosinPosinDatainPrevoutPrevdecLzma2Dec_Prepare_ST(p)(void *)(p->inBuf)&inLimp->outStreamdec->decoder.dic + wrPoswriteSizeres2ICompressProgress_Progress(p->progress, p->inProcessed, p->outProcessed)(p->progress)->Progress(p->progress, p->inProcessed, p->outProcessed)p->progressp->inProcessedp->outProcessedoutProcessedoutFinishedneedStopnextwritteninDeltaoutDelta41943041 << 22(1 << 22)Lzma2Dec_Prepare_ST&p->dec&(&p->dec)->decoderLzma2Dec_Allocate(&p->dec, p->prop, &p->alignOffsetAlloc.vt)p->allocMidp->props.inBufSize_STLzma2DecMt_MtCallback_Writemeconst CLzma2DecMtThreadconst CLzma2DecMtThread *CLzma2DecMtThread[32]CLzma2DecMtThread *needContinue2 TrueisCrossme->outStreamMtProgress_ProgressAdd(&me->mtc.mtProgress, 0, 0)LZMA2DECMT_STREAM_WRITE_STEP"Write"coderIndexprintf("\n" "Write" " %d %d\n", (unsigned)coderIndex, (unsigned)srcSize)Lzma2DecMt_MtCallback_CodesrcProcessedblockWasFinished"Code"printf("\n" "Code" " %d %d\n", (unsigned)coderIndex, (unsigned)srcSize)Lzma2DecMt_MtCallback_PreCodeme->allocMidt->outPreSizeLzma2DecMt_MtCallback_Parse&t->dec&(&t->dec)->decoderkNumAlignBitskNumCacheLineBits(unsigned)1(unsigned)1 << 11((unsigned)1 << 11)1 << 8(1 << 8)2304((unsigned)1 << 11) + (1 << 8)1 << 62368((unsigned)1 << 11) + (1 << 8) + (1 << 6)(((unsigned)1 << 11) + (1 << 8) + (1 << 6))(unsigned)1 << kNumAlignBits((unsigned)1 << kNumAlignBits)(unsigned)1 << kNumCacheLineBits((unsigned)1 << kNumCacheLineBits)3968((unsigned)1 << kNumAlignBits) - ((unsigned)1 << kNumCacheLineBits)(((unsigned)1 << kNumAlignBits) - ((unsigned)1 << kNumCacheLineBits))unpackRemconst SizeTsrcOrigsrcSize_PointdicPos_PointsrcCur163841 << 14(1 << 14)needWriteToStreamcanRecodeinCodePosoutCodePosstopcc"Parse"cc->srcSizeprintf("\n" "Parse" " %d %d\n", (unsigned)coderIndex, (unsigned)cc->srcSize)&t->alloc.vtp->alignOffsetAlloc.baseAllocLzma2DecMt_FreeSt&p->alignOffsetAlloc.vtLzma2DecMt_FreeOutBufst->outBufsizeof(CLzma2DecMt)216241 << 201 << 18268435456LZMA2DECMT_OUT_BLOCK_MAX_DEFAULTCLzma2DecMtCLzma2DecMtThreadcodersmtcmtc_WasConstructedoutProcessed_Parsedec_createdoutSize_DefinedalignOffsetAllocByte[128]unsigned char[128]1 << 7mtPadoutCodeSizeinCodeSizeoutPreSizeinPreSizeparseStatusoutBufSizeoutBufneedInit(1 << 28)PRF_STR_INT_2(s,d1,d2)PRF(printf("\n" s " %d %d\n", (unsigned)d1, (unsigned)d2))PRF_STR(s)PRF(printf("\n" s "\n"))/*
    if (status == LZMA_STATUS_FINISHED_WITH_MARK)
      return readRes;

    if (size == 0 && status != LZMA_STATUS_NEEDS_MORE_INPUT)
    {
      if (p->finishMode && p->outSize_Defined && p->outProcessed >= p->outSize)
        return SZ_ERROR_DATA;
      return readRes;
    }
    *//*
    #ifndef _7ZIP_ST
    if (res == SZ_OK && tMode && p->mtc.parseRes != SZ_OK)
      res = p->mtc.parseRes;
    #endif
    */// res = SZ_OK; // for test/*
      if (!outStream)
        *outBufSize = p->outBuf - outBuf;
      */// p->mtc.inDataSize = inDataSize;// p->mtc.inData = inData;// p->alignOffsetAlloc.baseAlloc;// p->mtc.inBlockMax = p->props.inBlockMax;/*
    if (!outStream)
    {
      // p->outBuf = outBuf;
      // p->outBufSize = *outBufSize;
      // *outBufSize = 0;
      return SZ_ERROR_PARAM;
    }
    */// p->outBufSize = 0;// p->outBuf = NULL;// p->mtc.isAllocError = False;// p->mtc.allocError_for_Read_BlockIndex = 0;// p->mtc.crossEnd = 0;// p->mtc.crossStart = 0;// p->mtc.numFilledThreads = 0;// p->mtc.parseRes = SZ_OK;// inLim -= 5; p->readWasFinished = True; // for test// p->readProcessed += inLim;/*
  if (size > me->outBufSize)
    return SZ_ERROR_OUTPUT_EOF;
  memcpy(me->outBuf, data, size);
  me->outBufSize -= size;
  me->outBuf += size;
  *needContinue = needContinue2;
  return SZ_OK;
  */// me->mtc.writtenTotal += written;// t->parseStatus == LZMA_STATUS_FINISHED_WITH_MARK// int finished, int blockFinished,// alloc.vt// Sleep(200);// + (1 << 28)/* we also reserve space for max possible number of output bytes of current LZMA chunk */// (status == LZMA_STATUS_NOT_FINISHED)// (status == LZMA_STATUS_NOT_SPECIFIED)// we don't need control byte of next block// we revert to latest newBlock state// && limit == me->props.outBlockMax// && limit == t->dec.decoder.dicPos// we decode small blocks in one thread// that must be finished at position <= outBlockMax.// checkFinishBlock = False, if we want to decode partial data// (cc->srcSize == 0) is allowed// t->finishedWithMark = False;// t->blockWasFinished = False;/* <= kNumAlignBits *//* (1 << 12) is expected size of one way in data cache.
           We optimize alignment for cache line size of 128 bytes and smaller */// p->alloc !!!// we don't need to free dict here// Lzma2DecMtProps_Init(&p->props);// p->alloc = alloc;// ISzAllocPtr alloc;/* ---------- CLzma2DecMt ---------- *//* ---------- CLzma2DecMtThread ---------- */// #define _7ZIP_ST// #define SHOW_DEBUG_INFO/* Lzma2DecMt.c -- LZMA2 Decoder Multi-thread
2021-04-01 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/LzmaEnc.hLzmaEncodeconst CLzmaEncPropsconst CLzmaEncProps *_CLzmaEncProps *LzmaEnc_MemEncodeLzmaEnc_EncodeLzmaEnc_IsWriteEndMarkLzmaEnc_WritePropertiesLzmaEnc_SetDataSizeLzmaEnc_SetPropsLzmaEnc_DestroyLzmaEnc_CreateLzmaEncProps_GetDictSizeLzmaEncProps_NormalizeCLzmaEncProps *LzmaEncProps_InitCLzmaEncHandleCLzmaEncProps_CLzmaEncPropsreduceSizewriteEndMarkmcfbalgodictSizelevel__LZMA_ENC_H/* LzmaEnc* functions can return the following exit codes:
SRes:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - ISeqOutStream write callback error
  SZ_ERROR_OUTPUT_EOF - output buffer overflow - version with (Byte *) output
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - error in multithreading functions (only for Mt version)
*//* ---------- CLzmaEncHandle Interface ---------- *//* estimated size of data that will be compressed. default = (UInt64)(Int64)-1.
                        Encoder uses this value to reduce dictionary size *//* 1 or 2, default = 2 *//* 0 - do not write EOPM, 1 - write EOPM, default = 0 *//* 1 <= mc <= (1 << 30), default = 32 *//* 2, 3 or 4, default = 4 *//* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 *//* 5 <= fb <= 273, default = 32 *//* 0 - fast, 1 - normal, default = 1 *//* 0 <= pb <= 4, default = 2 *//* 0 <= lp <= 4, default = 0 *//* 0 <= lc <= 8, default = 3 *//* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
                      (1 << 12) <= dictSize <= (3 << 29) for 64-bit version
                      default = (1 << 24) *//* 0 <= level <= 9 *//*  LzmaEnc.h -- LZMA Encoder
2019-10-30 : Igor Pavlov : Public domain */propsEncodedallocBigpropertiesexpectedDataSiizeprops2/home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2Enc.h"LzmaEnc.h"CLzma2EncHandleCLzma2EncPropsnumTotalThreadsnumBlockThreads_MaxnumBlockThreads_ReducedlzmaPropsLZMA2_ENC_PROPS__BLOCK_SIZE__SOLID((UInt64)(Int64)-1)LZMA2_ENC_PROPS__BLOCK_SIZE__AUTO__LZMA2_ENC_HLzma2Enc_Encode2Lzma2Enc_WritePropertiesLzma2Enc_SetDataSizeLzma2Enc_SetPropsconst CLzma2EncPropsconst CLzma2EncProps *Lzma2Enc_DestroyLzma2Enc_CreateLzma2EncProps_NormalizeCLzma2EncProps *Lzma2EncProps_Init/* Lzma2Enc_* functions can return the following exit codes:
SRes:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - ISeqOutStream write callback error
  SZ_ERROR_OUTPUT_EOF - output buffer overflow - version with (Byte *) output
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - error in multithreading functions (only for Mt version)
*//* ---------- CLzmaEnc2Handle Interface ---------- *//* Lzma2Enc.h -- LZMA2 Encoder
2017-07-27 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/MtCoder.hMtCoder_CodeCMtCoder *_CMtCoder *MtCoder_DestructMtCoder_ConstructMtProgressThunk_CreateVTableCMtProgressThunk *CMtCoder_CMtCoderCMtCoderThreadCMtCoderBlockIMtCoderCallback2CMtProgressThunkstartEventmtCoderCMtCoderThread[64]struct <unnamed>[64]MTCODER__THREADS_MAXCMtCoderBlock[76]struct <unnamed>[76]MTCODER__BLOCKS_MAXblocksfinishedbufIndexunsigned int[76]freeBlockListfreeBlockHeadnumBlocksMaxnumStartedThreadsLimitnumFinishedThreadsByte[76]unsigned char[76]ReadyBlockswriteIndexwriteResfinishedEventstopReadingblocksSemaphorereadEventIMtCoderCallback2 *MtProgressThunk_Init(p){ (p)->inSize = 0; (p)->outSize = 0; }(MTCODER__GET_NUM_BLOCKS_FROM_THREADS(MTCODER__THREADS_MAX) + 3)MTCODER__GET_NUM_BLOCKS_FROM_THREADS(numThreads)((numThreads) + (numThreads) / 8 + 1)__MT_CODER_HMTCODER__USE_WRITE_THREAD/* #define MTCODER__USE_WRITE_THREAD *//*
  if (    defined MTCODER__USE_WRITE_THREAD) : main thread writes all data blocks to output stream
  if (not defined MTCODER__USE_WRITE_THREAD) : any coder thread can write data blocks to output stream
*//* MtCoder.h -- Multi-thread Coder
2018-07-04 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Lzma2Enc.c"MtCoder.h""Lzma2Enc.h"CLzma2Enc *CLzma2EncInt[64]CLzma2EncInt *destBlockSizeLzma2Enc_MtCallback_Writesize_t[76]unsigned long[76]Byte *[76]unsigned char *[76]Lzma2Enc_MtCallback_CodedestSizeprogressThunkme->allocme->outBufSizeLzma2Enc_EncodeMt1unpackTotalpackTotaloutLimlimitedInStreamLZMA2_CHUNK_SIZE_COMPRESSED_MAX((1 << 16) + 16)65552Lzma2EncInt_InitStream(p, &me->props)LzmaEnc_PrepareForLzma2(p->enc, &limitedInStream.vt, LZMA2_KEEP_WINDOW_SIZE, me->alloc, me->allocBig)LzmaEnc_PrepareForLzma2(p->enc, &limitedInStream.vt, (1 << 21), me->alloc, me->allocBig)LzmaEnc_MemPrepare(p->enc, inData + (size_t)unpackTotal, inSizeCur, LZMA2_KEEP_WINDOW_SIZE, me->alloc, me->allocBig)LzmaEnc_MemPrepare(p->enc, inData + (size_t)unpackTotal, inSizeCur, (1 << 21), me->alloc, me->allocBig)&binSizeCurCLimitedSeqInStream *expected2097152outBufIndexdestPosLZMA2_CONTROL_EOFp->allocp->tempBufLzmaLzma2Enc_FreeOutBufsp->outBufs[i]sizeof(CLzma2Enc)13992t1t1nt2t2rt3kMinSize(UInt32)1 << 20kMaxSize(UInt32)1 << 28kMinSize - 1(kMinSize - 1)(UInt64)(kMinSize - 1)18446744073708503040~(UInt64)(kMinSize - 1)Lzma2EncInt_EncodeSubblockpackSizeLimitLZMA2_UNPACK_SIZE_MAXlzHeaderSizeuseCopyBlockLZMA2_PACK_SIZE_MAXprintf("################# COPY           ")uLZMA2_CONTROL_COPY_NO_RESETpmLZMA2_CONTROL_LZMAprintf("               ")printf("\npackSize = %7d unpackSize = %7d  ", packSize, unpackSize)LzmaEnc_RestoreStateLzmaEnc_SaveStateLzmaEnc_FinishLzmaEnc_GetCurBufLzmaEnc_CodeOneMemBlockLzmaEnc_MemPrepareLzmaEnc_PrepareForLzma2Lzma2EncInt_InitBlockLzma2EncInt_InitStreamLzmaEnc_SetProps(p->enc, &props->lzmaProps)LzmaEnc_WriteProperties(p->enc, propsEncoded, &propsSize)LimitedSeqInStream_ReadCLimitedSeqInStreamLimitedSeqInStream_InitCLzma2EncCLzma2EncIntoutBufsmtCoder_WasConstructedoutBufsDataSizesoutBuf_RemtempBufLzmapropEncodedsrcPosneedInitPropneedInitStatepropsBytepropsAreSetencLZMA2_KEEP_WINDOW_SIZE(1 << 21)LZMA2_COPY_CHUNK_SIZE/* finished *//* SZ_ERROR_MEM */// 0;// 0/*
      if (LzmaEnc_GetNumAvailableBytes(p->enc) == 0)
        break;
      */// LzmaEnc_SetDataSize(p->enc, inSizeCur);// inStream version works only in one thread. So we use CLzma2Enc::expectedDataSize// outStream version works only in one thread. So we use CLzma2Enc::tempBufLzma/* size of allocated outBufs[i] *//* remainder in outBuf *//* ---------- Lzma2 ---------- *//* if there is no block multi-threading, we use SOLID block *//* ---------- Lzma2 Props ---------- *//* needInitState = True; *//*
UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp);
*//* ---------- CLzma2EncInt ---------- *//* ---------- CLimitedSeqInStream ---------- *//* x *//* #define _7ZIP_ST *//* Lzma2Enc.c -- LZMA2 Encoder
2021-02-09 : Igor Pavlov : Public domain */packSizeResreInitdesiredPackSizekeepWindowSize/home/atharvakale/390r-debugging-setup/p7zip/C/LzmaDec.cRC_INIT_SIZELzmaDec_AllocateProbs(&p, propData, propSize, alloc)propNewLzmaProps_Decode(&propNew, props, propsSize)LzmaDec_AllocateProbs2(p, &propNew, alloc)const CLzmaPropsconst CLzmaProps *(UInt32)1 << 12((UInt32)1 << 12)4095((UInt32)1 << 12) - 1(UInt32)1 << 22((UInt32)1 << 22)4194303((UInt32)1 << 22) - 1((UInt32)1 << 20)((UInt32)1 << 20) - 1LzmaDec_AllocateProbs21664-1664-1536-1280-768-2563201984numProbs * sizeof(CLzmaProb)LZMA_DIC_MINLzmaDec_FreeDictp->dicp->probsoutSizeCur&p->prop274kMatchSpecLenStart276kMatchSpecLen_Error_Fail214748262421474846713221224448kBadRepCode275dummyRescheckEndMarkNow 0bufLimitdummyProcessedbufOutconst CLzmaDecconst CLzmaDec *DUMMY_INPUT_EOFkMatchSpecLen_Error_DataaheadLzmaDec_TryDummyconst CLzmaProbconst CLzmaProb *p->processedPos((unsigned)1 << p->prop.pb) - 1prob + symbolsymbolprobLitoffs ^= bit;probLenprobLen + len1 << kNumPosSlotBitsposSlotprob + posSlotprob + iposStateIsMatchLiteralLZMA_LIT_SIZE(UInt32)LZMA_LIT_SIZEkNumLitStatesmatchByteoffsbitDUMMY_LITIsRepLenCoderDUMMY_MATCHDUMMY_REPIsRepG0IsRep0LongIsRepG1IsRepG2kNumStatesRepLenCoderLenLowkLenNumLowBits1 << kLenNumLowBitsLenChoice2(1 << kLenNumLowBits)kLenNumLowSymbolsLenHighkLenNumHighBits1 << kLenNumHighBitsPosSlotkNumLenToPosStateskNumPosSlotBitskStartPosModelIndexnumDirectBitskEndPosModelIndexSpecPosAlignLzmaDec_DecodeReal2LzmaDec_WriteRemrep0LzmaDec_DecodeReal_3rep1rep2rep3pbMasklpMask(unsigned)0x100(1 << kLenNumHighBits)distanceprob + distancedistance += m; m += mm += m; distance += m;i += 1;i += 1 * 2;i += 2;i += 2 * 2;i += 4;i += 4 * 2;i -= 8(UInt32)3(UInt32)0xFFFFFFFFkMatchMinLen514curLenELzmaDummyRETURN__NOT_FINISHED__FOR_FINISH*status = LZMA_STATUS_NOT_FINISHED; return SZ_ERROR_DATA;IS_DUMMY_END_MARKER_POSSIBLE(dummyRes)((dummyRes) == DUMMY_MATCH)(kBound0 + (((kRange0 - kBound0) >> kNumBitModelTotalBits) << (kNumBitModelTotalBits - 1)))kBound0((kRange0 >> kNumBitModelTotalBits) << (kNumBitModelTotalBits - 1))kRange0LZMA_DECODE_REALGET_LEN_STATE(posState)COMBINED_PS_STATE(posState + state)CALC_POS_STATE(processedPos,pbMask)(((processedPos) & (pbMask)) << 4)LzmaProps_GetNumProbs(p)(NUM_BASE_PROBS + ((UInt32)LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))NUM_BASE_PROBS(Literal + kStartOffset)(PosSlot + (kNumLenToPosStates << kNumPosSlotBits))(IsRepG2 + kNumStates)(IsRepG1 + kNumStates)(IsRepG0 + kNumStates)(IsRep + kNumStates)(Align + kAlignTableSize)(IsMatch + (kNumStates2 << kNumPosBitsMax))(LenCoder + kNumLenProbs)(RepLenCoder + kNumLenProbs)(IsRep0Long + (kNumStates2 << kNumPosBitsMax))(SpecPos + kNumFullDistances)(-kStartOffset)GET_PROBSp->probs_1664kStartOffset(kMatchSpecLen_Error_Data - 1)(1 << 9)(kMatchMinLen + kLenNumLowSymbols * 2 + kLenNumHighSymbols)kAlignTableSize(1 << kNumAlignBits)kNumFullDistances(1 << (kEndPosModelIndex >> 1))kNumStates2(LenLow + (1 << kLenNumLowBits))LenChoicekNumLenProbs(LenHigh + kLenNumHighSymbols)(LenLow + 2 * (kNumPosStatesMax << kLenNumLowBits))kLenNumHighSymbolskNumPosStatesMax(1 << kNumPosBitsMax)kNumPosBitsMaxREV_BIT_CHECK(p,i,m)IF_BIT_0_CHECK(p + i) { UPDATE_0_CHECK; i += m; m += m; } else { UPDATE_1_CHECK; m += m; i += m; }TREE_DECODE_CHECK(probs,limit,i){ i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }GET_BIT_CHECK(p,i)GET_BIT2_CHECK(p, i, ; , ;)GET_BIT2_CHECK(p,i,A0,A1)IF_BIT_0_CHECK(p) { UPDATE_0_CHECK; i = (i + i); A0; } else { UPDATE_1_CHECK; i = (i + i) + 1; A1; }UPDATE_1_CHECKrange -= bound; code -= bound;UPDATE_0_CHECKrange = bound;IF_BIT_0_CHECK(p)ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * (UInt32)ttt; if (code < bound)NORMALIZE_CHECKif (range < kTopValue) { if (buf >= bufLimit) return DUMMY_INPUT_EOF; range <<= 8; code = (code << 8) | (*buf++); }MATCHED_LITER_DECmatchByte += matchByte; bit = offs; offs &= matchByte; probLit = prob + (offs + bit + symbol); GET_BIT2(probLit, symbol, offs ^= bit; , ;)NORMAL_LITER_DECTREE_GET_BIT(prob, symbol)TREE_6_DECODE(probs,i){ i = 1; TREE_GET_BIT(probs, i); TREE_GET_BIT(probs, i); TREE_GET_BIT(probs, i); TREE_GET_BIT(probs, i); TREE_GET_BIT(probs, i); TREE_GET_BIT(probs, i); i -= 0x40; }TREE_DECODE(probs,limit,i){ i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }REV_BIT_LAST(p,i,m)REV_BIT(p, i, i -= m , ; )REV_BIT_CONST(p,i,m)REV_BIT(p, i, i += m; , i += m * 2; )REV_BIT_VAR(p,i,m)REV_BIT(p, i, i += m; m += m, m += m; i += m; )REV_BIT(p,i,A0,A1)IF_BIT_0(p + i) { UPDATE_0(p + i); A0; } else { UPDATE_1(p + i); A1; }TREE_GET_BIT(probs,i){ GET_BIT2(probs + i, i, ;, ;); }GET_BIT2(p,i,A0,A1)IF_BIT_0(p) { UPDATE_0(p); i = (i + i); A0; } else { UPDATE_1(p); i = (i + i) + 1; A1; }UPDATE_1(p)range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));UPDATE_0(p)range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));IF_BIT_0(p)ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * (UInt32)ttt; if (code < bound)NORMALIZEif (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }(1 << kNumBitModelTotalBits)kNumBitModelTotalBits((UInt32)1 << kNumTopBits)kNumTopBits_LZMA_DEC_OPT_LZMA_SIZE_OPTAlign != 0 && kStartOffset != 0NUM_BASE_PROBS != 1984kBadRepCode != (0xC0000000 - 0x400)/*  Some unexpected error: internal error of code, memory corruption or hardware failure */// we decode one symbol from (p->tempBuf) here, so the (bufLimit) is equal to (p->buf)// p->remainLen = kMatchSpecLen_Error_Data;// rem   - the size of temp buffer including new data from (src)// ahead - the size of new data copied from (src) to (p->tempBuf)// in relaxed mode: tempBufSize not larger than required for one Symbol decoding.// in strict mode: tempBufSize is not enough for one Symbol decoding.// we have some data in (p->tempBuf)// we will decode only one iteration// (p->remainLen == 0)// (p->remainLen == 0 || p->dicPos == dicLimit)// return SZ_OK; // for relaxed mode// for strict mode/*
LZMA supports optional end_marker.
So the decoder can lookahead for one additional LZMA-Symbol to check end_marker.
That additional LZMA-Symbol can require up to LZMA_REQUIRED_INPUT_MAX bytes in input stream.
When the decoder reaches dicLimit, it looks (finishMode) parameter:
  if (finishMode == LZMA_FINISH_ANY), the decoder doesn't lookahead
  if (finishMode != LZMA_FINISH_ANY), the decoder lookahead, if end_marker is possible for current position

When the decoder lookahead, and the lookahead symbol is not end_marker, we have two ways:
  1) Strict mode (default) : the decoder returns SZ_ERROR_DATA.
  2) The relaxed mode (alternative mode) : we could return SZ_OK, and the caller
     must check (status) value. The caller can show the error,
     if the end of stream is expected, and the (status) is noit
     LZMA_STATUS_FINISHED_WITH_MARK or LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK.
*//* if (code >= range) code -= range; *//* need more input data *//*
LzmaDec_DecodeReal2():
  It calls LZMA_DECODE_REAL() and it adjusts limit according (p->checkDicSize).

We correct (p->checkDicSize) after LZMA_DECODE_REAL() and in LzmaDec_WriteRem(),
and we support the following state of (p->checkDicSize):
  if (total_processed < p->prop.dicSize) then
  {
    (total_processed == p->processedPos)
    (p->checkDicSize == 0)
  }
  else
    (p->checkDicSize == p->prop.dicSize)
*//*
At staring of new stream we have one of the following symbols:
  - Literal        - is allowed
  - Non-Rep-Match  - is allowed only if it's end marker symbol
  - Rep-Match      - is not allowed
We use early check of (RangeCoder:Code) over kBadRepCode to simplify main decoding code
*//* we use SizeT to avoid the BUG of VC14 for AMD64 *//* || len >= kMatchSpecLenStart */// & (kMatchSpecLen_Error_Data - 1); // we can write real length for error matches too./*
          We stop decoding and return SZ_OK, and we can resume decoding later.
          Any error conditions can be tested later in caller code.
          For more strict mode we can stop decoding with error
          // len += kMatchSpecLen_Error_Data;
          */// len += kMatchMinLen;// len = kMatchSpecLen_Error_Data;/*
              distance <<= 1;
              if (code >= range)
              {
                code -= range;
                distance |= 1;
              }
              *//* (UInt32)((Int32)code >> 31) */// if (dicPos == limit) { state = state < kNumLitStates ? 9 : 11; len = 1; break; }// so we don't need the following check:// The caller doesn't allow (dicPos == limit) case here// if (checkDicSize == 0 && processedPos == 0) { len = kMatchSpecLen_Error_Data + 1; break; }// that case was checked before with kBadRepCode/*
LZMA_DECODE_REAL()
In:
  RangeCoder is normalized
  if (p->dicPos == limit)
  {
    LzmaDec_TryDummy() was called before to exclude LITERAL and MATCH-REP cases.
    So first symbol can be only MATCH-NON-REP. And if that MATCH-NON-REP symbol
    is not END_OF_PAYALOAD_MARKER, then the function doesn't write any byte to dictionary,
    the function returns SZ_OK, and the caller can use (p->remainLen) and (p->reps[0]) later.
  }

Processing:
  The first LZMA symbol will be decoded in any case.
  All main checks for limits are at the end of main loop,
  It decodes additional LZMA-symbols while (p->buf < bufLimit && dicPos < limit),
  RangeCoder is still without last normalization when (p->buf < bufLimit) is being checked.
  But if (p->buf < bufLimit), the caller provided at least (LZMA_REQUIRED_INPUT_MAX + 1) bytes for
  next iteration  before limit (bufLimit + LZMA_REQUIRED_INPUT_MAX),
  that is enough for worst case LZMA symbol with one additional RangeCoder normalization for one bit.
  So that function never reads bufLimit [LZMA_REQUIRED_INPUT_MAX] byte.

Out:
  RangeCoder is normalized
  Result:
    SZ_OK - OK
      p->remainLen:
        < kMatchSpecLenStart : the number of bytes to be copied with (p->reps[0]) offset
        = kMatchSpecLenStart : the LZMA stream was finished with end mark

    SZ_ERROR_DATA - error, when the MATCH-Symbol refers out of dictionary
      p->remainLen : undefined
      p->reps[*]    : undefined
*//*
LzmaDec_DecodeReal_3() can be implemented in external ASM file.
3 - is the code compatibility version of that function for check at link time.
*//* ---------- LZMA_DECODE_REAL ---------- *//*
p->remainLen : shows status of LZMA decoder:
    < kMatchSpecLenStart  : the number of bytes to be copied with (p->rep0) offset
    = kMatchSpecLenStart  : the LZMA stream was finished with end mark
    = kMatchSpecLenStart + 1  : need init range coder
    = kMatchSpecLenStart + 2  : need init range coder and state
    = kMatchSpecLen_Error_Fail                : Internal Code Failure
    = kMatchSpecLen_Error_Data + [0 ... 273]  : LZMA Data Error
*//*
#define GET_PROBS p->probs + kStartOffset
#else
#define kStartOffset 0
#define GET_PROBS p->probs
#endif
*//*
#ifdef MY_CPU_X86_OR_AMD64
*//* (probs_1664) is faster and better for code size at some platforms *//* External ASM code needs same CLzmaProb array layout. So don't change it. */// _LZMA_DEC_OPT/* #define _LZMA_SIZE_OPT *//* #include "CpuArch.h" *//* LzmaDec.c -- LZMA Decoder
2021-04-01 : Igor Pavlov : Public domain */CMatchFinderMt_CMatchFinderMtMf_GetHeadsMf_Mix_MatchesCMtSync_CMtSyncMatchFinderGetHeadsFunchashSyncfailure_BThashNumAvailhashBufPosLimithashBufPoshashBufkMtCacheLineDummybtDummybtSyncfailureBuffailure_LZ_BTMixMatchesFuncbtNumAvailByteslzPosbtBufPosLimitbtBufPosbtBufpointerToCurPosfilledSemaphorefreeSemaphorewasStoppedcanStartstopWritingcsWasEnteredcsWasInitializedneedStartwasCreatednumProcessedBlocks__LZ_FIND_MT_H/* call MatchFinderMt_InitMt() before IMatchFinder::Init() */// only for Mt part// CMatchFinder MatchFinder;/* Hash *//* Byte hashDummy[kMtCacheLineDummy]; *//* BT + Hash *//* BT *//* LZ + BT */// UInt32 crc[256];// UInt32 failure_LZ_LZ; // failure in LZ tables// failure in BT transfered to LZ// UInt32 hash4Mask;/* LZ *//* kMtCacheLineDummy must be >= size_of_CPU_cache_line */// UInt32 numBlocks_Sent;/* LzFindMt.h -- multithreaded Match finder for LZ algorithms
2021-07-12 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/LzmaEnc.cCLzmaEnc *const CLzmaEncconst CLzmaEnc *(UInt32)1 << 21((UInt32)1 << 21)kDictMask4293918720~kDictMask11 * 2props + 1LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig)LzmaEnc_Encode2Byte[768]unsigned char[768]p->nowPos64RangeEnc_GetProcessed(&p->rc)( (&p->rc)->processed + (size_t)((&p->rc)->buf - (&p->rc)->bufBase) + (&p->rc)->cacheSize)&p->rcCRangeEnc *nowPos64SeqOutStreamBuf_WriteCLzmaEnc_SeqOutStreamBufCLzmaEnc_SeqOutStreamBuf *LzmaEnc_SetInputBufLzmaEnc_PrepareLzmaEnc_AllocAndInitkDicLogSizeMaxLzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig)LzmaEnc_InitPricesLZMA_MATCH_LEN_MINREP_LEN_COUNTCLenPriceEnc *const CLenEncconst CLenEnc *const CProbPriceconst CProbPrice *CLenEnc *CProbPrice[128]unsigned int[128]kNumMoveReducingBitsCProbPrice *LzmaEnc_InitLZMA_NUM_REPS1 << kNumAlignBitsCLzmaProb[16]unsigned short[16]kProbInitValueLZMA_NUM_PB_STATES_MAXCLzmaProb[12][16]unsigned short[12][16]CLzmaProb(*)[16]unsigned short(*)[16]CLzmaProb[12]unsigned short[12]CLzmaProb[64]unsigned short[64]CLzmaProb[4][64]unsigned short[4][64]CLzmaProb(*)[64]unsigned short(*)[64](1 << kNumPosSlotBits)CLzmaProb[128]unsigned short[128](UInt32)0x300kNumOptsCOptimal[2048]struct <unnamed>[2048]COptimal *kInfinityPriceLzmaEnc_AllocbeforeSizelclp((UInt32)0x300 << lclp) * sizeof(CLzmaProb)kBigHashDicLimit(UInt32)2 << 30((UInt32)2 << 30)(UInt32)3 << 30((UInt32)3 << 30)MatchFinderMt_Create(&p->matchFinderMt, dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX + 1 , allocBig)MatchFinderMt_Create(&p->matchFinderMt, dictSize, beforeSize, p->numFastBytes, (2 + ((1 << 3) * 2 + (1 << 8)) - 1) + 1 , allocBig)2722730xFFFFFFLZMA_MATCH_LEN_MAXLzmaEnc_CodeOneBlocknowPos32startPos32MatchFinderMt_InitMt(&p->matchFinderMt)CheckErrors(p)numPairscurBytekState_Start*(data - 1)distp->posAlignEncoder + mnewBoundociconst COptimalconst COptimal *optMARK_LITconst Byte[12]unsigned char[12]maxPackSizemaxUnpackSizeByte[16384]unsigned char[16384]kNumLogBits1 << kNumLogBitszzsym1 << kNumPosSlotBits * 2(1 << kNumPosSlotBits * 2)(kNumPosSlotBits - 1)2017footerBitsbasepos240265318400xF0000000300kPackReserve1 << 17(1 << 17)LzmaEnc_DestructLzmaEnc_FreeLitsp->litProbsp->saveState.litProbssizeof(CLzmaEnc)133032LzmaEnc_ConstructFillDistancesPricesUInt32[128]tempPriceslpsProbPricesprobs[m]price2047probs[sym]slotdistTableSize2posSlotPriceskDistTableSizeMaxUInt32[4][64]unsigned int[4][64]UInt32(*)[64]unsigned int(*)[64]1 << (kNumPosSlotBits - 1)(1 << (kNumPosSlotBits - 1))(kEndPosModelIndex / 2 - 1)(kEndPosModelIndex / 2 - 1) - kNumAlignBits(UInt32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits)kNumBitPriceShiftBits(UInt32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) << kNumBitPriceShiftBits((UInt32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) << kNumBitPriceShiftBits)(UInt32)1 << kNumBitPriceShiftBits((UInt32)1 << kNumBitPriceShiftBits)dpUInt32[4][128]unsigned int[4][128]UInt32(*)[128]unsigned int(*)[128]slotPriceFillAlignPricesFlushCheckErrors2147943759-2147023537WriteEndMarkerprobs + mnumBits30 - kNumAlignBitsGetOptimumFastnumAvailmainDistmainLenrepIndexrepLennowPoslen - 1data2mainLen - 1UInt32[548]unsigned int[548]546548dist2repLen - 11 << 91 << 15(1 << 15)newDistmainLen - 2GetOptimumlastrepLensmatchesrepMaxIndexmatchPricerepMatchPricepositionp->isMatch[p->state][posState]&p->opt[1]p->isRep[p->state]p->isRepG0[p->state]p->isRep0Long[p->state][posState]shortRepPrice&p->repLenEncprice2UInt32[272]unsigned int[272]kLenNumSymbolsTotalUInt32[16][272]unsigned int[16][272]UInt32(*)[272]unsigned int(*)[272]&p->lenEncnormalMatchPricelenToPosState(kNumFullDistances - 1)kAlignMaskcurOptnextOptp->isRep[state]p->isRepG0[state]p->isRep0Long[state][posState]state2posState2p->isMatch[state2][posState2]p->isRep0Long[state2][posState2]p->isRep[state2]p->isRepG0[state2]len2position + lendata[(size_t)len - 1]lenNormnumAvailFullnewLenstartLenlitPricenextIsLitbestprevOptb0kState_RepAfterLitkState_MatchAfterLitcurPricekState_LitAfterRepkState_LitAfterMatchBackwardwrGetPrice_PureRepp->isRepG2[state]repIndex - 2const CLzmaProb[16]const CLzmaProb(*)[16]ReadMatchDistancesp2(ptrdiff_t)-1LenPriceEnc_UpdateTablesCLzmaProb[256]unsigned short[256](kLenNumLowBits + 1)enc->low[kLenNumLowSymbols]enc->low[(1 << 3)]prices1 + kLenNumLowBits(1 + kLenNumLowBits)(kLenNumHighBits - 1)1 << (kLenNumHighBits - 1)(1 << (kLenNumHighBits - 1))numPairsResnumPosStatessizeof(p->prices[0][0])SetPrices_3probs[1 ](i >> 2)probs[2 + (i >> 2)](i >> 1) & 1LenEnc_Encodercprobs + 11 << 1LenEnc_Init(LZMA_NUM_PB_STATES_MAX << (kLenNumLowBits + 1))RcTree_ReverseEncodestartPriceLitEnc_Matched_GetPriceprobs[offs + (matchByte & offs) + (sym >> 8)](sym >> 7) & 10x10000LitEnc_GetPriceLzmaEnc_InitPriceTables(kBitModelTotal >> kNumMoveReducingBits)kCyclesBits(kNumMoveReducingBits - 1)1 << (kNumMoveReducingBits - 1)(1 << (kNumMoveReducingBits - 1))bitCount(UInt32)1 << 16(unsigned)kNumBitModelTotalBits(unsigned)kNumBitModelTotalBits << kCyclesBits((unsigned)kNumBitModelTotalBits << kCyclesBits)((unsigned)kNumBitModelTotalBits << kCyclesBits) - 15LitEnc_EncodeMatchedLitEnc_EncodeRangeEnc_EncodeBit_0RangeEnc_FlushDatahighRangeEnc_FlushStreamp->bufBaseRangeEnc_InitRangeEnc_FreeRangeEnc_AllocRC_BUF_SIZERangeEnc_ConstructLZMA_LC_MAXLZMA_LP_MAXLZMA_PB_MAXkLzmaMaxHistorySizedict64(UInt64)1kDicLogSizeMaxCompress8589934592(UInt64)1 << kDicLogSizeMaxCompress((UInt64)1 << kDicLogSizeMaxCompress)const CSaveStateconst CSaveState *CSaveState *const UInt32[4]posAlignEncoderisRepconst CLzmaProb[12]isRepG0isRepG1isRepG2isMatchconst CLzmaProb[12][16]isRep0LongposSlotEncoderconst CLzmaProb[64]const CLzmaProb(*)[64]const CLzmaProb[4][64]posEncodersconst CLzmaProb[128]sizeof(CLzmaProb)LzmaEnc_FastPosInit(UInt32)1 << 25((UInt32)1 << 25)(UInt32)1 << 26((UInt32)1 << 26)kReduceMinCLzmaEncCProbPriceCSaveStateCRangeEncCLenPriceEncCLenEncCOptimalCExtraCStatepad2saveStaterepLenEnclenEncg_FastPosrepLenProbslenProbsdistancesPricesalignPricespadmatchFinderBasematchFinderMtmtModedistTableSizerepLenEncCountermatchPriceCountmultiThreadfastModebackReslitProbsadditionalOffsetnumFastByteslongestMatchLenoptEndoptCurmatchFindermatchFinderObjbufBasebufLimtableSizekShortRepNextStateskRepNextStateskMatchNextStateskLiteralNextStatesChangePair(smallDist,bigDist)(((bigDist) >> 7) > (smallDist))MATCHESLIT_PROBS(pos,prevByte)(p->litProbs + (UInt32)3 * (((((pos) << 8) + (prevByte)) & p->lpMask) << p->lc))GetPrice_Rep_0(p,state,posState)( GET_PRICE_1(p->isMatch[state][posState]) + GET_PRICE_1(p->isRep0Long[state][posState])) + GET_PRICE_1(p->isRep[state]) + GET_PRICE_0(p->isRepG0[state])GetPrice_ShortRep(p,state,posState)( GET_PRICE_0(p->isRepG0[state]) + GET_PRICE_0(p->isRep0Long[state][posState]))IsShortRep(p)((p)->dist == 0)MakeAs_ShortRep(p){ (p)->dist = 0; (p)->extra = 0; }MakeAs_Lit(p){ (p)->dist = MARK_LIT; (p)->extra = 0; }((UInt32)(Int32)-1)MOVE_POS(p,num){ p->additionalOffset += (num); p->matchFinder.Skip(p->matchFinderObj, (UInt32)(num)); }GET_PRICEa_1(prob)ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]GET_PRICEa_0(prob)ProbPrices[(prob) >> kNumMoveReducingBits]GET_PRICE_1(prob)p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]GET_PRICE_0(prob)p->ProbPrices[(prob) >> kNumMoveReducingBits]GET_PRICEa(prob,bit)ProbPrices[((prob) ^ (unsigned)((-((int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];GET_PRICE(prob,bit)p->ProbPrices[((prob) ^ (unsigned)(((-(int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];RC_BIT_1(p,prob)RC_BIT_1_BASE(p, prob) RC_NORM(p)RC_BIT_0(p,prob)RC_BIT_0_BASE(p, prob) RC_NORM(p)RC_BIT_1_BASE(p,prob)range -= newBound; (p)->low += newBound; *(prob) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));RC_BIT_0_BASE(p,prob)range = newBound; *(prob) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));RC_BIT(p,prob,bit){ UInt32 mask; RC_BIT_PRE(p, prob) mask = 0 - (UInt32)bit; range &= mask; mask &= newBound; range -= mask; (p)->low += mask; mask = (UInt32)bit - 1; range += newBound & mask; mask &= (kBitModelTotal - ((1 << kNumMoveBits) - 1)); mask += ((1 << kNumMoveBits) - 1); ttt += (UInt32)((Int32)(mask - ttt) >> kNumMoveBits); *(prob) = (CLzmaProb)ttt; RC_NORM(p) }RC_BIT_PRE(p,prob)ttt = *(prob); newBound = (range >> kNumBitModelTotalBits) * ttt;RC_NORM(p)if (range < kTopValue) { range <<= 8; RangeEnc_ShiftLow(p); }RangeEnc_GetProcessed_sizet(p)((size_t)(p)->processed + (size_t)((p)->buf - (p)->bufBase) + (size_t)(p)->cacheSize)RangeEnc_GetProcessed(p)( (p)->processed + (size_t)((p)->buf - (p)->bufBase) + (p)->cacheSize)(1 << 30)GetLenToPosState(len)(((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)GetLenToPosState2(len)(((len) < kNumLenToPosStates - 1) ? (len) : kNumLenToPosStates - 1)IsLitState(s)((s) < 7)COPY_ARR(dest,src,arr)memcpy(dest->arr, src->arr, sizeof(src->arr));MFB(p->matchFinderBase)GET_PRICE_LEN(p,posState,len)((p)->prices[posState][(size_t)(len) - LZMA_MATCH_LEN_MIN])(LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)(kLenNumLowSymbols * 2 + kLenNumHighSymbols)(1 << LZMA_PB_MAX)(kAlignTableSize - 1)(kDicLogSizeMax * 2)(kNumOpts * 8)(1 << 11)GetPosSlot(pos,res){ if (pos < kNumFullDistances) res = p->g_FastPos[pos & (kNumFullDistances - 1)]; else BSR2_RET(pos, res); }GetPosSlot2(pos,res){ BSR2_RET(pos, res); }GetPosSlot1(pos)p->g_FastPos[pos]BSR2_RET(pos,res){ unsigned zz = (pos < (1 << (kNumLogBits + 6))) ? 6 : 6 + kNumLogBits - 1; res = p->g_FastPos[pos >> zz] + (zz * 2); }((kNumLogBits - 1) * 2 + 7)(11 + sizeof(size_t) / 8 * 3)(kBitModelTotal >> 1)((UInt32)15 << 28)defined(SHOW_STAT) || defined(SHOW_STAT2)(defined(__clang__) && (__clang_major__ >= 6)) \defined(_MSC_VER) && (_MSC_VER >= 1300)LZMA_LOG_BSRdefined(__clang__) \BSR2_RET_LZMA_ENC_USE_BRANCHSHOW_STAT2/*
#ifndef _7ZIP_ST
void LzmaEnc_GetLzThreads(CLzmaEncHandle pp, HANDLE lz_threads[2])
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  lz_threads[0] = p->matchFinderMt.hashSync.thread;
  lz_threads[1] = p->matchFinderMt.btSync.thread;
}
#endif
*/// we write aligned dictionary value to properties for lzma decoder/*
  if (res == SZ_OK && !Inline_MatchFinder_IsFinishedOK(&MFB))
    res = SZ_ERROR_FAIL;
  }
  *//*
UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
}
*/// p->mf_Failure = False;/* 21.03 *//* 18.04 *//* in worst case we can look ahead for
        max(LZMA_MATCH_LEN_MAX, numFastBytes + 1 + numFastBytes) bytes.
     we send larger value for (keepAfter) to MantchFinder_Create():
        (numFastBytes + LZMA_MATCH_LEN_MAX + 1)
  *//* 21.03 : here we reduce the dictionary for 2 reasons:
       1) we don't want 32-bit back_distance matches in decoder for 2 GB dictionary.
       2) we want to elimate useless last MatchFinder_Normalize3() for corner cases,
          where data size is aligned for 1 GB: 5/6/8 GB.
          That reducing must be >= 1 for such corner cases. */// }}// { int y; for (y = 0; y < 100; y++) {/*
        if (p->alignPriceCount >= 16) // kAlignTableSize
          FillAlignPrices(p);
        if (p->matchPriceCount >= 128)
          FillDistancesPrices(p);
        if (p->lenEnc.counter <= 0)
          LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);
        */// p->alignPriceCount++;// RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);/*
            do
            {
              range >>= 1;
              p->rc.low += range & (0 - ((dist >> --footerBits) & 1));
              RC_NORM(&p->rc)
            }
            while (footerBits > kNumAlignBits);
            */// RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);/* - base */// RcTree_Encode_PosSlot(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], posSlot);// --p->lenEnc.counter;// p->state = kLiteralNextStates[p->state];// }// posSlotPrices[slot] = RcTree_GetPrice(encoder, kNumPosSlotBits, slot, p->ProbPrices);// tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base, footerBits, i - base, p->ProbPrices);// int y; for (y = 0; y < 100; y++) {// p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);// p->alignPriceCount = 0;/* ReleaseMFStream(); */// printf("\nCheckErrors p->matchFinderMt.failureLZ\n");// p->matchFinderMt.failure_LZ_LZ ||// p->mf_Failure ||// RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);// RangeEnc_EncodeDirectBits(&p->rc, ((UInt32)1 << (30 - kNumAlignBits)) - 1, 30 - kNumAlignBits);    UInt32 range = p->range;// RcTree_Encode_PosSlot(&p->rc, p->posSlotEncoder[0], (1 << kNumPosSlotBits) - 1);/* for GCC */// if (mainLen < 2 && p->state == 0) return 1; // 18.06.notused// if (dist >= kNumFullDistances)// while (len2 >= 3);// offset--;// price2 = price + GetPrice_Len_Rep_0(p, len2, state2, posState2);// do// state2 = kLiteralNextStates[state2];// if (len2 >= 3)// MATCH : LIT : REP_0// if (p->_maxMode) {/*2*/// startLen = 2; /* speed optimization *//* for (unsigned len = 2; len <= newLen; len++) */// ---------- MATCH ----------// numFastBytes + 1 + numFastBytes// ---------- REP : LIT : REP_0 ----------/* if (_maxMode) */// startLen = len + 1; // 18.new// 17.old// if (len < startLen) continue; // 18.new: speed optimization// unsigned repIndex = IsLitState(state) ? 0 : 1; // 18.notused// ---------- REP ----------/* speed optimization */// while (len >= 3);// price2 = price + GetPrice_Len_Rep_0(p, len, state2, posState2);// 18.new// ---------- LIT : REP_0 ----------// numAvail <= p->numFastBytes// if (shortRepPrice <= nextOpt->price) // 17.old// && nextOpt->extra <= 1 // 17.old// we can check nextOpt->len, if skip items are not allowed in p->opt// nextOpt->price >= kInfinityPrice ||// if (numAvailFull < 2 || data[1] != *(data - reps[0] + 1))// ---------- SHORT_REP ----------// 18.06// && !IsLitState(state)// 18.new.06// here we can allow skip_items in p->opt, if we don't check (nextOpt->price < kInfinityPrice)/*
    The order of Price checks:
       <  LIT
       <= SHORT_REP
       <  LIT : REP_0
       <  REP    [ : LIT : REP_0 ]
       <  MATCH  [ : LIT : REP_0 ]
    *//*
    if (curOpt->price >= kInfinityPrice)
      continue;
    */// we need that check here, if skip_items in p->opt are possible// ---------- Optimal Parsing ----------/* if (position >= 0) */// #define MATCHES  p->matches// 21.03 : optimization// if (!d) { p->mf_Failure = True; *numPairsRes = 0;  return 0; }/*
  #ifdef SHOW_STAT
  g_STAT_OFFSET += num;
  printf("\n MovePos %u", num);
  #endif
*/// UInt32 price = a + RcTree_GetPrice(probs, kLenNumHighBits - 1, sym, ProbPrices);/*
        p->prices2[i] = a +
        // RcTree_GetPrice(enc->high, kLenNumHighBits, i - kLenNumLowSymbols * 2, ProbPrices);
        LitEnc_GetPrice(probs, i - kLenNumLowSymbols * 2, ProbPrices);
        */// p->counter = 64;// p->counter = numSymbols;/*
  {
    unsigned i;
    UInt32 b;
    a = GET_PRICEa_0(enc->low[0]);
    for (i = 0; i < kLenNumLowSymbols; i++)
      p->prices2[i] = a;
    a = GET_PRICEa_1(enc->low[0]);
    b = a + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);
    for (i = kLenNumLowSymbols; i < kLenNumLowSymbols * 2; i++)
      p->prices2[i] = b;
    a += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);
  }
  */// RcTree_Encode(rc, probs + (posState << kLenNumLowBits), kLenNumLowBits, sym);// RcTree_Encode(rc, p->high, kLenNumHighBits, sym - kLenNumLowSymbols * 2);// RangeEnc_EncodeBit(rc, probs + m, bit);// printf("\n%3d: %5d", i, ProbPrices[i]);// RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (sym >> 8)), (sym >> 7) & 1);// RangeEnc_EncodeBit(p, probs + (sym >> 8), (sym >> 7) & 1);// #define _LZMA_ENC_USE_BRANCH/*
  if (newMultiThread != _multiThread)
  {
    ReleaseMatchFinder();
    _multiThread = newMultiThread;
  }
  */// p->_maxMode = True;/*
#ifndef _7ZIP_ST
#define MFB (p->matchFinderMt.MatchFinder)
#endif
*/// BoolInt mf_Failure;// we want 8-bytes alignment here// we want {len , dist} pairs to be 8-bytes aligned in matches array// LZ thread// we suppose that we have 8-bytes alignment after CMatchFinder// CMatchFinder matchFinderBase;// #else// end of CMatchFinderMt is used in BT and HASH threads// begin of CMatchFinderMt is used in LZ thread// unsigned alignPriceCount;// BoolInt _maxMode;/*
#define GET_PRICE_LEN(p, posState, len) \
    ((p)->prices2[(size_t)(len) - 2] + ((p)->prices1[posState][((len) - 2) & (kLenNumLowSymbols * 2 - 1)] & (((len) - 2 - kLenNumLowSymbols * 2) >> 9)))
*/// UInt32 prices2[kLenNumSymbolsTotal];// UInt32 prices1[LZMA_NUM_PB_STATES_MAX][kLenNumLowSymbols * 2];// #define kDicLogSizeMin 0// #define kPackReserve (1 + kNumOpts * 2)// #define kNumOpts (1 << 12)// > 1 : MATCH (extra-1) : LIT : REP0 (len)// 1   : LIT : MATCH// 0   : normal// LZMA_LOG_BSR/*
#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
  p->g_FastPos[pos >> 6] + 12 : \
  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
*//*
#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \
  (0 - (((((UInt32)1 << (kNumLogBits)) - 1) - (pos >> 6)) >> 31))); \
  res = p->g_FastPos[pos >> zz] + (zz * 2); }
*//*
#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \
  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
  res = p->g_FastPos[pos >> zz] + (zz * 2); }
*//* we can use ((limit - pos) >> 31) only if (pos < ((UInt32)1 << 31)) */// ! LZMA_LOG_BSR// MY_CPU_X86_OR_AMD64// _BitScanReverse code is not optimal for some MSVC compilers// #define MY_clz  __lzcnt  // we can use lzcnt (unsupported by old CPU)// if defined(MY_CPU_X86_OR_AMD64)// #if defined(_MSC_VER)// __builtin_ia32_lzcnt_u32// __lzcnt32/*
  C code:                  : (30 - __builtin_clz(x))
    gcc9/gcc10 for x64 /x86  : 30 - (bsr(x) xor 31)
    clang10 for x64          : 31 + (bsr(x) xor -32)
*/// #include <intrin.h>// #endif// #if defined(MY_CPU_ARM_OR_ARM64)/* || defined(MY_CPU_X86_OR_AMD64) */// #define LZMA_LOG_BSR/*
x86/x64:

BSR:
  IF (SRC == 0) ZF = 1, DEST is undefined;
                  AMD : DEST is unchanged;
  IF (SRC != 0) ZF = 0; DEST is index of top non-zero bit
  BSR is slow in some processors

LZCNT:
  IF (SRC  == 0) CF = 1, DEST is size_in_bits_of_register(src) (32 or 64)
  IF (SRC  != 0) CF = 0, DEST = num_lead_zero_bits
  IF (DEST == 0) ZF = 1;

LZCNT works only in new processors starting from Haswell.
if LZCNT is not supported by processor, then it's executed as BSR.
LZCNT can be faster than BSR, if supported.
*/// #define kBitPrice (1 << kNumBitPriceShiftBits)/* for good normalization speed we still reserve 256 MB before 4 GB range *//* the following LzmaEnc_* declarations is internal LZMA interface for LZMA2 encoder *//* #define SHOW_STAT2 *//* LzmaEnc.c -- LZMA Encoder
2021-11-18: Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/MtCoder.cp->allocBigt->inBufCMtCoderThread *ArEvent_OptCreate_And_Reset(&p->finishedEvent)ArEvent_OptCreate_And_Reset(&p->readEvent)Semaphore_OptCreateInit(&p->blocksSemaphore, numBlocksMax, numBlocksMax)(unsigned)(int)-1nextThreadMtCoderThread_CreateAndStart(nextThread)Event_Set(&p->readEvent)MtCoder_Free&p->readEvent&p->blocksSemaphore&t->startEvent&t->thread&p->finishedEventThreadFunc(THREAD_FUNC_RET_TYPE)SZ_ERROR_THREADnumFinishedLONG *ThreadFunc2Event_Wait(&mtc->readEvent)mtc->allocBigmtc->blockSizeEvent_Set(&mtc->readEvent)Semaphore_Release1(&mtc->blocksSemaphore)Semaphore_ReleaseN(&mtc->blocksSemaphore, 1)&mtc->blocksSemaphoreCMtCoderBlock *blockwiisReadyFullRead&curMtCoderThread_Destructt->mtCoder->allocBigMtCoderThread_CreateAndStartArEvent_OptCreate_And_ResetMtProgressThunk_ProgressthunkprocessedSizeinSize2outSize2{ if ((x) != 0) return SZ_ERROR_THREAD; }// for (i = 0; i < numThreads; i++)/*
  p->stopReading = True;
  if (Event_IsCreated(&p->readEvent))
    Event_Set(&p->readEvent);
  */// MtProgress_Reinit(&mtc->mtProgress, t->index);// MtProgress_SetError(&mtc->mtProgress, res);/* we must get some block from blocksSemaphore before Event_Set(&mtc->readEvent) *//* after reading error - we can stop encoding of previous blocks *//* after Event_Wait(&mtc->readEvent) we must call Event_Set(&mtc->readEvent) in any case to unlock another threads *//*
  ThreadFunc2() returns:
  SZ_OK           - in all normal cases (even for stream error or memory allocation error)
  SZ_ERROR_THREAD - in case of failure in system synch function
*//* MtCoder.c -- Multi-thread Coder
2021-12-21 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/MtDec.cp->crossBlocksresMtDec_Free(size_t)1 << 18&t->canRead&t->canWritelinkCMtDecBufLink *__CMtDecBufLink *crossSizeThreadFunc1printf("\nthread exit error = %d\n", res)"=============== Event_Wait(&t->canRead)"t->indexprintf("\n" "=============== Event_Wait(&t->canRead)" " %d\n", (unsigned)t->index)Event_Wait(&t->canRead)"after Event_Wait(&t->canRead)"printf("\n" "after Event_Wait(&t->canRead)" " %d\n", (unsigned)t->index)printf("\ncrossSize = %d\n", crossSize)MTDEC__LINK_DATA_OFFSET + p->inBufSizesizeof(CMtDecBufLink) + p->inBufSizeprintf("\ncross : crossStart = %7d  crossEnd = %7d finish = %1d", (int)p->crossStart, (int)p->crossEnd, (int)finish)printf("\nParse size = %d\n", (unsigned)size)printf("   Parse processed = %d, state = %d \n", (unsigned)parse.srcSize, (unsigned)parse.state)printf("\n Overflow")printf("\n inDataSize = %d", (unsigned)inDataSize)printf("\ncross alloc error error\n")printf("\nfinished error SZ_ERROR_FAIL = %d\n", res)printf("\nERROR: numStartedThreads=%d\n", p->numStartedThreads)Event_Set(&nextThread->canRead)printf("\nCode Interrupt error = %x\n", codeRes)Event_Wait(&t->canWrite)printf("\n--Write afterSize = %d\n", (unsigned)afterEndData_Size)printf("\nAfter Write needContinue = %d\n", (unsigned)needContinue)printf("\nprocessed = %d\n", (unsigned)p->inProcessed)printf("\nWrite error = %d\n", res)printf("\nWrite Interrupt error = %x\n", res)printf("\np->numFilledThreads = %d\n", p->numFilledThreads)printf("p->filledThreadStart = %d\n", p->filledThreadStart)Event_Set(&nextThread->canWrite)Event_Set(&p->threads[0].canWrite)Event_Set(&p->threads[0].canRead)finishneedCodeneedWriteafterEndDataafterEndData_SizeafterEndData_IsCrossparseDataMTDEC_ProgessStepparsecrcrSizenextIndexisStartBlockisErrorMode"ThreadFunc2"printf("\n" "ThreadFunc2" " %d\n", (unsigned)t->index)MtDec_InterruptMtDec_Progress_GetError_Specp->mtProgress.progressp->mtProgress.totalInSizep->mtProgress.totalOutSizeMtDec_GetError_SpecMtDecThread_DestructMtDec_CloseThreadsMtDecThread_CloseThreadt->mtDec->allocMtDecThread_CreateAndStartMtDecThread_CreateEventsp->totalInSizep->totalOutSizeCMtDecBufLink__CMtDecBufLinkvoid *[3]MTDEC__DATA_PTR_FROM_LINK(link)((Byte *)(link) + MTDEC__LINK_DATA_OFFSET)MTDEC__LINK_DATA_OFFSETsizeof(CMtDecBufLink)PRF_STR_INT(s,d)PRF(printf("\n" s " %d\n", (unsigned)d))USE_ALLOCA// return SZ_ERROR_FAIL;// if (sres != SZ_OK)// p->needContinue = True;// || p->mtc.codeRes == SZ_ERROR_MEM// wres != 0// wres == 0// wres = Event_Wait(&p->finishedEvent);// wres = 17; // for test// wres = MtDecThread_CreateAndStart(nextThread);// RINOK_THREAD(ArEvent_OptCreate_And_Reset(&p->finishedEvent));// it must be larger than not_defined index (0)// Event_Close(&p->finishedEvent);// Event_Construct(&p->finishedEvent);// p->inDataSize = 0;// p->inData = NULL;// fprintf(stderr, "\n%d = %p - before", t->index, &t);// it's unexpected situation for some threading function error// fprintf(stdout, "\n%d = %p\n", t->index, &t);// we exit from decoding// we restore decoding with new iteration// res = SZ_ERROR_FAIL; // for test// needWrite// p->inProcessed += inCodePos;// if (res == SZ_OK && needWrite && !wasInterrupted)// if (inDelta != 0 || outDelta != 0)// || !needCode // check it !!!// it's never executed in normal cases// ---------- WRITE ----------// Sleep(1);// we interrupt only later blocks// srcFinished// ---------- CODE ----------// Don't change (finish) variable in the further code//   - otherwise we stop decoding and exit from ThreadFunc2()//   - if (needContinue) after Write(&needContinue), we restore decoding with new iteration// if (  finish ) we switch to single-thread mode and there are 2 ways at the end of current iteration (current block):// if ( !finish ) we must call Event_Set(&nextThread->canWrite) in any case// each call of Event_Set(&nextThread->canRead) must be followed by call of Event_Set(&nextThread->canWrite)// And that next thread now is responsible for possible exit from decoding (threading_code)// We have started executing for new iteration (with next thread)// if only one thread is possible, we leave muti-threading code// if (p->numStartedThreads % 1000 == 0) PRF(printf("\n numStartedThreads=%d\n", p->numStartedThreads));//   if (codeRes != SZ_ERROR_MEM) - we can stop decoding or try single-thread decoding.//   if (codeRes == SZ_ERROR_MEM) - we will try single-thread decoding later.// SZ_ERROR_MEM is expected error here.// it's partial size (parsed only)// inDataSize_Full = inDataSize;// p->allocError_for_Read_BlockIndex = blockIndex;// res = SZ_ERROR_MEM;// partial parsed - is not in initial cross block - we need to copy new data to cross block// it's only parsed now// partial parsed - need cross transfer// we reduce data size to required bytes (parsed only)// full parsed - no cross transfer// p->crossFinished = finish;// we don't need to parse in current thread anymore// PRF(printf("\nisBlockFinished = %d", (unsigned)parse.blockWasFinished));// Overflow or Parse error - switch from MT decoding to ST decoding// || wasInterrupted// ||// inDataSize - (size - parse.srcSize) > p->inBlockMax// parseRes != SZ_OK ||// printf("\n\n%12I64u %12I64u", (UInt64)p->mtProgress.totalInSize, (UInt64)p->mtProgress.totalOutSize);// p->readError_BlockIndex = blockIndex;// we want to decode all data before error// PRF(printf("\nRead error = %d\n", res))// res = E_INVALIDARG; // test// size = 10; // test// printf("\n%6d : %x", ++g_num, (unsigned)(size_t)((Byte *)link - (Byte *)prev));// static unsigned g_num = 0;// if (p->inStream)// inDataSize_Full = 0;// PRF(printf("\ncanRead\n"))// if (t->index == 3) return 19; // for test// CMtDecCallbackInfo parse;// UInt64 inDataSize_Full;// SetThreadAffinityMask(GetCurrentThread(), 1 << t->index);// #define MTDEC_ProgessStep (1 << 22)/*
  ThreadFunc2() returns:
  0      - in all normal cases (even for stream error or memory allocation error)
  (!= 0) - WRes error return by system threading function
*//* we can disable it. There are no threads waiting canWrite in normal cases *//* MtDec.c -- Multi-thread Decoder
2021-12-21 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd.hCPpmd_Byte_RefCPpmd_Void_RefCPpmd_State_RefCPpmd_State4CPpmd_State4_CPpmd_State2CPpmd_State2_CPpmd_StateCPpmd_SeeSuccessor_1Successor_0FreqSymbolCountShiftSummPPMD_SetAllBitsIn256Bytes(p){ size_t z; for (z = 0; z < 256 / sizeof(p[0]); z += 8) { p[z+7] = p[z+6] = p[z+5] = p[z+4] = p[z+3] = p[z+2] = p[z+1] = p[z+0] = ~(size_t)0; }}Ppmd_SET_SUCCESSOR(p,v){ (p)->Successor_0 = (UInt16)((UInt32)(v) ); (p)->Successor_1 = (UInt16)(((UInt32)(v) >> 16) ); }Ppmd_GET_SUCCESSOR(p)( (CPpmd_Void_Ref) ((p)->Successor_0 | ((UInt32)(p)->Successor_1 << 16)) )Ppmd_GetPtr_Type(p,offs,type)((type *)Ppmd_GetPtr(p, offs))Ppmd_GetPtr(p,offs)((void *)((p)->Base + (offs)))Ppmd_GetRef(p,ptr)((UInt32)((Byte *)(ptr) - (p)->Base))Ppmd_Ref_Type(type)Ppmd_See_Update(p)if ((p)->Shift < PPMD_PERIOD_BITS && --(p)->Count == 0) { (p)->Summ = (UInt16)((p)->Summ << 1); (p)->Count = (Byte)(3 << (p)->Shift++); }PPMD_NUM_INDEXES(PPMD_N1 + PPMD_N2 + PPMD_N3 + PPMD_N4)PPMD_N4((128 + 3 - 1 * PPMD_N1 - 2 * PPMD_N2 - 3 * PPMD_N3) / 4)PPMD_N3PPMD_N2PPMD_N1PPMD_UPDATE_PROB_1(prob)((prob) - PPMD_GET_MEAN(prob))PPMD_UPDATE_PROB_0(prob)((prob) + (1 << PPMD_INT_BITS) - PPMD_GET_MEAN(prob))PPMD_GET_MEAN(summ)PPMD_GET_MEAN_SPEC((summ), PPMD_PERIOD_BITS, 2)PPMD_GET_MEAN_SPEC(summ,shift,round)(((summ) + (1 << ((shift) - (round)))) >> (shift))PPMD_BIN_SCALE(1 << (PPMD_INT_BITS + PPMD_PERIOD_BITS))PPMD_PERIOD_BITSPPMD_INT_BITS__PPMD_HPPMD_32BIT/* & 0xFFFF *//*
   We can write 16-bit halves to 32-bit (Successor) field in any selected order.
   But the native order is more consistent way.
   So we use the native order, if LE/BE order can be detected here at compile time.
*//*
#ifdef MY_CPU_LE_UNALIGN
// the unaligned 32-bit access latency can be too large, if the data is not in L1 cache.
#define Ppmd_GET_SUCCESSOR(p) ((CPpmd_Void_Ref)*(const UInt32 *)(const void *)&(p)->Successor_0)
#define Ppmd_SET_SUCCESSOR(p, v) *(UInt32 *)(void *)(void *)&(p)->Successor_0 = (UInt32)(v)

#else
*/// PPMD_32BIT/*
   PPMD code can write full CPpmd_State structure data to CPpmd*_Context
      at (byte offset = 2) instead of some fields of original CPpmd*_Context structure.
   
   If we use pointers to different types, but that point to shared
   memory space, we can have aliasing problem (strict aliasing).
   
   XLC compiler in -O2 mode can change the order of memory write instructions
   in relation to read instructions, if we have use pointers to different types.
   
   To solve that aliasing problem we use combined CPpmd*_Context structure
   with unions that contain the fields from both structures:
   the original CPpmd*_Context and CPpmd_State.
   So we can access the fields from both structures via one pointer,
   and the compiler doesn't change the order of write instructions
   in relation to read instructions.

   If we don't use memory write instructions to shared memory in
   some local code, and we use only reading instructions (read only),
   then probably it's safe to use pointers to different types for reading.
*//* Count to next change of Shift *//* Speed of Freq change; low Shift is for fast change *//* Freq *//* SEE-contexts for PPM-contexts with masked symbols *//* Most compilers works OK here even without #pragma pack(push, 1), but some GCC compilers need it. *//*
   PPMD code always uses 32-bit internal fields in PPMD structures to store internal references in main block.
   if (PPMD_32BIT is     defined), the PPMD code stores internal pointers to 32-bit reference fields.
   if (PPMD_32BIT is NOT defined), the PPMD code stores internal UInt32 offsets to reference fields.
   if (pointer size is 64-bit), then (PPMD_32BIT) mode is not allowed,
   if (pointer size is 32-bit), then (PPMD_32BIT) mode is optional,
     and it's allowed to disable PPMD_32BIT mode even if pointer is 32-bit.
   PPMD code works slightly faster in (PPMD_32BIT) mode.
*//* Ppmd.h -- PPMD codec common code
2021-04-13 : Igor Pavlov : Public domain
This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd7.h"Ppmd.h"Ppmd7z_EncodeSymbolsCPpmd7 *Ppmd7z_Flush_RangeEncPpmd7z_Init_RangeEncPpmd7z_DecodeSymbolPpmd7z_RangeDec_InitCPpmd7_RangeDec *Ppmd7a_DecodeSymbolPpmd7a_RangeDec_InitCPpmd7CPpmd7z_RangeEncCPpmd7_RangeDecCPpmd7_ContextCPpmd7_Context_CPpmd7_Context_RefUInt16[64]UInt16[128][64]unsigned short[128][64]BinSummCPpmd_See[16]struct <unnamed>[16]CPpmd_See[25][16]struct <unnamed>[25][16]SeeDummySeeByte[16]ExpEscapeNS2IndxNS2BSIndxCPpmd_Void_Ref[38]unsigned int[38]FreeListUnits2IndxByte[40]unsigned char[40]Indx2UnitsUnitsStartTextHiUnitLoUnitBaseAlignOffsetGlueCountSizeInitRLRunLengthHiBitsFlagMaxOrderPrevSuccessInitEscOrderFallCPpmd_State *FoundStateCPpmd7_Context *CPpmd7_Context_ *MaxContextMinContextStreamCacheSizeLowCacheRangeSuffixUnion4Union2NumStatsState4StatsState2SummFreqPpmd7z_RangeDec_IsFinishedOK(p)((p)->Code == 0)Ppmd7a_RangeDec_IsFinishedOK(p)PPMD7_SYM_ERROR(-2)PPMD7_SYM_ENDPpmd7_GetBinSumm(p)&p->BinSumm[(size_t)(unsigned)Ppmd7Context_OneState(p->MinContext)->Freq - 1] [ p->PrevSuccess + ((p->RunLength >> 26) & 0x20) + p->NS2BSIndx[(size_t)Ppmd7_GetContext(p, p->MinContext->Suffix)->NumStats - 1] + PPMD7_HiBitsFlag_4(Ppmd7Context_OneState(p->MinContext)->Symbol) + (p->HiBitsFlag = PPMD7_HiBitsFlag_3(p->FoundState->Symbol)) ]PPMD7_HiBitsFlag_4(sym)((((unsigned)sym + 0xC0) >> (8 - 4)) & (1 << 4))PPMD7_HiBitsFlag_3(sym)((((unsigned)sym + 0xC0) >> (8 - 3)) & (1 << 3))Ppmd7_GetStats(p,ctx)Ppmd_GetPtr_Type(p, (ctx)->Union4.Stats, CPpmd_State)Ppmd7_GetContext(p,ptr)Ppmd_GetPtr_Type(p, ptr, CPpmd7_Context)Ppmd7_GetPtr(p,ptr)Ppmd_GetPtr(p, ptr)Ppmd7_WasAllocated(p)((p)->Base != NULL)Ppmd7Context_OneState(p)((CPpmd_State *)&(p)->Union2)PPMD7_MAX_MEM_SIZE(0xFFFFFFFF - 12 * 3)PPMD7_MIN_MEM_SIZEPPMD7_MAX_ORDERPPMD7_MIN_ORDER__PPMD7_HCPpmd_See *Ppmd7_MakeEscFreqPpmd7_Update2Ppmd7_Update1_0Ppmd7_Update1Ppmd7_InitPpmd7_FreePpmd7_AllocPpmd7_Constructstruct CPpmd7_Context_// void Ppmd7z_EncodeSymbol(CPpmd7 *p, int symbol);/* ---------- Encode ---------- */// Byte *Ppmd7z_DecodeSymbols(CPpmd7 *p, Byte *buf, const Byte *lim);/* Ppmd7z_* : modified PPMdH with 7z Range Coder *//* Ppmd7a_* : original PPMdH *//*
You must set (CPpmd7::rc.dec.Stream) before Ppmd7*_RangeDec_Init()

Ppmd7*_DecodeSymbol()
out:
  >= 0 : decoded byte
    -1 : PPMD7_SYM_END   : End of payload marker
    -2 : PPMD7_SYM_ERROR : Data error
*//* ---------- Decode ---------- *//*
We support two versions of Ppmd7 (PPMdH) methods that use same CPpmd7 structure:
  1) Ppmd7a_*: original PPMdH
  2) Ppmd7z_*: modified PPMdH with 7z Range Coder
Ppmd7_*: the structures and functions that are common for both versions of PPMd7 (PPMdH)
*/// #define PPMD7_HiBitsFlag_4(sym) ((sym) < 0x40 ? 0 : (1 << 4))// #define PPMD7_HiBitsFlag_3(sym) ((sym) < 0x40 ? 0 : (1 << 3))/* ---------- Internal Functions ---------- */// int LastSymbol;// +2 for alignment/* must be 32-bit at least */// Byte _dummy_[3];// MY_CPU_pragma_pop// MY_CPU_pragma_pack_push_1/* Ppmd7.h -- Ppmd7 (PPMdH) compression codec
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.H (2001): Dmitry Shkarin : Public domain */numMaskedscalemaxOrder/home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd7.c"Ppmd7.h"MAX_FREQsummFreqtmpNextContextSUCCESSOR(p->FoundState)( (CPpmd_Void_Ref) ((p->FoundState)->Successor_0 | ((UInt32)(p->FoundState)->Successor_1 << 16)) )p->FoundStateseeconst CPpmd7_Contextconst CPpmd7_Context *numStats(mc)->SuffixnonMaskedCPpmd_See(*)[16]struct <unnamed>(*)[16]summRescaleaddersumFreqescFreqp->MinContext(p->MinContext)->Union4.Statsstatss1n0n1ptr(const void *)statsnumStatsNewunion <unnamed> *i0i1CPpmd_Void_Ref *z(mc)->Union4.StatsPpmd7_UpdateModelmaxSuccessorminSuccessors0ns(p->MinContext)->Suffix(c)->Union4.StatstextoldNU(size_t)oldNU + 1oldPtr(c)->Suffixns1cfsf(UInt32)4CreateSuccessorsupBranchnewSymnewFreqnumPsCPpmd_State *[64]struct <unnamed> *[64]psCPpmd_State **struct <unnamed> **successorc1UNIT_SIZERestartModelsizeof(p->FreeList)256 / 2U2B(256 / 2)257256 + 1UInt16(*)[64]const UInt16[8]unsigned short[8](PPMD_PERIOD_BITS - 4)SetSuccessorAllocUnitsnumBytesI2U(indx)((unsigned)p->Indx2Units[indx])indxloAllocUnitsRareusGlueFreeBlocksheadCPpmd7_Node *CPpmd7_Node_ *CPpmd7_NodenuCPpmd7_Node_Union *_CPpmd7_Node_Union *unconst CPpmd7_Node_RefEMPTY_NODECPpmd7_Node_Ref *nodenode2i = U2I(nu)i = (p->Units2Indx[(size_t)(nu) - 1])--iSplitBlockoldIndxnewIndxI2U(newIndx)((unsigned)p->Indx2Units[newIndx])RemoveNodep->FreeList[indx]InsertNodep->AlignOffset + sizep->Basestep0 << 1(0 << 1)2 << 1(2 << 1)3 << 1(3 << 1)256 - 11CPpmd7_Node_Union_CPpmd7_Node_UnionCPpmd7_Node_CPpmd7_Node_RefCTX_PTRNextRefNodePrevNextNUStampconst UInt16[]unsigned short[]kInitBinEsc155810x3CDD79990x1F3F229750x59BF186750x48F3257610x64A1232280x5ABC261620x6632246570x6051PPMD7_kExpEscapeSwapStates(s){ CPpmd_State tmp = s[0]; s[0] = s[-1]; s[-1] = tmp; }SUCCESSOR(p)MyMem12Cpy(dest,src,num){ UInt32 *d = (UInt32 *)dest; const UInt32 *z = (const UInt32 *)src; UInt32 n = num; do { d[0] = z[0]; d[1] = z[1]; d[2] = z[2]; z += 3; d += 3; } while (--n); }NODE(r)Ppmd_GetPtr_Type(p, r, CPpmd7_Node)SUFFIX(ctx)CTX((ctx)->Suffix)ONE_STATE(ctx)Ppmd7Context_OneState(ctx)STATS(ctx)Ppmd7_GetStats(p, ctx)CTX(ref)((CPpmd7_Context *)Ppmd7_GetContext(p, ref))STATS_REF(ptr)((CPpmd_State_Ref)REF(ptr))REF(ptr)Ppmd_GetRef(p, ptr)I2U_UInt16(indx)((UInt16)p->Indx2Units[indx])U2I(nu)(p->Units2Indx[(size_t)(nu) - 1])U2B(nu)((UInt32)(nu) * UNIT_SIZE)PPMD7_ORDER_0_SUPPPORTstruct CPpmd7_Node_/*
PPMd Memory Map:
{
  [ 0 ]           contains subset of original raw text, that is required to create context
                  records, Some symbols are not written, when max order context was reached
  [ Text ]        free area
  [ UnitsStart ]  CPpmd_State vectors and CPpmd7_Context records
  [ LoUnit ]      free  area for CPpmd_State and CPpmd7_Context items
[ HiUnit ]      CPpmd7_Context records
  [ Size ]        end of array
}

These addresses don't cross at any time.
And the following condtions is true for addresses:
  (0  <= Text < UnitsStart <= LoUnit <= HiUnit <= Size)

Raw text is BYTE--aligned.
the data in block [ UnitsStart ... Size ] contains 12-bytes aligned UNITs.

Last UNIT of array at offset (Size - 12) is root order-0 CPpmd7_Context record.
The code can free UNITs memory blocks that were allocated to store CPpmd_State vectors.
The code doesn't free UNITs allocated for CPpmd7_Context records.

The code calls RestartModel(), when there is no free memory for allocation.
And RestartModel() changes the state to orignal start state, with full free block.


The code allocates UNITs with the following order:

Allocation of 1 UNIT for Context record
  - from free space (HiUnit) down to (LoUnit)
  - from FreeList[0]
  - AllocUnitsRare()

AllocUnits() for CPpmd_State vectors:
  - from FreeList[i]
  - from free space (LoUnit) up to (HiUnit)
  - AllocUnitsRare()

AllocUnitsRare()
  - if (GlueCount == 0)
       {  Glue lists, GlueCount = 255, allocate from FreeList[i]] }
  - loop for all higher sized FreeList[...] lists
  - from (UnitsStart - Text), GlueCount--
  - ERROR


Each Record with Context contains the CPpmd_State vector, where each
CPpmd_State contains the link to Successor.
There are 3 types of Successor:
  1) NULL-Successor   - NULL pointer. NULL-Successor links can be stored
                        only in 0-order Root Context Record.
                        We use 0 value as NULL-Successor
  2) RAW-Successor    - the link to position in raw text,
                        that "RAW-Successor" is being created after first
                        occurrence of new symbol for some existing context record.
                        (RAW-Successor > 0).
  3) RECORD-Successor - the link to CPpmd7_Context record of (Order+1),
                        that record is being created when we go via RAW-Successor again.

For any successors at any time: the following condtions are true for Successor links:
(NULL-Successor < RAW-Successor < UnitsStart <= RECORD-Successor)


---------- Symbol Frequency, SummFreq and Range in Range_Coder ----------

CPpmd7_Context::SummFreq = Sum(Stats[].Freq) + Escape_Freq

The PPMd code tries to fulfill the condition:
  (SummFreq <= (256 * 128 = RC::kBot))

We have (Sum(Stats[].Freq) <= 256 * 124), because of (MAX_FREQ = 124)
So (4 = 128 - 124) is average reserve for Escape_Freq for each symbol.
If (CPpmd_State::Freq) is not aligned for 4, the reserve can be 5, 6 or 7.
SummFreq and Escape_Freq can be changed in Rescale() and *Update*() functions.
Rescale() can remove symbols only from max-order contexts. So Escape_Freq can increase after multiple calls of Rescale() for
max-order context.

When the PPMd code still break (Total <= RC::Range) condition in range coder,
we have two ways to resolve that problem:
  1) we can report error, if we want to keep compatibility with original PPMd code that has no fix for such cases.
  2) we can reduce (Total) value to (RC::Range) by reducing (Escape_Freq) part of (Total) value.
*//*
void Ppmd7_UpdateBin(CPpmd7 *p)
{
  unsigned freq = p->FoundState->Freq;
  p->FoundState->Freq = (Byte)(freq + (freq < 128));
  p->PrevSuccess = 1;
  p->RunLength++;
  NextContext(p);
}
*/// & 0xFFFF// if (see->Summ) field is larger than 16-bit, we need only low 16 bits of Summ// Escape_Freq halving here// p->MinContext->Union4.Stats = STATS_REF(ShrinkUnits(p, stats, n0, n1));// (freq <= 260 / 4)/* Create Single-Symbol context *//* We increase (escFreq) for the number of removed symbols.
       So we will have (0.5) increase for Escape_Freq in avarage per
       removed symbol after Escape_Freq halving *//* Remove all items with Freq == 0 */// we don't remove symbols from order-0 context/*
  if (p->OrderFall == 0), adder = 0 : it's     allowed to remove symbol from     MAX Order context
  if (p->OrderFall != 0), adder = 1 : it's NOT allowed to remove symbol from NON-MAX Order context
  *//* Sort the list by Freq *//* It can add (0, 1, 2) to Escape_Freq */// max(InitEsc = PPMD7_kExpEscape[*]) is 25. So the max(escapeFreq) is 26 here// (max(s->freq) == 120), when we convert from 1-symbol into 2-symbol context// (Successor_0 and Successor_1) in LE/BE.// SetSuccessor(s, c->Union4.Stats);  // call it only for debug purposes to check the order of// s = *ONE_STATE(c);// instead of One-symbol context we create 2-symbol context// sum = (UInt16)sum;/* original PPMdH uses 16-bit variable for (sum) here.
         But (sum < 0x9000). So we don't truncate (sum) to 16-bit *//* max increase of Escape_Freq is 3 here.
         total increase of Union2.SummFreq for all symbols is less than 256 here *//* Expand for one UNIT */// s0 : is pure Escape Freq/*
    FoundState has NULL-Successor here.
    And only root 0-order context can contain NULL-Successors.
    We change Successor in FoundState to RAW-Successor,
    And next context will be same 0-order root Context.
    *//*
      if (MaxContext != MinContext)
      {
        there was order fall from MaxOrder and we don't need current symbol
        to transfer some RAW-Succesors to real contexts.
        So we roll back pointer in raw data for one position.
      }
      *//*
      if we move to MaxOrder context, then minSuccessor will be common Succesor for both:
        MinContext that is (MaxOrder - 1)
        MaxContext that is (MaxOrder)
      so we don't need new RAW-Successor, and we can use real minSuccessor
      as succssors for both MinContext and MaxContext.
      */// minSuccessor now is real Context pointer that points to existing (Order+1) context// minSuccessor is RAW-Successor. So we will create real contexts records:// So the next context will be one order higher than MinContext.// there is Successor for FoundState in MinContext./* NON-MAX ORDER context *//* (FoundState->Successor) is RAW-Successor. *//* MAX ORDER context */// s++; if (s->Symbol == sym) break;/* Update Freqs in Suffix Context *//* = AllocContext(p); */// Create new single-symbol contexts from low order to high order in loop/*
      cf - is frequency of symbol that will be Successor in new context records.
      s0 - is commulative frequency sum of another symbols from parent context.
      max(newFreq)= (s->Freq + 1), when (s0 == 1)
      we have requirement (Ppmd7Context_OneState()->Freq <= 128) in BinSumm[]
      so (s->Freq < 128) - is requirement for multi-symbol contexts
    */// after FoundState->Successor// All new RAW-Successors will point to next position in RAW text// All created contexts will have single-symbol with new RAW-Successor// So we don't need to create any new contexts.// (c) is real record MAX Order Context here,// (c) is real record Context here,/*
  CreateSuccessors()
  It's called when (FoundState->Successor) is RAW-Successor,
  that is the link to position in Raw text.
  So we create Context records and write the links to
  FoundState->Successor and to identical RAW-Successors in suffix
  contexts of MinContex.
  
  The function returns:
  if (OrderFall == 0) then MinContext is already at MAX order,
    { return pointer to new or existing context of same MAX order }
  else
    { return pointer to new real context that will be (Order+1) in comparison with MinContext

  also it can return pointer to real context of same order,
*//* unused *//* AllocUnits(p, PPMD_NUM_INDEXES - 1); *//* AllocContext(p); *//*
static void *ShrinkUnits(CPpmd7 *p, void *oldPtr, unsigned oldNU, unsigned newNU)
{
  unsigned i0 = U2I(oldNU);
  unsigned i1 = U2I(newNU);
  if (i0 == i1)
    return oldPtr;
  if (p->FreeList[i1] != 0)
  {
    void *ptr = RemoveNode(p, i1);
    MyMem12Cpy(ptr, oldPtr, newNU);
    InsertNode(p, oldPtr, i0);
    return ptr;
  }
  SplitBlock(p, oldPtr, i0, i1);
  return oldPtr;
}
*//* Fill lists of free blocks *//* Glue free blocks *//* Glue and Fill must walk the list in same direction *//* Don't change the order of the following commands: *//* Create list of free blocks.
       We still need one additional list walk pass before Glue. *//* we set guard NODE at LoUnit *//*
  we use first UInt16 field of 12-bytes UNITs as record type stamp
    CPpmd_State    { Byte Symbol; Byte Freq; : Freq != 0
    CPpmd7_Context { UInt16 NumStats;        : NumStats != 0
    CPpmd7_Node    { UInt16 Stamp            : Stamp == 0 for free record
                                             : Stamp == 1 for head record and guard
    Last 12-bytes UNIT in array is always contains 12-bytes order-0 CPpmd7_Context record.
  *//* Original PPmdH (Ppmd7) code uses doubly linked list in GlueFreeBlocks()
   we use single linked list similar to Ppmd8 code *//* we use CPpmd7_Node_Union union to solve XLC -O2 strict pointer aliasing problem */// p->FreeList[indx] = node->Next;// CPpmd7_Node *node = NODE((CPpmd7_Node_Ref)p->FreeList[indx]);// ((CPpmd7_Node *)node)->Next = (CPpmd7_Node_Ref)p->FreeList[indx];/* We can use CPpmd7_Node in list of free units (as in Ppmd8)
   But we still need one additional list walk pass in GlueFreeBlocks().
   So we use simple CPpmd_Void_Ref instead of CPpmd7_Node in InsertNode() / RemoveNode()
*/// ---------- Internal Memory Allocator ----------/* must be at offset >= 4 *//* must be at offset 0 as CPpmd7_Context::NumStats. Stamp=0 means free */// #define PPMD7_ORDER_0_SUPPPORT/* define PPMD7_ORDER_0_SUPPPORT to suport order-0 mode, unsupported by orignal PPMd var.H. code *//* Ppmd7.c -- PPMdH codec
2021-04-13 : Igor Pavlov : Public domain
This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd7Dec.csize_t[32]unsigned long[32]sizeof(size_t)256 / sizeof(size_t)charMasks->Freq(&p->rc.dec)((&p->rc.dec))->Stream(hiCnt - count) - s->FreqhiCntsummFreq - hiCntp->FoundState->Symbols->Symbolsym0sym1p->MinContext->SuffixPpmd7Context_OneState(p->MinContext)->Symbol((CPpmd_State *)&(p->MinContext)->Union2)->Symbolpr(pr)SUCCESSOR(s)( (CPpmd_Void_Ref) ((s)->Successor_0 | ((UInt32)(s)->Successor_1 << 16)) )counts2size01 << PPMD_INT_BITS(1 << PPMD_INT_BITS)mc->SuffixfreqSum(s)->SymbolfreqSum - hiCntRangeDec_Decode(p)->StreamMASK(sym)((unsigned char *)charMask)[sym]RC_GetThreshold(total)(R->Code / (R->Range /= (total)))RC_DecodeFinal(start,size)RC_Decode(start, size) RC_NORM_REMOTE(R)RC_Decode(start,size)RangeDec_Decode(p, start, size);RC_NORM_REMOTE(p)RC_NORM_LOCAL(p)RC_NORM_BASE(p) RC_NORM_BASE(p) }}RC_NORM_1(p)RC_NORM_BASE(p) }RC_NORM_BASE(p)if ((p)->Range < kTopValue) { (p)->Code = ((p)->Code << 8) | READ_BYTE(p); (p)->Range <<= 8;READ_BYTE(p)IByteIn_Read((p)->Stream)/*
Byte *Ppmd7z_DecodeSymbols(CPpmd7 *p, Byte *buf, const Byte *lim)
{
  int sym = 0;
  if (buf != lim)
  do
  {
    sym = Ppmd7z_DecodeSymbol(p);
    if (sym < 0)
      break;
    *buf = (Byte)sym;
  }
  while (++buf < lim);
  p->LastSymbol = sym;
  return buf;
}
*/// new (see->Summ) value can overflow over 16-bits in some rare cases// We increase (see->Summ) for sum of Freqs of all non_Masked symbols.// count -= s->Freq & (unsigned)(MASK((s)->Symbol)); s++; if ((Int32)count < 0) break;// if ((Int32)count >= 0)// count -= s->Freq & (unsigned)(MASK(s->Symbol));// RangeDec_DecodeBit1(size0);// NextContext(p);// Ppmd7_UpdateBin(p);// sym = (p->FoundState = Ppmd7Context_OneState(p->MinContext))->Symbol;/* we can use single byte normalization here because of
         (min(BinSumm[][]) = 95) > (1 << (14 - 8)) */// RangeDec_DecodeBit0(size0);// do { MASK((--s)->Symbol) = 0; } while (--i);// i = p->MinContext->NumStats - 1;// static// MY_NO_INLINE// RC_NORM(p)// we must use only one type of Normalization from two: LOCAL or REMOTE/* Ppmd7Dec.c -- Ppmd7z (PPMdH with 7z Range Coder) Decoder
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.H (2001): Dmitry Shkarin : Public domain */start/home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd7Enc.cPpmd7z_EncodeSymbolp->MinContext->Union2.SummFreq - sumCPpmd7z_RangeEnc *totalRangeEnc_EncodeR->Stream(&p->rc.enc)->Stream(Byte)(temp + (Byte)(R->Low >> 32))(Byte)(temp + (Byte)((&p->rc.enc)->Low >> 32))RC_EncodeFinal(start,size)RC_Encode(start, size); RC_NORM_REMOTE(p);RC_Encode(start,size)RangeEnc_Encode(p, start, size);if (R->Range < kTopValue) { R->Range <<= 8; RangeEnc_ShiftLow(p);(&p->rc.enc)// i = mc->NumStats;// see = Ppmd7_MakeEscFreq(p, numMasked, &escFreq);/* EndMarker (symbol = -1) */// RangeEnc_EncodeBit_1(p, bound);// p->FoundState = s;// RangeEnc_EncodeBit_0(p, bound);// MASK(s->Symbol) = 0;// R->Range /= p->MinContext->Union2.SummFreq;/*
#define RangeEnc_Encode(p, start, _size_) \
  { UInt32 size = _size_; \
    R->Low += start * R->Range; \
    R->Range *= size; \
    RC_NORM_LOCAL(p); }
*//* Ppmd7Enc.c -- Ppmd7z (PPMdH with 7z Range Coder) Encoder
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.H (2001): Dmitry Shkarin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd7aDec.c32767(UInt32)PPMD_BIN_SCALE16383(UInt32)PPMD_BIN_SCALE - 1((UInt32)PPMD_BIN_SCALE - 1)4294950912~((UInt32)PPMD_BIN_SCALE - 1)while ((p->Low ^ (p->Low + p->Range)) < kTop || (p->Range < kBot && ((p->Range = (0 - p->Low) & (kBot - 1)), 1))) { p->Code = (p->Code << 8) | READ_BYTE(p); p->Range <<= 8; p->Low <<= 8; }kBotkTop/* Ppmd7aDec.c -- PPMd7a (PPMdH) Decoder
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.H (2001): Dmitry Shkarin : Public domain
  Carryless rangecoder (1999): Dmitry Subbotin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd8.hPpmd8_EncodeSymbolCPpmd8 *Ppmd8_Flush_RangeEncPpmd8_DecodeSymbolPpmd8_Init_RangeDecCPpmd8PPMD8_RESTORE_METHOD_RESTARTPPMD8_RESTORE_METHOD_CUT_OFFPPMD8_RESTORE_METHOD_UNSUPPPORTEDCPpmd8_ContextCPpmd8_Context_CPpmd8_Context_RefUInt16[25][64]unsigned short[25][64]CPpmd_See[32]CPpmd_See[24][32]struct <unnamed>[24][32]Byte[260]unsigned char[260]260UInt32[38]StampsRestoreMethodCPpmd8_Context *CPpmd8_Context_ *OutInFlagsPpmd8_Init_RangeEnc(p){ (p)->Low = 0; (p)->Range = 0xFFFFFFFF; }Ppmd8_RangeDec_IsFinishedOK(p)PPMD8_SYM_ERRORPPMD8_SYM_ENDPPMD8_CORRECT_SUM_RANGE(p,_sum_)if (_sum_ > p->Range ) _sum_ = p->Range;Ppmd8_GetBinSumm(p)&p->BinSumm[p->NS2Indx[(size_t)Ppmd8Context_OneState(p->MinContext)->Freq - 1]] [ p->PrevSuccess + ((p->RunLength >> 26) & 0x20) + p->NS2BSIndx[Ppmd8_GetContext(p, p->MinContext->Suffix)->NumStats] + + p->MinContext->Flags ]Ppmd8_GetStats(p,ctx)Ppmd8_GetContext(p,ptr)Ppmd_GetPtr_Type(p, ptr, CPpmd8_Context)Ppmd8_GetPtr(p,ptr)Ppmd8_WasAllocated(p)Ppmd8Context_OneState(p)PPMD8_MAX_ORDERPPMD8_MIN_ORDER__PPMD8_HPPMD8_FREEZE_SUPPORTPpmd8_MakeEscFreqPpmd8_Update2Ppmd8_Update1_0Ppmd8_Update1Ppmd8_InitPpmd8_FreePpmd8_AllocPpmd8_Constructstruct CPpmd8_Context_/*
You must set (CPpmd8::Stream.In) before Ppmd8_RangeDec_Init()

Ppmd8_DecodeSymbol()
out:
  >= 0 : decoded byte
    -1 : PPMD8_SYM_END   : End of payload marker
    -2 : PPMD8_SYM_ERROR : Data error
*//* /1 *//* 20.01: the original PPMdI encoder and decoder probably could work incorrectly in some rare cases,
   where the original PPMdI code can give "Divide by Zero" operation.
   We use the following fix to allow correct working of encoder and decoder in any cases.
   We correct (Escape_Freq) and (_sum_), if (_sum_) is larger than p->Range) */// #define PPMD8_FREEZE_SUPPORT/* PPMdI code rev.2 contains the fix over PPMdI code rev.1.
   But the code PPMdI.2 is not compatible with PPMdI.1 for some files compressed
   in FREEZE mode. So we disable FREEZE mode support. *//* Ppmd8.h -- Ppmd8 (PPMdI) compression codec
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.I (2002): Dmitry Shkarin : Public domain
  Carryless rangecoder (1999): Dmitry Subbotin : Public domain */restoreMethod/home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd8.c"Ppmd8.h"const CPpmd8_Contextconst CPpmd8_Context *CPpmd_See(*)[32]struct <unnamed>(*)[32]stats->SymbolHiBits_Prepare(stats->Symbol)((unsigned)(stats->Symbol) + 0xC0)ShrinkUnits(p, stats, n0, n1)FLAG_PREV_HIGHFLAG_RESCALEDPpmd8_UpdateModelfFreqflagfSymbolnumMasked1CTX(minSuccessor)HiBits_Prepare(fSymbol)((unsigned)(fSymbol) + 0xC0)(unsigned)4ReduceOrderp->TextCPpmd_State *[17]struct <unnamed> *[17]HiBits_Prepare(p->FoundState->Symbol)((unsigned)(p->FoundState->Symbol) + 0xC0)HiBits_Prepare(newSym)((unsigned)(newSym) + 0xC0)RestoreModelHiBits_Prepare(s->Symbol)((unsigned)(s->Symbol) + 0xC0)skipctxErrorp->MaxContext(p->MaxContext)->Suffixconst CPpmd8const CPpmd8 *GetUsedMemoryCutOffctx(ctx)->Union4.StatsHiBits_Prepare(sym)((unsigned)(sym) + 0xC0)orderSwapStatesRefresh(UInt32)1 << 15((UInt32)1 << 15)sizeof(p->Stamps)256 - 1ExpandTextAreasizeof(count)CPpmd8_Node *CPpmd8_Node_ *CPpmd8_NodecntCPpmd8_Node_Ref *SpecialFreeUnitFreeUnitsShrinkUnitsnewNU(NULL)1 << 13(CPpmd8_Node_Ref)p->FreeList[indx]CPpmd8_Node_CPpmd8_Node_RefPPMD8_kExpEscapeRESTORE_MODEL(c1,fSuccessor)RestoreModel(p, c1)PPMD8_HiBitsFlag_4(sym)HiBits_Convert_4(HiBits_Prepare(sym))PPMD8_HiBitsFlag_3(sym)HiBits_Convert_3(HiBits_Prepare(sym))HiBits_Convert_4(flags)(((flags) >> (8 - 4)) & (1 << 4))HiBits_Convert_3(flags)(((flags) >> (8 - 3)) & (1 << 3))RESET_TEXT(offs){ p->Text = p->Base + p->AlignOffset + (offs); }Ppmd_GetPtr_Type(p, r, CPpmd8_Node)Ppmd8Context_OneState(ctx)Ppmd8_GetStats(p, ctx)((CPpmd8_Context *)Ppmd8_GetContext(p, ref))struct CPpmd8_Node_/* H->I changes:
  NS2Indx
  GlueCount, and Glue method
  BinSum
  See / EscFreq
  CreateSuccessors updates more suffix contexts
  Ppmd8_UpdateModel consts.
  PrevSuccess Update

Flags:
  (1 << 2) - the Context was Rescaled
  (1 << 3) - there is symbol in Stats with (sym >= 0x40) in
  (1 << 4) - main symbol of context is (sym >= 0x40)
*//*
void Ppmd8_UpdateBin(CPpmd8 *p)
{
  unsigned freq = p->FoundState->Freq;
  p->FoundState->Freq = (Byte)(freq + (freq < 196)); // Ppmd8 (196)
  p->PrevSuccess = 1;
  p->RunLength++;
  NextContext(p);
}
*/// Ppmd8 (>=)// (3 <= numStats + 2 <= 256)   (3 <= NS2Indx[3] and NS2Indx[256] === 26)/*
      unsigned flags = HiBits_Prepare((s = STATS(mc))->Symbol);
      i = mc->NumStats;
      do { flags |= HiBits_Prepare((++s)->Symbol); } while (--i);
      mc->Flags = (Byte)((mc->Flags & ~FLAG_SYM_HIGH) + HiBits_Convert_3(flags));
      */// but we still need current (Flags & FLAG_PREV_HIGH), if we will convert context to 1-symbol context later.// here we are for max order only. So Ppmd8_MakeEscFreq() doesn't use mc->Flags/* It can add (1, 2, 3) to Escape_Freq */// Ppmd8 (> 2)/* original PPMdH uses 16-bit variable for (sum) here.
         But (sum < ???). Do we need to truncate (sum) to 16-bit *//* max increase of Escape_Freq is 1 here.
         an average increase is 1/3 per symbol *//* check it *//* The BUG in Shkarin's code was fixed: ps could overflow in CUT_OFF mode. *//*
    

      max(newFreq)= (s->Freq - 1), when (s0 == 1)


    *//* fixed over Shkarin's code. Maybe it could work without + 1 too. */// we change the current mode to (PPMD8_RESTORE_METHOD_FREEZE + 1)// why?// ONE_STATE(c)// increase Escape Freq for context [ctxError ... p->MinContext)/* Refresh() can increase Escape_Freq on value of Freq of last symbol, that was added before error.
         so the largest possible increase for Escape_Freq is (8) from value before ModelUpoadet() */// *ONE_STATE(c) = *s;// So we rollback all created (symbols) before error.// We remove last symbol from each of contexts [p->MaxContext ... ctxError) contexts// Order(MinContext) < Order(ctxError) <= Order(MaxContext)// we go here in cases of error of allocation for context (c1)/* Suffix context can be removed already, since different (high-order)
       Successors may refer to same context. So we check Flags == 0xFF (Stamp == EMPTY_NODE) *//*
RemoveBinContexts()
  It conversts Successors at MaxOrder to another Contexts to NULL-Successors
  It changes RAW-Successors to NULL-Successors
  removes Bin Context without Successor, if suffix of that context is also binary.
*/// *ONE_STATE(ctx) = *stats;// ctx->Union4.Stats = STATS_REF(MoveUnitsUp(p, STATS(ctx), nu));/* O_BOUND *//*
CutOff() reduces contexts:
  It conversts Successors at MaxOrder to another Contexts to NULL-Successors
  It removes RAW-Successors and NULL-Successors that are not Order-0
      and it removes contexts when it has no Successors.
  if the (Union4.Stats) is close to (UnitsStart), it moves it up.
*/// if (p->RestoreMethod >= PPMD8_RESTORE_METHOD_FREEZE)/*
    (ctx->Union2.SummFreq >= ((UInt32)1 << 15)) can be in FREEZE mode for some files.
    It's not good for range coder. So new versions of support fix:
       -   original PPMdI code rev.1
       +   original PPMdI code rev.2
       -   7-Zip default ((PPMD8_FREEZE_SUPPORT is not defined)
       +   7-Zip (p->RestoreMethod >= PPMD8_RESTORE_METHOD_FREEZE)
    if we       use that fixed line, we can lose compatibility with some files created before fix
    if we don't use that fixed line, the program can work incorrectly in FREEZE mode in rare case.
  */// #ifdef PPMD8_FREEZE_SUPPORT/*
Refresh() is called when we remove some symbols (successors) in context.
It increases Escape_Freq for sum of all removed symbols.
*/// #define PPMD8_HiBitsFlag_4(sym) (0x10 * ((sym) >= 0x40))// #define PPMD8_HiBitsFlag_3(sym) (0x08 * ((sym) >= 0x40))// #define FLAG_SYM_HIGH  (1 << 3)/*
static void *MoveUnitsUp(CPpmd8 *p, void *oldPtr, unsigned nu)
{
  unsigned indx = U2I(nu);
  void *ptr;
  if ((Byte *)oldPtr > p->UnitsStart + (1 << 14) || REF(oldPtr) > p->FreeList[indx])
    return oldPtr;
  ptr = RemoveNode(p, indx);
  MyMem12Cpy(ptr, oldPtr, nu);
  if ((Byte *)oldPtr != p->UnitsStart)
    InsertNode(p, oldPtr, indx);
  else
    p->UnitsStart += U2B(I2U(indx));
  return ptr;
}
*//* it's used for (Flags == 0xFF) check in RemoveBinContexts() *//*
  we use first UInt32 field of 12-bytes UNITs as record type stamp
    CPpmd_State    { Byte Symbol; Byte Freq; : Freq != 0xFF
    CPpmd8_Context { Byte NumStats; Byte Flags; UInt16 SummFreq;  : Flags != 0xFF ???
    CPpmd8_Node    { UInt32 Stamp            : Stamp == 0xFFFFFFFF for free record
                                             : Stamp == 0 for guard
    Last 12-bytes UNIT in array is always contains 12-bytes order-0 CPpmd8_Context record
  *//* Ppmd8.c -- PPMdI codec
2021-04-13 : Igor Pavlov : Public domain
This code is based on PPMd var.I (2002): Dmitry Shkarin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd8Dec.c(p)->Stream.InPpmd8Context_OneState(p->MinContext)->SymbolfreqSum2freqSum2 - hiCntIByteIn_Read((p)->Stream.In)// Ppmd_See_Update(see); // new (see->Summ) value can overflow over 16-bits in some rare cases// RangeDec_DecodeBit1(rc2, size0);// Ppmd8_UpdateBin(p);// sym = (p->FoundState = Ppmd8Context_OneState(p->MinContext))->Symbol;/* Ppmd8Dec.c -- Ppmd8 (PPMdI) Decoder
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.I (2002): Dmitry Shkarin : Public domain
  Carryless rangecoder (1999): Dmitry Subbotin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Ppmd8Enc.cp->Stream.Out(Byte)(p->Low >> 24)summFreq - sumtotal - sumRC_EncodeFinal(start,size,total)RC_Encode(start, size, total); RC_NORM_REMOTE(p);RC_Encode(start,size,total)RangeEnc_Encode(p, start, size, total);while ((p->Low ^ (p->Low + p->Range)) < kTop || (p->Range < kBot && ((p->Range = (0 - p->Low) & (kBot - 1)), 1))) { WRITE_BYTE(p); p->Range <<= 8; p->Low <<= 8; }WRITE_BYTE(p)IByteOut_Write(p->Stream.Out, (Byte)(p->Low >> 24))// Ppmd8 (196)// i = p->MinContext->NumStats;// RC_PRE(summFreq);// #define RC_PRE(total)// #define RC_PRE(total) p->Range /= total;/* Ppmd8Enc.c -- Ppmd8 (PPMdI) Encoder
2021-04-13 : Igor Pavlov : Public domain
This code is based on:
  PPMd var.I (2002): Dmitry Shkarin : Public domain
  Carryless rangecoder (1999): Dmitry Subbotin : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Sha1.hCSha1SHA1_FUNC_UPDATE_BLOCKSSHA1_BLOCK_SIZE__pad_3UInt32[5]unsigned int[5]SHA1_NUM_DIGEST_WORDSUInt64[2]unsigned long long[2]__pad_2func_UpdateBlocksSHA1_ALGO_HWSHA1_ALGO_SWSHA1_ALGO_DEFAULTSHA1_DIGEST_SIZE(SHA1_NUM_DIGEST_WORDS * 4)(SHA1_NUM_BLOCK_WORDS * 4)SHA1_NUM_BLOCK_WORDS__7Z_SHA1_HSha1PrepareSha1_GetBlockDigestconst CSha1const CSha1 *Sha1_PrepareBlockSha1_FinalCSha1 *Sha1_UpdateSha1_InitSha1_InitStateSha1_SetFunction/*
call Sha1Prepare() once at program start.
It prepares all supported implementations, and detects the fastest implementation.
*/// void MY_FAST_CALL Sha1_UpdateBlocks(UInt32 state[5], const Byte *data, size_t numBlocks);/*
Sha1_SetFunction()
return:
  0 - (algo) value is not supported, and func_UpdateBlocks was not changed
  1 - func_UpdateBlocks was set according (algo) value.
*//*
  if (the system supports different SHA1 code implementations)
  {
    (CSha1::func_UpdateBlocks) will be used
    (CSha1::func_UpdateBlocks) can be set by
       Sha1_Init()        - to default (fastest)
       Sha1_SetFunction() - to any algo
  }
  else
  {
    (CSha1::func_UpdateBlocks) is ignored.
  }
*//* Sha1.h -- SHA-1 Hash
2021-02-08 : Igor Pavlov : Public domain */destDigest/home/atharvakale/390r-debugging-setup/p7zip/C/Sha1.c"Sha1.h"f_hwstdestDigest + 0st[0]destDigest + 1 * 4st[1]destDigest + 2 * 4st[2]destDigest + 3 * 4st[3]destDigest + 4 * 4st[4]&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 2]&((UInt32 *)(void *)block)[16 - 2](UInt32)(numBits >> 32)&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 1]&((UInt32 *)(void *)block)[16 - 1](UInt32)(numBits)(UInt32 *)(void *)(block + size)(SHA1_NUM_BLOCK_WORDS - 2)(SHA1_NUM_BLOCK_WORDS - 2) * 464 - 8(64 - 8)p->buffer + 64 - 8p->buffer + 64 - 4p->state[0]digest + 4p->state[1]digest + 8p->state[2]digest + 12p->state[3]digest + 16p->state[4]Sha1_UpdateBlocksUInt32[80]unsigned int[80]kNumWWf0w0w0((i) )(W[(i)] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((i)) * 4)))(i)data + (size_t)((i)) * 4w0((i)+1)(W[(i)+1] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((i)+1) * 4)))(i)+1data + (size_t)((i)+1) * 4w0((i)+2)(W[(i)+2] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((i)+2) * 4)))(i)+2data + (size_t)((i)+2) * 4w0((i)+3)(W[(i)+3] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((i)+3) * 4)))(i)+3data + (size_t)((i)+3) * 4w0((i)+4)(W[(i)+4] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((i)+4) * 4)))(i)+4data + (size_t)((i)+4) * 4w1w0((15) )(W[(15)] = __builtin_bswap32(*(const UInt32 *)(const void *)(data + (size_t)((15)) * 4)))(15)data + (size_t)((15)) * 4w1((15)+1)(W[(15)+1] = (((W[(size_t)((15)+1)-3] ^ W[(size_t)((15)+1)-8] ^ W[(size_t)((15)+1)-14] ^ W[(size_t)((15)+1)-16]) << (1)) | ((W[(size_t)((15)+1)-3] ^ W[(size_t)((15)+1)-8] ^ W[(size_t)((15)+1)-14] ^ W[(size_t)((15)+1)-16]) >> (32 - (1)))))(15)+1w((size_t)((15)+1)-3) ^ w((size_t)((15)+1)-8) ^ w((size_t)((15)+1)-14) ^ w((size_t)((15)+1)-16)W[(size_t)((15)+1)-3] ^ W[(size_t)((15)+1)-8] ^ W[(size_t)((15)+1)-14] ^ W[(size_t)((15)+1)-16](size_t)((15)+1)-3(size_t)((15)+1)-8(size_t)((15)+1)-14(size_t)((15)+1)-16w1((15)+2)(W[(15)+2] = (((W[(size_t)((15)+2)-3] ^ W[(size_t)((15)+2)-8] ^ W[(size_t)((15)+2)-14] ^ W[(size_t)((15)+2)-16]) << (1)) | ((W[(size_t)((15)+2)-3] ^ W[(size_t)((15)+2)-8] ^ W[(size_t)((15)+2)-14] ^ W[(size_t)((15)+2)-16]) >> (32 - (1)))))(15)+2w((size_t)((15)+2)-3) ^ w((size_t)((15)+2)-8) ^ w((size_t)((15)+2)-14) ^ w((size_t)((15)+2)-16)W[(size_t)((15)+2)-3] ^ W[(size_t)((15)+2)-8] ^ W[(size_t)((15)+2)-14] ^ W[(size_t)((15)+2)-16](size_t)((15)+2)-3(size_t)((15)+2)-8(size_t)((15)+2)-14(size_t)((15)+2)-16w1((15)+3)(W[(15)+3] = (((W[(size_t)((15)+3)-3] ^ W[(size_t)((15)+3)-8] ^ W[(size_t)((15)+3)-14] ^ W[(size_t)((15)+3)-16]) << (1)) | ((W[(size_t)((15)+3)-3] ^ W[(size_t)((15)+3)-8] ^ W[(size_t)((15)+3)-14] ^ W[(size_t)((15)+3)-16]) >> (32 - (1)))))(15)+3w((size_t)((15)+3)-3) ^ w((size_t)((15)+3)-8) ^ w((size_t)((15)+3)-14) ^ w((size_t)((15)+3)-16)W[(size_t)((15)+3)-3] ^ W[(size_t)((15)+3)-8] ^ W[(size_t)((15)+3)-14] ^ W[(size_t)((15)+3)-16](size_t)((15)+3)-3(size_t)((15)+3)-8(size_t)((15)+3)-14(size_t)((15)+3)-16w1((15)+4)(W[(15)+4] = (((W[(size_t)((15)+4)-3] ^ W[(size_t)((15)+4)-8] ^ W[(size_t)((15)+4)-14] ^ W[(size_t)((15)+4)-16]) << (1)) | ((W[(size_t)((15)+4)-3] ^ W[(size_t)((15)+4)-8] ^ W[(size_t)((15)+4)-14] ^ W[(size_t)((15)+4)-16]) >> (32 - (1)))))(15)+4w((size_t)((15)+4)-3) ^ w((size_t)((15)+4)-8) ^ w((size_t)((15)+4)-14) ^ w((size_t)((15)+4)-16)W[(size_t)((15)+4)-3] ^ W[(size_t)((15)+4)-8] ^ W[(size_t)((15)+4)-14] ^ W[(size_t)((15)+4)-16](size_t)((15)+4)-3(size_t)((15)+4)-8(size_t)((15)+4)-14(size_t)((15)+4)-16f1w1((i) )(W[(i)] = (((W[(size_t)((i))-3] ^ W[(size_t)((i))-8] ^ W[(size_t)((i))-14] ^ W[(size_t)((i))-16]) << (1)) | ((W[(size_t)((i))-3] ^ W[(size_t)((i))-8] ^ W[(size_t)((i))-14] ^ W[(size_t)((i))-16]) >> (32 - (1)))))w((size_t)((i))-3) ^ w((size_t)((i))-8) ^ w((size_t)((i))-14) ^ w((size_t)((i))-16)W[(size_t)((i))-3] ^ W[(size_t)((i))-8] ^ W[(size_t)((i))-14] ^ W[(size_t)((i))-16](size_t)((i))-3(size_t)((i))-8(size_t)((i))-14(size_t)((i))-16w1((i)+1)(W[(i)+1] = (((W[(size_t)((i)+1)-3] ^ W[(size_t)((i)+1)-8] ^ W[(size_t)((i)+1)-14] ^ W[(size_t)((i)+1)-16]) << (1)) | ((W[(size_t)((i)+1)-3] ^ W[(size_t)((i)+1)-8] ^ W[(size_t)((i)+1)-14] ^ W[(size_t)((i)+1)-16]) >> (32 - (1)))))w((size_t)((i)+1)-3) ^ w((size_t)((i)+1)-8) ^ w((size_t)((i)+1)-14) ^ w((size_t)((i)+1)-16)W[(size_t)((i)+1)-3] ^ W[(size_t)((i)+1)-8] ^ W[(size_t)((i)+1)-14] ^ W[(size_t)((i)+1)-16](size_t)((i)+1)-3(size_t)((i)+1)-8(size_t)((i)+1)-14(size_t)((i)+1)-16w1((i)+2)(W[(i)+2] = (((W[(size_t)((i)+2)-3] ^ W[(size_t)((i)+2)-8] ^ W[(size_t)((i)+2)-14] ^ W[(size_t)((i)+2)-16]) << (1)) | ((W[(size_t)((i)+2)-3] ^ W[(size_t)((i)+2)-8] ^ W[(size_t)((i)+2)-14] ^ W[(size_t)((i)+2)-16]) >> (32 - (1)))))w((size_t)((i)+2)-3) ^ w((size_t)((i)+2)-8) ^ w((size_t)((i)+2)-14) ^ w((size_t)((i)+2)-16)W[(size_t)((i)+2)-3] ^ W[(size_t)((i)+2)-8] ^ W[(size_t)((i)+2)-14] ^ W[(size_t)((i)+2)-16](size_t)((i)+2)-3(size_t)((i)+2)-8(size_t)((i)+2)-14(size_t)((i)+2)-16w1((i)+3)(W[(i)+3] = (((W[(size_t)((i)+3)-3] ^ W[(size_t)((i)+3)-8] ^ W[(size_t)((i)+3)-14] ^ W[(size_t)((i)+3)-16]) << (1)) | ((W[(size_t)((i)+3)-3] ^ W[(size_t)((i)+3)-8] ^ W[(size_t)((i)+3)-14] ^ W[(size_t)((i)+3)-16]) >> (32 - (1)))))w((size_t)((i)+3)-3) ^ w((size_t)((i)+3)-8) ^ w((size_t)((i)+3)-14) ^ w((size_t)((i)+3)-16)W[(size_t)((i)+3)-3] ^ W[(size_t)((i)+3)-8] ^ W[(size_t)((i)+3)-14] ^ W[(size_t)((i)+3)-16](size_t)((i)+3)-3(size_t)((i)+3)-8(size_t)((i)+3)-14(size_t)((i)+3)-16w1((i)+4)(W[(i)+4] = (((W[(size_t)((i)+4)-3] ^ W[(size_t)((i)+4)-8] ^ W[(size_t)((i)+4)-14] ^ W[(size_t)((i)+4)-16]) << (1)) | ((W[(size_t)((i)+4)-3] ^ W[(size_t)((i)+4)-8] ^ W[(size_t)((i)+4)-14] ^ W[(size_t)((i)+4)-16]) >> (32 - (1)))))w((size_t)((i)+4)-3) ^ w((size_t)((i)+4)-8) ^ w((size_t)((i)+4)-14) ^ w((size_t)((i)+4)-16)W[(size_t)((i)+4)-3] ^ W[(size_t)((i)+4)-8] ^ W[(size_t)((i)+4)-14] ^ W[(size_t)((i)+4)-16](size_t)((i)+4)-3(size_t)((i)+4)-8(size_t)((i)+4)-14(size_t)((i)+4)-16f2f3151850024918597753932400959708339546978217325841930x6745230140232334170xEFCDAB8925623831020x98BADCFE2717338780x1032547632853775200xC3D2E1F0Sha1_UpdateBlocks_HWg_FUNC_UPDATE_BLOCKS_HWg_FUNC_UPDATE_BLOCKSSha1_UpdateBlock(p)UPDATE_BLOCKS(p)(p->state, p->buffer, 1)R20(ii,fx){ size_t i; for (i = (ii); i < (ii) + 20; i += STEP_MAIN) { R_MAIN(i, fx, w1); } }R_MAINR5R20_START{ size_t i; for (i = 0; i < 15; i += STEP_PRE) { R5(i, f0, w0); } } M5 ( 15, f0, w0, w1);R5(i,fx,wx)M5 ( i, fx, wx, wx)M5(i,fx,wx0,wx1)T5 ( a,b,c,d,e, fx, wx0((i) ) ); T5 ( e,a,b,c,d, fx, wx1((i)+1) ); T5 ( d,e,a,b,c, fx, wx1((i)+2) ); T5 ( c,d,e,a,b, fx, wx1((i)+3) ); T5 ( b,c,d,e,a, fx, wx1((i)+4) );T5(a,b,c,d,e,fx,ww)e += fx(b,c,d) + ww + rotlFixed(a, 5); b = rotlFixed(b, 30);f3(x,y,z)( 0xca62c1d6 + (x^y^z) )f2(x,y,z)( 0x8f1bbcdc + ((x&y)|(z&(x|y))) )f1(x,y,z)( 0x6ed9eba1 + (x^y^z) )f0(x,y,z)( 0x5a827999 + (z^(x&(y^z))) )w1(i)(w(i) = rotlFixed(w((size_t)(i)-3) ^ w((size_t)(i)-8) ^ w((size_t)(i)-14) ^ w((size_t)(i)-16), 1))w0(i)(W[i] = GetBe32(data + (size_t)(i) * 4))w(i)W[i]STEP_MAINSTEP_PRE_SHA1_BIG_WUPDATE_BLOCKS(p)p->func_UpdateBlocks_SHA_SUPPORTEDdefined(_MSC_VER) && (_MSC_VER < 1900)_MSC_VER >= 1200(__INTEL_COMPILER >= 1800)_MSC_VER >= 1910 && _MSC_VER >= 1929 && _MSC_FULL_VER >= 192930037_SHA1_UNROLLSTEP_PRE > 5STEP_PRE == 5STEP_PRE == 1STEP_PRE == 2STEP_PRE == 4STEP_MAIN > 5STEP_MAIN == 1STEP_MAIN == 2STEP_MAIN == 4STEP_MAIN == 5STEP_PRE < 5 || STEP_MAIN < 5USE_MY_MMdefined(MY_CPU_ARM_OR_ARM64) && defined(_MSC_VER)// printf("\n========== SHA-1 hardware version failure ======== \n");/* there was bug in MSVC compiler for ARM64 -O2 before version VS2019 16.10 (19.29.30037).
       It generated incorrect SHA-1 code.
       21.03 : we test sha1-hardware code at runtime initialization */// printf("\n========== HW SHA1 ======== \n");// && CPU_IsSupported_SSE41()// SetBe32((UInt32 *)(block + size), 0x80000000);/*
  if (pos & 3)
  {
    p->buffer[pos] = 0;
    p->buffer[pos + 1] = 0;
    p->buffer[pos + 2] = 0;
    pos += 3;
    pos &= ~3;
  }
  {
    for (; pos < 64 - 8; pos += 4)
      *(UInt32 *)(&p->buffer[pos]) = 0;
  }
  */// memset(&p->buf.buffer[pos], 0, 64 - pos);// if (numBlocks != 0x1264378347) return;/*
#define R1(i, fx, wx) \
    T1 ( fx, wx(i)); 
#define R2(i, fx, wx) \
    R1 ( (i)    , fx, wx); \
    R1 ( (i) + 1, fx, wx); 
#define R4(i, fx, wx) \
    R2 ( (i)    , fx, wx); \
    R2 ( (i) + 2, fx, wx); \
*//*
#define T1(fx, ww) \
    tmp = e + fx(b,c,d) + ww + rotlFixed(a, 5); \
    e = d; \
    d = c; \
    c = rotlFixed(b, 30); \
    b = a; \
    a = tmp; \
*/// allowed unroll steps: (1, 2, 4, 5, 20)// #define _SHA1_UNROLL/* define it for speed optimization */// #define USE_MY_MM/* Sha1.c -- SHA-1 Hash
2021-07-13 : Igor Pavlov : Public domain
This code is based on public domain code of Steve Reid from Wei Dai's Crypto++ library. *//home/atharvakale/390r-debugging-setup/p7zip/C/Sha1Opt.c"sha,ssse3"660510x00010203674380870x040506071348101230x08090a0b2021821590x0c0d0e0fabcde0SM1SM3(0)*4+0e1((0)*4+0) / 5(0)*4+1((0)*4+1) / 5(0)*4+2((0)*4+2) / 5(0)*4+3((0)*4+3) / 5(1)*4+0((1)*4+0) / 5(1)*4+1((1)*4+1) / 5(1)*4+2((1)*4+2) / 5(1)*4+3((1)*4+3) / 5(2)*4+0((2)*4+0) / 5(2)*4+1((2)*4+1) / 5(2)*4+2((2)*4+2) / 5(2)*4+3((2)*4+3) / 5(3)*4+0((3)*4+0) / 5(3)*4+1((3)*4+1) / 5(3)*4+2((3)*4+2) / 5(3)*4+3((3)*4+3) / 5e2SM2NNN(4)*4+0((4)*4+0) / 5(4)*4+1((4)*4+1) / 5(4)*4+2((4)*4+2) / 5(4)*4+3((4)*4+3) / 5abcd_savePREPARE_STATESHUFFLE_EPI32 (abcd, 0x1B); SHUFFLE_EPI32 (e0, 0x1B);R16(k,mx,OP0,OP1,OP2,OP3)R4 ( (k)*4+0, e0,e1, m0,m1,m2,m3, OP0 ) R4 ( (k)*4+1, e1,e0, m1,m2,m3,m0, OP1 ) R4 ( (k)*4+2, e0,e1, m2,m3,m0,m1, OP2 ) R4 ( (k)*4+3, e1,e0, m3,mx,m1,m2, OP3 )R4(k,e0,e1,m0,m1,m2,m3,OP)e1 = abcd; SHA1_RND4(abcd, e0, (k) / 5); SHA1_NEXTE(e1, m1); OP(m0, m1, m2, m3);NNN(m0,m1,m2,m3)SM3(m0,m1,m2,m3)XOR_SI128(m3, m1); SM1(m0, m1, m2, m3) SHA1_MSG2(m3, m2);SM2(m0,m1,m2,m3)XOR_SI128(m3, m1); SHA1_MSG2(m3, m2);SM1(m0,m1,m2,m3)SHA1_MSG1(m0, m1);LOAD_SHUFFLE(m,k)m = _mm_loadu_si128((const __m128i *)(const void *)(data + (k) * 16)); SHUFFLE_EPI8(m, mask);SHA1_MSG2(dest,src)dest = _mm_sha1msg2_epu32(dest, src);SHA1_MSG1(dest,src)dest = _mm_sha1msg1_epu32(dest, src);SHA1_NEXTE(e,m)e = _mm_sha1nexte_epu32(e, m);SHA1_RND4(abcd,e0,f)abcd = _mm_sha1rnds4_epu32(abcd, e0, f);SHUFFLE_EPI32(dest,mask)dest = _mm_shuffle_epi32(dest, mask);SHUFFLE_EPI8(dest,mask)dest = _mm_shuffle_epi8(dest, mask);XOR_SI128(dest,src)dest = _mm_xor_si128(dest, src);ADD_EPI32(dest,src)dest = _mm_add_epi32(dest, src);ATTRIB_SHA__attribute__((__target__("sha,ssse3")))USE_HW_SHA(_MSC_VER < 1900) && (_MSC_VER >= 1200)_MSC_VER >= USE_VER_MIN!defined(_MSC_VER) || (_MSC_VER >= 1900)defined(_MSC_VER) && (_MSC_VER >= 1600)/*
  UNUSED_VAR(state);
  UNUSED_VAR(data);
  UNUSED_VAR(numBlocks);
  exit(1);
  return;
  */// #include "Sha1.h"// #include <stdlib.h>// #error Stop_Compiling_UNSUPPORTED_SHA// USE_HW_SHA// typedef __n128 v128; // MSVC// #pragma message("=== Sha1 HW === ")// 000e// dbca/*
SHA1 uses:
SSE2:
  _mm_loadu_si128
  _mm_storeu_si128
  _mm_set_epi32
  _mm_add_epi32
  _mm_shuffle_epi32 / pshufd
  _mm_xor_si128
  _mm_cvtsi128_si32
  _mm_cvtsi32_si128
SSSE3:
  _mm_shuffle_epi8 / pshufb

SHA:
  _mm_sha1*
*/// #include <wmmintrin.h>// #pragma message("Sha1 HW")// #endif // MY_CPU_X86_OR_AMD64// #pragma GCC target("sha,ssse3")// SSSE3: for clang-cl:/* Sha1Opt.c -- SHA-1 optimized code for SHA-1 hardware instructions
2021-04-01 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Sha256.h/home/atharvakale/390r-debugging-setup/p7zip/C/Sha256.c"Sha256.h"Sha256PrepareSha256_FinalCSha256 *Sha256_UpdateSha256_UpdateBlocksW_PREdata + ((size_t)(j) + 0) * 4data + ((size_t)(j) + 1) * 4W_MAIN(0)-16w(j, (0)-2)W[(size_t)(j) + (0)-2](0)-2(0)-7w(j, (0)-15)W[(size_t)(j) + (0)-15](0)-15(1)-16w(j, (1)-2)W[(size_t)(j) + (1)-2](1)-2(1)-7w(j, (1)-15)W[(size_t)(j) + (1)-15](1)-15(2)-16w(j, (2)-2)W[(size_t)(j) + (2)-2](2)-2(2)-7w(j, (2)-15)W[(size_t)(j) + (2)-15](2)-152 + 1(2 + 1)-16w(j, (2 + 1)-2)W[(size_t)(j) + (2 + 1)-2](2 + 1)-2(2 + 1)-7w(j, (2 + 1)-15)W[(size_t)(j) + (2 + 1)-15](2 + 1)-15const UInt32[64]Sha256_InitSha256_InitState0x6a09e6670xbb67ae850x3c6ef3720xa54ff53a0x510e527f0x9b05688c0x1f83d9ab0x5be0cd19Sha256_SetFunctionSHA256_ALGO_SWSHA256_ALGO_DEFAULTSHA256_ALGO_HWSha256_UpdateBlocks_HWSHA256_K_ARRAY11163524080x428a2f9818994474410x7137449130493234710xb5c0fbcf39210095730xe9b5dba59619871630x3956c25b15089709930x59f111f124536357480x923f82a428707632210xab1c5ed536243810800xd807aa983105984010x12835b016072252780x243185be14268819870x550c7dc319250783880x72be5d7421620782060x80deb1fe26148881030x9bdc06a732482225800xc19bf17438353904010xe49b69c140222247740xefbe47862643470780x0fc19dc66048076280x240ca1cc7702559830x2de92c6f12491501220x4a7484aa15550816920x5cb0a9dc19960649860x76f988da25542208820x983e515228218343490xa831c66d29529968080xb00327c832103136710xbf597fc733365718910xc6e00bf335845287110xd5a791471139269930x06ca63513382418950x142929676663072050x27b70a857735299120x2e1b213812947573720x4d2c6dfc13961822910x53380d1316951837000x650a735419866610510x766a0abb21770263500x81c2c92e24569560370x92722c8527304859210xa2bfe8a128203024110xa81a664b32597308000xc24b8b7033457647710xc76c51a335160658170xd192e81936003528040xd699062440945719090xf40e35852754233440x106aa0704302277340x19a4c1165069486160x1e376c086590605560x2748774c8839978770x34b0bcb59581395710x391c0cb313228222180x4ed8aa4a15370020630x5b9cca4f17478737790x682e6ff319555622220x748f82ee20241048150x78a5636f22277304520x84c8781423618524240x8cc7020824284364740x90befffa27567341870xa4506ceb32040314790xbef9a3f733293252980xc67178f2Sha256_UpdateBlock(p)KS1S0R2_MAIN(i)R1_MAIN(i) R1_MAIN(i + 1)R1_MAIN(i)T1( W_MAIN, i)R1_PRE(i)T1( W_PRE, i)T1(wx,i)tmp = h + S1(e) + Ch(e,f,g) + K[(i)+(size_t)(j)] + wx(i); h = g; g = f; f = e; e = d + tmp; tmp += S0(a) + Maj(a, b, c); d = c; c = b; b = a; a = tmp;W_MAIN(i)blk2(j, i)blk2(j,i)(w(j, i) = w(j, (i)-16) + blk2_main(j, i))w(j,i)W[(size_t)(j) + i]blk2_main(j,i)s1(w(j, (i)-2)) + w(j, (i)-7) + s0(w(j, (i)-15))W_PRE(i)(W[(i) + (size_t)(j)] = GetBe32(data + ((size_t)(j) + i) * 4))Maj(x,y,z)((x&y)|(z&(x|y)))Ch(x,y,z)(z^(x&(y^z)))s1(x)(rotrFixed(x,17) ^ rotrFixed(x,19) ^ (x >> 10))s0(x)(rotrFixed(x, 7) ^ rotrFixed(x,18) ^ (x >> 3))S1(x)(rotrFixed(x, 6) ^ rotrFixed(x,11) ^ rotrFixed(x, 25))S0(x)(rotrFixed(x, 2) ^ rotrFixed(x,13) ^ rotrFixed(x, 22))_SHA256_BIG_WSTEP_MAIN != 16STEP_MAIN == 16(!defined(_SHA256_UNROLL) || STEP_MAIN < 8) && (STEP_MAIN >= 4)defined(_SHA256_UNROLL) && STEP_MAIN >= 8!defined(_SHA256_UNROLL) || (STEP_MAIN <= 4) || (STEP_PRE <= 4)STEP_PRE > 4STEP_PRE < 8STEP_PRE == 16STEP_PRE >= 2STEP_PRE >= 4STEP_MAIN < 8STEP_MAIN >= 2STEP_MAIN >= 4STEP_MAIN >= 8STEP_MAIN >= 16// printf("\n========== HW SHA256 ======== \n");/* memset(W, 0, sizeof(W)); *//* Wipe variables */// we use +i instead of +(i) to change the order to solve CLANG compiler warning for signed/unsigned.// #define _SHA256_UNROLL/* Sha256.c -- SHA-256 Hash
2021-04-01 : Igor Pavlov : Public domain
This code is based on public domain code from Wei Dai's Crypto++ library. *//home/atharvakale/390r-debugging-setup/p7zip/C/Sha256Opt.cstate0state1state0_savestate1_savemsgtmp = _mm_shuffle_epi32(state0, 0x1B); state0 = _mm_shuffle_epi32(state1, 0x1B); state1 = state0; state0 = _mm_unpacklo_epi64(state0, tmp); state1 = _mm_unpackhi_epi64(state1, tmp);R16(k,OP0,OP1,OP2,OP3,OP4,OP5,OP6,OP7)R4 ( (k)*4+0, m0, m1, m2, m3, OP0, OP1 ) R4 ( (k)*4+1, m1, m2, m3, m0, OP2, OP3 ) R4 ( (k)*4+2, m2, m3, m0, m1, OP4, OP5 ) R4 ( (k)*4+3, m3, m0, m1, m2, OP6, OP7 )R4(k,g0,g1,g2,g3,OP0,OP1)RND2_0(g0, k); OP0(g0, g1, g2, g3); RND2_1; OP1(g0, g1, g2, g3);RND2_1RND2(state1, state0);RND2_0(m,k)msg = _mm_add_epi32(m, *(const __m128i *) (const void *) &K[(k) * 4]); RND2(state0, state1); msg = _mm_shuffle_epi32(msg, 0x0E);RND2(t0,t1)t0 = _mm_sha256rnds2_epu32(t0, t1, msg);NNN(g0,g1,g2,g3)SM2(g0,g1,g2,g3)tmp = _mm_alignr_epi8(g1, g0, 4); ADD_EPI32(g2, tmp); SHA25G_MSG2(g2, g1);SM1(g0,g1,g2,g3)SHA256_MSG1(g3, g0);m = _mm_loadu_si128((const __m128i *)(const void *)(data + (k) * 16)); m = _mm_shuffle_epi8(m, mask);SHA25G_MSG2(dest,src)dest = _mm_sha256msg2_epu32(dest, src);SHA256_MSG1(dest,src)dest = _mm_sha256msg1_epu32(dest, src);// #include "Sha256.h"// K array must be aligned for 16-bytes at least.// #pragma message("=== Sha256 HW === ")// #define msg tmp/* abef *//* cdgh *//* efgh *//* abcd */// We use scheme with 3 rounds ahead for SHA256_MSG1 / 2 rounds ahead for SHA256_MSG2// #define LS1(k, g0, g1, g2, g3) LOAD_SHUFFLE(g1, k+1)// #define LS0(k, g0, g1, g2, g3) LOAD_SHUFFLE(g0, k)//   movdqa - for code with    align attribute//   movdqu - for code without align attribute// The compiler can look align attribute and selects/*
SHA256 uses:
SSE2:
  _mm_loadu_si128
  _mm_storeu_si128
  _mm_set_epi32
  _mm_add_epi32
  _mm_shuffle_epi32 / pshufd


  
SSSE3:
  _mm_shuffle_epi8 / pshufb
  _mm_alignr_epi8
SHA:
  _mm_sha256*
*/// #pragma message("Sha256 HW")/* Sha256Opt.c -- SHA-256 optimized code for SHA-256 hardware instructions
2021-04-01 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Sort.cHeapSortDown(p,k,size,temp){ for (;;) { size_t s = (k << 1); if (s > size) break; if (s < size && p[s + 1] > p[s]) s++; if (temp >= p[s]) break; p[k] = p[s]; k = s; } p[k] = temp; }/*
#define HeapSortRefDown(p, vals, n, size, temp) \
  { size_t k = n; UInt32 val = vals[temp]; for (;;) { \
    size_t s = (k << 1); \
    if (s > size) break; \
    if (s < size && vals[p[s + 1]] > vals[p[s]]) s++; \
    if (val >= vals[p[s]]) break; \
    p[k] = p[s]; k = s; \
  } p[k] = temp; }

void HeapSortRef(UInt32 *p, UInt32 *vals, size_t size)
{
  if (size <= 1)
    return;
  p--;
  {
    size_t i = size / 2;
    do
    {
      UInt32 temp = p[i];
      HeapSortRefDown(p, vals, i, size, temp);
    }
    while (--i != 0);
  }
  do
  {
    UInt32 temp = p[size];
    p[size--] = p[1];
    HeapSortRefDown(p, vals, 1, size, temp);
  }
  while (size > 1);
}
*//*
  do
  {
    size_t k = 1;
    UInt64 temp = p[size];
    p[size--] = p[1];
    HeapSortDown(p, k, size, temp)
  }
  while (size > 1);
  *//*
  do
  {
    size_t k = 1;
    UInt32 temp = p[size];
    p[size--] = p[1];
    HeapSortDown(p, k, size, temp)
  }
  while (size > 1);
  *//* Sort.c -- Sort functions
2014-04-05 : Igor Pavlov : Public domain */700_ISOC2X_SOURCE_ISOC11_SOURCE_ISOC99_SOURCE_ISOC95_SOURCEsize_t((void *)0)__size_t_SIZET__GCC_SIZE_T___int_size_t_h__DEFINED_size_t_SIZE_T_DECLARED_BSD_SIZE_T_DEFINED__SIZE_T_DEFINED_SIZE_T_DEFINED__BSD_SIZE_T__SIZE_T___SIZE_T_T_SIZE_T_SIZE__SYS_SIZE_T_H_SIZE_T__SIZE_T____size_t__(!defined(_STDDEF_H) && !defined(_STDDEF_H_) && !defined(_ANSI_STDDEF_H) \(!defined(__need_wchar_t) && !defined(__need_size_t)	\__sys_stdtypes_hdefined(__NetBSD__)defined (__FreeBSD__)!defined(_SIZE_T_) && !defined(_BSD_SIZE_T_)!defined(_PTRDIFF_T_) && !defined(_BSD_PTRDIFF_T_)!defined(_WCHAR_T_) && !defined(_BSD_WCHAR_T_)_BSD_WCHAR_T_defined (__need_ptrdiff_t) || defined (_STDDEF_H_)defined (__need_size_t) || defined (_STDDEF_H_)defined (__need_wchar_t) || defined (_STDDEF_H_)defined (__sequent__) && defined (_PTRDIFF_T_)defined (_TYPE_ptrdiff_t) && (defined (__need_ptrdiff_t) || defined (_STDDEF_H_))defined (_TYPE_size_t) && (defined (__need_size_t) || defined (_STDDEF_H_))defined (_TYPE_wchar_t) && (defined (__need_wchar_t) || defined (_STDDEF_H_))defined (_STDDEF_H) || defined (__need_ptrdiff_t)_PTRDIFF_T_T_PTRDIFF__T_PTRDIFF__PTRDIFF_T_PTRDIFF_T__BSD_PTRDIFF_T____int_ptrdiff_t_h_GCC_PTRDIFF_T_PTRDIFF_T_DECLARED__DEFINED_ptrdiff_t__PTRDIFF_TYPE__defined (_STDDEF_H) || defined (__need_size_t)defined (__FreeBSD__) \!(defined (__GNUG__) && defined (size_t))__BEOS__defined (_STDDEF_H) || defined (__need_wchar_t)__wchar_t____WCHAR_T___WCHAR_T_T_WCHAR__T_WCHAR__WCHAR_T_WCHAR_T__BSD_WCHAR_T_DEFINED__BSD_RUNE_T_DEFINED__WCHAR_T_DECLARED__DEFINED_wchar_t_WCHAR_T_DEFINED__WCHAR_T_DEFINED_WCHAR_T_H___int_wchar_t_h__INT_WCHAR_T_H_GCC_WCHAR_T_BSD_RUNE_T_!defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)defined (__FreeBSD__) && (__FreeBSD__ < 5)defined (__FreeBSD__) && (__FreeBSD__ >= 5)__BSD_VISIBLE_RUNE_T_DECLARED__WCHAR_TYPE__defined (__need_wint_t)_WINT_T__WINT_TYPE___GCC_PTRDIFF_T__GCC_SIZE_T__GCC_WCHAR_T_defined (_STDDEF_H) || defined (__need_NULL)__GNUG___STDDEF_H(defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) \_GCC_MAX_ALIGN_T__i386__defined(__cplusplus) && __cplusplus >= 201103L_GXX_NULLPTR_T/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before *//* _STDDEF_H was defined this time *//* C++11.  *//* C11 or C++11.  *//* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  *//* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  *//* Offset of member MEMBER in a struct of type TYPE. *//* NULL not defined and <stddef.h> or need NULL.  *//* G++ *//* C++ *//* in case <stdio.h> has defined it. *//* A null pointer constant.  *//* __sys_stdtypes_h *//* __NetBSD__ *//*  The following ones are the real ones.  *//*  The references to _GCC_PTRDIFF_T_, _GCC_SIZE_T_, and _GCC_WCHAR_T_
    are probably typos and should be removed before 2.8 is released.  *//* _STDDEF_H or __need_wchar_t.  *//* __wchar_t__ *//* __WCHAR_T__ *//* _BSD_RUNE_T_DEFINED_ *//* _WCHAR_T_DECLARED *//* __DEFINED_wchar_t *//* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... *//* Why is this file so hard to maintain properly?  In contrast to
   the comment above regarding BSD/386 1.1, on FreeBSD for as long
   as the symbol has existed, _BSD_RUNE_T_ must not stay defined or
   redundant typedefs will occur when stdlib.h is included after this file. *//* Darwin *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." *//* Cray Unicos/Mk *//* BeOS *//* musl libc *//* FreeBSD 5 *//* Define this type if we are doing the whole job,
   or if we want this type in particular.  *//* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  *//* _STDDEF_H or __need_size_t.  *//* __size_t__ *//* __SIZE_T__ *//* _SIZE_T *//* _SYS_SIZE_T_H *//* _T_SIZE_ *//* _T_SIZE *//* __SIZE_T *//* _SIZE_T_ *//* _BSD_SIZE_T_ *//* _SIZE_T_DEFINED_ *//* _SIZE_T_DEFINED *//* _BSD_SIZE_T_DEFINED_ *//* _SIZE_T_DECLARED *//* __DEFINED_size_t *//* ___int_size_t_h *//* _GCC_SIZE_T *//* _SIZET_ *//* __size_t *//* !(defined (__GNUG__) && defined (size_t)) *//* __BEOS__ *//* __size_t is a typedef, must not trash it.  *//* in case <sys/types.h> has defined it. *//* Unsigned type of `sizeof' something.  *//* _STDDEF_H or __need_ptrdiff_t.  *//* If this symbol has done its job, get rid of it.  *//* _PTRDIFF_T *//* _T_PTRDIFF_ *//* _T_PTRDIFF *//* __PTRDIFF_T *//* _PTRDIFF_T_ *//* _BSD_PTRDIFF_T_ *//* ___int_ptrdiff_t_h *//* _GCC_PTRDIFF_T *//* _PTRDIFF_T_DECLARED *//* __DEFINED_ptrdiff_t *//* DragonFly *//* Signed type of difference of two pointers.  *//* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  *//* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  *//* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  *//* defined(__NetBSD__) *//* Undef _FOO_T_ if we are supposed to define foo_t.  *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_. *//* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  *//* snaroff@next.com says the NeXT needs this.  *//* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  *//*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 *//* Copyright (C) 1989-2022 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */<bits/types/struct_sched_param.h>setnsgetcpusched_getcpuunsharecloneCLONE_NEWTIME0x00000080CLONE_IOCLONE_NEWNETCLONE_NEWPID0x20000000CLONE_NEWUSER0x10000000CLONE_NEWIPC0x08000000CLONE_NEWUTS0x04000000CLONE_NEWCGROUP0x02000000CLONE_CHILD_SETTID0x01000000CLONE_UNTRACED0x00800000CLONE_DETACHED0x00400000CLONE_CHILD_CLEARTID0x00200000CLONE_PARENT_SETTID0x00100000CLONE_SETTLS0x00080000CLONE_SYSVSEM0x00040000CLONE_NEWNS0x00020000CLONE_THREAD0x00010000CLONE_PARENT0x00008000CLONE_VFORK0x00004000CLONE_PTRACE0x00002000CLONE_PIDFD0x00001000CLONE_SIGHAND0x00000800CLONE_FILES0x00000400CLONE_FS0x00000200CLONE_VM0x00000100CSIGNAL0x000000ffSCHED_RESET_ON_FORKSCHED_DEADLINESCHED_IDLESCHED_ISOSCHED_BATCHSCHED_RRSCHED_FIFOSCHED_OTHER_BITS_SCHED_H_SCHED_H/* bits/sched.h *//* Switch process to namespace of type NSTYPE indicated by FD.  *//* Get currently used CPU and NUMA node.  *//* Get index of currently used CPU.  *//* Unshare the specified resources.  *//* Clone current process.  *//* New time namespace *//* cloning flags intersect with CSIGNAL so can be used only with unshare and
   clone3 syscalls.  *//* Clone I/O context.  *//* New network namespace.  *//* New pid namespace.  *//* New user namespace.  *//* New ipcs.  *//* New utsname group.  *//* New cgroup namespace.  *//* Store TID in userlevel buffer in
					  the child.  *//* Set if the tracing process can't
				      force CLONE_PTRACE on this clone.  *//* Create clone detached.  *//* Register exit futex and memory
					    location to clear.  *//* Store TID in userlevel buffer
					   before MM copy.  *//* Set TLS info.  *//* Set to shared SVID SEM_UNDO semantics.  *//* Set to create new namespace.  *//* Set to add to same thread group.  *//* Set if we want to have the same
				     parent as the cloner.  *//* Set if the parent wants the child to
				     wake it up on mm_release.  *//* Set if tracing continues on the child.  *//* Set if a pidfd should be placed
				     in parent.  *//* Set if signal handlers shared.  *//* Set if open files shared between processes.  *//* Set if fs info shared between processes.  *//* Set if VM shared between processes.  *//* Signal mask to be sent at exit.  *//* Cloning flags.  *//* Scheduling algorithms.  *//* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits__nstype__fn__child_stack<bits/cpu-set.h><bits/sched.h><bits/types/struct_timespec.h>sched_getaffinitycpu_set_t *sched_setaffinityconst cpu_set_tconst cpu_set_t *sched_rr_get_intervaltimespec *sched_get_priority_minsched_get_priority_maxsched_yieldsched_getschedulersched_setschedulerconst sched_paramconst sched_param *sched_param *sched_getparamsched_setparamCPU_FREE(cpuset)__CPU_FREE (cpuset)CPU_ALLOC(count)__CPU_ALLOC (count)CPU_ALLOC_SIZE(count)__CPU_ALLOC_SIZE (count)CPU_XOR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, ^)CPU_OR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, |)CPU_AND_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, &)CPU_XOR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)CPU_OR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)CPU_AND(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)CPU_EQUAL_S(setsize,cpusetp1,cpusetp2)__CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)CPU_EQUAL(cpusetp1,cpusetp2)__CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)CPU_COUNT_S(setsize,cpusetp)__CPU_COUNT_S (setsize, cpusetp)CPU_ZERO_S(setsize,cpusetp)__CPU_ZERO_S (setsize, cpusetp)CPU_ISSET_S(cpu,setsize,cpusetp)__CPU_ISSET_S (cpu, setsize, cpusetp)CPU_CLR_S(cpu,setsize,cpusetp)__CPU_CLR_S (cpu, setsize, cpusetp)CPU_SET_S(cpu,setsize,cpusetp)__CPU_SET_S (cpu, setsize, cpusetp)CPU_COUNT(cpusetp)__CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)CPU_ZERO(cpusetp)__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)CPU_ISSET(cpu,cpusetp)__CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_CLR(cpu,cpusetp)__CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SET(cpu,cpusetp)__CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SETSIZE__CPU_SETSIZE__sched_prioritysched_priority__USE_TIME_BITS64__REDIRECT_NTH/* sched.h *//* Get the CPU affinity for a task *//* Set the CPU affinity for a task *//* Access macros for `cpu_set'.  *//* Get the SCHED_RR interval for the named process.  *//* Get minimum priority value for a scheduler.  *//* Get maximum priority value for a scheduler.  *//* Yield the processor.  *//* Retrieve scheduling algorithm for a particular purpose.  *//* Set scheduling algorithm and/or parameters for a process.  *//* Retrieve scheduling parameters for a particular process.  *//* Set scheduling parameters for a process.  *//* Backward compatibility.  *//* Get system specific constant and data structure definitions.  *//* Get type definitions.  *//* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__pid__cpusetsize__cpuset__t__algorithm__policy/usr/include/bits/timex.h<bits/types/struct_timeval.h>timex(unnamed bitfield)taistbcnterrcntcalcntjitcntstabilshiftjitterppsfreqticktimetoleranceprecisionconstantesterrormaxerrormodesSTA_RONLY(STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)STA_CLKSTA_MODESTA_NANOSTA_CLOCKERRSTA_PPSERRORSTA_PPSWANDERSTA_PPSJITTERSTA_PPSSIGNALSTA_FREQHOLDSTA_UNSYNCSTA_DELSTA_INSSTA_FLLSTA_PPSTIMESTA_PPSFREQSTA_PLLMOD_NANOADJ_NANOMOD_MICROADJ_MICROMOD_TAIADJ_TAIMOD_CLKAADJ_OFFSET_SINGLESHOTMOD_CLKBADJ_TICKMOD_TIMECONSTADJ_TIMECONSTMOD_STATUSADJ_STATUSMOD_ESTERRORADJ_ESTERRORMOD_MAXERRORADJ_MAXERRORMOD_FREQUENCYADJ_FREQUENCYMOD_OFFSETADJ_OFFSETADJ_OFFSET_SS_READ0xa0010x8001ADJ_SETOFFSET_BITS_TIMEX_Hdefined __USE_TIME_BITS64 || (__TIMESIZE == 64 && __WORDSIZE == 32)/* bits/timex.h *//* Read-only bits *//* clock source (0 = A, 1 = B) (ro) *//* mode (0 = PLL, 1 = FLL) (ro) *//* resolution (0 = us, 1 = ns) (ro) *//* clock hardware fault (ro) *//* PPS signal calibration error (ro) *//* PPS signal wander exceeded (ro) *//* PPS signal jitter exceeded (ro) *//* PPS signal present (ro) *//* hold frequency (rw) *//* clock unsynchronized (rw) *//* delete leap (rw) *//* insert leap (rw) *//* select frequency-lock mode (rw) *//* enable PPS time discipline (rw) *//* enable PPS freq discipline (rw) *//* enable PLL updates (rw) *//* Status codes (timex.status) *//* 0x8000 in original *//* xntp 3.4 compatibility names *//* read-only adjtime *//* old-fashioned adjtime *//* tick value *//* select nanosecond resolution *//* select microsecond resolution *//* add 'time' to current time *//* set TAI offset *//* pll time constant *//* clock status *//* estimated time error *//* maximum time error *//* frequency offset *//* time offset *//* Mode codes (timex.mode) *//* ??? *//* TAI offset (ro) *//* stability limit exceeded (ro) *//* calibration errors (ro) *//* calibration intervals (ro) *//* jitter limit exceeded (ro) *//* pps stability (scaled ppm) (ro) *//* interval duration (s) (shift) (ro) *//* pps jitter (us) (ro) *//* pps frequency (scaled ppm) (ro) *//* (modified) usecs between clock ticks *//* (read only, except for ADJ_SETOFFSET) *//* clock frequency tolerance (ppm) (ro) *//* clock precision (usec) (ro) *//* clock command/status *//* estimated error (usec) *//* maximum error (usec) *//* frequency offset (scaled ppm) *//* time offset (usec) *//* mode selector *//* pad *//* clock precision (usec) (read only) *//* These definitions from linux/timex.h as of 3.18.  *//* Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/timex.h>clock_adjtimetimex *TIMER_ABSTIMECLOCK_TAICLOCK_BOOTTIME_ALARMCLOCK_REALTIME_ALARMCLOCK_BOOTTIMECLOCK_MONOTONIC_COARSECLOCK_REALTIME_COARSECLOCK_MONOTONIC_RAWCLOCK_THREAD_CPUTIME_IDCLOCK_PROCESS_CPUTIME_IDCLOCK_MONOTONICCLOCK_REALTIMECLOCKS_PER_SEC((__clock_t) 1000000)_BITS_TIME_H(!defined __STRICT_ANSI__ || defined __USE_POSIX) \defined(__REDIRECT_NTH)/* bits/time.h *//* use GNU *//* Tune a POSIX clock.  *//* Flag to indicate time is absolute.  *//* Like CLOCK_REALTIME but in International Atomic Time.  *//* Like CLOCK_BOOTTIME but also wakes suspended system.  *//* Like CLOCK_REALTIME but also wakes suspended system.  *//* Monotonic system-wide clock that includes time spent in suspension.  *//* Monotonic system-wide clock, updated only on ticks.  *//* Identifier for system-wide realtime clock, updated only on ticks.  *//* Monotonic system-wide clock, not adjusted for frequency scaling.  *//* Thread-specific CPU-time clock.  *//* High-resolution timer from the CPU.  *//* Monotonic system-wide clock.  *//* Identifier for system-wide realtime clock.  *//* 2 is _SC_CLK_TCK *//* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
   presents the real value for clock ticks per second for the system.  *//* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. *//* ISO/IEC 9899:1999 7.23.1: Components of time
   The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
   the number per second of the value returned by the `clock' function.  *//*
 * Never include this file directly; use <time.h> instead.
 *//* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__clock_id__utx<bits/types/locale_t.h><bits/types/struct_itimerspec.h><bits/types/struct_tm.h><bits/time.h>getdate_rtm *tm *__restrict__getdatetimespec_getrestimespec_gettimer_getoverruntimer_gettimeitimerspec *timer_settimeconst itimerspecconst itimerspec *const itimerspec *__restrict__itimerspec *__restrict__timer_deletetimer_createsigevent *sigevent *__restrict__timer_t *timer_t *__restrict__clock_getcpuclockidclockid_t *clock_nanosleepconst timespecconst timespec *clock_settimeclock_gettimeclock_getresnanosleepdysizetimelocaltimegmtzsetctime_rconst time_tconst time_t *const time_t *__restrict__asctime_rconst tmconst tm *const tm *__restrict__ctimeasctimelocaltime_rgmtime_rlocaltimegmtimestrptime_lstrftime_lstrptimestrftimemktimedifftimetime_t *clocksigeventgetdate_errtimezonedaylightchar *[2]tzname__timezone__daylight__tzname__isleap(year)((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))TIME_UTC_TIME_Hdefined __USE_POSIX199309 || defined __USE_ISOC11defined __USE_POSIX || __GLIBC_USE (ISOC2X)defined __USE_MISC || __GLIBC_USE (ISOC2X)/* time.h.  *//* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
	specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) *//* Set TS to resolution of time base BASE.  *//* Set TS to calendar time based in time base BASE.  *//* Get expiration overrun for timer TIMERID.  *//* Get current value of timer TIMERID and store it in VALUE.  *//* Set timer TIMERID to VALUE, returning old value in OVALUE.  *//* Delete timer TIMERID.  *//* Create new per-process timer using CLOCK_ID.  *//* Return clock ID for CPU-time clock.  *//* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Set clock CLOCK_ID to value TP.  *//* Get current value of clock CLOCK_ID and store it in TP.  *//* Get resolution of clock CLOCK_ID.  *//* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Return the number of days in YEAR.  *//* Another name for `mktime'.  *//* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  *//* Like `mktime', but for TP represents Universal Time, not local time.  *//* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  *//* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  *//* Same as above.  *//* Seconds west of UTC.  *//* If daylight-saving time is ever in use.  *//* Current timezone names.  *//* Defined in localtime.c.  *//* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  *//* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  *//* Reentrant versions of the above functions.  *//* Equivalent to `asctime (localtime (timer))'.  *//* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  *//* POSIX || C2X *//* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  *//* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  *//* Return the `struct tm' representation
   of *TIMER in the local timezone.  *//* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  *//* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  *//* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  *//* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  *//* Return the `time_t' representation of TP and normalize TP.  *//* Return the difference between TIME1 and TIME0.  *//* Return the current time and put it in *TIMER if TIMER is not NULL.  *//* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SEC is program time in seconds.  *//* Time base values for timespec_get.  *//* Many of the typedefs and structs whose official home is this header
   may also need to be defined by other headers.  *//* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second, and possibly a number of other constants.   *//*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */__resbufp__ts__timerid__ovalue__evp__req__rem__tp__requested_time__remaining__year__timer__loc__maxsize__time1__time0<bits/thread-shared-types.h>pthread_barrierattr_tpthread_barrier_tvolatile intpthread_spinlock_tpthread_rwlockattr_tpthread_rwlock_tpthread_cond_tpthread_mutex_tpthread_attr_tpthread_once_tpthread_key_tpthread_condattr_tpthread_mutexattr_tpthread_t__alignchar[4]__SIZEOF_PTHREAD_BARRIERATTR_Tchar[32]__SIZEOF_PTHREAD_BARRIER_Tchar[8]__SIZEOF_PTHREAD_RWLOCKATTR_Tchar[56]__SIZEOF_PTHREAD_RWLOCK_T__datachar[48]__SIZEOF_PTHREAD_COND_Tchar[40]__SIZEOF_PTHREAD_MUTEX_T__SIZEOF_PTHREAD_ATTR_T__SIZEOF_PTHREAD_CONDATTR_T__SIZEOF_PTHREAD_MUTEXATTR_T__have_pthread_attr_t_BITS_PTHREADTYPES_COMMON_H/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  *//* POSIX spinlock data type.  *//* Data structure for reader-writer lock variable handling.  The
   structure of the attribute type is deliberately not exposed.  *//* Once-only execution *//* Keys for thread-specific data *//* Data structure for condition variable handling.  The structure of
   the attribute type is not exposed on purpose.  *//* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  *//* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  *//* For internal mutex and condition variable definitions.  *//* Declaration of common pthread types for all architectures.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__sysconfPTHREAD_STACK_MIN__sysconf (__SC_THREAD_STACK_MIN_VALUE)__SC_THREAD_STACK_MIN_VALUEdefined __USE_DYNAMIC_STACK_SIZE && __USE_DYNAMIC_STACK_SIZE/* Definition of PTHREAD_STACK_MIN, possibly dynamic.
   Copyright (C) 2021-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/pthread_stack_min-dynamic.h><bits/types/struct___jmp_buf_tag.h><bits/types/__sigset_t.h><bits/wordsize.h><bits/setjmp.h><bits/endian.h><time.h><sched.h>pthread_equalpthread_equal (pthread_t __thread1, pthread_t __thread2)pthread_atforkpthread_getcpuclockid__clockid_t *pthread_setspecificpthread_getspecificpthread_key_deletepthread_key_createpthread_key_t *pthread_barrierattr_setpsharedpthread_barrierattr_t *pthread_barrierattr_getpsharedconst pthread_barrierattr_tconst pthread_barrierattr_t *const pthread_barrierattr_t *__restrict__pthread_barrierattr_destroypthread_barrierattr_initpthread_barrier_waitpthread_barrier_t *pthread_barrier_destroypthread_barrier_initpthread_barrier_t *__restrict__pthread_spin_unlockpthread_spinlock_t *pthread_spin_trylockpthread_spin_lockpthread_spin_destroypthread_spin_initpthread_condattr_setclockpthread_condattr_t *pthread_condattr_getclockconst pthread_condattr_tconst pthread_condattr_t *const pthread_condattr_t *__restrict____clockid_t *__restrict__pthread_condattr_setpsharedpthread_condattr_getpsharedpthread_condattr_destroypthread_condattr_initpthread_cond_clockwaitpthread_cond_t *pthread_cond_t *__restrict__pthread_mutex_t *pthread_mutex_t *__restrict__const timespec *__restrict__pthread_cond_timedwaitpthread_cond_waitpthread_cond_broadcastpthread_cond_signalpthread_cond_destroypthread_cond_initpthread_rwlockattr_setkind_nppthread_rwlockattr_t *pthread_rwlockattr_getkind_npconst pthread_rwlockattr_tconst pthread_rwlockattr_t *const pthread_rwlockattr_t *__restrict__pthread_rwlockattr_setpsharedpthread_rwlockattr_getpsharedpthread_rwlockattr_destroypthread_rwlockattr_initpthread_rwlock_unlockpthread_rwlock_t *pthread_rwlock_clockwrlockpthread_rwlock_t *__restrict__pthread_rwlock_timedwrlockpthread_rwlock_trywrlockpthread_rwlock_wrlockpthread_rwlock_clockrdlockpthread_rwlock_timedrdlockpthread_rwlock_tryrdlockpthread_rwlock_rdlockpthread_rwlock_destroypthread_rwlock_initpthread_mutexattr_setrobust_nppthread_mutexattr_t *pthread_mutexattr_setrobustpthread_mutexattr_getrobust_nppthread_mutexattr_getrobustconst pthread_mutexattr_tconst pthread_mutexattr_t *pthread_mutexattr_setprioceilingpthread_mutexattr_getprioceilingconst pthread_mutexattr_t *__restrict__pthread_mutexattr_setprotocolpthread_mutexattr_getprotocolpthread_mutexattr_settypepthread_mutexattr_gettypepthread_mutexattr_setpsharedpthread_mutexattr_getpsharedpthread_mutexattr_destroypthread_mutexattr_initpthread_mutex_consistent_nppthread_mutex_consistentpthread_mutex_setprioceilingpthread_mutex_getprioceilingconst pthread_mutex_tconst pthread_mutex_t *const pthread_mutex_t *__restrict__pthread_mutex_unlockpthread_mutex_clocklockpthread_mutex_timedlockpthread_mutex_lockpthread_mutex_trylockpthread_mutex_destroypthread_mutex_init__sigsetjmp_cancel__cancel_jmp_buf_tag[1](struct __cancel_jmp_buf_tag __env[1], int __savemask)__sigsetjmp__pthread_unwind_next__pthread_unwind_buf_t *__pthread_unregister_cancel_restore__pthread_register_cancel_defer__pthread_unregister_cancel__pthread_register_cancelpthread_testcancelpthread_cancelpthread_setcanceltypepthread_setcancelstatepthread_oncepthread_once_t *pthread_getaffinity_nppthread_setaffinity_nppthread_yieldpthread_setconcurrencypthread_getconcurrencypthread_setname_nppthread_getname_nppthread_setschedpriopthread_getschedparamsched_param *__restrict__pthread_setschedparampthread_getattr_nppthread_attr_t *pthread_setattr_default_npconst pthread_attr_tconst pthread_attr_t *pthread_attr_getsigmask_np__sigset_t *pthread_attr_setsigmask_npconst __sigset_tconst __sigset_t *pthread_getattr_default_nppthread_attr_getaffinity_nppthread_attr_setaffinity_nppthread_attr_setstackpthread_attr_getstackconst pthread_attr_t *__restrict__void **__restrict__pthread_attr_setstacksizepthread_attr_getstacksizepthread_attr_setstackaddrpthread_attr_getstackaddrpthread_attr_setscopepthread_attr_getscopepthread_attr_setinheritschedpthread_attr_getinheritschedpthread_attr_setschedpolicypthread_attr_getschedpolicypthread_attr_setschedparampthread_attr_t *__restrict__const sched_param *__restrict__pthread_attr_getschedparampthread_attr_setguardsizepthread_attr_getguardsizepthread_attr_setdetachstatepthread_attr_getdetachstatepthread_attr_destroypthread_attr_initpthread_selfpthread_detachpthread_clockjoin_nppthread_timedjoin_nppthread_tryjoin_nppthread_joinpthread_exitpthread_createpthread_t *pthread_t *__restrict____pthread_cleanup_frame__pthread_unwind_buf_t__cancel_jmp_buf_tagPTHREAD_CANCEL_DEFERREDPTHREAD_CANCEL_ASYNCHRONOUSPTHREAD_CANCEL_ENABLEPTHREAD_CANCEL_DISABLE_pthread_cleanup_bufferPTHREAD_PROCESS_PRIVATEPTHREAD_PROCESS_SHAREDPTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_PROCESSPTHREAD_INHERIT_SCHEDPTHREAD_EXPLICIT_SCHEDPTHREAD_RWLOCK_PREFER_READER_NPPTHREAD_RWLOCK_PREFER_WRITER_NPPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NPPTHREAD_RWLOCK_DEFAULT_NPPTHREAD_PRIO_NONEPTHREAD_PRIO_INHERITPTHREAD_PRIO_PROTECTPTHREAD_MUTEX_STALLEDPTHREAD_MUTEX_STALLED_NPPTHREAD_MUTEX_ROBUSTPTHREAD_MUTEX_ROBUST_NPPTHREAD_MUTEX_TIMED_NPPTHREAD_MUTEX_RECURSIVE_NPPTHREAD_MUTEX_ERRORCHECK_NPPTHREAD_MUTEX_ADAPTIVE_NPPTHREAD_MUTEX_NORMALPTHREAD_MUTEX_RECURSIVEPTHREAD_MUTEX_ERRORCHECKPTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_FAST_NPPTHREAD_CREATE_JOINABLEPTHREAD_CREATE_DETACHED__cancel_type__do_it__cancel_arg__cancel_routinevoid *[4]__pad__cancel_jmp_buf__mask_was_saved_pthread_cleanup_buffer *__prev__canceltype__routinepthread_cleanup_pop_restore_np(execute)do { } while (0); } while (0); __pthread_unregister_cancel_restore (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)pthread_cleanup_push_defer_np(routine,arg)do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel_defer (&__cancel_buf); do {pthread_cleanup_pop(execute)do { } while (0); } while (0); __pthread_unregister_cancel (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)pthread_cleanup_push(routine,arg)do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel (&__cancel_buf); do {__cleanup_fct_attributePTHREAD_ATTR_NO_SIGMASK_NPPTHREAD_BARRIER_SERIAL_THREADPTHREAD_ONCE_INITPTHREAD_CANCELED((void *) -1)PTHREAD_COND_INITIALIZER{ { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP{ { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) } }PTHREAD_RWLOCK_INITIALIZER{ { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_DEFAULT_NP) } }PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ADAPTIVE_NP) } }PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ERRORCHECK_NP) } }PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_RECURSIVE_NP) } }PTHREAD_MUTEX_INITIALIZER{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_TIMED_NP) } }_PTHREAD_Hdefined __USE_UNIX98 || defined __USE_XOPEN2K8defined __GNUC__ && defined __EXCEPTIONSSHARED__GNUC_PREREQ (11, 0)__REDIRECT_NTHNL__none__(1, 2, 4)(1, 3)"pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust"pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobustchar[78]deprecated(pthread_mutexattr_t *, int)"pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust"pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust(pthread_mutexattr_t *, int *)"pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent"pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistentchar[72](pthread_mutex_t *)returns_twiceweak"pthread_yield is deprecated, use sched_yield instead"pthread_yield is deprecated, use sched_yield insteadchar[53]__thread1__thread2__prepare__parent__child__thread_id__pointer__destr_function__attr__pshared__barrier__lock__cond__mutex__abstime__cond_attr__pref__rwlock__clockid__robustness__prioceiling__protocol__kind__old_ceiling__mutexattr__env__savemask__th__type__oldtype__state__oldstate__once_control__init_routine__level__target_thread__buflen__priosigmask__stackaddr__stacksize__scope__inherit__guardsize__detachstate__thread_return__retval"pthread_mutexattr_setrobust""pthread_mutexattr_getrobust""pthread_mutex_consistent""__sigsetjmp""sched_yield"/* pthread.h *//* Optimizations.  *//* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  *//* Get ID of CPU-time clock for thread THREAD_ID.  *//* Store POINTER in the thread-specific data slot identified by KEY. *//* Return current value of the thread-specific data slot identified by KEY.  *//* Destroy KEY.  *//* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  *//* Functions for handling thread-specific data.  *//* Set the process-shared flag of the barrier attribute ATTR.  *//* Get the process-shared flag of the barrier attribute ATTR.  *//* Destroy previously dynamically initialized barrier attribute ATTR.  *//* Initialize barrier attribute ATTR.  *//* Wait on barrier BARRIER.  *//* Destroy a previously dynamically initialized barrier BARRIER.  *//* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  *//* Functions to handle barriers.  *//* Release spinlock LOCK.  *//* Try to lock spinlock LOCK.  *//* Wait until spinlock LOCK is retrieved.  *//* Destroy the spinlock LOCK.  *//* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  *//* Functions to handle spinlocks.  *//* Set the clock selected for the condition variable attribute ATTR.  *//* Get the clock selected for the condition variable attribute ATTR.  *//* Set the process-shared flag of the condition variable attribute ATTR.  *//* Get the process-shared flag of the condition variable attribute ATTR.  *//* Destroy condition variable attribute ATTR.  *//* Initialize condition variable attribute ATTR.  *//* Functions for handling condition variable attributes.  *//* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME measured by the specified clock. MUTEX is assumed to be
   locked before. CLOCK is the clock to use. ABSTIME is an absolute
   time specification against CLOCK's epoch.

   This function is a cancellation point and therefore not marked with
   __THROW. *//* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wake up all threads waiting for condition variables COND.  *//* Wake up one thread waiting for condition variable COND.  *//* Destroy condition variable COND.  *//* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  *//* Functions for handling conditional variables.  *//* Set reader/write preference.  *//* Return current setting of reader/writer preference.  *//* Set process-shared attribute of ATTR to PSHARED.  *//* Return current setting of process-shared attribute of ATTR in PSHARED.  *//* Destroy attribute object ATTR.  *//* Initialize attribute object ATTR with default values.  *//* Functions for handling read-write lock attributes.  *//* Unlock RWLOCK.  *//* Try to acquire write lock for RWLOCK or return after specfied time.  *//* Try to acquire write lock for RWLOCK.  *//* Acquire write lock for RWLOCK.  *//* Try to acquire read lock for RWLOCK or return after specfied time.  *//* Try to acquire read lock for RWLOCK.  *//* Acquire read lock for RWLOCK.  *//* Destroy read-write lock RWLOCK.  *//* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  *//* Functions for handling read-write locks.  *//* Set the robustness flag of the mutex attribute ATTR.  *//* Get the robustness flag of the mutex attribute ATTR.  *//* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  *//* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  *//* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  *//* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  *//* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  *//* Return in *KIND the mutex kind attribute in *ATTR.  *//* Set the process-shared flag of the mutex attribute ATTR.  *//* Get the process-shared flag of the mutex attribute ATTR.  *//* Destroy mutex attribute object ATTR.  *//* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  *//* Functions for handling mutex attributes.  *//* Declare the state protected by MUTEX as consistent.  *//* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  *//* Get the priority ceiling of MUTEX.  *//* Unlock a mutex.  *//* Wait until lock becomes available, or specified time passes. *//* Lock a mutex.  *//* Try locking a mutex.  *//* Destroy a mutex.  *//* Initialize a mutex.  *//* Mutex handling.  *//* Function used in the macros.  Calling __sigsetjmp, with its first
   argument declared as an array, results in a -Wstringop-overflow
   warning from GCC 11 because struct pthread_unwind_buf is smaller
   than jmp_buf.  The calls from the macros have __SAVEMASK set to 0,
   so nothing beyond the common prefix is used and this warning is a
   false positive.  Use an alias with its first argument declared to
   use the type in the macros if possible to avoid this warning.  *//* Internal interface to initiate cleanup.  *//* Empty to allow label before pthread_cleanup_pop.  *//* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  *//* NOTREACHED *//* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  *//* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. *//* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  *//* Function called to call the cleanup handler.  As an extern inline
   function the compiler is free to decide inlining the change when
   needed or fall back on the copy which must exist somewhere
   else.  *//* Class to handle cancellation handler invocation.  *//* Structure to hold the cleanup handler information.  *//* No special attributes by default.  *//* Cancellation handling with integration into exception handling.  *//* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  *//* Cancel THREAD immediately or at the next possibility.  *//* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  *//* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  *//* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  *//* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  *//* Functions for handling initialization.  *//* Get bit set in CPUSET representing the processors TH can run on.  *//* Limit specified thread TH to run only on the processors represented
   in CPUSET.  *//* Set new concurrency level to LEVEL.  *//* Determine level of concurrency.  *//* Set thread name visible in the kernel and its interfaces.  *//* Get thread name visible in the kernel and its interfaces.  *//* Set the scheduling priority for TARGET_THREAD.  *//* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. *//* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  *//* Functions for scheduling control.  *//* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  *//* Set the default attributes to be used by pthread_create in this
   process.  *//* Special return value from pthread_attr_getsigmask_np if the signal
   mask has not been set.  *//* Store the signal mask of *ATTR in *SIGMASK.  If there is no signal
   mask stored, return PTHREAD_ATTR_NOSIGMASK_NP.  Return zero on
   success.  *//* Store *SIGMASK as the signal mask for the new thread in *ATTR.  *//* Get the default attributes used by pthread_create in this process.  *//* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  *//* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  *//* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  *//* Return the previously set address for the stack.  *//* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  *//* Return the currently used minimal stack size.  *//* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  *//* Set scheduling contention scope in *ATTR according to SCOPE.  *//* Return in *SCOPE the scheduling contention scope of *ATTR.  *//* Set scheduling inheritance mode in *ATTR according to INHERIT.  *//* Return in *INHERIT the scheduling inheritance mode of *ATTR.  *//* Set scheduling policy in *ATTR according to POLICY.  *//* Return in *POLICY the scheduling policy of *ATTR.  *//* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  *//* Return in *PARAM the scheduling parameters of *ATTR.  *//* Set the size of the guard area created for stack overflow protection.  *//* Get the size of the guard area created for stack overflow protection.  *//* Set detach state attribute.  *//* Get detach state attribute.  *//* Destroy thread attribute *ATTR.  *//* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  *//* Thread attribute handling.  *//* Compare two thread identifiers.  *//* Obtain the identifier of the current thread.  *//* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  *//* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT measured against the clock specified by CLOCKID.  The
   exit status of the thread is stored in *THREAD_RETURN, if
   THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  *//* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*//* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  *//* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants *//* Single execution handling.  *//* Cancellation *//* Chaining of cleanup functions.  *//* Saved cancellation type. *//* Its argument.  *//* Function to call.  *//* Cleanup buffers *//* Conditional variable handling.  *//* Process shared or private flag.  *//* Scope handling.  *//* Scheduler inheritance.  *//* Unix98 or XOpen2K *//* Read-write lock initializers.  *//* Read-write lock types.  *//* Mutex protocols.  *//* Robust mutex or not flags.  *//* For compatibility.  *//* Mutex types.  *//* Detach state.  *//* Copyright (C) 2002-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__newthread__start_routine/usr/include/bits/types/error_t.herror_t__error_t_defined/* Define error_t.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/types<bits/types/error_t.h><bits/errno.h>__errno_locationprogram_invocation_short_nameprogram_invocation_nameerrno(*__errno_location ())_ERRNO_H/* errno.h *//* !__ASSEMBLER__ *//* __USE_GNU *//* The full and simple forms of the name with which the program was
   invoked.  These variables are set up automatically at startup based on
   the value of argv[0].  *//* The error code set by various library functions.  *//* When included from assembly language, this header only provides the
   E* constants.  *//* The system-specific definitions of the E* constants, as macros.  *//*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */__GLIBC_USE_IEC_60559_TYPES_EXT__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X__GLIBC_USE_IEC_60559_FUNCS_EXT__GLIBC_USE_IEC_60559_EXT__GLIBC_USE_IEC_60559_BFP_EXT_C2X__GLIBC_USE_IEC_60559_BFP_EXT__GLIBC_USE_LIB_EXT2defined __USE_GNU || defined __STDC_WANT_IEC_60559_BFP_EXT____GLIBC_USE (IEC_60559_BFP_EXT) || __GLIBC_USE (ISOC2X)__GLIBC_USE (IEC_60559_BFP_EXT) || defined __STDC_WANT_IEC_60559_EXT__defined __USE_GNU || defined __STDC_WANT_IEC_60559_FUNCS_EXT____GLIBC_USE (IEC_60559_FUNCS_EXT) || __GLIBC_USE (ISOC2X)defined __USE_GNU || defined __STDC_WANT_IEC_60559_TYPES_EXT__IEC_60559_FUNCS_EXTIEC_60559_BFP_EXT/* ISO/IEC TS 18661-3:2015 defines the
   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.  *//* ISO/IEC TS 18661-4:2015 defines the
   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
   functions, the symbols from this TS are enabled unconditionally in
   C2X.  *//* ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
   macro.  Most but not all symbols enabled by that macro in TS
   18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
   Annex F still require a new feature test macro
   __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
   __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
   18661-1 are not included in C2X (and thus should depend on
   __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
   enabled).

   __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
   18661-1 not included in C2X.

   __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
   18661-1 that are also included in C2X (with no feature test macro
   required in C2X).

   __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
   that are included in C2X but conditional on
   __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
   conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
   18661-1.)  *//* ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
   macro.  *//* This header is internal to glibc and should not be included outside
   of glibc headers.  Headers including it must define
   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
   cannot have multiple include guards because ISO C feature test
   macros depend on the definition of the macro when an affected
   header is included, not when the first system header is
   included.  *//* Handle feature test macros at the start of a header.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__WCLONE__WALL__WNOTHREADWNOWAITWCONTINUEDWEXITEDWSTOPPEDWUNTRACEDWNOHANG!defined _SYS_WAIT_H && !defined _STDLIB_H/* Wait for cloned process.  *//* Wait for any child.  *//* Don't wait on children of other threads
				      in this group *//* Don't reap, just poll status.  *//* Report continued child.  *//* Report dead child.  *//* Report stopped child (same as WUNTRACED). *//* Bits in the fourth argument to `waitid'.  *//* Report status of stopped children.  *//* Don't block waiting.  *//* Bits in the third argument to `waitpid'.  *//* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/types/sigset_t.h><bits/select.h>pselectfd_set *fd_set *__restrict__const __sigset_t *__restrict__selecttimeval *timeval *__restrict__fd_maskfd_set__fd_mask__fd_mask[16]long[16]__FD_SETSIZE__NFDBITSfds_bitsFD_ZERO(fdsetp)__FD_ZERO (fdsetp)FD_ISSET(fd,fdsetp)__FD_ISSET (fd, fdsetp)FD_CLR(fd,fdsetp)__FD_CLR (fd, fdsetp)FD_SET(fd,fdsetp)__FD_SET (fd, fdsetp)NFDBITSFD_SETSIZE__FDS_BITS(set)((set)->fds_bits)__FD_MASK(d)((__fd_mask) (1UL << ((d) % __NFDBITS)))__FD_ELT(d)((d) / __NFDBITS)(8 * (int) sizeof (__fd_mask))_SYS_SELECT_H__USE_FORTIFY_LEVEL > 0 && defined __GNUC__/* sys/select.h *//* Define some inlines helping to catch common problems.  *//* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Access macros for `fd_set'.  *//* Number of bits per word of `fd_set' (some code assumes this is 32).  *//* Sometimes the fd_set member is assumed to have this type.  *//* Maximum number of file descriptors in `fd_set'.  *//* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  *//* fd_set for select and pselect.  *//* It's easier to assume 8-bit bytes than to get CHAR_BIT.  *//* Some versions of <linux/posix_types.h> define this macros.  *//* The fd_set member is required to be an array of longs.  *//* Get definition of timer specification structures.  *//* Get sigset_t.  *//* Get __FD_* definitions.  *//* Get definition of needed basic types.  *//*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  *//* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__nfds__readfds__writefds__exceptfds__timeout__sigmaskfsfilcnt64_tfsblkcnt64_tblkcnt64_tsuseconds_tuseconds_toff64_tino64_t__off64_t_defined__ino64_t_definedgetptptsname_rptsnameunlockptgrantptposix_openptqsort_rcanonicalize_file_namemkostemps64mkostempsmkostemp64mkostempsecure_getenvstrtof64x_lstrtof32x_lstrtof128_lstrtof64_lstrtof32_lstrtold_lstrtof_lstrtod_lstrtoull_lstrtoll_lstrtoul_lstrtol_lstrfromf64xstrfromf32xstrfromf128strfromf64strfromf32strfromlstrfromfstrfromdstrtof64xstrtof32xstrtof128strtof64strtof32__compar_d_fn_tcomparison_fn_t(char *__template, int __suffixlen, int __flags)(char *__template, int __flags)__oflag__dest(__write_only__, 2, 3)"mkostemps64""mkostemp64"strncasecmp_lstrcasecmp_lstrncasecmpstrcasecmpffsllffslffsrindexbzerobcopybcmp_STRINGS_Hdefined __cplusplus && __GNUC_PREREQ (4, 4)defined __USE_MISC || !defined __USE_XOPEN2K8__CORRECT_ISO_CPP_STRINGS_H_PROTOdefined __OPTIMIZE__defined __USE_MISC || !defined __USE_XOPEN2K8 || defined __USE_XOPEN2K8XSI__GNUC_PREREQ (3,4) && __USE_FORTIFY_LEVEL > 0 \/* strings.h  *//* Functions with security checks.  *//* Compare no more than N chars of S1 and S2, ignoring case, using
   collation rules from LOC.  *//* Compare S1 and S2, ignoring case, using collation rules from LOC.  *//* POSIX.1-2008 extended locale interface (see locale.h).  *//* Compare no more than N chars of S1 and S2, ignoring case.  *//* Compare S1 and S2, ignoring case.  *//* The following two functions are non-standard but necessary for non-32 bit
   platforms.  *//* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  *//* Find the last occurrence of C in S (same as strrchr).  *//* Find the first occurrence of C in S (same as strchr).  *//* Set N bytes of S to 0.  *//* Copy N bytes of SRC to DEST (like memmove, but args reversed).  *//* Compare N bytes of S1 and S2 (same as memcmp).  *//* Tell the caller that we provide correct C++ prototypes.  */__s1__s2__ll__l<strings.h>basenamememfrobstrfrystrverscmpstpncpy__stpncpystpcpy__stpcpysigdescr_npsigabbrev_npstrsignalstrsepexplicit_bzerostrerror_lstrerrorname_npstrerrordesc_npstrerror_rstrerrorstrnlenstrlenmempcpy__mempcpymemmemstrcasestrstrtok_r__strtok_rstrtokstrstrstrpbrkstrspnstrcspnstrchrnulstrrchrstrchrstrndupstrdupstrxfrm_lstrcoll_lstrxfrmstrcollstrncmpstrcmpstrncatstrcatstrncpystrcpymemrchrrawmemchrmemchr__memcmpeqmemcmpmemsetmemccpymemmovememcpystrndupa(s,n)(__extension__ ({ const char *__old = (s); size_t __len = strnlen (__old, (n)); char *__new = (char *) __builtin_alloca (__len + 1); __new[__len] = '\0'; (char *) memcpy (__new, __old, __len); }))strdupa(s)(__extension__ ({ const char *__old = (s); size_t __len = strlen (__old) + 1; char *__new = (char *) __builtin_alloca (__len); (char *) memcpy (__new, __old, __len); }))_STRING_Hdefined __cplusplus && (__GNUC_PREREQ (4, 4) \defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)__CORRECT_ISO_CPP_STRING_H_PROTO(defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8	\defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X)defined __USE_GNU && defined __GNUC__defined __USE_XOPEN2K && !defined __USE_GNU__GNUC_PREREQ (3,4)__read_write__(__read_write__, 1, 2)(__read_only__, 3, 4)(__read_only__, 1, 2)(__read_only__, 1, 3)(__write_only__, 1, 4)/* string.h  *//* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  *//* Frobnicate N bytes of S.  *//* Sautee STRING briskly.  *//* Compare S1 and S2 as strings holding name & indices/version numbers.  *//* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  *//* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  *//* Return a string describing the meaning of the signal number in SIG,
   the result is not translated.  *//* Return an abbreviation string for the signal number SIG.  *//* Return a string describing the meaning of the signal number in SIG.  *//* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  *//* Set N bytes of S to 0.  The compiler will not delete a call to this
   function, even if S is dead after the call.  *//* Translate error number to string according to the locale L.  *//* Return a string with the error name in ERR.  *//* Return a string describing the meaning of tthe error in ERR.  *//* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  *//* Fill BUF with a string describing the meaning of the `errno' code in
   ERRNUM.  *//* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  *//* Return a string describing the meaning of the `errno' code in ERRNUM.  *//* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  *//* Return the length of S.  *//* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  *//* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  *//* Similar to `strstr' but this function ignores the case of both strings.  *//* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  *//* Divide S into tokens separated by characters in DELIM.  *//* Find the first occurrence of NEEDLE in HAYSTACK.  *//* Find the first occurrence in S of any character in ACCEPT.  *//* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  *//* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  *//* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  *//* Find the last occurrence of C in S.  *//* Find the first occurrence of C in S.  *//* Return an alloca'd copy of at most N bytes of string.  *//* Duplicate S, returning an identical alloca'd string.  *//* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  *//* Duplicate S, returning an identical malloc'd string.  *//* Put a transformation of SRC into no more than N bytes of DEST,
   using sorting rules from L.  *//* Compare the collated forms of S1 and S2, using sorting rules from L.  *//* Put a transformation of SRC into no more than N bytes of DEST.  *//* Compare the collated forms of S1 and S2.  *//* Compare N characters of S1 and S2.  *//* Compare S1 and S2.  *//* Append no more than N characters from SRC onto DEST.  *//* Append SRC onto DEST.  *//* Copy no more than N characters of SRC to DEST.  *//* Copy SRC to DEST.  *//* Search N bytes of S for the final occurrence of C.  *//* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  *//* Search N bytes of S for C.  *//* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
   Return some non-zero value otherwise.

   Essentially __memcmpeq has the exact same semantics as memcmp
   except the return value is less constrained.  memcmp is always a
   correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
   or bcmp are correct implementations.

   __memcmpeq is meant to be used by compilers when memcmp return is
   only used for its boolean value.

   __memcmpeq is declared only for use by compilers.  Programs should
   continue to use memcmp.  *//* Compare N bytes of S1 and S2.  *//* Set N bytes of S to C.  *//* Misc || X/Open.  *//* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  *//* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  *//* Copy N bytes of SRC to DEST.  *//* Get size_t and NULL from <stddef.h>.  *//*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */__sig__stringp__delim__errnum__err__haystack__haystacklen__needle__needlelen__save_ptr__accept__reject/home/atharvakale/390r-debugging-setup/p7zip/C/Threads.c__sync_add_and_fetch_4volatile voidvolatile void *EINTRres1pthread_mutex_lock(&p->_mutex)newCountret2147942698-2147024598pthread_mutex_unlock(&p->_mutex)pthread_mutex_init(&p->_mutex, NULL)pthread_mutex_init(&p->_mutex, ((void *)0))pthread_cond_init(&p->_cond, NULL)pthread_cond_init(&p->_cond, ((void *)0))Event_Createthread_return&cssizeof (cpu_set_t)__builtin_memsetCCpuSet *__cpusizeof(affinity)sizeof(affinity) * 8__cpu_mask[16]unsigned long[16]__cpu_mask *"Thread_Create_WithAffinity"printf("\n%s\n", "Thread_Create_WithAffinity")attrpthread_attr_init(&attr)sizeof(*cpuSet)"Thread_Create_With_CpuSet"printf("\n%s\n", "Thread_Create_With_CpuSet")PRF(printf("\n%s\n", s))PRF(p)USE_HACK_UNSAFE_ATOMIC// Print("InterlockedIncrement");// int ret =// Print("CriticalSection_Delete");// Print("CriticalSection_Leave");// Print("CriticalSection_Enter");// Print("CriticalSection_Init");// EINVAL;/*
    WRes wres = Semaphore_Close(p);
    if (wres != 0)
      return wres;
    */// if (ret != 0) break;// ret =// ETIMEDOUT// probably we can't use that (_tid) after pthread_join(), so we close thread here// Print("Thread_Wait_Close");// Print("Thread_Close");// if (ret2 != 0) ret = ret2;// ret2 =/*
      if (cpuSet)
      {
        // ret2 =
        pthread_setaffinity_np(p->_tid, sizeof(*cpuSet), cpuSet);
        // if (ret2) ret = ret2;
      }
      */// if (ret2) ret = ret2;/*
      printf("\n affinity :");
      unsigned i;
      for (i = 0; i < sizeof(*cpuSet) && i < 8; i++)
      {
        Byte b = *((const Byte *)cpuSet + i);
        char temp[32];
        #define GET_HEX_CHAR(t) ((char)(((t < 10) ? ('0' + t) : ('A' + (t - 10)))))
        temp[0] = GET_HEX_CHAR((b & 0xF));
        temp[1] = GET_HEX_CHAR((b >> 4));
        // temp[0] = GET_HEX_CHAR((b >> 4));  // big-endian
        // temp[1] = GET_HEX_CHAR((b & 0xF));  // big-endian
        temp[2] = 0;
        printf("%s", temp);
      }
      printf("\n");
      */// int ret2;// new thread in Posix probably inherits affinity from parrent thread// #define PRF(p) p// #include <sched.h>// _GNU_SOURCE can be required for pthread_setaffinity_np() / CPU_ZERO / CPU_SET// ---------- POSIX ----------/* InitializeCriticalSectionAndSpinCount(p, 0); *//* InitializeCriticalSection() can raise exception:
     Windows XP, 2003 : can raise a STATUS_NO_MEMORY exception
     Windows Vista+   : no exceptions */// if (Semaphore_IsCreated(p))// negative ((LONG)maxCount) is not supported in WIN32::CreateSemaphore()/* maybe we must use errno here, but probably GetLastError() is also OK. *//* ResumeThread() returns:
         0 : was_not_suspended
         1 : was_resumed
        -1 : error
      *//*
      if (prevMask == 0)
      {
        // affinity change is non-critical error, so we can ignore it
        // wres = GetError();
      }
      */// DWORD_PTR prevMask =/* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions *//*
    (dw) result:
    WAIT_OBJECT_0  // 0
    WAIT_ABANDONED // 0x00000080 : is not compatible with Win32 Error space
    WAIT_TIMEOUT   // 0x00000102 : is     compatible with Win32 Error space
    WAIT_FAILED    // 0xFFFFFFFF
  *//* Threads.c -- multithreading library
2021-12-21 : Igor Pavlov : Public domain */releaseCountmanualResetUInt32[]unsigned int[]CRC_UPDATE_BYTE(crc,b)(g_CrcTable[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))CRC_GET_DIGEST(crc)((crc) ^ CRC_INIT_VAL)__7Z_CRC_H/* Call CrcGenerateTable one time before other CRC functions *//* 7zCrc.h -- CRC32 calculation
2013-01-18 : Igor Pavlov : Public domain */CSha256SHA256_FUNC_UPDATE_BLOCKSSHA256_BLOCK_SIZESHA256_NUM_DIGEST_WORDSSHA256_DIGEST_SIZE(SHA256_NUM_DIGEST_WORDS * 4)(SHA256_NUM_BLOCK_WORDS * 4)SHA256_NUM_BLOCK_WORDS__7Z_SHA256_H/*
call Sha256Prepare() once at program start.
It prepares all supported implementations, and detects the fastest implementation.
*/// void MY_FAST_CALL Sha256_UpdateBlocks(UInt32 state[8], const Byte *data, size_t numBlocks);/*
Sha256_SetFunction()
return:
  0 - (algo) value is not supported, and func_UpdateBlocks was not changed
  1 - func_UpdateBlocks was set according (algo) value.
*//*
  if (the system supports different SHA256 code implementations)
  {
    (CSha256::func_UpdateBlocks) will be used
    (CSha256::func_UpdateBlocks) can be set by
       Sha256_Init()        - to default (fastest)
       Sha256_SetFunction() - to any algo
  }
  else
  {
    (CSha256::func_UpdateBlocks) is ignored.
  }
*//* Sha256.h -- SHA-256 Hash
2021-01-01 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Xz.hXzDecMt_Decodeconst CXzDecMtPropsconst CXzDecMtProps *CXzStatInfo *XzStatInfo_ClearXzDecMt_DestroyXzDecMt_CreateXzDecMtProps_InitCXzDecMtProps *XzUnpacker_IsBlockFinishedconst CXzUnpackerconst CXzUnpacker *XzUnpacker_PrepareToRandomBlockDecodingCXzUnpacker *XzUnpacker_GetExtraSizeXzUnpacker_IsStreamWasFinishedXzUnpacker_CodeFullECoderStatus *XzUnpacker_CodeXzUnpacker_FreeXzUnpacker_SetOutBufXzUnpacker_InitXzUnpacker_ConstructXzs_GetUnpackSizeconst CXzsconst CXzs *Xzs_GetNumBlocksXzs_ReadBackwardCXzs *Xzs_FreeXzs_ConstructXz_GetPackSizeconst CXzStreamconst CXzStream *Xz_GetUnpackSizeXz_ReadHeaderCXzStreamFlags *Xz_ParseHeaderXzBlock_ReadHeaderCXzBlock *XzBlock_ParseXz_ReadVarIntCXzStatInfoCXzDecMtHandleCXzDecMtPropsCXzUnpackerEXzStateXZ_STATE_STREAM_HEADERXZ_STATE_STREAM_INDEXXZ_STATE_STREAM_INDEX_CRCXZ_STATE_STREAM_FOOTERXZ_STATE_STREAM_PADDINGXZ_STATE_BLOCK_HEADERXZ_STATE_BLOCKXZ_STATE_BLOCK_FOOTERCMixCoderIStateCoder_IStateCoderECoderFinishModeCODER_FINISH_ANYCODER_FINISH_ENDECoderStatusCODER_STATUS_NOT_SPECIFIEDCODER_STATUS_FINISHED_WITH_MARKCODER_STATUS_NOT_FINISHEDCODER_STATUS_NEEDS_MORE_INPUTCXzsCXzStreamCXzBlockSizesCXzStreamFlagsCXzCheckCXzBlockCXzFilterCombinedRes_TypeCombinedResProgressResReadResDecodeResNumBlocksNumStreamsOutSizeInSizeDecodingTruncatedDataAfterEndNumBlocks_DefinedNumStreams_DefinedUnpackSize_DefinedmemUseMaxignoreErrorsByte[1024]unsigned char[1024]XZ_BLOCK_HEADER_SIZE_MAXshaDigestoutDataWrittendecodeOnlyOneBlockdecodeToStreamSignatureheaderParsedOkparseModeshachecknumTotalBlocksnumFinishedStreamsnumStartedStreamspadSizeindexPosindexSizeblockHeaderSizestreamFlagsindexPreSizealignPosIStateCoder[4]_IStateCoder[4]MIXCODER_NUM_FILTERS_MAXSRes[4]int[4]resultsUInt64[4]unsigned long long[4]idssize_t[3]unsigned long[3]int[3]wasFinishedoutWrittennumCodersFilterCode2SetPropsCXzStream *streamsnumAllocatedstartOffsetCXzBlockSizes *totalSizecrc64CXzFilter[4]struct <unnamed>[4]XZ_NUM_FILTERS_MAXfiltersXZ_FILTER_PROPS_SIZE_MAXidXzUnpacker_GetPackSizeForIndex(p)((p)->packSize + (p)->blockHeaderSize + XzFlags_GetCheckSize((p)->streamFlags))XZ_SIZE_OVERFLOWXzFlags_HasDataCrc32(f)(Xz_GetCheckType(f) == XZ_CHECK_CRC32)XzFlags_GetCheckType(f)((f) & XZ_CHECK_MASK)XzFlags_IsSupported(f)((f) <= XZ_CHECK_MASK)XZ_CHECK_SHA256XZ_CHECK_CRC64XZ_CHECK_CRC32XZ_CHECK_NOXZ_CHECK_MASKXZ_STREAM_FOOTER_SIZE(XZ_FOOTER_SIG_SIZE + XZ_STREAM_FLAGS_SIZE + XZ_STREAM_CRC_SIZE + 4)XZ_STREAM_HEADER_SIZE(XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZE + XZ_STREAM_CRC_SIZE)XZ_STREAM_CRC_SIZEXZ_STREAM_FLAGS_SIZEXZ_FOOTER_SIG_1'Z'XZ_FOOTER_SIG_0'Y'XZ_FOOTER_SIG_SIZEXZ_SIG_SIZEXzBlock_HasUnsupportedFlags(p)(((p)->flags & ~(XZ_BF_NUM_FILTERS_MASK | XZ_BF_PACK_SIZE | XZ_BF_UNPACK_SIZE)) != 0)XzBlock_HasUnpackSize(p)(((p)->flags & XZ_BF_UNPACK_SIZE) != 0)XzBlock_HasPackSize(p)(((p)->flags & XZ_BF_PACK_SIZE) != 0)XzBlock_GetNumFilters(p)(((unsigned)(p)->flags & XZ_BF_NUM_FILTERS_MASK) + 1)XZ_BF_UNPACK_SIZEXZ_BF_PACK_SIZEXZ_BF_NUM_FILTERS_MASKXZ_ID_LZMA2XZ_ID_SPARCXZ_ID_ARMTXZ_ID_ARMXZ_ID_IA64XZ_ID_PPCXZ_ID_X86XZ_ID_DeltaXZ_ID_Subblock__XZ_HXz_FreeXz_ConstructXzFlags_GetCheckSizeXzCheck_FinalCXzCheck *XzCheck_UpdateXzCheck_Initconst Byte[6]unsigned char[6]XZ_SIGXz_WriteVarInt//      1 means that MT (Multi-Thread) version was used// out: 0 means that ST (Single-Thread) version was used// out: decoding results and statistics// 0 - partial unpacking is allowed, 1 - xz stream(s) must be finished/*

XzDecMt_Decode()
SRes: it's combined decoding result. It also is equal to stat->CombinedRes.

  SZ_OK               - no error
                        check also output value in (stat->DataAfterEnd)
                        that can show additional possible error

  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_NO_ARCHIVE - is not xz archive
  SZ_ERROR_ARCHIVE    - Headers error
  SZ_ERROR_DATA       - Data Error
  SZ_ERROR_UNSUPPORTED - Unsupported method or method properties
  SZ_ERROR_CRC        - CRC Error
  SZ_ERROR_INPUT_EOF  - it needs more input data
  SZ_ERROR_WRITE      - ISeqOutStream error
  (SZ_ERROR_READ)     - ISeqInStream errors
  (SZ_ERROR_PROGRESS) - ICompressProgress errors
  // SZ_ERROR_THREAD     - error in multi-threading functions
  MY_SRes_HRESULT_FROM_WRes(WRes_error) - error in multi-threading function
*/// = SZ_ERROR_* codes for decoding// = SZ_ERROR_WRITE,    if error from ISeqOutStream// = SZ_ERROR_PROGRESS, if error from ICompressProgress// = SZ_ERROR_READ,     if error from ISeqInStream// but check also (DataAfterEnd) that can show additional minor errors.// = S_OK, if there is no error.// Combined result error code that shows main rusult// error code from ICompressProgress:Progress()// error code from ISeqInStream:Read()// the error code of xz streams data decoding// end of xz stream, if that data was not correct// pack size processed. That value doesn't include the data after// Decoding was Truncated, we need only partial output data// there are some additional data after good xz streams, and that data is not new xz stream./*
  alloc    : XzDecMt uses CAlignOffsetAlloc internally for addresses allocated by (alloc).
  allocMid : for big allocations, aligned allocation is better
*/// it's recommended to set (memUseMax) manually to value that is smaller of total size of RAM in computer.// the limit of total memory usage for Multi-Thread decoding.// size of small input data buffers for Multi-Thread decoding. Big number of such small buffers can be created// the number of threads for Multi-Thread decoding. if (umThreads == 1) it will use Single-thread decoding// if set to 1, the decoder can ignore some errors and it skips broken parts of data.// size of output buffer for Single-Thread decoding// size of input buffer for Single-Thread decoding/*
  if (CXzDecMtProps::numThreads > 1), the decoder can try to use
  Multi-Threading. The decoder analyses xz block header, and if
  there are pack size and unpack size values stored in xz block header,
  the decoder reads compressed data of block to internal buffers,
  and then it can start parallel decoding, if there are another blocks.
  The decoder can switch back to Single-Thread decoding after some conditions.

  The sequence of calls for xz decoding with in/out Streams:
  {
    XzDecMt_Create()
    XzDecMtProps_Init(XzDecMtProps) to set default values of properties
    // then you can change some XzDecMtProps parameters with required values
    // here you can set the number of threads and (memUseMax) - the maximum
    Memory usage for multithreading decoding.
    for()
    {
      XzDecMt_Decode() // one call per one file
    }
    XzDecMt_Destroy()
  }
*//* ---- Single-Thread and Multi-Thread xz Decoding with Input/Output Streams ---- *//*
  for random block decoding:
    XzUnpacker_Init();
    set CXzUnpacker::streamFlags
    XzUnpacker_PrepareToRandomBlockDecoding()
    loop
    {
      XzUnpacker_Code()
      XzUnpacker_IsBlockFinished()
    }
*//*
XzUnpacker_GetExtraSize() returns then number of unconfirmed bytes,
 if it's in (XZ_STATE_STREAM_HEADER) state or in (XZ_STATE_STREAM_PADDING) state.
These bytes can be some data after xz archive, or
it can be start of new xz stream.
 
Call XzUnpacker_GetExtraSize() after XzUnpacker_Code() function to detect real size of
xz stream in two cases, if XzUnpacker_Code() returns:
  res == SZ_OK && status == CODER_STATUS_NEEDS_MORE_INPUT
  res == SZ_ERROR_NO_ARCHIVE
*//*
If you decode full xz stream(s), then you can call XzUnpacker_IsStreamWasFinished()
after successful XzUnpacker_CodeFull() or after last call of XzUnpacker_Code().
*//*
finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  CODER_FINISH_ANY - use smallest number of input bytes
  CODER_FINISH_END - read EndOfStream marker after decoding

Returns:
  SZ_OK
    status:
      CODER_STATUS_NOT_FINISHED,
      CODER_STATUS_NEEDS_MORE_INPUT - the decoder can return it in two cases:
         1) it needs more input data to finish current xz stream
         2) xz stream was finished successfully. But the decoder supports multiple
            concatented xz streams. So it expects more input data for new xz streams.
         Call XzUnpacker_IsStreamWasFinished() to check that latest xz stream was finished successfully.

  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_DATA - Data error
  SZ_ERROR_UNSUPPORTED - Unsupported method or method properties
  SZ_ERROR_CRC  - CRC error
  // SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).

  SZ_ERROR_NO_ARCHIVE - the error with xz Stream Header with one of the following reasons:
     - xz Stream Signature failure
     - CRC32 of xz Stream Header is failed
     - The size of Stream padding is not multiple of four bytes.
    It's possible to get that error, if xz stream was finished and the stream
    contains some another data. In that case you can call XzUnpacker_GetExtraSize()
    function to get real size of xz stream.
*//*
  XzUnpacker
  The sequence for decoding functions:
  {
    XzUnpacker_Construct()
    [Decoding_Calls]
    XzUnpacker_Free()
  }

  [Decoding_Calls]

  There are 3 types of interfaces for [Decoding_Calls] calls:

  Interface-1 : Partial output buffers:
    {
      XzUnpacker_Init()
      for()
      {
        XzUnpacker_Code();
      }
      XzUnpacker_IsStreamWasFinished()
    }
    
  Interface-2 : Direct output buffer:
    Use it, if you know exact size of decoded data, and you need
    whole xz unpacked data in one output buffer.
    xz unpacker doesn't allocate additional buffer for lzma2 dictionary in that mode.
    {
      XzUnpacker_Init()
      XzUnpacker_SetOutBufMode(); // to set output buffer and size
      for()
      {
        XzUnpacker_Code(); // (dest = NULL) in XzUnpacker_Code()
      }
      XzUnpacker_IsStreamWasFinished()
    }

  Interface-3 : Direct output buffer : One call full decoding
    It unpacks whole input buffer to output buffer in one call.
    It uses Interface-2 internally.
    {
      XzUnpacker_CodeFull()
      XzUnpacker_IsStreamWasFinished()
    }
*//* alloc : aligned for cache line allocation is better */// the size of data in (outBuf) that were fully unpacked// number of finished blocks in current stream// BoolInt SingleBufMode;// is equal to lzmaDecoder.dicPos (in outBuf mode)// int *wasFinished,// ECoderFinishMode values are identical to ELzmaFinishMode// ECoderStatus values are identical to ELzmaStatus values of LZMA2 decoder/*
extern const Byte XZ_FOOTER_SIG[XZ_FOOTER_SIG_SIZE];
*//* ---------- xz stream ---------- *//* ---------- xz block ---------- *//* Xz.h - Xz interface
2021-04-01 : Igor Pavlov : Public domain */statisIndexheaderSizeResheadermaxSize/home/atharvakale/390r-debugging-setup/p7zip/C/XzCrc64.hCrc64CalcCrc64UpdateCrc64GenerateTableUInt64[]unsigned long long[]g_Crc64TableCRC64_UPDATE_BYTE(crc,b)(g_Crc64Table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))CRC64_GET_DIGEST(crc)((crc) ^ CRC64_INIT_VAL)CRC64_INIT_VALUINT64_CONST(0xFFFFFFFFFFFFFFFF)__XZ_CRC64_H/* XzCrc64.h -- CRC64 calculation
2013-01-18 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/Xz.c"XzCrc64.h""Xz.h"CRC_GET_DIGEST(p->crc)((p->crc) ^ 0xFFFFFFFF)p->crcp->crc640xFFFFFFFFFFFFFFFFp->blocks'7''z''X'/* const Byte XZ_FOOTER_SIG[XZ_FOOTER_SIG_SIZE] = { 'Y', 'Z' }; *//* Xz.c - Xz
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzCrc64.c0xC96C5795D7870F4214514072000185962306(UInt64)0UInt64[1024]unsigned long long[1024]CRC64_NUM_TABLES256 * CRC64_NUM_TABLESXzCrc64UpdateT4CRC64_FUNCg_Crc64UpdatekCrc64PolyUINT64_CONST(0xC96C5795D7870F42)/* XzCrc64.c -- CRC64 calculation
2017-05-23 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzCrc64Opt.cCRC64_UPDATE_BYTE_2(crc,b)/* XzCrc64Opt.c -- CRC64 calculation
2021-02-09 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzDec.cCXzDecMt *truncatedconst CXzDecMtThreadconst CXzDecMtThread *coderCXzDecMtThread[32]CXzDecMtThread *XzStatInfo_SetStatextraSizeXzDecMt_Decode_STp->outBufp->props.outStep_ST(void *)p->inBufdecodingTruncatedXzDecMt_Callback_WriteXZDECMT_STREAM_WRITE_STEP"XZ_STATE_STREAM_HEADER crossEnd = "(unsigned)me->mtc.crossEndprintf("\n" "XZ_STATE_STREAM_HEADER crossEnd = " " %d\n", (unsigned)(unsigned)me->mtc.crossEnd)crossBufinProgressPrevme->inStream(void *)crossBufMtProgress_Progress_ST(&me->mtc.mtProgress)"PostSingle"printf("\n" "PostSingle" " %d\n", (unsigned)srcSize)"Write MTDEC_PARSE_END"me->mtc.inProcessedprintf("\n" "Write MTDEC_PARSE_END" " %d\n", (unsigned)me->mtc.inProcessed)XzDecMt_Callback_CodeXzDecMt_Callback_PreCodeCMixCoder *const CXzBlockconst CXzBlock *XzDecMt_Callback_ParsesrcSize2printf("\n" "Parse" " %d\n", (unsigned)srcSize2)(size_t)0(size_t)0 - 1packSizeAlignedcheckSizeblockPackSumblockMaxrequiredrem2XzDecMt_FreeStXzDecMt_FreeOutBufscoder->outBufsizeof(CXzDecMt)83176sizeof(size_t) << 28destLenOrigsrcLenOrig"CODER_STATUS_NEEDS_MORE_INPUT"printf("\n" "CODER_STATUS_NEEDS_MORE_INPUT" "\n")"ERROR: block.size mismatch"printf("\n" "ERROR: block.size mismatch" "\n")Xz_ParseHeader(&p->streamFlags, p->buf)XzBlock_Parse(&p->block, p->buf)p->streamFlagsXzDecMix_Init(&p->decoder, &p->block, p->outBuf, p->outBufSize)srcRemdestLen2srcLen2finishMode2srcFinished2destFinishXZ_CHECK_SIZE_MAXXzUnpacker_UpdateIndexXzDecMix_InitneedReInitnumFiltersconst CXzFilterconst CXzFilter *MixCoder_SetFromMethod(p, i, block->filters[numFilters - 1 - i].id, outBuf, outBufSize)MixCoder_ResetFromMethod(p, 0, block->filters[numFilters - 1].id, outBuf, outBufSize)sc->SetProps(sc->p, f->props, f->propsSize, p->alloc)IStateCoder *_IStateCoder *scheaderSizeheader + headerSize&p->packSize9223372036854775808(UInt64)1 << 63&p->unpackSize&filter->idCXzFilter *filter-196XzBlock_AreSupportedFiltersXz_CheckFooterbuf + 4buf + 8buf + XZ_SIG_SIZEbuf + 6buf + XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZEbuf + 6 + 2MixCoder_Code"------- MixCoder Single ----------"printf("\n" "------- MixCoder Single ----------" "\n")"filter"printf("\n" "filter" " %d\n", (unsigned)i)CODER_BUF_SIZE * (MIXCODER_NUM_FILTERS_MAX - 1)((size_t)1 << 17) * (4 - 1)srcWasFinished393216allFinishedresMaindest2src2encodingWasFinishedstatus2CODER_BUF_SIZESRes *"standard mix"printf("\n" "standard mix" "\n")MixCoder_ResetFromMethodMixCoder_SetFromMethodMixCoder_InitMixCoder_FreeMixCoder_ConstructLzma2State_ResetOutBufCLzma2Dec_Spec *specLzma2State_SetFromMethodsizeof(CLzma2Dec_Spec)&spec->decoder&(&spec->decoder)->decoderLzma2State_Code2Lzma2State_InitLzma2State_SetPropsLzma2State_Free&p->decoderBraState_SetFromMethodCBraState *sizeof(CBraState)16688BraState_Code2destRemBRA_BUF_SIZEBraState_FilterPPCIA64ARMARMTSPARCBraState_Initp->x86StatemethodIdencodeModeBraState_SetPropsBraState_FreeCXzDecMtCXzDecMtThreadCLzma2Dec_SpecCBraStateparsing_TruncatedisBlockHeaderState_WriteisBlockHeaderState_ParsemainErrorCodenumStreamsfinishedDecoderIndexmainDecoderWasCalledunpackBlockMaxSizeatBlockHeaderparseStateskipModeblockPackTotalblockPackSize_for_IndexinPreHeaderSizeoutBufModedeltaStatex86StatebufTotalbufConvREAD_VARINT_AND_CHECK(buf,pos,size,res){ unsigned s = Xz_ReadVarInt(buf + pos, size - pos, res); if (s == 0) return SZ_ERROR_ARCHIVE; pos += s; }CASE_BRA_CONV(isa)case XZ_ID_ ## isa: size = isa ## _Convert(data, size, p->ip, p->encodeMode); break;((size_t)1 << 17)XZ_DUMPUSE_SUBBLOCK// of decoding problem// we set read error as combined error, only if that error was the reason// && p->inProcessed == p->readProcessed// truncated// p->readProcessed,// we must set error code from MT decoding at first// && p->mtc.inProcessed == p->mtc.readProcessed// p->mtc.readProcessed,// but we still keep state variables, that was set in XzUnpacker_Init()// we just free ST buffers here// p->numBadBlocks = 0;/*
    p->outBuf = NULL;
    p->outBufSize = 0;
    if (!outStream)
    {
      p->outBuf = outBuf;
      p->outBufSize = *outBufSize;
      *outBufSize = 0;
    }
    */// p->outSize = 457; p->outSize_Defined = True; p->finishMode = False; // for test// p->stat = stat;// some extra data after all streams// he we suppose that all xz streams were finsihed OK, and we have// if (extraSize != 0 || readProcessed != inProcessed)// if there were good xz streams before error// if (inProcessed == extraSize), there was no any good xz stream header, and we keep error/*
    SZ_ERROR_NO_ARCHIVE is possible for 2 states:
      XZ_STATE_STREAM_HEADER  - if bad signature or bad CRC
      XZ_STATE_STREAM_PADDING - if non-zero padding data
    extraSize and inProcessed don't include "bad" byte
    */// if (status != CODER_STATUS_FINISHED_WITH_MARK)// so he we have (status == CODER_STATUS_NOT_FINISHED)// CODER_STATUS_FINISHED_WITH_MARK is not possible for multi stream xz decoding// if xz stream was not finished, then we need more data// any extra data is part of correct data// CODER_STATUS_NEEDS_MORE_INPUT is expected status for correct xz streams// it's result from CXzUnpacker unpacker// UInt64 readProcessed,/*
XzStatInfo_SetStat() transforms
    CXzUnpacker return code and status to combined CXzStatInfo results.
    it can convert SZ_OK to SZ_ERROR_INPUT_EOF
    it can convert SZ_ERROR_NO_ARCHIVE to SZ_OK and (DataAfterEnd = 1)
*/// return res;// so we return SZ_OK here instead of (res);// and it can be corrected later as final result// p->codeRes is preliminary error from XzUnpacker_Code.// p->outProcessed += written; // 21.01: BUG fixed// dec->decodeOnlyOneBlock = False;/*
  XzDecMt_Decode_ST() can return SZ_OK or the following errors
     - SZ_ERROR_MEM for memory allocation error
     - error from XzUnpacker_Code() function
     - SZ_ERROR_WRITE for ISeqOutStream::Write(). stat->CombinedRes_Type = SZ_ERROR_WRITE in that case
     - ICompressProgress::Progress() error,  stat->CombinedRes_Type = SZ_ERROR_PROGRESS.
  But XzDecMt_Decode_ST() doesn't return ISeqInStream::Read() errors.
  ISeqInStream::Read() result is set to p->readRes.
  also it can set stat->CombinedRes_Type to SZ_ERROR_WRITE or SZ_ERROR_PROGRESS.
*/// inData = crossBuf;// XzDecMt_Prepare_InBuf_ST(p);// res = SZ_ERROR_ARCHIVE; // for failure test// CODER_FINISH_ANY,/*
      We have processed all xz-blocks of stream,
      And xz unpacker is at XZ_STATE_BLOCK_HEADER state, where
      (src) is a pointer to xz-Index structure.
      We finish reading of current xz-Stream, including Zero padding after xz-Stream.
      We exit, if we reach extra byte (first byte of new-Stream or another data).
      But we don't update input stream pointer for that new extra byte.
      If extra byte is not correct first byte of xz-signature,
      we have SZ_ERROR_NO_ARCHIVE error here.
      */// so we can use mtc variables without lock// (coder->state == MTDEC_PARSE_END) means that there are no other working threads// PRF_STR_INT("Written size =", size);// PRF(printf("\nWritten ask = %d written = %d\n", (unsigned)cur, (unsigned)written));// me->numBadBlocks++;// we use in me->dec: sha, numBlocks, indexSize// PRF(printf("\nWrite processed = %d srcSize = %d\n", (unsigned)me->mtc.inProcessed, (unsigned)srcSize));// PRF(printf(" res = %d, srcSize2 = %d, outSizeCur = %d", res, (unsigned)srcProcessed, (unsigned)outSizeCur));// coder->finishedWithMark ? CODER_FINISH_END : CODER_FINISH_ANY,// PRF(printf("\nCallback_Code: Code %d %d\n", (unsigned)srcSize, (unsigned)outSizeCur));// if (res == SZ_ERROR_MEM) return res;// res = SZ_ERROR_UNSUPPORTED; // to test// return SZ_ERROR_MEM;// SZ_OK;// next block can be zero size// we check control byte of next block// ---------- skipMode ----------// if (coder->inPreSize <= me->props.inBlockMax)// unpackBlockMaxSize// if (blockPackSum <= me->props.inBlockMax)// && block->unpackSize <= me->props.outBlockMax// res;/*
      if (res == SZ_ERROR_MEM)
        return res;
      return SZ_OK;
      */// PRF(printf(" res = %d, srcSize2 = %d", res, (unsigned)srcSize2));// it can be = SZ_ERROR_DATA, in some another cases// it can be = SZ_ERROR_INPUT_EOF// it's set to error code, if the size Code() output doesn't patch the size from Parsing stage// UInt64 numBadBlocks;// UInt64 numFinishedStreams// global values that are used in Parse stage// int statErrorDefined;/* ---------- CXzDecMt ---------- */// BoolInt finishedWithMark;// including stream header, block header and checksum.// including block header and checksum./* ---------- CXzDecMtThread ---------- *//*
  if (p->state == XZ_STATE_FINISHED)
    *status = CODER_STATUS_FINISHED_WITH_MARK;
  return SZ_OK;
  *//* to disable GCC warning */// XZ_STATE_BLOCK_FOOTER can transit to XZ_STATE_BLOCK_HEADER without input bytes// continue;/*
      if (srcLen2 == 0 && destLen2 == 0)
      {
        *status = CODER_STATUS_NOT_FINISHED;
        return SZ_OK;
      }
      */// outBuf = NULL;// p->SingleBufMode = False;// p->SingleBufMode = (outBuf != NULL);/* (headerSize != 0) : another code checks */// &encodingWasFinished,// destLen2_Orig = destLen2;// destLen2_Orig;/*
    if (p->numCoders == 1 && *destLen == destLenOrig && finishMode == LZMA_FINISH_ANY)
      break;
    *//*
    if (wasFinished)
      p->status = CODER_STATUS_FINISHED_WITH_MARK;
    else
    {
      if (res == SZ_OK)
        if (destLen2 != destLenOrig)
          p->status = CODER_STATUS_NEEDS_MORE_INPUT;
    }
    */// &wasFinished,// if (p->SingleBufMode)/*
 if (destFinish) - then unpack data block is finished at (*destLen) position,
                   and we can return data that were not processed by filter

output (status) can be :
  CODER_STATUS_NOT_FINISHED
  CODER_STATUS_FINISHED_WITH_MARK
  CODER_STATUS_NEEDS_MORE_INPUT - not implemented still
*//* 9.31: the BUG was fixed */// *wasFinished = (status2 == LZMA_STATUS_FINISHED_WITH_MARK);/* ELzmaFinishMode fm = (finishMode == LZMA_FINISH_ANY) ? LZMA_FINISH_ANY : LZMA_FINISH_END; *//*
  if (outBufMode), then (dest) is not used. Use NULL.
         Data is unpacked to (spec->decoder.decoder.dic) output buffer.
*/// *wasFinished = (*destLen == 0 && *srcLen == 0); /* change it *//* change it */// int *wasFinished/* ---------- SbState ---------- */// *wasFinished = 1;// *wasFinished = False;/* ---------- BraState ---------- */// #define USE_SUBBLOCK/* #define XZ_DUMP */// #define XZ_DUMP/* XzDec.c -- Xz Decode
2021-09-04 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzEnc.hCXzEncHandleCXzPropsCXzFilterPropsforceWriteSizesInHeadercheckIdfilterPropslzma2PropsipDefinedXZ_PROPS__BLOCK_SIZE__SOLIDXZ_PROPS__BLOCK_SIZE__AUTO__XZ_ENC_HXz_EncodeEmptyXz_Encodeconst CXzPropsconst CXzProps *XzEnc_EncodeXzEnc_SetDataSizeXzEnc_SetPropsXzEnc_DestroyXzEnc_CreateXzProps_InitCXzProps *XzFilterProps_InitCXzFilterProps */* XzEnc.h -- Xz Encode
2017-06-27 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzEnc.c"XzEnc.h"xzIndexCXzEncIndex *(CXzStreamFlags)0const CXzEncIndexconst CXzEncIndex *xzCXzEnc *4611686018427387904(UInt64)1 << 62XzEncIndex_PreAlloc(&p->xzIndex, numBlocks, blockSize, XZ_GET_ESTIMATED_BLOCK_TOTAL_PACK_SIZE(blockSize), p->alloc)XzEncIndex_PreAlloc(&p->xzIndex, numBlocks, blockSize, (1024 + ((blockSize) + ((blockSize) >> 10) + 16 + 64)), p->alloc)Xz_WriteHeader((CXzStreamFlags)props->checkId, outStream)p->mtCoder.blockSizeMtCoder_Code(&p->mtCoder)Xz_CompressBlock( &p->lzmaf_Items[0], writeStartSizes ? NULL : outStream, writeStartSizes ? p->outBufs[0] : NULL, bufData, bufSize, inStream, NULL, 0, props, progress ? &progress2.vt : NULL, &inStreamFinished, &blockSizes, p->alloc, p->allocBig)Xz_CompressBlock( &p->lzmaf_Items[0], writeStartSizes ? ((void *)0) : outStream, writeStartSizes ? p->outBufs[0] : ((void *)0), bufData, bufSize, inStream, ((void *)0), 0, props, progress ? &progress2.vt : ((void *)0), &inStreamFinished, &blockSizes, p->alloc, p->allocBig)blockSizes.totalSizeWriteBytes(outStream, p->outBufs[0], blockSizes.headerSize)WriteBytes(outStream, bufData, (size_t)totalPackFull - blockSizes.headerSize)XzEncIndex_AddIndexRecord(&p->xzIndex, blockSizes.unpackSize, blockSizes.totalSize, p->alloc)writeStartSizesprogress2bufDatablockSizesinStreamFinishedCLzma2WithFilters *CXzEncBlockInfo *CLzma2WithFilters[64]totalPackFullXzEnc_MtCallback_Writeconst CXzEncBlockInfoconst CXzEncBlockInfo *bInfoCXzEncBlockInfo[76]WriteBytes(me->outStream, data, bInfo->headerSize)bInfo->totalSizeWriteBytes(me->outStream, data + XZ_BLOCK_HEADER_SIZE_MAX, (size_t)totalPackFull - bInfo->headerSize)WriteBytes(me->outStream, data + 1024, (size_t)totalPackFull - bInfo->headerSize)XzEnc_MtCallback_Code&progressThunksizeof(CXzEnc)20392XzEnc_FreeXzEnc_FreeOutBufsXzEnc_ConstructCompressProgress_XzEncOffset_ProgressCCompressProgress_XzEncOffsetconst CCompressProgress_XzEncOffsetconst CCompressProgress_XzEncOffset *CCompressProgress_XzEncOffset *Xz_CompressBlockcheckInStreamseqSizeOutStreamfilterIndexconst CXzFilterPropsconst CXzFilterProps *fpLzma2WithFilters_Create(lzmaf, alloc, allocBig)Lzma2Enc_SetProps(lzmaf->lzma2, &props->lzma2Props)&block1 + (fp ? 1 : 0)fp->ipXzBlock_WriteHeader(&block, &seqSizeOutStream.vt)CSeqCheckInStream *lzmafoutBufHeaderoutBufDataoutBufDataLimitSeqInFilter_Init(&lzmaf->filter, filter, alloc)CSeqInFilter *useStreamByte[68]unsigned char[68]4 + 64seqSizeOutStream.processedWriteBytes(&seqSizeOutStream.vt, buf + (4 - padSize), padSize + XzFlags_GetCheckSize((CXzStreamFlags)props->checkId))Lzma2WithFilters_FreeLzma2WithFilters_CreateLzma2WithFilters_ConstructXzProps_Normalizelzma2tpXzEncProps_Normalize_FixedSeqInFilter_FreebigAllocSeqInFilter_ConstructSeqInFilter_ReadCSeqInFiltersizeOriginalISeqInStream_Read(p->realStream, p->buf, &p->endPos)(p->realStream)->Read(p->realStream, p->buf, &p->endPos)&p->endPosFILTER_BUF_SIZESeqInFilter_Init(1 << 20)BraState_SetFromMethod(&p->StateCoder, props->id, 1, alloc)p->StateCoder.SetProps(p->StateCoder.p, props->props, props->propsSize, alloc)SeqSizeOutStream_WriteCSeqSizeOutStreamCSeqSizeOutStream *SeqCheckInStream_ReadCSeqCheckInStreamSeqCheckInStream_GetDigestSeqCheckInStream_InitXzEncIndex_WriteFooterglobalPos CRC_INIT_VALWriteBytesUpdateCrc(s, buf, pos, &crc)WriteBytesUpdateCrc(s, p->blocks, p->size, &crc)((crc) ^ 0xFFFFFFFF)buf + 8 + 4(UInt32)(globalPos >> 2)8 + 88 + 9CrcCalc(buf + 8 + 4, 6)8 + 108 + 11XzEncIndex_AddIndexRecordXzEncIndex_ReAlloc(p, newSize, alloc)16 * 2XzEncIndex_PreAllocnewSize64XzEncIndex_ReAlloccheckModeXzEncIndex_FreeXzEncIndex_InitXzEncIndex_ConstructXzBlock_WriteHeaderheader + posCrcCalc(header, pos)Xz_WriteHeaderByte[12]header + XZ_SIG_SIZE + XZ_STREAM_FLAGS_SIZEheader + 6 + 2WriteBytesUpdateCrcWriteBytesCXzEncCXzEncBlockInfoCLzma2WithFiltersCXzEncIndexEncBlockscheckTypelzmaf_ItemsxzPropsoutOffsetinOffsetendPosStateCoderoutBufLimitrealStreamFinishedallocatedXzBlock_SetHasUnpackSize(p)(p)->flags |= XZ_BF_UNPACK_SIZE;XzBlock_SetHasPackSize(p)(p)->flags |= XZ_BF_PACK_SIZE;XzBlock_SetNumFilters(p,n)(p)->flags = (Byte)((p)->flags | ((n) - 1));XzBlock_ClearFlags(p)(p)->flags = 0;XZ_GET_ESTIMATED_BLOCK_TOTAL_PACK_SIZE(unpackSize)(XZ_BLOCK_HEADER_SIZE_MAX + XZ_GET_MAX_BLOCK_PACK_SIZE(unpackSize))XZ_GET_MAX_BLOCK_PACK_SIZE(unpackSize)((unpackSize) + ((unpackSize) >> 10) + 16 + 64)XZ_GET_PAD_SIZE(dataSize)((4 - ((unsigned)(dataSize) & 3)) & 3)// g_Alloc// rem,// for GCC/*
      UInt64 rem = (UInt64)(Int64)-1;
      if (props->reduceSize != (UInt64)(Int64)-1
          && props->reduceSize >= progress2.inOffset)
        rem = props->reduceSize - progress2.inOffset;
      */// srcSize, // expectedSize// - (size_t)seqSizeOutStream.processed;//  + (size_t)seqSizeOutStream.processed;// useStream = True;/*
  if (expectedSize != (UInt64)(Int64)-1)
  {
    block.unpackSize = expectedSize;
    if (props->blockSize != (UInt64)(Int64)-1)
      if (expectedSize > props->blockSize)
        block.unpackSize = props->blockSize;
    XzBlock_SetHasUnpackSize(&block);
  }
  *//* only for inStream version */// used if (!inStream), it's block size, props->blockSize is ignored// used if (!inStream)// UInt64 expectedSize,/* ---------- CLzma2WithFilters ---------- */// we can use xz::reduceSize or xz::blockSize as base for lzmaProps::reduceSize// xz-fixed// fixed or solid, LZMA2_ENC_PROPS__BLOCK_SIZE__SOLID// fixed or solid//   we calculate block size for lzma2 and use that block size for xz, lzma2 uses single-chunk per block// if (xz-auto && (lzma2-auto || lzma2-fixed_)// if (xz-auto && lzma2-solid) - we use solid for both// xz-auto/* we normalize xzProps properties, but we normalize only some of CXzProps::lzma2Props properties.
     Lzma2Enc_SetProps() will normalize lzma2Props later. */// p->forceWriteSizesInHeader = 1;/* ---------- CXzProps ---------- *//* ---------- CSbEncInStream ---------- *//* ---------- CSeqInFilter ---------- *//* ---------- CSeqSizeOutStream ---------- *//* ---------- CSeqCheckInStream ---------- *//* max pack size for LZMA2 block + check-64bytrs: *//* XzEnc.c -- Xz Encode
2021-04-01 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/XzIn.cendOffsetILookInStream_Seek(stream, &endOffset, SZ_SEEK_END)(stream)->Seek(stream, &endOffset, SZ_SEEK_END)&endOffsetnewNum * sizeof(CXzStream)p->streamsLookInStream_SeekTo(stream, (UInt64)*startOffset)(UInt64)(endOffset - *startOffset)newNumsizeof(CXzStream)Xz_GetUnpackSize(&p->streams[i])Xz_ReadBackwardLookInStream_SeekRead_ForArc(stream, pos, buf, XZ_STREAM_FOOTER_SIZE)LookInStream_SeekRead_ForArc(stream, pos, buf, (2 + 2 + 4 + 4))buf + 10LookInStream_SeekRead_ForArc(stream, pos, temp, i)TEMP_BUF_SIZEp->flagsbuf_ptrLookInStream_SeekTo(stream, pos)Xz_ReadIndex(p, stream, indexSize, alloc)((UInt64)1 << 63)headerFlagssecToReadXz_ReadHeader(&headerFlags, &secToRead.vt)LookInStream_SeekRead_ForArcLookInStream_SeekTo(stream, offset)Xz_ReadIndex(UInt32)1 << 31Xz_ReadIndex2buf + sizenumBlocks64&numBlocks64sizeof(CXzBlockSizes) * numBlocks&block->totalSize&block->unpackSize(p->blocks[i].totalSize + 3) & ~(UInt64)3p->blocks[i].unpackSizeSeqInStream_ReadByte(inStream, &header[0])SeqInStream_Read(inStream, header + 1, headerSize - 1)sigSeqInStream_Read2(inStream, sig, XZ_STREAM_HEADER_SIZE, SZ_ERROR_NO_ARCHIVE)SeqInStream_Read2(inStream, sig, (6 + 2 + 4), 17)ADD_SIZE_CHECK(size,val){ UInt64 newSize = size + (val); if (newSize < size) return XZ_SIZE_OVERFLOW; size = newSize; }XZ_FOOTER_SIG_CHECK(p)((p)[0] == XZ_FOOTER_SIG_0 && (p)[1] == XZ_FOOTER_SIG_1)/*
UInt64 Xzs_GetPackSize(const CXzs *p)
{
  UInt64 size = 0;
  size_t i;
  for (i = 0; i < p->num; i++)
    ADD_SIZE_CHECK(size, Xz_GetTotalSize(&p->streams[i]));
  return size;
}
*//* ---------- Xz Streams ---------- *//* to eliminate GCC 6.3 warning:
       dereferencing type-punned pointer will break strict-aliasing rules *//* return LookInStream_Read2(stream, buf, size, SZ_ERROR_NO_ARCHIVE); *//*
SRes XzBlock_ReadFooter(CXzBlock *p, CXzStreamFlags f, ISeqInStream *inStream)
{
  return SeqInStream_Read(inStream, p->check, XzFlags_GetCheckSize(f));
}
*//*
#define XZ_FOOTER_SIG_CHECK(p) (memcmp((p), XZ_FOOTER_SIG, XZ_FOOTER_SIG_SIZE) == 0)
*//* XzIn.c - Xz input
2021-09-04 : Igor Pavlov : Public domain *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/brotli/port.hBROTLI_ENC_APIBROTLI_PUBLICBROTLI_DEC_APIBROTLI_COMMON_APIBROTLI_ARRAY_PARAM(name)(name)__attribute__ ((visibility ("default")))BROTLI_SANITIZEDBROTLI_HAS_FEATURE(feature)__has_feature(feature)BROTLI_GNUC_HAS_BUILTIN(builtin,major,minor,patch)__has_builtin(builtin)BROTLI_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch)__has_attribute(attribute)BROTLI_TINYC_VERSION_CHECK(major,minor,patch)(0)BROTLI_IAR_VERSION_CHECK(major,minor,patch)BROTLI_TI_VERSION_CHECK(major,minor,patch)BROTLI_IBM_VERSION_CHECK(major,minor,patch)BROTLI_ARM_VERSION_CHECK(major,minor,patch)BROTLI_SUNPRO_VERSION_CHECK(major,minor,patch)BROTLI_PGI_VERSION_CHECK(major,minor,patch)BROTLI_INTEL_VERSION_CHECK(major,minor,patch)BROTLI_MSVC_VERSION_CHECK(major,minor,patch)BROTLI_GNUC_VERSION_CHECK(major,minor,patch)(BROTLI_GNUC_VERSION >= BROTLI_MAKE_VERSION(major, minor, patch))BROTLI_GNUC_VERSIONBROTLI_MAKE_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)BROTLI_MAKE_VERSION(major,minor,revision)(((major) * 1000000) + ((minor) * 1000) + (revision))BROTLI_COMMON_PORT_H_defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)defined(BROTLI_GNUC_VERSION)defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000)defined(_MSC_FULL_VER)!defined(_MSC_VER)defined(_MSC_VER) && (_MSC_VER >= 1400)defined(_MSC_VER) && (_MSC_VER >= 1200)defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE)defined(BROTLI_INTEL_VERSION)defined(__PGI) && \defined(BROTLI_PGI_VERSION)defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)defined(__SUNPRO_C)defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)defined(__SUNPRO_CC)defined(BROTLI_SUNPRO_VERSION)defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)defined(__CC_ARM) && defined(__ARMCC_VERSION)defined(BROTLI_ARM_VERSION)defined(__ibmxl__)defined(__xlC__) && defined(__xlC_ver__)defined(__xlC__)defined(BROTLI_IBM_VERSION)defined(__TI_COMPILER_VERSION__)defined(BROTLI_TI_VERSION)defined(__IAR_SYSTEMS_ICC__)__VER__ > 1000defined(BROTLI_IAR_VERSION)defined(__TINYC__)defined(BROTLI_TINYC_VERSION)defined(__has_attribute)defined(__has_builtin)defined(__has_feature)defined(ADDRESS_SANITIZER) || BROTLI_HAS_FEATURE(address_sanitizer) || \defined(_WIN32) || defined(__CYGWIN__)BROTLI_GNUC_VERSION_CHECK(3, 3, 0) ||                         \defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \defined(BROTLI_SHARED_COMPILATION)defined(BROTLICOMMON_SHARED_COMPILATION)defined(BROTLIDEC_SHARED_COMPILATION)defined(BROTLIENC_SHARED_COMPILATION)BROTLI_SHARED_COMPILATION__GNUC_PATCHLEVEL__memory_sanitizerthread_sanitizeraddress_sanitizer/* BROTLI_COMMON_PORT_H_ *//* BROTLI_SHARED_COMPILATION *//* _WIN32 *//* BROTLIENC_SHARED_COMPILATION *//* BROTLIDEC_SHARED_COMPILATION *//* BROTLICOMMON_SHARED_COMPILATION *//* <<< <<< <<< end of hedley macros. *//* >>> >>> >>> hedley macros *//* The following macros were borrowed from https://github.com/nemequ/hedley
 * with permission of original author - Evan Nemerson <evan@nemerson.com> *//* Macros for compiler / platform specific API declarations. *//* Copyright 2016 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/brotli/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/platform.h<brotli/types.h><brotli/port.h>BrotliSuppressUnusedFunctionsunused&BrotliSuppressUnusedFunctions&BrotliUnalignedRead16&BrotliUnalignedRead32&BrotliUnalignedRead64&BrotliUnalignedWrite64&BROTLI_UNALIGNED_LOAD16LE&BROTLI_UNALIGNED_LOAD32LE&BROTLI_UNALIGNED_LOAD64LE&BROTLI_UNALIGNED_STORE64LE&BrotliRBit&brotli_min_double&brotli_max_double&brotli_min_float&brotli_max_float&brotli_min_int&brotli_max_int&brotli_min_size_t&brotli_max_size_t&brotli_min_uint32_t&brotli_max_uint32_t&brotli_min_uint8_t&brotli_max_uint8_t&BrotliDefaultAllocFunc&BrotliDefaultFreeFuncBrotliDefaultFreeFuncBrotliDefaultAllocFuncbrotli_max_uint8_tuint8_tbrotli_min_uint8_tbrotli_max_uint32_tuint32_tbrotli_min_uint32_tbrotli_max_size_tbrotli_min_size_tbrotli_max_intbrotli_min_intbrotli_max_floatfloatbrotli_min_floatbrotli_max_doublebrotli_min_doubleBrotliRBitBrotliUnalignedWrite64uint64_t *BrotliUnalignedRead64const uint64_tconst uint64_t *BrotliUnalignedRead32const uint32_tconst uint32_t *BrotliUnalignedRead16const uint16_tconst uint16_t *BROTLI_BSR32(x)(31u ^ (uint32_t)__builtin_clz(x))BROTLI_TZCNT64BROTLI_SWAP(T,A,I,J){ T __brotli_swap_tmp = (A)[(I)]; (A)[(I)] = (A)[(J)]; (A)[(J)] = __brotli_swap_tmp; }BROTLI_MAX(T,A,B)(brotli_max_ ## T((A), (B)))BROTLI_MIN(T,A,B)(brotli_min_ ## T((A), (B)))BROTLI_MIN_MAXBROTLI_MIN_MAX(T)static BROTLI_INLINE T brotli_min_ ## T (T a, T b) { return a < b ? a : b; } static BROTLI_INLINE T brotli_max_ ## T (T a, T b) { return a > b ? a : b; }BROTLI_UNUSED(X)(void)(X)BROTLI_REPEAT(N,X){ if ((N & 1) != 0) {X;} if ((N & 2) != 0) {X; X;} if ((N & 4) != 0) {X; X; X; X;} }BROTLI_DUMP()(void)(0)BROTLI_DCHECK(x)BROTLI_LOG(x)BROTLI_HAS_UBFX(!!0)BROTLI_IS_CONSTANT(x)(!!__builtin_constant_p(x))BROTLI_UNALIGNED_STORE64LEBROTLI_UNALIGNED_LOAD64LEBROTLI_UNALIGNED_LOAD32LEBROTLI_UNALIGNED_LOAD16LEBROTLI_ALIGNED_READBROTLI_BIG_ENDIANBROTLI_LITTLE_ENDIANbrotli_reg_tuint64_tBROTLI_64_BITSBROTLI_TARGET_X64BROTLI_ALIGNED(N)__attribute__((aligned(N)))BROTLI_UNUSED_FUNCTIONstatic BROTLI_INLINE __attribute__ ((unused))BROTLI_INTERNAL__attribute__ ((visibility ("hidden")))BROTLI_NOINLINE__attribute__((__noinline__))BROTLI_INLINEBROTLI_MAYBE_INLINE __attribute__((__always_inline__))BROTLI_MAYBE_INLINEinlineBROTLI_RESTRICTrestrictBROTLI_PREDICT_FALSE(x)(__builtin_expect(x, 0))BROTLI_PREDICT_TRUE(x)(__builtin_expect(!!(x), 1))BROTLI_COMMON_PLATFORM_H_defined(OS_LINUX) || defined(OS_CYGWIN) || defined(__EMSCRIPTEN__)defined(OS_FREEBSD)defined(OS_MACOSX)BROTLI_MSVC_VERSION_CHECK(12, 0, 0)defined(BROTLI_ENABLE_LOG) || defined(BROTLI_DEBUG)BROTLI_GNUC_HAS_BUILTIN(__builtin_expect, 3, 0, 0) || \BROTLI_GNUC_VERSION_CHECK(3, 1, 0) ||                         \BROTLI_SUNPRO_VERSION_CHECK(5, 3, 0) && !defined(__cplusplus)(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__) || \BROTLI_MSVC_VERSION_CHECK(12, 0, 0) || \BROTLI_GNUC_HAS_ATTRIBUTE(always_inline, 4, 0, 0) ||                       \BROTLI_TI_VERSION_CHECK(7, 0, 0) && defined(__cplusplus)BROTLI_IAR_VERSION_CHECK(8, 0, 0)BROTLI_GNUC_HAS_ATTRIBUTE(noinline, 4, 0, 0) ||                            \BROTLI_MSVC_VERSION_CHECK(13, 10, 0)BROTLI_PGI_VERSION_CHECK(10, 2, 0)BROTLI_TI_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)!defined(BROTLI_INTERNAL)BROTLI_GNUC_HAS_ATTRIBUTE(unused, 2, 7, 0) || \BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0)(defined(__ARM_ARCH) && (__ARM_ARCH == 7)) || \(defined(__ARM_ARCH) && (__ARM_ARCH == 8)) || \defined(__ARM_32BIT_STATE)defined(__ARM_64BIT_STATE)defined(__ARM_NEON__) || defined(__ARM_NEON)defined(__i386) || defined(_M_IX86)defined(__x86_64__) || defined(_M_X64)defined(__PPC64__)defined(__riscv) && defined(__riscv_xlen) && __riscv_xlen == 64defined(BROTLI_BUILD_64_BIT)defined(BROTLI_BUILD_32_BIT)defined(BROTLI_TARGET_X64) || defined(BROTLI_TARGET_ARMV8_64) || \(BROTLI_64_BITS)defined(BROTLI_BUILD_BIG_ENDIAN)defined(BROTLI_BUILD_LITTLE_ENDIAN)defined(BROTLI_BUILD_ENDIAN_NEUTRAL)defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)defined(_WIN32) || defined(BROTLI_TARGET_X64)defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)defined(BROTLI_X_BYTE_ORDER)BROTLI_X_BYTE_ORDER == BROTLI_X_LITTLE_ENDIANBROTLI_X_BYTE_ORDER == BROTLI_X_BIG_ENDIAN!defined(BROTLI_LITTLE_ENDIAN)!defined(BROTLI_BIG_ENDIAN)defined(BROTLI_BUILD_PORTABLE)defined(BROTLI_TARGET_X86) || defined(BROTLI_TARGET_X64) || \defined(__cplusplus)BROTLI_GNUC_HAS_BUILTIN(__builtin_constant_p, 3, 0, 1) || \defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_ANY)defined(BROTLI_ENABLE_LOG)defined(BROTLI_DEBUG) || defined(BROTLI_ENABLE_LOG)(BROTLI_GNUC_VERSION_CHECK(3, 0, 0) || defined(__llvm__)) && \!defined(BROTLI_RBIT)BROTLI_GNUC_HAS_BUILTIN(__builtin_ctzll, 3, 4, 0) || \defined(BROTLI_TARGET_X64)BROTLI_GNUC_HAS_BUILTIN(__builtin_clz, 3, 4, 0) || \defaultvisibility__builtin_expect__builtin_clzOS_LINUX/* BROTLI_COMMON_PLATFORM_H_ *//* Default brotli_free_func *//* Default brotli_alloc_func *//* __builtin_clz *//* BROTLI_64_BITS *//* __builtin_ctzll *//* BROTLI_TARGET_X64 *//* BROTLI_RBIT *//* Should break build if used. *//* gcc || clang *//* armv7 / armv8 *//* TODO: detect ARMv6T2 and enable this code for it. *//* TODO: add appropriate icc/sunpro/arm/ibm/ti checks. *//* BROTLI_IS_CONSTANT macros returns true for compile-time constants. *//* BROTLI_LITTLE_ENDIAN *//* Read / store values byte-wise; hopefully compiler will understand. *//* Explain compiler to byte-swap values. *//* Straight endianness. Just read / write values. *//* BROTLI_ALIGNED_READ *//* BROTLI_SANITIZED *//* BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0) *//* If __attribute__(aligned) is available, use that. Otherwise, memcpy. *//* Avoid emitting LDRD / STRD, which require properly aligned address. *//* __cplusplus *//* extern "C" *//* Consider we have an unaligned load/store of 4 bytes from address 0x...05.
   AddressSanitizer will treat it as a 3-byte access to the range 05:07 and
   will miss a bug if 08 is the first unaddressable byte.
   ThreadSanitizer will also treat this as a 3-byte access to 05:07 and will
   miss a race between this access and some other accesses to 08.
   MemorySanitizer will correctly propagate the shadow on unaligned stores
   and correctly report bugs on unaligned loads, but it may not properly
   update and report the origin of the uninitialized memory.
   For all three tools, replacing an unaligned access with a tool-specific
   callback solves the problem. *//* Unaligned memory access is allowed: just cast pointer to requested type. *//* Portable unaligned memory access: read / write values via memcpy. *//* Allow unaligned read only for white-listed CPUs. *//* BROTLI_X_BYTE_ORDER *//* Win32 & x64 can currently always be assumed to be little endian *//* Just break elif chain. *//* ARMv8 *//* ARMv7 *//* BROTLI_INTERNAL could be defined to override visibility, e.g. for tests. *//* Define "BROTLI_PREDICT_TRUE" and "BROTLI_PREDICT_FALSE" macros for capable
   compilers.

To apply compiler hint, enclose the branching condition into macros, like this:

  if (BROTLI_PREDICT_TRUE(zero == 0)) {
    // main execution path
  } else {
    // compiler should place this code outside of main execution path
  }

OR:

  if (BROTLI_PREDICT_FALSE(something_rare_or_unexpected_happens)) {
    // compiler should place this code outside of main execution path
  }

*//* Let's try and follow the Linux convention *//* memcpy *//* Macros for compiler / platform specific features and build options.

   Build options are:
    * BROTLI_BUILD_32_BIT disables 64-bit optimizations
    * BROTLI_BUILD_64_BIT forces to use 64-bit optimizations
    * BROTLI_BUILD_BIG_ENDIAN forces to use big-endian optimizations
    * BROTLI_BUILD_ENDIAN_NEUTRAL disables endian-aware optimizations
    * BROTLI_BUILD_LITTLE_ENDIAN forces to use little-endian optimizations
    * BROTLI_BUILD_PORTABLE disables dangerous optimizations, like unaligned
      read and overlapping memcpy; this reduces decompression speed by 5%
    * BROTLI_BUILD_NO_RBIT disables "rbit" optimization for ARM CPUs
    * BROTLI_DEBUG dumps file name and line number when decoder detects stream
      or memory error
    * BROTLI_ENABLE_LOG enables asserts and dumps various state information
*//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/commonopaque/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/constants.h"./platform.h"BrotliCalculateDistanceCodeLimit&BrotliCalculateDistanceCodeLimitBROTLI_NUM_DISTANCE_SHORT_CODESforbidden_distancendistbitshalfpostfix1uBrotliPrefixCodeRangeBrotliDistanceCodeLimitnbitsmax_distancemax_alphabet_sizeBROTLI_MAX_BACKWARD_LIMIT(W)(((size_t)1 << (W)) - BROTLI_WINDOW_GAP)BROTLI_WINDOW_GAPBROTLI_DISTANCE_CONTEXT_BITSBROTLI_LITERAL_CONTEXT_BITSBROTLI_NUM_INS_COPY_CODESBROTLI_MAX_ALLOWED_DISTANCE0x7FFFFFFCBROTLI_MAX_DISTANCE0x3FFFFFCBROTLI_NUM_DISTANCE_SYMBOLSBROTLI_DISTANCE_ALPHABET_SIZE( BROTLI_MAX_NDIRECT, BROTLI_MAX_NPOSTFIX, BROTLI_LARGE_MAX_DISTANCE_BITS)BROTLI_DISTANCE_ALPHABET_SIZE(NPOSTFIX,NDIRECT,MAXNBITS)( BROTLI_NUM_DISTANCE_SHORT_CODES + (NDIRECT) + ((MAXNBITS) << ((NPOSTFIX) + 1)))BROTLI_MAX_DISTANCE_BITS24UBROTLI_MAX_NDIRECTBROTLI_MAX_NPOSTFIXBROTLI_LARGE_MAX_WBITSBROTLI_LARGE_MIN_WBITSBROTLI_LARGE_MAX_DISTANCE_BITS62UBROTLI_INITIAL_REPEATED_CODE_LENGTHBROTLI_CODE_LENGTH_CODES(BROTLI_REPEAT_ZERO_CODE_LENGTH + 1)BROTLI_REPEAT_ZERO_CODE_LENGTHBROTLI_REPEAT_PREVIOUS_CODE_LENGTHBROTLI_MAX_BLOCK_TYPE_SYMBOLS(BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + 2)BROTLI_MAX_CONTEXT_MAP_SYMBOLS(BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + BROTLI_CONTEXT_MAP_MAX_RLE)BROTLI_NUM_BLOCK_LEN_SYMBOLSBROTLI_NUM_COMMAND_SYMBOLS704BROTLI_NUM_LITERAL_SYMBOLSBROTLI_MAX_NUMBER_OF_BLOCK_TYPESBROTLI_CONTEXT_MAP_MAX_RLEBROTLI_COMMON_CONSTANTS_H_const BrotliPrefixCodeRangeconst BrotliPrefixCodeRange[26]struct <unnamed>[26]_kBrotliPrefixCodeRanges/* BROTLI_COMMON_CONSTANTS_H_ *//* "Soft-private", it is exported, but not "advertised" as API. *//* Represents the range of values belonging to a prefix code:
   [offset, offset + 2^nbits) *//* Calculate the maximal distance representable by alphabet. *//* Calculate the alphabet size. *//* Move to subregion. *//* Calculate region start. NB: ndistbits >= 1. *//* The last available distance in the subrange has all extra bits set. *//* After group was decremented, ndistbits and half must be recalculated. *//* Decrement "group", so it is the last permitted "group". *//* This case is added for correctness; does not occur for limit > 128. *//* Calculated "group" covers the prohibited distance value. *//* Calculate the "group" part of dcode. *//* Find subrange. *//* One bit is covered with subrange addressing ("half"). *//* Poor-man's log2floor, to avoid extra dependencies. *//* Calculate the number of distance bits. *//* Remove postfix and "head-start". *//* Postfix for the last dcode in the group. *//* Subtract "directly" encoded region. *//* The first prohibited value. *//* This case never happens / exists only for the sake of completeness. *//* Marking this function as unused, because not all files
     including "constants.h" use it -> compiler warns about that. *//* This function calculates maximal size of distance alphabet, such that the
   distances greater than the given values can not be represented.

   This limits are designed to support fast and safe 32-bit decoders.
   "32-bit" means that signed integer values up to ((1 << 31) - 1) could be
   safely expressed.

   Brotli distance alphabet symbols do not represent consecutive distance
   ranges. Each distance alphabet symbol (excluding direct distances and short
   codes), represent interleaved (for NPOSTFIX > 0) range of distances.
   A "group" of consecutive (1 << NPOSTFIX) symbols represent non-interleaved
   range. Two consecutive groups require the same amount of "extra bits".

   It is important that distance alphabet represents complete "groups".
   To avoid complex logic on encoder side about interleaved ranges
   it was decided to restrict both sides to complete distance code "groups".
 *//* Number of slack bytes for window size. Don't confuse
   with BROTLI_NUM_DISTANCE_SHORT_CODES. *//* 9.1. Format of the Stream Header *//* 7.2. Context ID for distances *//* "context IDs for literals are in the range of 0..63" *//* 7.1. Context modes and context ID lookup for literals *//* Specification: 4. Encoding of Literal Insertion Lengths and Copy Lengths *//* ((1 << 31) - 4) is the safe distance limit. Using this number as a limit
   allows safe distance calculation without overflows, given the distance
   alphabet size is limited to corresponding size
   (see kLargeWindowDistanceCodeLimits). *//* ((1 << 26) - 4) is the maximal distance that can be expressed in RFC 7932
   brotli stream using NPOSTFIX = 0 and NDIRECT = 0. With other NPOSTFIX and
   NDIRECT values distances up to ((1 << 29) + 88) could be expressed. *//* BROTLI_NUM_DISTANCE_SYMBOLS == 1128 *//**
 * Maximal number of "postfix" bits.
 *
 * Number of "postfix" bits is stored as 2 bits in meta-block header.
 *//* Specification: 4. Encoding of distances *//**
 * The maximum supported large brotli window bits by the encoder and decoder.
 * Large window brotli allows up to 62 bits, however the current encoder and
 * decoder, designed for 32-bit integers, only support up to 30 bits maximum.
 *//**
 * The theoretical maximum number of distance bits specified for large window
 * brotli, for 64-bit encoders and decoders. Even when in practice 32-bit
 * encoders and decoders only support up to 30 max distance bits, the value is
 * set to 62 because it affects the large window brotli file format.
 * Specifically, it affects the encoding of simple huffman tree for distances,
 * see Specification RFC 7932 chapter 3.4.
 *//* "Large Window Brotli" *//* "code length of 8 is repeated" *//* Specification: 3.5. Complex prefix codes *//* Specification: 3.3. Alphabet sizes: insert-and-copy length *//* Specification: 2. Compressed representation overview *//* Specification: 7.3. Encoding of the context map *//**
 * @file
 * Common constants used in decoder and encoder API.
 */npostfixndirect/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/brotli/types.h/usr/lib/gcc/x86_64-redhat-linux/12/include/stdint.h/usr/include/stdint.h/usr/include/bits/wchar.h/usr/include/bits/stdint-uintn.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/constants.c"./constants.h"305369497753126522894337843316625/* Copyright 2013 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/max_align_twchar_tptrdiff_t__max_align_ld__alignof__(long double)__max_align_ll__alignof__(long long)offsetof(TYPE,MEMBER)__builtin_offsetof (TYPE, MEMBER)__need_ptrdiff_t_ANSI_STDDEF_H_STDDEF_H_long int/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/context.hconst uint8_tconst uint8_t *ContextLutContextTypeCONTEXT_LSB6CONTEXT_MSB6CONTEXT_UTF8CONTEXT_SIGNEDBROTLI_CONTEXT(P1,P2,LUT)((LUT)[P1] | ((LUT) + 256)[P2])BROTLI_CONTEXT_LUT(MODE)(&_kBrotliContextLookupTable[(MODE) << 9])BROTLI_COMMON_CONTEXT_H_const uint8_t[2048]unsigned char[2048]_kBrotliContextLookupTable/* BROTLI_COMMON_CONTEXT_H_ *//* typeof(LUT) == ContextLut *//* typeof(MODE) == ContextType; returns ContextLut *//* Common context lookup table for all context modes. *//* Lookup table to map the previous two bytes to a context id.

  There are four different context modeling modes defined here:
    CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,
    CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,
    CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,
    CONTEXT_SIGNED: second-order context model tuned for signed integers.

  If |p1| and |p2| are the previous two bytes, and |mode| is current context
  mode, we calculate the context as:

    context = ContextLut(mode)[p1] | ContextLut(mode)[p2 + 256].

  For CONTEXT_UTF8 mode, if the previous two bytes are ASCII characters
  (i.e. < 128), this will be equivalent to

    context = 4 * context1(p1) + context2(p2),

  where context1 is based on the previous byte in the following way:

    0  : non-ASCII control
    1  : \t, \n, \r
    2  : space
    3  : other punctuation
    4  : " '
    5  : %
    6  : ( < [ {
    7  : ) > ] }
    8  : , ; :
    9  : .
    10 : =
    11 : number
    12 : upper-case vowel
    13 : upper-case consonant
    14 : lower-case vowel
    15 : lower-case consonant

  and context2 is based on the second last byte:

    0 : control, space
    1 : punctuation
    2 : upper-case letter, number
    3 : lower-case letter

  If the last byte is ASCII, and the second last byte is not (in a valid UTF8
  stream it will be a continuation byte, value between 128 and 191), the
  context is the same as if the second last byte was an ASCII control or space.

  If the last byte is a UTF8 lead byte (value >= 192), then the next byte will
  be a continuation byte and the context id is 2 or 3 depending on the LSB of
  the last byte and to a lesser extent on the second last byte if it is ASCII.

  If the last byte is a UTF8 continuation byte, the second last byte can be:
    - continuation byte: the next byte is probably ASCII or lead byte (assuming
      4-byte UTF8 characters are rare) and the context id is 0 or 1.
    - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1
    - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3

  The possible value combinations of the previous two bytes, the range of
  context ids and the type of the next byte is summarized in the table below:

  |--------\-----------------------------------------------------------------|
  |         \                         Last byte                              |
  | Second   \---------------------------------------------------------------|
  | last byte \    ASCII            |   cont. byte        |   lead byte      |
  |            \   (0-127)          |   (128-191)         |   (192-)         |
  |=============|===================|=====================|==================|
  |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |
  |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |
  |-------------|-------------------|---------------------|------------------|
  |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |
  |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |
  |-------------|-------------------|---------------------|------------------|
  |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |
  |  (192-207)  |                   |  context: 0 - 1     |                  |
  |-------------|-------------------|---------------------|------------------|
  |  lead byte  | not valid         |  next: cont.        |  not valid       |
  |  (208-)     |                   |  context: 2 - 3     |                  |
  |-------------|-------------------|---------------------|------------------|
*//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/context.c"./context.h"/* CONTEXT_SIGNED, second last byte. *//* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. *//* UTF8 lead byte range. *//* UTF8 continuation byte range. *//* ASCII range. *//* CONTEXT_UTF8 second last byte. *//* CONTEXT_UTF8, last byte. *//* CONTEXT_MSB6, second last byte, *//* CONTEXT_MSB6, last byte. *//* CONTEXT_LSB6, second last byte, *//* CONTEXT_LSB6, last byte. */<stdint.h>brotli_free_funcbrotli_alloc_funcBROTLI_SIZE_MAX(~((size_t)0))BROTLI_UINT32_MAX(~((uint32_t)0))BROTLI_MAKE_UINT64_T(high,low)((((uint64_t)(high)) << 32) | low)TO_BROTLI_BOOL(X)(!!(X) ? BROTLI_TRUE : BROTLI_FALSE)BROTLI_FALSEBROTLI_TRUEBROTLI_BOOLBROTLI_COMMON_TYPES_H_defined(_MSC_VER) && (_MSC_VER < 1600)/* BROTLI_COMMON_TYPES_H_ *//**
 * Deallocating function pointer type.
 *
 * This function @b SHOULD do nothing if @p address is @c 0.
 *
 * @param opaque custom memory manager handle provided by client
 * @param address memory region pointer returned by ::brotli_alloc_func, or @c 0
 *//**
 * Allocating function pointer type.
 *
 * @param opaque custom memory manager handle provided by client
 * @param size requested memory region size; can not be @c 0
 * @returns @c 0 in the case of failure
 * @returns a valid pointer to a memory region of at least @p size bytes
 *          long otherwise
 *//** @c bool to ::BROTLI_BOOL conversion macros. *//** Portable @c false replacement. *//** Portable @c true replacement. *//**
 * A portable @c bool replacement.
 *
 * ::BROTLI_BOOL is a "documentation" type: actually it is @c int, but in API it
 * denotes a type, whose only values are ::BROTLI_TRUE and ::BROTLI_FALSE.
 *
 * ::BROTLI_BOOL values passed to Brotli should either be ::BROTLI_TRUE or
 * ::BROTLI_FALSE, or be a result of ::TO_BROTLI_BOOL macros.
 *
 * ::BROTLI_BOOL values returned by Brotli should not be tested for equality
 * with @c true, @c false, ::BROTLI_TRUE, ::BROTLI_FALSE, but rather should be
 * evaluated, for example: @code{.cpp}
 * if (SomeBrotliFunction(encoder, BROTLI_TRUE) &&
 *     !OtherBrotliFunction(decoder, BROTLI_FALSE)) {
 *   bool x = !!YetAnotherBrotliFunction(encoder, TO_BROLTI_BOOL(2 * 2 == 4));
 *   DoSomething(x);
 * }
 * @endcode
 *//* defined(_MSC_VER) && (_MSC_VER < 1600) *//* for size_t *//**
 * @file
 * Common types used in decoder and encoder API.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/dictionary.hBrotliDictionarydata_sizeuint32_t[32]unsigned int[32]offsets_by_lengthuint8_t[32]size_bits_by_lengthBROTLI_MAX_DICTIONARY_WORD_LENGTHBROTLI_MIN_DICTIONARY_WORD_LENGTHBROTLI_COMMON_DICTIONARY_H_defined(__cplusplus) || defined(c_plusplus)BrotliSetDictionaryDataconst BrotliDictionaryconst BrotliDictionary *BrotliDictionary *BrotliGetDictionary/* BROTLI_COMMON_DICTIONARY_H_ *//**
 * Sets dictionary data.
 *
 * When dictionary data is already set / present, this method is no-op.
 *
 * Dictionary data MUST be provided before BrotliGetDictionary is invoked.
 * This method is used ONLY in multi-client environment (e.g. C + Java),
 * to reduce storage by sharing single dictionary between implementations.
 *//* Data array is not bound, and should obey to size_bits_by_length values.
     Specified size matches default (RFC 7932) dictionary. Its size is
     defined by data_size *//* assert(data_size == offsets_by_length[31]) *//* assert(offset[i + 1] == offset[i] + (bits[i] ? (i << bits[i]) : 0)) *//**
   * Number of bits to encode index of dictionary word in a bucket.
   *
   * Specification: Appendix A. Static Dictionary Data
   *
   * Words in a dictionary are bucketed by length.
   * @c 0 means that there are no words of a given length.
   * Dictionary consists of words with length of [4..24] bytes.
   * Values at [0..3] and [25..31] indices should not be addressed.
   *//* Collection of static dictionary words. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/dictionary.c"./dictionary.h"kBrotliDictionary92162150435840440325324863488747528704093696100864104704106752108928113536115968118528119872121280122016122784const uint8_t[122784]unsigned char[122784]const uint8_t[]unsigned char[]kBrotliDictionaryData!defined(BROTLI_EXTERNAL_DICTIONARY_DATA)defined(BROTLI_EXTERNAL_DICTIONARY_DATA)// Appease -Werror=unused-parameter/* data *//* data_size ==  sizeof(kBrotliDictionaryData) *//* offsets_by_length *//* size_bits_by_length *//* !BROTLI_EXTERNAL_DICTIONARY_DATA *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/platform.c/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/transform.hBrotliTransformsBrotliWordTransformTypeBROTLI_TRANSFORM_IDENTITYBROTLI_TRANSFORM_OMIT_LAST_1BROTLI_TRANSFORM_OMIT_LAST_2BROTLI_TRANSFORM_OMIT_LAST_3BROTLI_TRANSFORM_OMIT_LAST_4BROTLI_TRANSFORM_OMIT_LAST_5BROTLI_TRANSFORM_OMIT_LAST_6BROTLI_TRANSFORM_OMIT_LAST_7BROTLI_TRANSFORM_OMIT_LAST_8BROTLI_TRANSFORM_OMIT_LAST_9BROTLI_TRANSFORM_UPPERCASE_FIRSTBROTLI_TRANSFORM_UPPERCASE_ALLBROTLI_TRANSFORM_OMIT_FIRST_1BROTLI_TRANSFORM_OMIT_FIRST_2BROTLI_TRANSFORM_OMIT_FIRST_3BROTLI_TRANSFORM_OMIT_FIRST_4BROTLI_TRANSFORM_OMIT_FIRST_5BROTLI_TRANSFORM_OMIT_FIRST_6BROTLI_TRANSFORM_OMIT_FIRST_7BROTLI_TRANSFORM_OMIT_FIRST_8BROTLI_TRANSFORM_OMIT_FIRST_9BROTLI_TRANSFORM_SHIFT_FIRSTBROTLI_TRANSFORM_SHIFT_ALLBROTLI_NUM_TRANSFORM_TYPESint16_t[10]signed short[10]BROTLI_TRANSFORMS_MAX_CUT_OFFcutOffTransformsparamstransformsnum_transformsprefix_suffix_mapprefix_suffixprefix_suffix_sizeBROTLI_TRANSFORM_SUFFIX(T,I)(&(T)->prefix_suffix[ (T)->prefix_suffix_map[BROTLI_TRANSFORM_SUFFIX_ID(T, I)]])BROTLI_TRANSFORM_PREFIX(T,I)(&(T)->prefix_suffix[ (T)->prefix_suffix_map[BROTLI_TRANSFORM_PREFIX_ID(T, I)]])BROTLI_TRANSFORM_SUFFIX_ID(T,I)((T)->transforms[((I) * 3) + 2])BROTLI_TRANSFORM_TYPE(T,I)((T)->transforms[((I) * 3) + 1])BROTLI_TRANSFORM_PREFIX_ID(T,I)((T)->transforms[((I) * 3) + 0])BROTLI_COMMON_TRANSFORM_H_BrotliTransformDictionaryWorduint8_t *const BrotliTransformsconst BrotliTransforms *BrotliTransforms *BrotliGetTransforms/* BROTLI_COMMON_TRANSFORM_H_ *//* T is BrotliTransforms*; result is const uint8_t*. *//* T is BrotliTransforms*; result is uint8_t. *//* Indices of transforms like ["", BROTLI_TRANSFORM_OMIT_LAST_#, ""].
     0-th element corresponds to ["", BROTLI_TRANSFORM_IDENTITY, ""].
     -1, if cut-off transform does not exist. *//* Shift for BROTLI_TRANSFORM_SHIFT_FIRST and BROTLI_TRANSFORM_SHIFT_ALL,
     must be NULL if and only if no such transforms are present. *//* Each entry is a [prefix_id, transform, suffix_id] triplet. *//* Last character must be null, so prefix_suffix_size must be at least 1. *//* Counts transforms, not a transform itself. *//* transforms is a part of ABI, but not API.

   It means that there are some functions that are supposed to be in "common"
   library, but header itself is not placed into include/brotli. This way,
   aforementioned functions will be available only to brotli internals.
 */dstwordtransform_idx/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/transform.c"./transform.h"idxprefixtypesuffixprefix_lenBROTLI_TRANSFORM_OMIT_FIRST_1 - 1(BROTLI_TRANSFORM_OMIT_FIRST_1 - 1)uppercase8usuffix_lenscalar0x7FFFu0x1000000u0x8000u0x7Fu0x3Fu0x1Fu6u0x0Fu12u0x07u18uToUpperCase'a'kBrotliTransformsconst char[217]char[217]sizeof(kPrefixSuffix)const uint16_t[50]unsigned short[50]const uint8_t[363]unsigned char[363]363sizeof(kTransformsData)sizeof(kTransformsData[0])3 * sizeof(kTransformsData[0])(3 * sizeof(kTransformsData[0]))sizeof(kTransformsData) / (3 * sizeof(kTransformsData[0]))kTransformsDatakPrefixSuffixMapword_lenparameterkPrefixSuffix ,  of the  of s . and  in " to ">
. ] for  a  that ' with  from  by (. The  on  as  is ing 
	:ed =" at ly ,='.com/. This  not er al ful ive less est ize ous  the e "\1 \2, \10 of the \4 of \2s \1.\5 and \4 "
/* 0x  _0 _2  __5        _E    _3  _6 _8     _E */
      "in \1\"\4 to \2\">\1\n\2. \1]\5 for \3 a \6 "
/* 2x     _3_ _5    _A_  _D_ _F  _2 _4     _A   _E */
      "that \1\'\6 with \6 from \4 by \1(\6. T"
/* 4x       _5_ _7      _E      _5    _A _C */
      "he \4 on \4 as \4 is \4ing \2\n\t\1:\3ed "
/* 6x     _3    _8    _D    _2    _7_ _ _A _C */
      "\2=\"\4 at \3ly \1,\2=\'\5.com/\7. This \5"
/* 8x  _0 _ _3    _8   _C _E _ _1     _7       _F */
      " not \3er \3al \4ful \4ive \5less \4es"
/* Ax       _5   _9   _D    _2    _7     _D */
      "t \4ize \2\xc2\xa0\4ous \5 the \2e "/* 4-byte rune / 11110sss AAssssss BBssssss CCssssss / 21 bit scalar. *//* 3-byte rune / 1110ssss AAssssss BBssssss / 16 bit scalar. *//* 2-byte rune / 110sssss AAssssss / 11 bit scalar. *//* Continuation / 10AAAAAA. *//* 1-byte rune / 0sssssss / 7 bit scalar (ASCII). *//* Limited sign extension: scalar < (1 << 24). *//* An arbitrary transform for three byte characters. *//* An overly simplified uppercasing model for UTF-8. *//* no extra parameters *//* RFC 7932 transforms *//* Cx    _2    _7___ ___ _A    _F     _5        _8 *//* \0 - implicit trailing zero. *//* Ax       _5   _9   _D    _2    _7     _D *//* 8x  _0 _ _3    _8   _C _E _ _1     _7       _F *//* 6x     _3    _8    _D    _2    _7_ _ _A _C *//* 4x       _5_ _7      _E      _5    _A _C *//* 2x     _3_ _5    _A_  _D_ _F  _2 _4     _A   _E *//* 0x  _0 _2  __5        _E    _3  _6 _8     _E *//* RFC 7932 transforms string data *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/bit_reader.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/bit_reader.c"../common/platform.h""./bit_reader.h"BrotliSafeReadBits32SlowBrotliBitReader *BrotliBitReader *constuint32_t *low_valhigh_valmementoBrotliBitReaderState *n_bits <= 32n_bits > 24BrotliWarmupBitReaderaligned_read_masksizeof(br->val_)sizeof(br->val_) >> 1(sizeof(br->val_) >> 1)(sizeof(br->val_) >> 1) - 1!BROTLI_ALIGNED_READconst BrotliBitReaderconst BrotliBitReader *BrotliInitBitReadersizeof(br->val_) << 3const uint32_t[33]unsigned int[33]kBrotliBitMask0x000000000x000000010x000000030x000000070x0000000F0x0000001F0x0000003F0x0000007F0x000000FF0x000001FF0x000003FF0x000007FF0x00000FFF81910x00001FFF0x00003FFF0x00007FFF0x0000FFFF1310710x0001FFFF0x0003FFFF5242870x0007FFFF0x000FFFFF0x001FFFFF0x003FFFFF83886070x007FFFFF1342177270x07FFFFFF2684354550x0FFFFFFF5368709110x1FFFFFFF0x3FFFFFFF0x7FFFFFFF/* If we consumed all the input, we don't care about the alignment. *//* Fixing alignment after unaligned BrotliFillWindow would result accumulator
     overflow. If unalignment is caused by BrotliSafeReadBits, then there is
     enough space in accumulator to fix alignment. *//* Bit reading helpers *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/decbrn_bits"../common/constants.h"BrotliCopyBytesBrotliJumpToByteBoundarypad_bits_countpad_bitspad_bits == 0BrotliSafeReadBits32BrotliSafeReadBitsn_bits <= 24BrotliReadBits32BrotliReadBits24BrotliTakeBits("[BrotliTakeBits]  %d %d %d val: %6x\n", (int)br->avail_in, (int)br->bit_pos_, (int)n_bits, (int)*val)BrotliBitReaderUnloadunused_bytesunused_bitsBrotliDropBitsBrotliSafeGetBitsBrotliGetBitsBrotliGet16BitsUnmaskedBrotliGetBitsUnmaskedBrotliPullByteBrotliFillBitWindow16BrotliFillBitWindowBROTLI_SHORT_FILL_BIT_WINDOW_READBrotliCheckInputAmountbr->avail_in >= numBrotliGetRemainingByteskCap(size_t)1 << BROTLI_LARGE_MAX_WBITSBrotliGetAvailableBits(BROTLI_64_BITS ? 64 : 32)BrotliBitReaderRestoreStateBrotliBitReaderSaveStateBitMask0xFFFFFFFFu(0xFFFFFFFFu)BrotliBitReaderStateBrotliBitReaderavail_innext_inbit_pos_val_(sizeof(brotli_reg_t) >> 1)BROTLI_DEC_BIT_READER_H_hiddenchar[7]/* BROTLI_DEC_BIT_READER_H_ *//* Copies remaining input bytes stored in the bit reader to the output. Value
   |num| may not be larger than BrotliGetRemainingBytes. The bit reader must be
   warmed up again after this. *//* Advances the bit reader position to the next byte boundary and verifies
   that any skipped bits are set to zero. *//* Same as BrotliSafeReadBits, but allows reading up to 32 bits. *//* Tries to read the specified amount of bits. Returns BROTLI_FALSE, if there
   is not enough input. |n_bits| MUST be positive.
   Up to 24 bits are allowed to be requested from this method. *//* Same as BrotliReadBits24, but allows reading up to 32 bits. *//* Reads the specified number of bits from |br| and advances the bit pos.
   Assumes that there is enough input to perform BrotliFillBitWindow.
   Up to 24 bits are allowed to be requested from this method. *//* Reads the specified number of bits from |br| and advances the bit pos.
   Precondition: accumulator MUST contain at least |n_bits|. *//* Advances the bit pos by |n_bits|. *//* Tries to peek the specified amount of bits. Returns BROTLI_FALSE, if there
   is not enough input. *//* Returns the specified number of bits from |br| without advancing bit
   position. *//* Like BrotliGetBits, but does not mask the result.
   The result contains at least 16 valid bits. *//* Returns currently available bits.
   The number of valid bits could be calculated by BrotliGetAvailableBits. *//* Tries to pull one byte of input to accumulator.
   Returns BROTLI_FALSE if there is no input available. *//* Mostly like BrotliFillBitWindow, but guarantees only 16 bits and reads no
   more than BROTLI_SHORT_FILL_BIT_WINDOW_READ bytes of input. *//* here same as -= 16 because of the if condition *//* here same as -= 24 because of the if condition *//* here same as -= 32 because of the if condition *//* here same as -= 48 because of the if condition *//* here same as -= 56 because of the if condition *//* Guarantees that there are at least |n_bits| + 1 bits in accumulator.
   Precondition: accumulator contains at least 1 bit.
   |n_bits| should be in the range [1..24] for regular build. For portable
   non-64-bit little-endian build only 16 bits are safe to request. *//* Checks if there is at least |num| bytes left in the input ring-buffer
   (excluding the bits remaining in br->val_). *//* Returns amount of unread bytes the bit reader still has buffered from the
   BrotliInput, including whole bytes in br->val_. Result is capped with
   maximal ring-buffer size (larger number won't be utilized anyway). *//* Fallback for BrotliSafeReadBits32. Extracted as noninlined method to unburden
   the main code-path. Never called for RFC brotli streams, required only for
   "large-window" mode and other extensions. *//* Ensures that accumulator is not empty.
   May consume up to sizeof(brotli_reg_t) - 1 bytes of input.
   Returns BROTLI_FALSE if data is required but there is no input available.
   For BROTLI_ALIGNED_READ this function also prepares bit reader for aligned
   reading. *//* Initializes the BrotliBitReader fields. *//* the byte we're reading from *//* current bit-reading position in val_ *//* pre-fetched bits *//* Masking with this expression turns to a single
       "Unsigned Bit Field Extract" UBFX instruction on ARM. */tofrom/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/brotli/decode.hBrotliDecoderParameterBROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATIONBROTLI_DECODER_PARAM_LARGE_WINDOWBrotliDecoderErrorCodeBROTLI_DECODER_NO_ERRORBROTLI_ERROR_CODE_ENUM_ITEM_BROTLI_COMMA_BROTLI_DECODER_SUCCESSBROTLI_DECODER_NEEDS_MORE_INPUTBROTLI_DECODER_NEEDS_MORE_OUTPUTBROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLEBROTLI_DECODER_ERROR_FORMAT_RESERVEDBROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLEBROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABETBROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME-5BROTLI_DECODER_ERROR_FORMAT_CL_SPACE-6BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE-7BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEATBROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1-9BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2-10BROTLI_DECODER_ERROR_FORMAT_TRANSFORM-11BROTLI_DECODER_ERROR_FORMAT_DICTIONARY-12BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS-13BROTLI_DECODER_ERROR_FORMAT_PADDING_1-14BROTLI_DECODER_ERROR_FORMAT_PADDING_2-15BROTLI_DECODER_ERROR_FORMAT_DISTANCE-16BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET-19BROTLI_DECODER_ERROR_INVALID_ARGUMENTS-20BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES-21BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS-22BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP-25BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1-26BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2-27BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES-30BROTLI_DECODER_ERROR_UNREACHABLE-31BrotliDecoderResultBROTLI_DECODER_RESULT_ERRORBROTLI_DECODER_RESULT_SUCCESSBROTLI_DECODER_RESULT_NEEDS_MORE_INPUTBROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUTBrotliDecoderStateBROTLI_LAST_ERROR_CODEBROTLI_ERROR_CODE_ENUM_ITEM_(PREFIX,NAME,CODE)BROTLI_DECODER ## PREFIX ## NAME = CODEBROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE,SEPARATOR)BROTLI_ERROR_CODE(_, NO_ERROR, 0) SEPARATOR BROTLI_ERROR_CODE(_, SUCCESS, 1) SEPARATOR BROTLI_ERROR_CODE(_, NEEDS_MORE_INPUT, 2) SEPARATOR BROTLI_ERROR_CODE(_, NEEDS_MORE_OUTPUT, 3) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, EXUBERANT_NIBBLE, -1) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, RESERVED, -2) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, EXUBERANT_META_NIBBLE, -3) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, SIMPLE_HUFFMAN_ALPHABET, -4) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, SIMPLE_HUFFMAN_SAME, -5) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, CL_SPACE, -6) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, HUFFMAN_SPACE, -7) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, CONTEXT_MAP_REPEAT, -8) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, BLOCK_LENGTH_1, -9) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, BLOCK_LENGTH_2, -10) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, TRANSFORM, -11) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, DICTIONARY, -12) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, WINDOW_BITS, -13) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, PADDING_1, -14) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, PADDING_2, -15) SEPARATOR BROTLI_ERROR_CODE(_ERROR_FORMAT_, DISTANCE, -16) SEPARATOR BROTLI_ERROR_CODE(_ERROR_, DICTIONARY_NOT_SET, -19) SEPARATOR BROTLI_ERROR_CODE(_ERROR_, INVALID_ARGUMENTS, -20) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, CONTEXT_MODES, -21) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, TREE_GROUPS, -22) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, CONTEXT_MAP, -25) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, RING_BUFFER_1, -26) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, RING_BUFFER_2, -27) SEPARATOR BROTLI_ERROR_CODE(_ERROR_ALLOC_, BLOCK_TYPE_TREES, -30) SEPARATOR BROTLI_ERROR_CODE(_ERROR_, UNREACHABLE, -31)BROTLI_DEC_DECODE_H_BrotliDecoderVersionBrotliDecoderErrorStringBrotliDecoderGetErrorCodeconst BrotliDecoderStateInternalconst BrotliDecoderStateInternal *BrotliDecoderStateStruct *const BrotliDecoderStateconst BrotliDecoderState *BrotliDecoderIsFinishedBrotliDecoderIsUsedBrotliDecoderTakeOutputBrotliDecoderStateInternal *BrotliDecoderState *BrotliDecoderHasMoreOutputBrotliDecoderDecompressStreamconst uint8_t **uint8_t **BrotliDecoderDecompressuint8_t[]BrotliDecoderDestroyInstanceBrotliDecoderCreateInstanceBrotliDecoderSetParameterBrotliDecoderStateStruct*decoded_sizeencoded_size_ERROR_UNREACHABLE_ERROR_ALLOC_BLOCK_TYPE_TREESRING_BUFFER_2RING_BUFFER_1CONTEXT_MAPTREE_GROUPSCONTEXT_MODESINVALID_ARGUMENTSDICTIONARY_NOT_SET_ERROR_FORMAT_DISTANCEPADDING_2PADDING_1WINDOW_BITSDICTIONARYTRANSFORMBLOCK_LENGTH_2BLOCK_LENGTH_1CONTEXT_MAP_REPEATHUFFMAN_SPACECL_SPACESIMPLE_HUFFMAN_SAMESIMPLE_HUFFMAN_ALPHABETEXUBERANT_META_NIBBLERESERVEDEXUBERANT_NIBBLE_NEEDS_MORE_OUTPUTNEEDS_MORE_INPUTSUCCESSNO_ERROR/* BROTLI_DEC_DECODE_H_ *//**
 * Gets a decoder library version.
 *
 * Look at BROTLI_VERSION for more information.
 *//**
 * Converts error code to a c-string.
 *//**
 * Acquires a detailed error code.
 *
 * Should be used only after ::BrotliDecoderDecompressStream returns
 * ::BROTLI_DECODER_RESULT_ERROR.
 *
 * See also ::BrotliDecoderErrorString
 *
 * @param state decoder instance
 * @returns last saved error code
 *//**
 * Checks if decoder instance reached the final state.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE if decoder is in a state where it reached the end of
 *          the input and produced all of the output
 * @returns ::BROTLI_FALSE otherwise
 *//**
 * Checks if instance has already consumed input.
 *
 * Instance that returns ::BROTLI_FALSE is considered "fresh" and could be
 * reused.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE if decoder has already used some input bytes
 * @returns ::BROTLI_FALSE otherwise
 *//**
 * Acquires pointer to internal output buffer.
 *
 * This method is used to make language bindings easier and more efficient:
 *  -# push data to ::BrotliDecoderDecompressStream,
 *     until ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT is reported
 *  -# use ::BrotliDecoderTakeOutput to peek bytes and copy to language-specific
 *     entity
 *
 * Also this could be useful if there is an output stream that is able to
 * consume all the provided data (e.g. when data is saved to file system).
 *
 * @attention After every call to ::BrotliDecoderTakeOutput @p *size bytes of
 *            output are considered consumed for all consecutive calls to the
 *            instance methods; returned pointer becomes invalidated as well.
 *
 * @note Decoder output is not guaranteed to be contiguous. This means that
 *       after the size-unrestricted call to ::BrotliDecoderTakeOutput,
 *       immediate next call to ::BrotliDecoderTakeOutput may return more data.
 *
 * @param state decoder instance
 * @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
 *                 any amount could be handled; \n
 *                 @b out: amount of data pointed by returned pointer and
 *                 considered consumed; \n
 *                 out value is never greater than in value, unless it is @c 0
 * @returns pointer to output data
 *//**
 * Checks if decoder has more output.
 *
 * @param state decoder instance
 * @returns ::BROTLI_TRUE, if decoder has some unconsumed output
 * @returns ::BROTLI_FALSE otherwise
 *//**
 * Decompresses the input stream to the output stream.
 *
 * The values @p *available_in and @p *available_out must specify the number of
 * bytes addressable at @p *next_in and @p *next_out respectively.
 * When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
 *
 * After each call, @p *available_in will be decremented by the amount of input
 * bytes consumed, and the @p *next_in pointer will be incremented by that
 * amount. Similarly, @p *available_out will be decremented by the amount of
 * output bytes written, and the @p *next_out pointer will be incremented by
 * that amount.
 *
 * @p total_out, if it is not a null-pointer, will be set to the number
 * of bytes decompressed since the last @p state initialization.
 *
 * @note Input is never overconsumed, so @p next_in and @p available_in could be
 * passed to the next consumer after decoding is complete.
 *
 * @param state decoder instance
 * @param[in, out] available_in @b in: amount of available input; \n
 *                 @b out: amount of unused input
 * @param[in, out] next_in pointer to the next compressed byte
 * @param[in, out] available_out @b in: length of output buffer; \n
 *                 @b out: remaining size of output buffer
 * @param[in, out] next_out output buffer cursor;
 *                 can be @c NULL if @p available_out is @c 0
 * @param[out] total_out number of bytes decompressed so far; can be @c NULL
 * @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
 *          allocation failed, arguments were invalid, etc.;
 *          use ::BrotliDecoderGetErrorCode to get detailed error code
 * @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT decoding is blocked until
 *          more input data is provided
 * @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT decoding is blocked until
 *          more output space is provided
 * @returns ::BROTLI_DECODER_RESULT_SUCCESS decoding is finished, no more
 *          input might be consumed and no more output will be produced
 *//**
 * Performs one-shot memory-to-memory decompression.
 *
 * Decompresses the data in @p encoded_buffer into @p decoded_buffer, and sets
 * @p *decoded_size to the decompressed length.
 *
 * @param encoded_size size of @p encoded_buffer
 * @param encoded_buffer compressed data buffer with at least @p encoded_size
 *        addressable bytes
 * @param[in, out] decoded_size @b in: size of @p decoded_buffer; \n
 *                 @b out: length of decompressed data written to
 *                 @p decoded_buffer
 * @param decoded_buffer decompressed data destination buffer
 * @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
 *          allocation failed, or @p decoded_buffer is not large enough;
 * @returns ::BROTLI_DECODER_RESULT_SUCCESS otherwise
 *//**
 * Deinitializes and frees ::BrotliDecoderState instance.
 *
 * @param state decoder instance to be cleaned up and deallocated
 *//**
 * Creates an instance of ::BrotliDecoderState and initializes it.
 *
 * The instance can be used once for decoding and should then be destroyed with
 * ::BrotliDecoderDestroyInstance, it cannot be reused for a new decoding
 * session.
 *
 * @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
 * case they are both zero, default memory allocators are used. @p opaque is
 * passed to @p alloc_func and @p free_func when they are called. @p free_func
 * has to return without doing anything when asked to free a NULL pointer.
 *
 * @param alloc_func custom memory allocation function
 * @param free_func custom memory free function
 * @param opaque custom memory manager handle
 * @returns @c 0 if instance can not be allocated or initialized
 * @returns pointer to initialized ::BrotliDecoderState otherwise
 *//**
 * Sets the specified parameter to the given decoder instance.
 *
 * @param state decoder instance
 * @param param parameter to set
 * @param value new parameter value
 * @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
 * @returns ::BROTLI_TRUE if value is accepted
 *//**
   * Flag that determines if "Large Window Brotli" is used.
   *//**
   * Disable "canny" ring buffer allocation strategy.
   *
   * Ring buffer is allocated according to window size, despite the real size of
   * the content.
   *//** Options to be used with ::BrotliDecoderSetParameter. *//**
 * The value of the last error code, negative integer.
 *
 * All other error code values are in the range from ::BROTLI_LAST_ERROR_CODE
 * to @c -1. There are also 4 other possible non-error codes @c 0 .. @c 3 in
 * ::BrotliDecoderErrorCode enumeration.
 *//**
 * Error code for detailed logging / production debugging.
 *
 * See ::BrotliDecoderGetErrorCode and ::BROTLI_LAST_ERROR_CODE.
 *//* "Impossible" states *//* -28..-29 codes are reserved for dynamic ring-buffer allocation *//* -23..-24 codes are reserved for distinct tree groups *//* Literal, insert and distance trees together *//* Memory allocation problems *//* -17..-18 codes are reserved *//* Errors caused by invalid input *//* Same as BrotliDecoderResult values *//**
 * Template that evaluates items of ::BrotliDecoderErrorCode.
 *
 * Example: @code {.cpp}
 * // Log Brotli error code.
 * switch (brotliDecoderErrorCode) {
 * #define CASE_(PREFIX, NAME, CODE) \
 *   case BROTLI_DECODER ## PREFIX ## NAME: \
 *     LOG(INFO) << "error code:" << #NAME; \
 *     break;
 * #define NEWLINE_
 * BROTLI_DECODER_ERROR_CODES_LIST(CASE_, NEWLINE_)
 * #undef CASE_
 * #undef NEWLINE_
 *   default: LOG(FATAL) << "unknown brotli error code";
 * }
 * @endcode
 *//** Partially done; should be called again with more output. *//** Partially done; should be called again with more input. *//** Decoding successfully completed. *//** Decoding error, e.g. corrupted input or memory allocation problem. *//**
 * Result type for ::BrotliDecoderDecompress and
 * ::BrotliDecoderDecompressStream functions.
 *//**
 * Opaque structure that holds decoder state.
 *
 * Allocated and initialized with ::BrotliDecoderCreateInstance.
 * Cleaned up and deallocated with ::BrotliDecoderDestroyInstance.
 *//**
 * @file
 * API for Brotli decompression.
 */available_inavailable_outnext_outtotal_outencoded_bufferdecoded_sizedecoded_bufferalloc_funcfree_func/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/common/version.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/huffman.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/prefix.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/state.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/decode.c"./state.h""./prefix.h""./huffman.h""../common/version.h""../common/transform.h""../common/dictionary.h""../common/context.h"<brotli/decode.h>16777225BROTLI_VERSIONBROTLI_ERROR_CODE_CASE_BROTLI_NOTHING_char[9]char[17]char[18]char[22]char[24]char[14]char[19]char[15]char[10]char[11]char[12]INVALID"INVALID"s->state == BROTLI_STATE_DONEs->state != BROTLI_STATE_UNINITED || BrotliGetAvailableBits(&s->br) != 01u << 24requested_outs->ringbuffer != 0 && UnwrittenBytes(s, BROTLI_FALSE) != 0s->ringbuffer != 0 && UnwrittenBytes(s, 0) != 0uint8_t[8]s->window_bits("[%s] %s = %lu\n", __func__, "s->window_bits", (unsigned long)(s->window_bits))sizeof(HuffmanCode) * 3 * (BROTLI_HUFFMAN_MAX_SIZE_258 + BROTLI_HUFFMAN_MAX_SIZE_26)sizeof(HuffmanCode) * 3 * (632 + 396)s->pos("[%s] %s = %lu\n", __func__, "s->pos", (unsigned long)(s->pos))s->is_last_metablock("[%s] %s = %lu\n", __func__, "s->is_last_metablock", (unsigned long)(s->is_last_metablock))s->meta_block_remaining_len("[%s] %s = %lu\n", __func__, "s->meta_block_remaining_len", (unsigned long)(s->meta_block_remaining_len))s->is_metadata("[%s] %s = %lu\n", __func__, "s->is_metadata", (unsigned long)(s->is_metadata))s->is_uncompressed("[%s] %s = %lu\n", __func__, "s->is_uncompressed", (unsigned long)(s->is_uncompressed))s->num_block_types[s->loop_counter]("[%s] %s = %lu\n", __func__, "s->num_block_types[s->loop_counter]", (unsigned long)(s->num_block_types[s->loop_counter]))s->block_length[s->loop_counter]("[%s] %s = %lu\n", __func__, "s->block_length[s->loop_counter]", (unsigned long)(s->block_length[s->loop_counter]))s->num_direct_distance_codes("[%s] %s = %lu\n", __func__, "s->num_direct_distance_codes", (unsigned long)(s->num_direct_distance_codes))s->distance_postfix_bits("[%s] %s = %lu\n", __func__, "s->distance_postfix_bits", (unsigned long)(s->distance_postfix_bits))(size_t)s->num_block_types[0]intermediate_resultBROTLI_STATE_UNINITEDBROTLI_STATE_LARGE_WINDOW_BITSBROTLI_STATE_INITIALIZEHuffmanCode *632396102812336BROTLI_HUFFMAN_MAX_SIZE_25818963 * BROTLI_HUFFMAN_MAX_SIZE_258BROTLI_STATE_METABLOCK_BEGINBROTLI_STATE_METABLOCK_HEADERBROTLI_STATE_METADATABROTLI_STATE_METABLOCK_DONEBROTLI_STATE_UNCOMPRESSEDBROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_HEADERBrotliMetablockHeaderArena *uint16_t *uint16_t[720]unsigned short[720]720BROTLI_HUFFMAN_MAX_CODE_LENGTHBROTLI_STATE_HUFFMAN_NONEBROTLI_STATE_TREE_GROUP_NONEBROTLI_STATE_CONTEXT_MAP_NONEBROTLI_STATE_HUFFMAN_CODE_0BROTLI_STATE_METABLOCK_HEADER_2uint32_t[3]BROTLI_STATE_HUFFMAN_CODE_1alphabet_sizetree_offsetBROTLI_STATE_HUFFMAN_CODE_2BROTLI_HUFFMAN_MAX_SIZE_26BROTLI_STATE_HUFFMAN_CODE_3const HuffmanCodeconst HuffmanCode *bitsBROTLI_STATE_CONTEXT_MODESBROTLI_STATE_CONTEXT_MAP_1BROTLI_STATE_CONTEXT_MAP_2distance_alphabet_size_maxdistance_alphabet_size_limitallocation_success BROTLI_TRUE2147483644HuffmanTreeGroup *BROTLI_STATE_TREE_GROUPhgroupBROTLI_STATE_BEFORE_COMPRESSED_METABLOCK_BODYHuffmanCode **BROTLI_STATE_COMMAND_BEGINBROTLI_STATE_COMMAND_INNERBROTLI_STATE_COMMAND_POST_DECODE_LITERALSBROTLI_STATE_COMMAND_POST_WRAP_COPYBROTLI_STATE_COMMAND_INNER_WRITEBROTLI_STATE_COMMAND_POST_WRITE_1BROTLI_STATE_COMMAND_POST_WRITE_2BROTLI_STATE_DONESafeProcessCommandsProcessCommandsProcessCommandsInternalBrotliWarmupBitReader(br)CommandBegins->block_length[1] == 0DecodeCommandBlockSwitch(s)ReadCommand(s, br, &i)CommandInners->block_length[0] == 0DecodeLiteralBlockSwitch(s)s->ringbuffer("[%s] %s[%lu] = %lu\n", __func__, "s->ringbuffer", (unsigned long)(pos), (unsigned long)s->ringbuffer[pos])pos == s->ringbuffer_sizes->context_lookup("[%s] %s = %lu\n", __func__, "context", (unsigned long)(context))s->context_map_slice[context]("[%s] %s = %lu\n", __func__, "s->context_map_slice[context]", (unsigned long)(s->context_map_slice[context]))pos & s->ringbuffer_mask("[%s] %s[%lu] = %lu\n", __func__, "s->ringbuffer", (unsigned long)(pos & s->ringbuffer_mask), (unsigned long)s->ringbuffer[pos & s->ringbuffer_mask])literalhcs->meta_block_remaining_len <= 0CommandPostDecodeLiteralss->block_length[2] == 0DecodeDistanceBlockSwitch(s)ReadDistance(s, br)("Invalid backward reference. pos: %d distance: %d " "len: %d bytes left: %d\n", pos, s->distance_code, i, s->meta_block_remaining_len)!words->data("[ProcessCommandsInternal] dictionary word: [%.*s]\n", len, word)("[ProcessCommandsInternal] dictionary word: [%.*s]," " transform_idx = %d, transformed: [%.*s]\n", i, word, transform_idx, len, &s->ringbuffer[pos])wordsword_idxconst int16_tconst int16_t *signed short *src_startcopy_dstcopy_srcdst_endsrc_endCommandPostWrapCopywrap_guard--wrap_guard == 0saveStateAndReturn("[ProcessCommandsInternal] pos = %d insert = %d copy = %d\n", pos, i, s->copy_length)("[ProcessCommandsInternal] pos = %d distance = %d\n", pos, s->distance_code)CheckInputAmountSafeReadCommandReadCommandReadCommandInternalcmd_codeinsert_len_extracopy_lengthconst CmdLutElementconst CmdLutElement[704]CmdLutElement[704]const CmdLutElement *CmdLutElement *v.insert_len_extra_bits != 0SafeReadDistancesafeinsert_lengthReadDistanceReadDistanceInternalBrotliMetablockBodyArena *distance_tree0xFu4294967280~0xFuuint8_t[544]unsigned char[544]544uint32_t[544]unsigned int[544]CalculateDistanceLutalphabet_size_limitSafeReadBits32SafeReadBitsTakeDistanceFromRingBufferindex_delta 363122580x605142ReadContextModess->context_modes("[%s] %s[%lu] = %lu\n", __func__, "s->context_modes", (unsigned long)(i), (unsigned long)s->context_modes[i])BrotliCalculateRingBufferSizewindow_sizenew_ringbuffer_sizemin_sizeoutput_sizeCopyUncompressedBlockToOutputBROTLI_STATE_UNCOMPRESSED_NONEnbytesBROTLI_STATE_UNCOMPRESSED_WRITEBrotliEnsureRingBufferold_ringbuffer(size_t)(s->new_ringbuffer_size) + kRingBufferWriteAheadSlackWrapRingBufferWriteRingBufferto_writenum_written("[%s] %s = %lu\n", __func__, "to_write", (unsigned long)(to_write))("[%s] %s = %lu\n", __func__, "num_written", (unsigned long)(num_written))UnwrittenBytespartial_pos_rbSafeDecodeDistanceBlockSwitchDecodeDistanceBlockSwitchDecodeDistanceBlockSwitchInternaluint32_t[6]unsigned int[6]SafeDecodeCommandBlockSwitchDecodeCommandBlockSwitchDecodeCommandBlockSwitchInternalSafeDecodeLiteralBlockSwitchDecodeLiteralBlockSwitchDecodeLiteralBlockSwitchInternalPrepareLiteralDecodingcontext_modetrivialblock_typecontext_offsetuint32_t[8]DetectTrivialLiteralBlockTypeserror |= s->context_map[offset + j++] ^ sample;errorsample1u << BROTLI_LITERAL_CONTEXT_BITS(1u << BROTLI_LITERAL_CONTEXT_BITS)DecodeBlockTypeAndLengthmax_block_typetype_treelen_treeringbufferBROTLI_STATE_READ_BLOCK_LENGTH_NONEforcewraptree_typeDecodeContextMapcontext_map_size("[%s] %s = %lu\n", __func__, "context_map_size", (unsigned long)(context_map_size))*num_htrees("[%s] %s = %lu\n", __func__, "*num_htrees", (unsigned long)(*num_htrees))(size_t)context_map_sizeh->max_run_length_prefix("[%s] %s = %lu\n", __func__, "h->max_run_length_prefix", (unsigned long)(h->max_run_length_prefix))("[%s] %s = %lu\n", __func__, "code", (unsigned long)(code))("[%s] %s = %lu\n", __func__, "reps", (unsigned long)(reps))BROTLI_STATE_CONTEXT_MAP_READ_PREFIXBROTLI_STATE_CONTEXT_MAP_HUFFMANHuffmanCode[646]struct <unnamed>[646]646BROTLI_STATE_CONTEXT_MAP_DECODEcontext_indexmax_run_length_prefixcontext_mapskip_preamble1UBROTLI_STATE_CONTEXT_MAP_TRANSFORMHuffmanTreeGroupDecodeBROTLI_STATE_TREE_GROUP_LOOPtable_sizeInverseMoveToFrontTransformupper_boundmtfuint32_t[65]unsigned int[65]mtf_u8const uint8_t[4]b0123patternconst uint8_t(*)[4]unsigned char(*)[4]673720360x04040404SafeReadBlockLengthconst BrotliPrefixCodeRange *BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIXReadBlockLengthReadHuffmanCodeh->sub_loop_counter("[%s] %s = %lu\n", __func__, "h->sub_loop_counter", (unsigned long)(h->sub_loop_counter))h->symbol("[%s] %s = %lu\n", __func__, "h->symbol", (unsigned long)(h->symbol))("[ReadHuffmanCode] space = %d\n", (int)h->space)uint16_t[16]sizeof(h->code_length_histo[0])BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH + 1)sizeof(h->code_length_histo[0]) *
              (BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH + 1)uint8_t[18]unsigned char[18]sizeof(h->code_length_code_lengths)BROTLI_STATE_HUFFMAN_COMPLEXBROTLI_STATE_HUFFMAN_SIMPLE_SIZEBROTLI_STATE_HUFFMAN_SIMPLE_READBROTLI_STATE_HUFFMAN_SIMPLE_BUILDHUFFMAN_TABLE_BITSconst uint8_t *constHuffmanCode[32]sizeof(h->code_length_histo)int[32](BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1)BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLSconst uint16_t *constReadCodeLengthCodeLengthsnum_codesspace!BrotliSafeGetBits(br, 4, &ix)h->code_length_code_lengthscode_len_idx("[%s] %s[%lu] = %lu\n", __func__, "h->code_length_code_lengths", (unsigned long)(code_len_idx), (unsigned long)h->code_length_code_lengths[code_len_idx])const uint8_t[18]ixavailable_bitsconst uint8_t[16]32USafeReadSymbolCodeLengthsget_byte BROTLI_FALSEbits & BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH)bits & BitMask(5)code_lenextra_bits14Urepeat_deltaReadSymbolCodeLengthsrepeatprev_code_lenrepeat_code_lensymbol_listscode_length_histonext_symbolBrotliGetBitsUnmasked(br) & BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH)BrotliGetBitsUnmasked(br) & BitMask(5)num_htreescontext_map_argv_lenalphabet_size_maxopt_table_sizeProcessRepeatedCodeLengthold_repeatnew_len3U("[ReadHuffmanCode] code_length[%d..%d] = %d\n", (int)*symbol, (int)(*symbol + repeat_delta - 1), (int)*repeat_code_len)ProcessSingleCodeLength("[ReadHuffmanCode] code_length[%d] = %d\n", (int)*symbol, (int)code_len)32768UReadSimpleHuffmanSymbolsmax_bitsnum_symbols!BrotliSafeReadBits(br, max_bits, &v)h->symbols_lists_array[i]("[%s] %s = %lu\n", __func__, "h->symbols_lists_array[i]", (unsigned long)(h->symbols_lists_array[i]))Log2FloorReadPreloadedSymbol*bits > HUFFMAN_TABLE_BITS*bits > 8Uext(val >> HUFFMAN_TABLE_BITS) & mask(val >> 8U) & maskHUFFMAN_TABLE_MASKPreloadSymbolBrotliGetBits(br, HUFFMAN_TABLE_BITS)BrotliGetBits(br, 8U)SafeReadSymbolBrotliSafeGetBits(br, 15, &val)SafeDecodeSymbolval & HUFFMAN_TABLE_MASKval & 0xFFBROTLI_HC_FAST_LOAD_VALUE(table) + val(table->value) + valReadSymbolDecodeSymbolbits & HUFFMAN_TABLE_MASKbits & 0xFFBROTLI_HC_FAST_LOAD_VALUE(table) + ((bits >> HUFFMAN_TABLE_BITS) & BitMask(nbits))(table->value) + ((bits >> 8U) & BitMask(nbits))DecodeMetaBlockLengthBROTLI_STATE_METABLOCK_HEADER_NONEBROTLI_STATE_METABLOCK_HEADER_NIBBLESBROTLI_STATE_METABLOCK_HEADER_EMPTYBROTLI_STATE_METABLOCK_HEADER_RESERVEDBROTLI_STATE_METABLOCK_HEADER_SIZEBROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSEDBROTLI_STATE_METABLOCK_HEADER_BYTESBROTLI_STATE_METABLOCK_HEADER_METADATADecodeVarLenUint8!BrotliSafeReadBits(br, 1, &bits)!BrotliSafeReadBits(br, 3, &bits)!BrotliSafeReadBits(br, *value, &bits)BROTLI_STATE_DECODE_UINT8_NONEBROTLI_STATE_DECODE_UINT8_SHORTBROTLI_STATE_DECODE_UINT8_LONGmemmove16uint32_t[4]DecodeWindowBitslarge_windowSaveErrorCode5152sizeof(BrotliDecoderState)!!valuekCodeLengthPrefixValuexkCodeLengthPrefixLengthkCodeLengthCodeOrderkRingBufferWriteAheadSlackBROTLI_ERROR_CODE_CASE_(PREFIX,NAME,CODE)case BROTLI_DECODER ## PREFIX ## NAME: return #NAME;BROTLI_SAFEBROTLI_SAFE(METHOD){ if (safe) { if (!Safe ## METHOD) { result = BROTLI_DECODER_NEEDS_MORE_INPUT; goto saveStateAndReturn; } } else { METHOD; } }8UBROTLI_LOG_ARRAY_INDEX(array_name,idx)BROTLI_LOG(("[%s] %s[%lu] = %lu\n", __func__, #array_name, (unsigned long)(idx), (unsigned long)array_name[idx]))BROTLI_LOG_UINT(name)BROTLI_LOG(("[%s] %s = %lu\n", __func__, #name, (unsigned long)(name)))BROTLI_FAILURE(CODE)(BROTLI_DUMP(), CODE)defined(BROTLI_TARGET_NEON)/* ... or stream is broken. Normally this should be caught by
       BrotliDecoderDecompressStream, this is just a safeguard. *//* Either WriteRingBuffer returns those "success" codes... *//* After unrecoverable error remaining output is considered nonsensical. *//* Fall through. *//* BROTLI_STATE_COMMAND_INNER_WRITE *//* Next metablock, if any. *//* Read one byte and ignore it. *//* Reads 1..11 bits. *//* Make small negative indexes addressable. *//* Initialize compressed metablock header arena. *//* Reads 2 - 31 bits. *//* Allocate memory for both block_type_trees and block_len_trees. *//* Maximum distance, see section 9.1. of the spec. *//* Reads 1..8 bits. *//* Decode window size. *//* Prepare to the first read. *//* Using input stream in last iteration. When decoder switches to input
           stream it has less than 8 bits in accumulator, so it is safe to
           return unused accumulator bits there. *//* Just consumed the buffered input and produced some output. Otherwise
           it would result in "needs more input". Reset internal buffer. *//* Fail or needs more output. *//* Unreachable. *//* Copy tail to internal buffer and return. *//* Input stream doesn't contain enough input. *//* Can't finish reading and no more input. *//* Retry with more data in buffer. *//* Not enough data in buffer, but can take one more byte from
               input stream. *//* Switch to input stream and restart. *//* Successfully finished read transaction.
               Accumulator contains less than 8 bits, because internal buffer
               is expanded byte-by-byte until it is enough to complete read. *//* Used with internal buffer. *//* WriteRingBuffer checks s->meta_block_remaining_len validity. *//* Pro-actively push output. *//* Error, needs more input/output. *//* State machine *//* At least one byte of input is required. More than one byte of input may
       be required to complete the transaction -> reading more data must be
       done in a loop -> do it in a main loop. *//* Just connect bit reader to input stream. *//* Do not try to process further in a case of unrecoverable error. *//* Ensure that |total_out| is set, even if no data will ever be pushed out. *//* Invariant: input stream is never overconsumed:
    - invalid input implies that the whole stream is invalid -> any amount of
      input could be read and discarded
    - when result is "needs more input", then at least one more byte is REQUIRED
      to complete decoding; all input data MUST be consumed by decoder, so
      client could swap the input buffer
    - when result is "needs more output" decoder MUST ensure that it doesn't
      hold more than 7 bits in bit reader; this saves client from swapping input
      buffer ahead of time
    - when result is "success" decoder MUST return all unused data back to input
      buffer; this is possible because the invariant is held on enter *//* This branch covers about 45% cases.
           Fixed size short copy allows more compiler optimizations. *//* At least one region wraps. *//* Regions intersect. *//* There are 32+ bytes of slack in the ring-buffer allocation.
       Also, we have 16 short codes, that make these 16 bytes irrelevant
       in the ring-buffer. Let's copy over them as a first guess. *//* Update the recent distances cache. *//* Compensate double distance-ring-buffer roll. *//* The maximum allowed distance is BROTLI_MAX_ALLOWED_DISTANCE = 0x7FFFFFFC.
       With this choice, no signed overflow can occur after decoding
       a special distance code (e.g., after adding 3 to the last distance). *//* Apply copy of LZ77 back-reference, or static dictionary reference if
     the distance is larger than the max LZ77 distance *//* Read distance code in the command, unless it was implicitly zero. *//* Implicit distance case. *//* 162 bits + 7 bytes *//* Read the literals in the command. *//* Read the insert/copy length in the command. *//* 156 bits + 7 bytes *//* Jump into state machine. *//* Convert the distance code to the actual distance by possibly
     looking up past distances from the s->dist_rb. *//* Precondition: s->distance_code < 0. *//* Always fill the complete group. *//* Fill regular distance codes. *//* Fill direct codes. *//* Skip short codes. *//* Calculates distance lookup table.
   NB: it is possible to have all 64 tables precalculated. *//* Remaining formulas from RFC 7932 Section 4 could be rewritten as following:

     alphabet_size = 16 + NDIRECT + (max_distbits << (NPOSTFIX + 1))

     half = ((xcode >> NPOSTFIX) & 1) << ndistbits
     postfix = xcode & ((1 << NPOSTFIX) - 1)
     range_start = 2 * (1 << ndistbits - 1 - 1)

     distance = (range_start + half + extra) << NPOSTFIX + postfix + NDIRECT + 1

   NB: ndistbits >= 1 -> range_start >= 0
   NB: range_start has factor 2, as the range is covered by 2 "halves"
   NB: extra -1 offset in range_start formula covers the absence of
       ndistbits = 0 case
   NB: when NPOSTFIX = 0, NDIRECT is not greater than 15

   In other words, xcode has the following binary structure - XXXHPPP:
    - XXX represent the number of extra distance bits
    - H selects upper / lower range of distances
    - PPP represent "postfix"

  "Regular" distance encoding has NPOSTFIX = 0; omitting the postfix part
  simplifies distance calculation.

  Using NPOSTFIX > 0 allows cheaper encoding of regular structures, e.g. where
  most of distances have the same reminder of division by 2/4/8. For example,
  the table of int32_t values that come from different sources; if it is likely
  that 3 highest bytes of values from the same source are the same, then
  copy distance often looks like 4x + y.

  Distance calculation could be rewritten to:

    ndistbits = NDISTBITS(NDIRECT, NPOSTFIX)[dcode]
    distance = OFFSET(NDIRECT, NPOSTFIX)[dcode] + extra << NPOSTFIX

  NDISTBITS and OFFSET could be pre-calculated, as NDIRECT and NPOSTFIX could
  change only once per meta-block.
*//*
   RFC 7932 Section 9.2 with "..." shortenings and "[]" emendations.

   ... to get the actual value of the parameter NDIRECT, left-shift this
   four-bit number by NPOSTFIX bits ...
*//*
   RFC 7932 Section 4 with "..." shortenings and "[]" emendations.

   Each distance ... is represented with a pair <distance code, extra bits>...
   The distance code is encoded using a prefix code... The number of extra bits
   can be 0..24... Two additional parameters: NPOSTFIX (0..3), and ...
   NDIRECT (0..120) ... are encoded in the meta-block header...

   The first 16 distance symbols ... reference past distances... ring buffer ...
   Next NDIRECT distance symbols ... represent distances from 1 to NDIRECT...
   [For] distance symbols 16 + NDIRECT and greater ... the number of extra bits
   ... is given by the following formula:

   [ xcode = dcode - NDIRECT - 16 ]
   ndistbits = 1 + [ xcode ] >> (NPOSTFIX + 1)

   ...
*//* A huge distance will cause a BROTLI_FAILURE() soon.
         This is a little faster than failing here. *//* Unpack one of six 4-bit values. *//* Compensate double distance-ring-buffer roll for dictionary items. *//* Reads 1..256 2-bit context modes. *//* Reduce ring buffer size to save memory when server is unscrupulous.
       In worst case memory usage might be 1.5x bigger for a short period of
       ring buffer reallocation. *//* Metadata blocks does not touch ring buffer. *//* If maximum is already reached, no further extension is retired. *//* We need at least 2 bytes of ring buffer size to get the last two
     bytes for context from there *//* Calculates the smallest feasible ring buffer.

   If we know the data size is small, do not allocate more ring buffer
   size than needed to reduce memory usage.

   When this method is called, metablock size and flags MUST be decoded. *//* Unreachable *//* Copy remaining bytes from s->br.buf_ to ring-buffer. *//* TODO: avoid allocation for single uncompressed block. *//* Restore previous value. *//* Allocates ring-buffer.

   s->ringbuffer_size MUST be updated by BrotliCalculateRingBufferSize before
   this function is called.

   Last two bytes of ring-buffer are initialized to 0, so context calculation
   could be done uniformly for the first two and all other positions. *//* Wrap ring buffer only if it has reached its maximal size. *//* Dumps output.
   Returns BROTLI_DECODER_NEEDS_MORE_OUTPUT only if there is more output to push
   and either ring-buffer is as big as window size, or |force| is true. *//* Block switch for distance codes.
   Reads 3..54 bits. *//* Block switch for insert/copy length.
   Reads 3..54 bits. *//* Decodes the block type and updates the state for literal context.
   Reads 3..54 bits. *//* Read 0..15 + 3..39 bits. *//* Decodes a command or literal and updates block type ring-buffer.
   Reads 3..54 bits. *//* RLE sub-stage. *//* Use RLE for zeros. *//* In next stage ReadHuffmanCode uses at least 4 bits, so it is safe
         to peek 4 bits ahead. *//* Decodes a context map.
   Decoding is done in 4 phases:
    1) Read auxiliary information (6..16 bits) and allocate memory.
       In case of trivial context map, decoding is finished at this phase.
    2) Decode Huffman table using ReadHuffmanCode function.
       This table will be used for reading context map items.
    3) Read context map items; "0" values could be run-length encoded.
    4) Optionally, apply InverseMoveToFront transform to the resulting map. *//* Decodes a series of Huffman table using ReadHuffmanCode function. *//* Remember amount of elements to be reinitialized. *//* Transform the input. *//* Advance all 4 values by 4. *//* Initialize list using 4 consequent values pattern. *//* Load endian-aware constant. *//* Make mtf[-1] addressable. *//* Reinitialize elements that could have been changed. *//* Transform:
    1) initialize list L with values 0, 1,... 255
    2) For each input element X:
    2.1) let Y = L[X]
    2.2) remove X-th element from L
    2.3) prepend Y to L
    2.4) append Y to output

   In most cases max(Y) <= 7, so most of L remains intact.
   To reduce the cost of initialization, we reuse L, remember the upper bound
   of Y values, and reinitialize only first elements in L.

   Most of input values are 0 and 1. To reduce number of branches, we replace
   inner for loop with do-while. *//* WARNING: if state is not BROTLI_STATE_READ_BLOCK_LENGTH_NONE, then
   reading can't be continued with ReadBlockLength. *//* nbits == 2..24 *//* Decodes a block length by reading 3..39 bits. *//* Decode Huffman-coded code lengths. *//* num_symbols *//* Read symbols, codes & code lengths directly. *//* num_codes *//* The value is used as follows:
           1 for simple code;
           0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths *//* State machine. *//* Decodes the Huffman tables.
   There are 2 scenarios:
    A) Huffman code contains only few symbols (1..4). Those symbols are read
       directly; their code lengths are defined by the number of symbols.
       For this scenario 4 - 49 bits will be read.

    B) 2-phase decoding:
    B.1) Small Huffman table is decoded; it is specified with code lengths
         encoded with predefined entropy code. 32 - 74 bits are used.
    B.2) Decoded table is used to decode code lengths of symbols in resulting
         Huffman table. In worst case 3520 bits are read. *//* space is 0 or wrapped around. *//* Reads and decodes 15..18 codes using static prefix code.
   Each code is 2..4 bits long. In total 30..72 bits are used. *//* code_len == 16..17, extra_bits == 2..3 *//* code_len == 0..17 *//* Use 1..5 bits. *//* Reads and decodes symbol codelengths. *//* for BROTLI_REPEAT_ZERO_CODE_LENGTH *//* Process repeated symbol code length.
    A) Check if it is the extension of previous repeat sequence; if the decoded
       value is not BROTLI_REPEAT_PREVIOUS_CODE_LENGTH, then it is a new
       symbol-skip
    B) Update repeat variable
    C) Check if operation is feasible (fits alphabet)
    D) For each symbol do the same operations as in ProcessSingleCodeLength

   PRECONDITION: code_len == BROTLI_REPEAT_PREVIOUS_CODE_LENGTH or
                 code_len == BROTLI_REPEAT_ZERO_CODE_LENGTH *//* code_len == 1..15 *//* Process single decoded symbol code length:
    A) reset the repeat variable
    B) remember code length (if it is not 0)
    C) extend corresponding index-chain
    D) reduce the Huffman space
    E) update the histogram *//* max_bits == 1..11; symbol == 0..3; 1..44 bits will be read. *//* Reads (s->symbol + 1) symbols.
   Totally 1..4 symbols are read, 1..11 bits each.
   The list of symbols MUST NOT contain duplicates. *//* Decodes the next Huffman code using data prepared by PreloadSymbol.
   Reads 0 - 15 bits. Also peeks 8 following bits. *//* Makes a look-up in first level Huffman table. Peeks 8 bits. *//* Not enough bits for the second level. *//* Speculatively drop HUFFMAN_TABLE_BITS. *//* Not enough bits to move to the second level. *//* Not enough bits for the first level. *//* No valid bits at all. *//* Same as DecodeSymbol, but it is known that there is less than 15 bits of
   input are currently available. *//* Reads and decodes the next Huffman code from bit-stream.
   This method peeks 16 bits of input and drops 0 - 15 of them. *//* Decodes the Huffman code.
   This method doesn't read data from the bit reader, BUT drops the amount of
   bits that correspond to the decoded symbol.
   bits MUST contain at least 15 (BROTLI_HUFFMAN_MAX_CODE_LENGTH) valid bits. *//* Decodes a metablock length and flags by reading 2 - 31 bits. *//* Use output value as a temporary storage. It MUST be persisted. *//* Decodes a number in the range [0..255], by reading 1 - 11 bits. *//* Decodes WBITS by reading 1 - 7 bits, or 0x11 for "Large Window Brotli".
   Precondition: bit-reader accumulator has at least 8 bits. *//* Saves error code and converts it to BrotliDecoderResult. *//* Deinitializes and frees BrotliDecoderState instance. *//* Static prefix code for the complex code length code lengths. *//* We need the slack region for the following reasons:
    - doing up to two 16-byte copies for fast backward copying
    - inserting transformed dictionary word:
        5 prefix + 24 base + 8 suffix *//* memcpy, memset *//* free, malloc */BROTLI_ABI_VERSION0x10090000x1000009BROTLI_COMMON_VERSION_H_/* BROTLI_COMMON_VERSION_H_ *//* ABI version, calculated as (CURRENT << 24) | (REVISION << 12) | AGE *//* This macro is used by build system to produce Libtool-friendly soname. See
   https://www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html
 *//* Semantic version, calculated as (MAJOR << 24) | (MINOR << 12) | PATCH *//* This macro should only be used when library is compiled together with client.
   If library is dynamically linked, use BrotliDecoderVersion and
   BrotliEncoderVersion methods. *//* Version definition. */CmdLutElementcopy_len_offsetinsert_len_offsetdistance_codecopy_len_extra_bitsinsert_len_extra_bitskCmdLutBROTLI_DEC_PREFIX_H_/* BROTLI_DEC_PREFIX_H_ *//* Lookup tables to map prefix codes to value ranges. This is used during
   decoding of the block lengths, literal insertion lengths and copy lengths. */BrotliDecoderHuffmanTreeGroupInitBrotliDecoderStateCleanupAfterMetablockBrotliDecoderStateMetablockBeginBrotliDecoderStateCleanupBrotliDecoderStateInitBrotliDecoderStateInternalBrotliMetablockBodyArenaBrotliMetablockHeaderArenaBrotliRunningHuffmanStateBrotliRunningContextMapStateBrotliRunningTreeGroupStateBrotliRunningReadBlockLengthStateBrotliRunningDecodeUint8StateBrotliRunningUncompressedStateBrotliRunningMetablockHeaderStateBrotliRunningStatearenabodydist_offsetdist_extra_bitsBROTLI_HUFFMAN_MAX_SIZE_272context_map_tablehtree_indexcode_length_code_lengthssymbols_lists_arraysub_loop_countersubstate_huffmansubstate_context_mapsubstate_tree_grouptrivial_literal_contextsdictionarycontext_modesnum_literal_htreeswindow_bitssize_nibblescanny_ringbuffer_allocationshould_wrap_ringbufferis_metadatais_uncompressedis_last_metablocksubstate_read_block_lengthsubstate_decode_uint8substate_uncompressedsubstate_metablock_header64 + 1mtf_upper_boundpartial_pos_outrb_roundtripsdist_htree_indexliteral_htreedist_context_mapnum_dist_htreesnum_direct_distance_codesdistance_postfix_bitsblock_type_rbnum_block_typesblock_lengthblock_length_indexmeta_block_remaining_lendistance_contexttrivial_literal_contextblock_len_treesblock_type_treesdistance_hgroupinsert_copy_hgroupliteral_hgroupdist_context_map_slicecontext_map_slicecontext_lookuphtree_commandringbuffer_enderror_codedist_rbdist_rb_idxringbuffer_maskringbuffer_sizemax_backward_distancebuffer_lengthu8u64memory_manager_opaqueloop_counterBROTLI_DECODER_FREE(S,X){ S->free_func(S->memory_manager_opaque, X); X = NULL; }BROTLI_DECODER_ALLOC(S,L)S->alloc_func(S->memory_manager_opaque, L)BROTLI_DEC_STATE_H_/* BROTLI_DEC_STATE_H_ *//* 256 bits *//* States inside function calls. *//* Less used attributes are at the end of this struct. *//* For InverseMoveToFrontTransform. *//* how much output to the user in total *//* how many times we went around the ring-buffer *//* For partial write operations. *//* Distance context is actual after command is decoded and before distance is
     computed. After distance computation it is used as a temporary variable. *//* This is true if the literal context map histogram type always matches the
     block type. It is then not needed to keep the context (faster decoding). *//* This ring buffer holds a few past copy distances that will be used by
     some special distance codes. *//* Temporary storage for remaining input. Brotli stream format is designed in
     a way, that 64 bits are enough to make progress in decoding. *//* This counter is reused for several disjoint loops. *//* For DecodeContextMap. *//* For HuffmanTreeGroupDecode. *//* Population counts for the code lengths. *//* Tails of symbol chains. *//* Storage from symbol_lists. *//* List of heads of symbol chains. *//* Huffman table for "histograms". *//* For ReadHuffmanCode. *//* Graphviz diagram that describes state transitions:

digraph States {
  graph [compound=true]
  concentrate=true
  node [shape="box"]

  UNINITED -> {LARGE_WINDOW_BITS -> INITIALIZE}
  subgraph cluster_metablock_workflow {
    style="rounded"
    label=< <B>METABLOCK CYCLE</B> >
    METABLOCK_BEGIN -> METABLOCK_HEADER
    METABLOCK_HEADER:sw -> METADATA
    METABLOCK_HEADER:s -> UNCOMPRESSED
    METABLOCK_HEADER:se -> METABLOCK_DONE:ne
    METADATA:s -> METABLOCK_DONE:w
    UNCOMPRESSED:s -> METABLOCK_DONE:n
    METABLOCK_DONE:e -> METABLOCK_BEGIN:e [constraint="false"]
  }
  INITIALIZE -> METABLOCK_BEGIN
  METABLOCK_DONE -> DONE

  subgraph cluster_compressed_metablock {
    style="rounded"
    label=< <B>COMPRESSED METABLOCK</B> >

    subgraph cluster_command {
      style="rounded"
      label=< <B>HOT LOOP</B> >

      _METABLOCK_DONE_PORT_ [shape=point style=invis]

      {
        // Set different shape for nodes returning from "compressed metablock".
        node [shape=invhouse]; CMD_INNER CMD_POST_DECODE_LITERALS;
        CMD_POST_WRAP_COPY; CMD_INNER_WRITE; CMD_POST_WRITE_1;
      }

      CMD_BEGIN -> CMD_INNER -> CMD_POST_DECODE_LITERALS -> CMD_POST_WRAP_COPY

      // IO ("write") nodes are not in the hot loop!
      CMD_INNER_WRITE [style=dashed]
      CMD_INNER -> CMD_INNER_WRITE
      CMD_POST_WRITE_1 [style=dashed]
      CMD_POST_DECODE_LITERALS -> CMD_POST_WRITE_1
      CMD_POST_WRITE_2 [style=dashed]
      CMD_POST_WRAP_COPY -> CMD_POST_WRITE_2

      CMD_POST_WRITE_1 -> CMD_BEGIN:s [constraint="false"]
      CMD_INNER_WRITE -> {CMD_INNER CMD_POST_DECODE_LITERALS}
          [constraint="false"]
      CMD_BEGIN:ne -> CMD_POST_DECODE_LITERALS [constraint="false"]
      CMD_POST_WRAP_COPY -> CMD_BEGIN [constraint="false"]
      CMD_POST_DECODE_LITERALS -> CMD_BEGIN:ne [constraint="false"]
      CMD_POST_WRITE_2 -> CMD_POST_WRAP_COPY [constraint="false"]
      {rank=same; CMD_BEGIN; CMD_INNER; CMD_POST_DECODE_LITERALS;
          CMD_POST_WRAP_COPY}
      {rank=same; CMD_INNER_WRITE; CMD_POST_WRITE_1; CMD_POST_WRITE_2}

      {CMD_INNER CMD_POST_DECODE_LITERALS CMD_POST_WRAP_COPY} ->
          _METABLOCK_DONE_PORT_ [style=invis]
      {CMD_INNER_WRITE CMD_POST_WRITE_1} -> _METABLOCK_DONE_PORT_
          [constraint="false" style=invis]
    }

    BEFORE_COMPRESSED_METABLOCK_HEADER:s -> HUFFMAN_CODE_0:n
    HUFFMAN_CODE_0 -> HUFFMAN_CODE_1 -> HUFFMAN_CODE_2 -> HUFFMAN_CODE_3
    HUFFMAN_CODE_0 -> METABLOCK_HEADER_2 -> CONTEXT_MODES -> CONTEXT_MAP_1
    CONTEXT_MAP_1 -> CONTEXT_MAP_2 -> TREE_GROUP
    TREE_GROUP -> BEFORE_COMPRESSED_METABLOCK_BODY:e
    BEFORE_COMPRESSED_METABLOCK_BODY:s -> CMD_BEGIN:n

    HUFFMAN_CODE_3:e -> HUFFMAN_CODE_0:ne [constraint="false"]
    {rank=same; HUFFMAN_CODE_0; HUFFMAN_CODE_1; HUFFMAN_CODE_2; HUFFMAN_CODE_3}
    {rank=same; METABLOCK_HEADER_2; CONTEXT_MODES; CONTEXT_MAP_1; CONTEXT_MAP_2;
        TREE_GROUP}
  }
  METABLOCK_HEADER:e -> BEFORE_COMPRESSED_METABLOCK_HEADER:n

  _METABLOCK_DONE_PORT_ -> METABLOCK_DONE:se
      [constraint="false" ltail=cluster_command]

  UNINITED [shape=Mdiamond];
  DONE [shape=Msquare];
}


 *//* Brotli state for partial streaming decoding. *//* Copyright 2015 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/ntrees/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/huffman.cBrotliBuildSimpleHuffmanTablegoal_sizesizeof(table[0])BrotliBuildHuffmanTablekey_stepsub_keysub_key_steptable_bitstotal_sizemax_lengthbits_countBROTLI_REVERSE_BITS_LOWEST(BROTLI_REVERSE_BITS_LOWEST << 1)(BROTLI_REVERSE_BITS_LOWEST << 1U)root_bitsroot_tableroot_bits <= BROTLI_REVERSE_BITS_MAXBROTLI_HUFFMAN_MAX_CODE_LENGTH - root_bits <= BROTLI_REVERSE_BITS_MAXBrotliBuildCodeLengthsHuffmanTableint[18]sortedint[6]{ symbol += count[bits]; offset[bits] = symbol; bits++; }{ symbol--; sorted[offset[code_lengths[symbol]]--] = symbol; }1 << BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTHBROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH <= BROTLI_REVERSE_BITS_MAXNextTableBitSizeReplicateValueBrotliReverseBitsuint8_t[256]BROTLI_REVERSE_BITS_MAX1 << BROTLI_REVERSE_BITS_MAXkReverseBits((brotli_reg_t)1 << (BROTLI_REVERSE_BITS_MAX - 1 + BROTLI_REVERSE_BITS_BASE))BROTLI_REVERSE_BITS_BASEdefined(BROTLI_RBIT)/* Fill in 2nd level tables and add pointers to root table. *//* If root_bits != table_bits then replicate to fill the remaining slots. *//* Fill in the root table. Reduce the table size to if possible,
     and create the repetitions by memcpy. *//* sum of root table size and 2nd level table sizes *//* size of current table *//* key length of current table *//* step size to replicate values in current table *//* 2nd level table prefix code addend *//* 2nd level table prefix code *//* prefix code addend *//* prefix code *//* symbol index in original or sorted table *//* current code length *//* next available space in table *//* current table entry *//* Fill in table. *//* Special case: all symbols but one have 0 code length. *//* Sort symbols by length, by symbol order within each length. *//* Symbols with code length 0 are placed after all other symbols. *//* Generate offsets into sorted symbol table by code length. *//* offsets in sorted table for each length *//* symbols sorted by code length *//* Returns the table width of the next 2nd level table. |count| is the histogram
   of bit lengths for the remaining symbols, |len| is the code length of the
   next processed symbol. *//* Assumes that end is an integer multiple of step *//* Stores code in table[0], table[step], table[2*step], ..., table[end] *//* Returns reverse(num >> BROTLI_REVERSE_BITS_BASE, BROTLI_REVERSE_BITS_MAX),
   where reverse(value, len) is the bit-wise reversal of the len least
   significant bits of value. *//* Utilities for building Huffman decoding tables. */code_lengthsendConstructHuffmanCodeHuffmanTreeGroupHuffmanCodecodeshtreesBROTLI_HC_FAST_LOAD_VALUE(H)(H->value)BROTLI_HC_FAST_LOAD_BITS(H)(H->bits)BROTLI_HC_ADJUST_TABLE_INDEX(H,V)H += (V)BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(H)BROTLI_DEC_HUFFMAN_H_((defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_32)) && \!defined(BROTLI_HUFFMAN_CODE_FAST_LOAD)/* BROTLI_DEC_HUFFMAN_H_ *//* alphabet_size_limit is needed due to simple codes, since
   log2(alphabet_size_max) could be greater than log2(alphabet_size_limit). *//* Contains a collection of Huffman trees with the same alphabet size. *//* Builds a simple Huffman table. The |num_symbols| parameter is to be
   interpreted as follows: 0 means 1 symbol, 1 means 2 symbols,
   2 means 3 symbols, 3 means 4 symbols with lengths [2, 2, 2, 2],
   4 means 4 symbols with lengths [1, 2, 3, 3]. *//* Builds Huffman lookup table assuming code lengths are in symbol order.
   Returns size of resulting table. *//* Builds Huffman lookup table assuming code lengths are in symbol order. *//* BROTLI_HUFFMAN_CODE_FAST_LOAD *//* These must be given a HuffmanCode pointer! *//* Please use the following macros to optimize HuffmanCode accesses in hot
 * paths.
 *
 * For example, assuming |table| contains a HuffmanCode pointer:
 *
 *   BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(table);
 *   BROTLI_HC_ADJUST_TABLE_INDEX(table, index_into_table);
 *   *bits = BROTLI_HC_GET_BITS(table);
 *   *value = BROTLI_HC_GET_VALUE(table);
 *   BROTLI_HC_ADJUST_TABLE_INDEX(table, offset);
 *   *bits2 = BROTLI_HC_GET_BITS(table);
 *   *value2 = BROTLI_HC_GET_VALUE(table);
 *
 *//* symbol value or table offset *//* number of bits used for this symbol *//* Do not create this struct directly - use the ConstructHuffmanCode
 * constructor below! *//* BROTLI_MAX_CONTEXT_MAP_SYMBOLS == 272 *//* BROTLI_MAX_BLOCK_TYPE_SYMBOLS == 258 *//* BROTLI_NUM_BLOCK_LEN_SYMBOLS == 26 */symbols/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/dec/state.cmax_table_size376code_sizesizeof(HuffmanCode)htree_sizesizeof(HuffmanCode*)code_size + htree_sizes->block_type_treess->context_maps->dist_context_maps->literal_hgroup.htreess->insert_copy_hgroup.htreess->distance_hgroup.htrees1U << 24/* Pointer alignment is, hopefully, wider than sizeof(HuffmanCode). *//* 376 = 256 (1-st level table) + 4 + 7 + 15 + 31 + 63 (2-nd level mix-tables)
     This number is discovered "unlimited" "enough" calculator; it is actually
     a wee bigger than required in several cases (especially for alphabets with
     less than 16 symbols). *//* BROTLI_DECODER_NO_ERROR *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/backward_references.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/command.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/fast_log.h/usr/include/math.h/usr/include/bits/math-vector.h/usr/include/bits/libm-simd-decl-stubs.h/usr/include/bits/flt-eval-method.h/usr/include/bits/fp-logb.h/usr/include/bits/fp-fast.h/usr/include/bits/mathcalls-helper-functions.h/usr/include/bits/mathcalls.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/params.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/include/brotli/encode.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/encoder_dict.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/static_dict_lut.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/prefix.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/find_match_length.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/memory.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/quality.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/static_dict.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_to_binary_tree_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_longest_match_quickly_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_longest_match_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_longest_match64_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_forgetful_chain_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_rolling_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/hash_composite_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/dictionary_hash.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/backward_references_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/backward_references.c"./backward_references_inc.h""./quality.h""./memory.h""./dictionary_hash.h""./command.h""./backward_references.h"BrotliCreateBackwardReferencesconst BrotliEncoderParamsconst BrotliEncoderParams *BrotliEncoderParams *Hasher *Command *CASE_ComputeDistanceCodedistance_plus_3offset0offset11586637840x97504682660174860xFDB1ACECASE_(N)case N: CreateBackwardReferencesNH ## N(num_bytes, position, ringbuffer, ringbuffer_mask, literal_context_lut, params, hasher, dist_cache, last_insert_len, commands, num_commands, num_literals); return;EXPAND_CATCATFNEXPORT_FNPREFIXHASHERHASHER()H65H55H35H54H42H41H40H6H5H4H3H2PREFIX()NEXPORT_FN(X)EXPAND_CAT(X, EXPAND_CAT(PREFIX(), HASHER()))FN(X)EXPAND_CAT(X, HASHER())CAT(a,b)a ## bEXPAND_CAT(a,b)CAT(a, b)/* NOLINTNEXTLINE(build/include) *//* Function to find backward reference copies. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/encnum_bytesliteral_context_luthasherdist_cachelast_insert_lencommandsnum_commandsnum_literalsCreateBackwardReferencesNH2CreateBackwardReferencesEXPAND_CAT(PREFIX(), HASHER())NH2H2 *privatparams->lgwinmax_backward_limitposition_offsetconst Commandconst Command *const Command *constorig_commandspos_endStoreLookaheadstore_endrandom_heuristics_window_sizeapply_random_heuristicsgapkMinScore1920BROTLI_SCORE_BASE2020PrepareDistanceCacheH2 *__restrict__HashTypeLengthposition + position_offsetFindLongestMatchsr.len - 1position + 1position + 1 + position_offsetposition + sr.lenrange_endBROTLI_MAX(size_t, range_start, position + sr.len - (sr.distance << 2))(brotli_max_size_t((range_start), (position + sr.len - (sr.distance << 2))))range_startposition + sr.len - (sr.distance << 2)StoreRangeFN(StoreLookahead)() - 1StoreLookaheadH2() - 1position + 16pos_end - kMarginStoreposition + 8dictionary_startsrconst BrotliEncoderDictionaryconst BrotliEncoderDictionary *BrotliEncoderDictionary *const uint8_t *__restrict__const int *__restrict__HasherSearchResult *HasherSearchResult *__restrict__delayed_backward_references_in_rowcost_diff_lazysr2MIN_QUALITY_FOR_EXTENSIVE_REFERENCE_SEARCHconst BrotliDistanceParamsconst BrotliDistanceParams *BrotliDistanceParams *kMarginpos_jump/* It is quite a long time since we saw a copy, so we assume
             that this data is not compressible, and store hashes less
             often. Hashes of non compressible data are less likely to
             turn out to be useful in the future, too, so we store less of
             them to not to flood out the hash table of good compressible
             data. *//* Going through uncompressible data, jump. *//* If we have not seen matches for a long time, we can skip some
         match lookups. Unsuccessful match lookups are very very expensive
         and this kind of a heuristic speeds up compression quite
         a lot. *//* Put the hash keys into the table, if there are enough bytes left.
         Depending on the hasher implementation, it can push all positions
         in the given range or only a subset of them.
         Avoid hash poisoning with RLE data. *//* The first 16 codes are special short-codes,
           and the minimum offset is 1. *//* Ok, let's just write one byte for now and start a match from the
             next byte. *//* Found a match. Let's look for something even better ahead. *//* Minimum score to accept a backward reference. *//* For speed up heuristics for random data. *//* Set maximum distance, see section 9.1. of the spec. *//* template parameters: EXPORT_FN, FN *//* NOLINT(build/header_guard) */CreateBackwardReferencesNH3NH3H3 *H3 *__restrict__StoreLookaheadH3() - 1CreateBackwardReferencesNH4NH4H4 *H4 *__restrict__StoreLookaheadH4() - 1CreateBackwardReferencesNH5NH5H5 *H5 *__restrict__StoreLookaheadH5() - 1CreateBackwardReferencesNH6NH6H6 *H6 *__restrict__StoreLookaheadH6() - 1CreateBackwardReferencesNH40NH40H40 *H40 *__restrict__StoreLookaheadH40() - 1CreateBackwardReferencesNH41NH41H41 *H41 *__restrict__StoreLookaheadH41() - 1CreateBackwardReferencesNH42NH42H42 *H42 *__restrict__StoreLookaheadH42() - 1CreateBackwardReferencesNH54NH54H54 *H54 *__restrict__StoreLookaheadH54() - 1CreateBackwardReferencesNH35NH35H35 *H35 *__restrict__StoreLookaheadH35() - 1CreateBackwardReferencesNH55NH55H55 *H55 *__restrict__StoreLookaheadH55() - 1CreateBackwardReferencesNH65NH65H65 *H65 *__restrict__StoreLookaheadH65() - 1FindMatchLengthWithLimitmatchedlimit2--limit2BROTLI_UNALIGNED_LOAD64LE(s2) == BROTLI_UNALIGNED_LOAD64LE(s1 + matched)BrotliUnalignedRead64(s2) == BrotliUnalignedRead64(s1 + matched)matching_bitss1[matched] == *s2BROTLI_ENC_FIND_MATCH_LENGTH_H_defined(BROTLI_TZCNT64) && BROTLI_64_BITS && BROTLI_LITTLE_ENDIAN/* BROTLI_ENC_FIND_MATCH_LENGTH_H_ *//* Find out how long the match is. We loop over the data 32 bits at a
     time until we find a 32-bit block that doesn't match; then we find
     the first non-matching bit and use that to calculate the total
     length of the match. *//* + 1 is for pre-decrement in while *//* Separate implementation for little-endian 64-bit targets, for speed. *//* Function to find maximal matching prefixes of strings. *//* Copyright 2010 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/"./encoder_dict.h"BrotliFindAllStaticDictionaryMatcheskInvalidMatch0xFFFFFFFBROTLI_MAX_STATIC_DICTIONARY_MATCH_LENBROTLI_ENC_STATIC_DICT_H_/* BROTLI_ENC_STATIC_DICT_H_ *//* Matches data against static dictionary words, and for each length l,
   for which a match is found, updates matches[l] to be the minimum possible
     (distance << 5) + len_code.
   Returns 1 if matches have been found, otherwise 0.
   Prerequisites:
     matches array is at least BROTLI_MAX_STATIC_DICTIONARY_MATCH_LEN + 1 long
     all elements are initialized to kInvalidMatch *//* Class to model the static dictionary. */min_length"./hash_composite_inc.h""./hash_rolling_inc.h""./hash_longest_match_quickly_inc.h""./hash_forgetful_chain_inc.h""./hash_longest_match64_inc.h""./hash_longest_match_inc.h""./hash_to_binary_tree_inc.h""./static_dict.h""./find_match_length.h""./fast_log.h"InitOrStitchToPreviousBlockMemoryManager *BROTLI_IS_OOM(m)INIT_H10 *H10 *__restrict__HasherSetupone_shothasher->common.extraINITIALIZE_BrotliHasherParams *BROTLI_IS_NULL(hasher->common.extra)HasherCommon *PREPARE_HasherSizeSIZE_input_sizeis_lastHasherResetDestroyHasherHasherInitBackwardMatchLengthCodeconst BackwardMatchconst BackwardMatch *BackwardMatch *BackwardMatchLengthInitDictionaryBackwardMatchInitBackwardMatchSearchInStaticDictionary2uitem_matchesTestStaticDictionaryItemmatchlenbackwardscorecuttransform_idBackwardReferencePenaltyUsingLastDistance(score_t)391172640x1CA100xEBackwardReferenceScoreUsingLastDistanceBROTLI_LITERAL_BYTE_SCOREBackwardReferenceScoreBROTLI_DISTANCE_BIT_PENALTYlast_distancenext_last_distanceHash14506832829kHashMul3232 - 14(32 - 14)HasherBackwardMatchHasherSearchResultHasherCommoncommon_H10MEMBER__H65_H55_H35_H54_H42_H41_H40_H6_H5_H4_H3_H2length_and_codelen_code_deltais_prepared_dict_num_matchesdict_num_lookupskHashMul64Long0x1FE35A7Bu0xD3579BD3u534993531229777971921656217635457340992297779722762296275BROTLI_MAKE_UINT64_T(0x1FE35A7Bu, 0xD3579BD3u)kHashMul640x1E35A7BD21768304250941603842176830425600993213BROTLI_MAKE_UINT64_T(0x1E35A7BD, 0x1E35A7BD)kCutoffTransforms0x071B520A0xDA2D32001192309865120931855398338563660395008512093189200228864BROTLI_MAKE_UINT64_T(0x071B520A, 0xDA2D3200)kCutoffTransformsCountINIT_(N)case N: StitchToPreviousBlockH ## N( &hasher->privat._H ## N, input_size, position, data, mask); break;PREPARE_(N)case N: PrepareH ## N( &hasher->privat._H ## N, one_shot, input_size, data); break;INITIALIZE_(N)case N: InitializeH ## N(&hasher->common, &hasher->privat._H ## N, params); break;SIZE_(N)case N: return HashMemAllocInBytesH ## N(params, one_shot, input_size);MEMBER_(N)H ## N _H ## N;FOR_ALL_HASHERS(H)FOR_GENERIC_HASHERS(H) H(10)FOR_GENERIC_HASHERS(H)FOR_SIMPLE_HASHERS(H) FOR_COMPOSITE_HASHERS(H)FOR_COMPOSITE_HASHERS(H)H(35) H(55) H(65)FOR_SIMPLE_HASHERS(H)H(2) H(3) H(4) H(5) H(6) H(40) H(41) H(42) H(54)HASHER_BHASHER_AHROLLINGHROLLING_FASTCHUNKLENJUMPNUMBUCKETS((NUMBUCKETS * 64) - 1)BUCKET_BITSBUCKET_SWEEP_BITSHASH_LENUSE_DICTIONARYBANK_BITSNUM_BANKSNUM_LAST_DISTANCES_TO_CHECKMAX_NUM_MATCHES_H10MAX_TREE_COMP_LENGTHMAX_TREE_SEARCH_DEPTHH10(BROTLI_DISTANCE_BIT_PENALTY * 8 * sizeof(size_t))score_tBROTLI_ENC_HASH_H_/* BROTLI_ENC_HASH_H_ *//* Default case. *//* MUST be invoked before any other method. *//* NOLINT(build/include) *//* fast large window hashers *//* For BUCKET_SWEEP_BITS == 0, enabling the dictionary lookup makes compression
   a little faster (0.5% - 1%) and it compresses 0.15% better on small text
   and HTML inputs. *//* MAX_NUM_MATCHES == 64 + MAX_TREE_SEARCH_DEPTH *//* Usually, we always choose the longest backward reference. This function
   allows for the exception of that rule.

   If we choose a backward reference that is further away, it will
   usually be coded with more bits. We approximate this by assuming
   log2(distance). If the distance can be expressed in terms of the
   last four distances, we use some heuristic constants to estimate
   the bits cost. For the first up to four literals we use the bit
   cost of the literals from the literal cost model, after that we
   use the average bit cost of the cost model.

   This function is used to sometimes discard a longer backward reference
   when it is not much longer and the bit cost for encoding it is more
   than the saved literals.

   backward_reference_offset MUST be positive. *//* Score must be positive after applying maximal penalty. *//* The higher bits contain more mixture from the multiplication,
     so we take our results from there. *//* kHashMul32 multiplier has these properties:
   * The multiplier must be odd. Otherwise we may lose the highest bit.
   * No long streaks of ones or zeros.
   * There is no effort to ensure that it is a prime, the oddity is enough
     for this use.
   * The number has been tuned heuristically against compression benchmarks. *//* == len_code - len *//* 0+0, 4+8, 8+19, 12+11, 16+26, 20+43, 24+32, 28+20, 32+27, 36+28 *//*   0,  12,   27,    23,    42,    63,    56,    48,    59,    64 *//* False if hasher needs to be "prepared" before use. *//* Dynamically allocated area; first member for quickest access. *//* memcmp, memset *//* A (forgetful) hash table to the data seen by the compressor, to
   help create backward references to previous data. */selflen_codemax_backwardshallowdistance_short_codebackward_reference_offsetdistance_cachenum_distances/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/backward_references_hq.h"./hash.h"ZopfliNodedcode_insert_lengthlengthshortcutcostBROTLI_ENC_BACKWARD_REFERENCES_HQ_H_BrotliZopfliCreateCommandsconst ZopfliNodeconst ZopfliNode *ZopfliNode *BrotliZopfliComputeShortestPathBrotliInitZopfliNodesBrotliCreateHqZopfliBackwardReferencesBrotliCreateZopfliBackwardReferences/* BROTLI_ENC_BACKWARD_REFERENCES_HQ_H_ *//* Computes the shortest path of commands from position to at most
   position + num_bytes.

   On return, path->size() is the number of commands found and path[i] is the
   length of the i-th command (copy length plus insert length).
   Note that the sum of the lengths of all commands can be less than num_bytes.

   On return, the nodes[0..num_bytes] array will have the following
   "ZopfliNode array invariant":
   For each i in [1..num_bytes], if nodes[i].cost < kInfinity, then
     (1) nodes[i].copy_length() >= 2
     (2) nodes[i].command_length() <= i and
     (3) nodes[i - nodes[i].command_length()].cost < kInfinity *//* Node position that provides next distance for distance cache. *//* Offset to the next node on the path. Equals to command_length() of the
       next node on the path. For last node equals to BROTLI_UINT32_MAX *//* Smallest cost to get to this byte from the beginning, as found so far. *//* This union holds information used by dynamic-programming. During forward
     pass |cost| it used to store the goal function. When node is processed its
     |cost| is invalidated in favor of |shortcut|. On path back-tracing pass
     |next| is assigned the offset to next node on the path. *//* Number of literal inserts before this copy; highest 5 bits contain
     distance short code + 1 (or zero if no short code). *//* Distance associated with the length. *//* Best length to get up to this byte (not including this byte itself)
     highest 7 bit is used to reconstruct the length code. */block_startnodesarray/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/literal_cost.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/backward_references_hq.c"./params.h""./literal_cost.h""./backward_references_hq.h"stream_offsetnum_matchesmatches_sizecur_match_posorig_num_literalsorig_last_insert_lenorig_dist_cacheorig_num_commandsshadow_matchesBROTLI_IS_NULL(num_matches)BROTLI_IS_NULL(matches)pos + stream_offsetcur_match_pos + MAX_NUM_MATCHES_H10 + shadow_matchescur_match_pos + 128 + shadow_matches(m)_new_sizenew_arrayBackwardMatchLength(&matches[j]) <= BackwardMatchLength(&matches[j + 1])pos + match_lennum_found_matchescur_match_endmatch_len325MAX_ZOPFLI_LEN_QUALITY_11sizeof(num_matches[0])sizeof(dist_cache[0])4 * sizeof(dist_cache[0])num_bytes + 1BROTLI_IS_NULL(nodes)ZopfliCostModel *const ZopfliCostModelconst ZopfliCostModel *max_zopfli_lenqueueBackwardMatch[384](MAX_NUM_MATCHES_H10 + 64)2 * (MAX_NUM_MATCHES_H10 + 64)lz_matches_offsetStartPosQueue *BackwardMatchLength(&matches[0])pos + skipBROTLI_LONG_COPY_QUICK_STEPZopfliIterateBackwardMatchLength(&matches[cur_match_pos - 1])block_start + pos + stream_offsetdistance > dictionary_start + gap0x7FFFFFFis_dictionarydist_codeComputeShortestPathFromNodesUpdateNodescur_ixcur_ix_maskedcur_ix + stream_offsetmax_lenmax_itersmin_lenconst PosDataconst PosData *PosData *posdataconst StartPosQueueconst StartPosQueue *min_costbackward > dictionary_start + gapldist > dictionary_start + gapinscodestart_costdiffbase_costbest_lenconst uint32_t[16]const int[16]int[16]prev_ixcontinuationdist_costcopycodecmdcodematchis_dictionary_matchdist_symboldistextradistnumextramax_match_len0x3FFEvaluateNodenode_coststarting_dist_cacheComputeDistanceCacheilenclenComputeDistanceShortcutComputeMinimumCopyLengthnext_len_bucketnext_len_offsetStartPosQueueAtPosData[8]StartPosQueuePushqPosDataoffset & 7(offset + 1) & 7__brotli_swap_tmpStartPosQueueSizeself->idx_InitStartPosQueueUpdateZopfliNode9uZopfliCostModelGetMinCostCmdZopfliCostModelGetLiteralCostsZopfliCostModelGetDistanceCostZopfliCostModelGetCommandCostfloat[704]ZopfliCostModelSetFromLiteralCostsliteral_costsliteral_carrycost_distcost_cmdZopfliCostModelSetFromCommandsuint32_t[256]histogram_literaluint32_t[704]unsigned int[704]histogram_cmdBROTLI_MAX_EFFECTIVE_DISTANCE_ALPHABET_SIZEhistogram_distfloat[256]cost_literalmin_cost_cmd1.699999976e+38kInfinitysizeof(histogram_literal)2816sizeof(histogram_cmd)2176sizeof(histogram_dist)inslengthcopylengthdistcodecost_cmd[i]SetCostmissing_symbol_sumlog2summissing_symbol_coststart_coststart_posshort_codehistogramhistogram_sizeliteral_histogram2.0CleanupZopfliCostModelself->literal_costs_self->cost_dist_InitZopfliCostModelnum_bytes + 2dist->alphabet_size_limitZopfliNodeCommandLengthZopfliNodeDistanceCodeZopfliNodeCopyDistanceZopfliNodeLengthCodemodifierZopfliNodeCopyLength0x1FFFFFFstubStartPosQueueZopfliCostModelidx_q_costdiffnum_bytes_min_cost_cmd_literal_costs_distance_histogram_sizecost_dist_cost_cmd_const int[]int[]kDistanceCacheOffsetconst uint32_t[]kDistanceCacheIndex1.7e38f/* Add the tail of the copy to the hasher. *//* Ensure that we have enough free slots. *//* REQUIRES: nodes != NULL and len(nodes) >= num_bytes + 1 *//* Try all copy lengths up until the maximum copy length corresponding
           to this distance. If the distance refers to the static dictionary, or
           the maximum length is long enough, try only one maximum length. *//* We already tried all possible last distance matches, so we can use
           normal distance code here. *//* Loop through all possible copy lengths at this position. *//* At higher iterations look only for new last distance matches, since
       looking only for new command start positions with the same distances
       does not help much. *//* "Gray" area. It is addressable by decoder, but this encoder
           instance does not have that data -> should not touch it. *//* Regular backward reference. *//* Word dictionary -> ignore. *//* Look for last distance matches using the distance cache from this
       starting position. *//* Go over the command starting positions in order of increasing cost
     difference. *//* Returns longest copy length. *//* Save cost, because ComputeDistanceCache invalidates it. *//* Maintains "ZopfliNode array invariant" and pushes node to the queue, if it
   is eligible. *//* Because of prerequisite, p >= clen + ilen >= 2. *//* Fills in dist_cache[0..3] with the last four distances (as defined by
   Section 4. of the Spec) that would be used at (block_start + pos) if we
   used the shortest path of commands from block_start, computed from
   nodes[0..pos]. The last four distances at block_start are in
   starting_dist_cache[0..3].
   REQUIRES: nodes[pos].cost < kInfinity
   REQUIRES: nodes[0..pos] satisfies that "ZopfliNode array invariant". *//* Since |block_start + pos| is the end position of the command, the copy part
     starts from |block_start + pos - clen|. Distances that are greater than
     this or greater than |max_backward_limit| + |gap| are static dictionary
     references, and do not update the last distances.
     Also distance code 0 (last distance) does not update the last distances. *//* REQUIRES: nodes[pos].cost < kInfinity
   REQUIRES: nodes[0..pos] satisfies that "ZopfliNode array invariant". *//* We reached the next copy length code bucket, so we add one more
         extra bit to the minimum cost. *//* We already reached (pos + len) with no more cost than the minimum
       possible cost of reaching anything from this pos, so there is no point in
       looking for lengths <= len. *//* Compute the minimum possible cost of reaching any future position. *//* future position. *//* Returns the minimum possible copy length that can improve the cost of any *//* Restore the sorted order. In the list of |len| items at most |len - 1|
     adjacent element comparisons / swaps are required. *//* Maintains the smallest 8 cost difference together with their positions *//* Maintains the "ZopfliNode array invariant". *//* REQUIRES: cost < kInfinity, nodes[start_pos].cost < kInfinity *//* REQUIRES: len >= 2, start_pos <= pos *//* Cannot be coded with less than 1 bit *//* Shannon bits for this symbol. *//* Cumulative costs of literals per position in the stream. *//* The insert and copy length symbols. *//* Histogram based cost model for zopflification. *//* ~= 2 ^ 127 *//* BrotliCalculateDistanceCodeLimit(BROTLI_MAX_ALLOWED_DISTANCE, 3, 120). *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/bit_cost_inc.hBrotliPopulationCostLiteralconst HistogramLiteralconst HistogramLiteral *HistogramLiteral *BrotliPopulationCostHistogramkOneSymbolHistogramCostkTwoSymbolHistogramCostkThreeSymbolHistogramCostkFourSymbolHistogramCostHistogramDataSizesize_t[5]unsigned long[5] 0.012.020.0histo0BROTLI_MAX(uint32_t, histo1, histo2)(brotli_max_uint32_t((histo1), (histo2)))histo1histo2histomax28.0histoh23histo[0]37.0max_depthuint32_t[18]unsigned int[18]depth_histolog2totallog2pdepth0.53.0HistogramTypeFN(Histogram)/* Add the entropy of the code length code histogram. *//* Add the estimated encoding cost of the code length code histogram. *//* Add the 3 extra bits for the 17 code length code. *//* Don't add any cost for the last zero run, since these are encoded
             only implicitly. *//* Compute the run length of zeros and add the appropriate number of 0
           and 17 code length codes to the code length code histogram. *//* Approximate the bit depth by round(-log2(P(symbol))) *//* Compute -log2(P(symbol)) = -log2(count(symbol)/total_count) =
                                    = log2(total_count) - log2(count(symbol)) *//* In this loop we compute the entropy of the histogram and simultaneously
       build a simplified histogram of the code length codes where we use the
       zero repeat code 17, but we don't use the non-zero repeat code 16. *//* Sort *//* template parameters: FN */BrotliPopulationCostCommandconst HistogramCommandconst HistogramCommand *HistogramCommand *BrotliPopulationCostDistanceconst HistogramDistanceconst HistogramDistance *HistogramDistance */home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/bit_cost.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/histogram.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/block_splitter.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/histogram_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/bit_cost.c"./bit_cost_inc.h""./histogram.h""./bit_cost.h"X ## DistanceX ## CommandX ## Literal/* Functions to estimate the bit cost of Huffman trees. */BrotliEncoderVersionBrotliEncoderTakeOutputBrotliEncoderState *BrotliEncoderStateStruct *BrotliEncoderHasMoreOutputBrotliEncoderIsFinishedBrotliEncoderCompressStreamBrotliEncoderCompressBrotliEncoderMaxCompressedSizeBrotliEncoderDestroyInstanceBrotliEncoderCreateInstanceBrotliEncoderSetParameterBrotliEncoderStateBrotliEncoderStateStructBrotliEncoderParameterBROTLI_PARAM_MODEBROTLI_PARAM_QUALITYBROTLI_PARAM_LGWINBROTLI_PARAM_LGBLOCKBROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELINGBROTLI_PARAM_SIZE_HINTBROTLI_PARAM_LARGE_WINDOWBROTLI_PARAM_NPOSTFIXBROTLI_PARAM_NDIRECTBROTLI_PARAM_STREAM_OFFSETBrotliEncoderOperationBROTLI_OPERATION_PROCESSBROTLI_OPERATION_FLUSHBROTLI_OPERATION_FINISHBROTLI_OPERATION_EMIT_METADATABrotliEncoderModeBROTLI_MODE_GENERICBROTLI_MODE_TEXTBROTLI_MODE_FONTBROTLI_DEFAULT_MODEBROTLI_DEFAULT_WINDOWBROTLI_DEFAULT_QUALITYBROTLI_MAX_QUALITYBROTLI_MIN_QUALITYBROTLI_MAX_INPUT_BLOCK_BITSBROTLI_MIN_INPUT_BLOCK_BITSBROTLI_LARGE_MAX_WINDOW_BITSBROTLI_MAX_WINDOW_BITSBROTLI_MIN_WINDOW_BITSBROTLI_ENC_ENCODE_H_*encoded_size/* BROTLI_ENC_ENCODE_H_ *//**
 * Gets an encoder library version.
 *
 * Look at BROTLI_VERSION for more information.
 *//**
 * Acquires pointer to internal output buffer.
 *
 * This method is used to make language bindings easier and more efficient:
 *  -# push data to ::BrotliEncoderCompressStream,
 *     until ::BrotliEncoderHasMoreOutput returns BROTL_TRUE
 *  -# use ::BrotliEncoderTakeOutput to peek bytes and copy to language-specific
 *     entity
 *
 * Also this could be useful if there is an output stream that is able to
 * consume all the provided data (e.g. when data is saved to file system).
 *
 * @attention After every call to ::BrotliEncoderTakeOutput @p *size bytes of
 *            output are considered consumed for all consecutive calls to the
 *            instance methods; returned pointer becomes invalidated as well.
 *
 * @note Encoder output is not guaranteed to be contiguous. This means that
 *       after the size-unrestricted call to ::BrotliEncoderTakeOutput,
 *       immediate next call to ::BrotliEncoderTakeOutput may return more data.
 *
 * @param state encoder instance
 * @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
 *                 any amount could be handled; \n
 *                 @b out: amount of data pointed by returned pointer and
 *                 considered consumed; \n
 *                 out value is never greater than in value, unless it is @c 0
 * @returns pointer to output data
 *//**
 * Checks if encoder has more output.
 *
 * @param state encoder instance
 * @returns ::BROTLI_TRUE, if encoder has some unconsumed output
 * @returns ::BROTLI_FALSE otherwise
 *//**
 * Checks if encoder instance reached the final state.
 *
 * @param state encoder instance
 * @returns ::BROTLI_TRUE if encoder is in a state where it reached the end of
 *          the input and produced all of the output
 * @returns ::BROTLI_FALSE otherwise
 *//**
 * Compresses input stream to output stream.
 *
 * The values @p *available_in and @p *available_out must specify the number of
 * bytes addressable at @p *next_in and @p *next_out respectively.
 * When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
 *
 * After each call, @p *available_in will be decremented by the amount of input
 * bytes consumed, and the @p *next_in pointer will be incremented by that
 * amount. Similarly, @p *available_out will be decremented by the amount of
 * output bytes written, and the @p *next_out pointer will be incremented by
 * that amount.
 *
 * @p total_out, if it is not a null-pointer, will be set to the number
 * of bytes compressed since the last @p state initialization.
 *
 *
 *
 * Internally workflow consists of 3 tasks:
 *  -# (optionally) copy input data to internal buffer
 *  -# actually compress data and (optionally) store it to internal buffer
 *  -# (optionally) copy compressed bytes from internal buffer to output stream
 *
 * Whenever all 3 tasks can't move forward anymore, or error occurs, this
 * method returns the control flow to caller.
 *
 * @p op is used to perform flush, finish the stream, or inject metadata block.
 * See ::BrotliEncoderOperation for more information.
 *
 * Flushing the stream means forcing encoding of all input passed to encoder and
 * completing the current output block, so it could be fully decoded by stream
 * decoder. To perform flush set @p op to ::BROTLI_OPERATION_FLUSH.
 * Under some circumstances (e.g. lack of output stream capacity) this operation
 * would require several calls to ::BrotliEncoderCompressStream. The method must
 * be called again until both input stream is depleted and encoder has no more
 * output (see ::BrotliEncoderHasMoreOutput) after the method is called.
 *
 * Finishing the stream means encoding of all input passed to encoder and
 * adding specific "final" marks, so stream decoder could determine that stream
 * is complete. To perform finish set @p op to ::BROTLI_OPERATION_FINISH.
 * Under some circumstances (e.g. lack of output stream capacity) this operation
 * would require several calls to ::BrotliEncoderCompressStream. The method must
 * be called again until both input stream is depleted and encoder has no more
 * output (see ::BrotliEncoderHasMoreOutput) after the method is called.
 *
 * @warning When flushing and finishing, @p op should not change until operation
 *          is complete; input stream should not be swapped, reduced or
 *          extended as well.
 *
 * @param state encoder instance
 * @param op requested operation
 * @param[in, out] available_in @b in: amount of available input; \n
 *                 @b out: amount of unused input
 * @param[in, out] next_in pointer to the next input byte
 * @param[in, out] available_out @b in: length of output buffer; \n
 *                 @b out: remaining size of output buffer
 * @param[in, out] next_out compressed output buffer cursor;
 *                 can be @c NULL if @p available_out is @c 0
 * @param[out] total_out number of bytes produced so far; can be @c NULL
 * @returns ::BROTLI_FALSE if there was an error
 * @returns ::BROTLI_TRUE otherwise
 *//**
 * Performs one-shot memory-to-memory compression.
 *
 * Compresses the data in @p input_buffer into @p encoded_buffer, and sets
 * @p *encoded_size to the compressed length.
 *
 * @note If ::BrotliEncoderMaxCompressedSize(@p input_size) returns non-zero
 *       value, then output is guaranteed to be no longer than that.
 *
 * @note If @p lgwin is greater than ::BROTLI_MAX_WINDOW_BITS then resulting
 *       stream might be incompatible with RFC 7932; to decode such streams,
 *       decoder should be configured with
 *       ::BROTLI_DECODER_PARAM_LARGE_WINDOW = @c 1
 *
 * @param quality quality parameter value, e.g. ::BROTLI_DEFAULT_QUALITY
 * @param lgwin lgwin parameter value, e.g. ::BROTLI_DEFAULT_WINDOW
 * @param mode mode parameter value, e.g. ::BROTLI_DEFAULT_MODE
 * @param input_size size of @p input_buffer
 * @param input_buffer input data buffer with at least @p input_size
 *        addressable bytes
 * @param[in, out] encoded_size @b in: size of @p encoded_buffer; \n
 *                 @b out: length of compressed data written to
 *                 @p encoded_buffer, or @c 0 if compression fails
 * @param encoded_buffer compressed data destination buffer
 * @returns ::BROTLI_FALSE in case of compression error
 * @returns ::BROTLI_FALSE if output buffer is too small
 * @returns ::BROTLI_TRUE otherwise
 *//**
 * Calculates the output size bound for the given @p input_size.
 *
 * @warning Result is only valid if quality is at least @c 2 and, in
 *          case ::BrotliEncoderCompressStream was used, no flushes
 *          (::BROTLI_OPERATION_FLUSH) were performed.
 *
 * @param input_size size of projected input
 * @returns @c 0 if result does not fit @c size_t
 *//**
 * Deinitializes and frees ::BrotliEncoderState instance.
 *
 * @param state decoder instance to be cleaned up and deallocated
 *//**
 * Creates an instance of ::BrotliEncoderState and initializes it.
 *
 * @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
 * case they are both zero, default memory allocators are used. @p opaque is
 * passed to @p alloc_func and @p free_func when they are called. @p free_func
 * has to return without doing anything when asked to free a NULL pointer.
 *
 * @param alloc_func custom memory allocation function
 * @param free_func custom memory free function
 * @param opaque custom memory manager handle
 * @returns @c 0 if instance can not be allocated or initialized
 * @returns pointer to initialized ::BrotliEncoderState otherwise
 *//**
 * Sets the specified parameter to the given encoder instance.
 *
 * @param state encoder instance
 * @param param parameter to set
 * @param value new parameter value
 * @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
 * @returns ::BROTLI_FALSE if value of parameter can not be changed at current
 *          encoder state (e.g. when encoding is started, window size might be
 *          already encoded and therefore it is impossible to change it)
 * @returns ::BROTLI_TRUE if value is accepted
 * @warning invalid values might be accepted in case they would not break
 *          encoding process.
 *//**
 * Opaque structure that holds encoder state.
 *
 * Allocated and initialized with ::BrotliEncoderCreateInstance.
 * Cleaned up and deallocated with ::BrotliEncoderDestroyInstance.
 *//**
   * Number of bytes of input stream already processed by a different instance.
   *
   * @note It is important to configure all the encoder instances with same
   *       parameters (except this one) in order to allow all the encoded parts
   *       obey the same restrictions implied by header.
   *
   * If offset is not 0, then stream header is omitted.
   * In any case output start is byte aligned, so for proper streams stitching
   * "predecessor" stream must be flushed.
   *
   * Range is not artificially limited, but all the values greater or equal to
   * maximal window size have the same effect. Values greater than 2**30 are not
   * allowed.
   *//**
   * Recommended number of direct distance codes (NDIRECT).
   *
   * Encoder may change this value.
   *
   * Range is from 0 to (15 << NPOSTFIX) in steps of (1 << NPOSTFIX).
   *//**
   * Recommended number of postfix bits (NPOSTFIX).
   *
   * Encoder may change this value.
   *
   * Range is from 0 to ::BROTLI_MAX_NPOSTFIX.
   *//**
   * Estimated total input size for all ::BrotliEncoderCompressStream calls.
   *
   * The default value is 0, which means that the total input size is unknown.
   *//**
   * Flag that affects usage of "literal context modeling" format feature.
   *
   * This flag is a "decoding-speed vs compression ratio" trade-off.
   *//**
   * Recommended input block size.
   *
   * Encoder may reduce this value, e.g. if input is much smaller than input
   * block size.
   *
   * Range is from ::BROTLI_MIN_INPUT_BLOCK_BITS to
   * ::BROTLI_MAX_INPUT_BLOCK_BITS.
   *
   * @note Bigger input block size allows better compression, but consumes more
   *       memory. \n The rough formula of memory used for temporary input
   *       storage is `3 << lgBlock`.
   *//**
   * Recommended sliding LZ77 window size.
   *
   * Encoder may reduce this value, e.g. if input is much smaller than
   * window size.
   *
   * Window size is `(1 << value) - 16`.
   *
   * Range is from ::BROTLI_MIN_WINDOW_BITS to ::BROTLI_MAX_WINDOW_BITS.
   *//**
   * The main compression speed-density lever.
   *
   * The higher the quality, the slower the compression. Range is
   * from ::BROTLI_MIN_QUALITY to ::BROTLI_MAX_QUALITY.
   *//**
   * Tune encoder for specific input.
   *
   * ::BrotliEncoderMode enumerates all available values.
   *//** Options to be used with ::BrotliEncoderSetParameter. *//**
   * Emit metadata block to stream.
   *
   * Metadata is opaque to Brotli: neither encoder, nor decoder processes this
   * data or relies on it. It may be used to pass some extra information from
   * encoder client to decoder client without interfering with main data stream.
   *
   * @note Encoder may emit empty metadata blocks internally, to pad encoded
   *       stream to byte boundary.
   *
   * @warning Until emitting metadata is complete client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * @warning The whole content of input buffer is considered to be the content
   *          of metadata block. Do @b NOT @e append metadata to input stream,
   *          before it is depleted with other operations.
   *
   * Stream is soft-flushed before metadata block is emitted. Metadata block
   * @b MUST be no longer than than 16MiB.
   *//**
   * Finalize the stream.
   *
   * Actual finalization is performed when input stream is depleted and there is
   * enough space in output stream. This means that client should repeat
   * ::BROTLI_OPERATION_FINISH operation until @p available_in becomes @c 0, and
   * ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
   * via ::BrotliEncoderTakeOutput, then operation should be repeated after
   * output buffer is drained.
   *
   * @warning Until finalization is complete, client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * Helper function ::BrotliEncoderIsFinished checks if stream is finalized and
   * output fully dumped.
   *
   * Adding more input data to finalized stream is impossible.
   *//**
   * Produce output for all processed input.
   *
   * Actual flush is performed when input stream is depleted and there is enough
   * space in output stream. This means that client should repeat
   * ::BROTLI_OPERATION_FLUSH operation until @p available_in becomes @c 0, and
   * ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
   * via ::BrotliEncoderTakeOutput, then operation should be repeated after
   * output buffer is drained.
   *
   * @warning Until flush is complete, client @b SHOULD @b NOT swap,
   *          reduce or extend input stream.
   *
   * When flush is complete, output data will be sufficient for decoder to
   * reproduce all the given input.
   *//**
   * Process input.
   *
   * Encoder may postpone producing output, until it has processed enough input.
   *//** Operations that can be performed by streaming encoder. *//** Default value for ::BROTLI_PARAM_MODE parameter. *//** Default value for ::BROTLI_PARAM_LGWIN parameter. *//** Default value for ::BROTLI_PARAM_QUALITY parameter. *//** Compression mode used in WOFF 2.0. *//** Compression mode for UTF-8 formatted text input. *//**
   * Default compression mode.
   *
   * In this mode compressor does not know anything in advance about the
   * properties of the input.
   *//** Options for ::BROTLI_PARAM_MODE parameter. *//** Maximal value for ::BROTLI_PARAM_QUALITY parameter. *//** Minimal value for ::BROTLI_PARAM_QUALITY parameter. *//** Maximal value for ::BROTLI_PARAM_LGBLOCK parameter. *//** Minimal value for ::BROTLI_PARAM_LGBLOCK parameter. *//**
 * Maximal value for ::BROTLI_PARAM_LGWIN parameter
 * in "Large Window Brotli" (32-bit).
 *//**
 * Maximal value for ::BROTLI_PARAM_LGWIN parameter.
 *
 * @note equal to @c BROTLI_MAX_DISTANCE_BITS constant.
 *//** Minimal value for ::BROTLI_PARAM_LGWIN parameter. *//**
 * @file
 * API for Brotli compression.
 */opqualitylgwininput_buffer/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/cluster.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/cluster_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/block_splitter_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/block_splitter.c"./block_splitter_inc.h""./cluster.h""./block_splitter.h"BrotliSplitBlockBlockSplit *literals_countliteralsBROTLI_IS_NULL(literals)kSymbolsPerLiteralHistogramkMaxLiteralHistogramskLiteralStrideLength28.10000000000000142kLiteralBlockSwitchCostinsert_and_copy_codesuint16_tBROTLI_IS_NULL(insert_and_copy_codes)530kSymbolsPerCommandHistogramkMaxCommandHistogramskCommandStrideLength13.5kCommandBlockSwitchCostdistance_prefixesBROTLI_IS_NULL(distance_prefixes)cmdkSymbolsPerDistanceHistogram14.59999999999999964kDistanceBlockSwitchCostBrotliDestroyBlockSplitself->typesself->lengthsBrotliInitBlockSplitBitCost-2.0MyRand1680716807UCopyLiteralsToByteArrayfrom_posinsert_lenhead_sizeCountLiteralstotal_lengthkMinItersForRefiningkIterMulForRefiningkMinLengthForBlockSplitting14.628.1DataTypeCLUSTERS_PER_BATCHHISTOGRAMS_PER_BATCH/* Create the block split on the array of distance prefixes. *//* Create a continuous array of distance prefixes. *//* TODO: reuse for distances? *//* Create the block split on the array of command prefixes. *//* Compute prefix codes for commands. *//* Create the block split on the array of literals.
       Literal histograms have alphabet size 256. *//* Create a continuous array of literals. *//* Initial seed should be 7. In this case, loop length is (1 << 29). *//* Count how many we have. *//* Block split point selection utilities. */cmdsliteral_splitinsert_and_copy_splitdist_splitseed<math.h>FastLog2BROTLI_LOG2_TABLE_SIZEconst double[256]double[256]Log2FloorNonZero(uint32_t)nkBrotliLog2TableLOG_2_INV1.4426950408889634BROTLI_ENC_FAST_LOG_H_defined(BROTLI_BSR32)!defined(BROTLI_HAVE_LOG2)((defined(_MSC_VER) && _MSC_VER <= 1700) || \!(BROTLI_HAVE_LOG2)BROTLI_HAVE_LOG2/* BROTLI_ENC_FAST_LOG_H_ *//* Faster logarithm for small integers, with the property of log2(0) == 0. *//* Visual Studio 2012 and Android API levels < 18 do not have the log2()
 * function defined, so we use log() and a multiplication instead. *//* A lookup table for small values of log2(int) to be used in entropy
   computation. *//* Utilities for fast computation of logarithms. */"./static_dict_lut.h"BrotliInitEncoderDictionaryBrotliEncoderDictionaryconst DictWordconst DictWord *DictWord *dict_wordsbucketshash_table_lengthshash_table_wordscutoffTransformscutoffTransformsCountBROTLI_ENC_ENCODER_DICT_H_/* BROTLI_ENC_ENCODER_DICT_H_ *//* from static_dict_lut.h, for slow encoder *//* from dictionary_hash.h, for fast encoder *//* cut off for fast encoder *//* Dictionary data (words and transforms) for 1 possible context *//* Copyright 2017 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/dict<brotli/encode.h>BrotliEncoderParamsBrotliDistanceParamsBrotliHasherParamsdisable_literal_context_modelingsize_hintlgblocknum_last_distances_to_checkhash_lenblock_bitsbucket_bitsBROTLI_ENC_PARAMS_H_/* BROTLI_ENC_PARAMS_H_ *//* Encoding parameters *//* Parameters for the Brotli encoder with chosen quality levels. */PrefixEncodeCopyDistancebucketpostfix_maskBROTLI_ENC_PREFIX_H_/* BROTLI_ENC_PREFIX_H_ *//* Here distance_code is an intermediate code, i.e. one of the special codes or
   the actual distance increased by BROTLI_NUM_DISTANCE_SHORT_CODES - 1. *//* Functions for encoding of integers into prefix codes the amount of extra
   bits, and the actual values of the extra bits. */num_direct_codespostfix_bitsCommandCopyLenCodeCommandCopyLenCommandDistanceContextCommandRestoreDistanceCode0x3FFudcodehcodelcode2U4UInitInsertCommand4 << 25InitCommand(self->dist_prefix_ & 0x3FF) == 0GetCopyExtraconst uint32_t[24]unsigned int[24]GetCopyBaseGetInsertExtraGetInsertBaseGetLengthCodeCombineLengthCodesbits640x7u3u16u64u5u0x40u53773440x520D40u0xC0uGetCopyLengthCode211823uGetInsertLengthCode2114621021u2259422uCommanddist_prefix_cmd_prefix_dist_extra_copy_len_insert_len_kBrotliCopyExtrakBrotliCopyBasekBrotliInsExtrakBrotliInsBaseBROTLI_ENC_COMMAND_H_/* BROTLI_ENC_COMMAND_H_ *//* The distance prefix and extra bits are stored in this Command as if
     npostfix and ndirect were 0, they are only recomputed later after the
     clustering if needed. *//* Don't rely on signed int representation, use honest casts. *//* distance_code is e.g. 0 for same-as-last short code, or 16 for offset 1. *//* Stores distance code in low 10 bits
     and number of extra bits in high 6 bits. *//* Stores distance extra bits. *//* Stores copy_len in low 25 bits and copy_code - copy_len in high 7 bit. *//* All values in specification are K * 64,
       where   K = [2, 3, 6, 4, 5, 8, 7, 9, 10],
           i + 1 = [1, 2, 3, 4, 5, 6, 7, 8,  9],
       K - i - 1 = [1, 1, 3, 0, 0, 2, 0, 1,  2] = D.
       All values in D require only 2 bits to encode.
       Magic constant is shifted 6 bits left, to avoid final multiplication. *//* offset = 2 * index, where index is in range [0..8] *//* Specification: 5 Encoding of ... (last table) *//* This class models a sequence of literals and a backward reference copy. */insertlencopylencopylen_code_deltause_last_distanceBrotliWipeOutMemoryManagerBrotliFreeBrotliAllocateBrotliInitMemoryManagerMemoryManagerBROTLI_ENSURE_CAPACITY_APPEND(M,T,A,C,S,V){ (S)++; BROTLI_ENSURE_CAPACITY(M, T, A, C, S); A[(S) - 1] = (V); }BROTLI_ENSURE_CAPACITY(M,T,A,C,R){ if (C < (R)) { size_t _new_size = (C == 0) ? (R) : C; T* new_array; while (_new_size < (R)) _new_size *= 2; new_array = BROTLI_ALLOC((M), T, _new_size); if (!BROTLI_IS_OOM(M) && !BROTLI_IS_NULL(new_array) && C != 0) memcpy(new_array, A, C * sizeof(T)); BROTLI_FREE((M), A); A = new_array; C = _new_size; } }BROTLI_IS_NULL(A)BROTLI_IS_OOM(M)BROTLI_FREE(M,P){ BrotliFree((M), (P)); P = NULL; }BROTLI_ALLOC(M,T,N)((N) > 0 ? ((T*)BrotliAllocate((M), (N) * sizeof(T))) : NULL)BROTLI_ENCODER_EXIT_ON_OOMBROTLI_ENC_MEMORY_H_!defined(BROTLI_ENCODER_CLEANUP_ON_OOM) && \!defined(BROTLI_ENCODER_EXIT_ON_OOM)defined(BROTLI_ENCODER_EXIT_ON_OOM)defined(__clang_analyzer__) && !defined(BROTLI_ENCODER_EXIT_ON_OOM)/* BROTLI_ENC_MEMORY_H_ *//*
Appends value and dynamically grows array capacity when needed
M: MemoryManager
T: data type
A: array
C: array capacity
S: array size
V: value to append
*//*
Dynamically grows array capacity to at least the requested size
M: MemoryManager
T: data type
A: array
C: capacity
R: requested size
*//* defined(__clang_analyzer__) *//*
BROTLI_IS_NULL is a fake check, BROTLI_IS_OOM does the heavy lifting.
The only purpose of it is to explain static analyzers the state of things.
NB: use ONLY together with BROTLI_IS_OOM
    AND ONLY for allocations in the current scope.
 *//* BROTLI_ENCODER_EXIT_ON_OOM *//* Macros for memory management. */ChooseHasherLiteralSpreeLengthForSparseSearchMaxMetablockSizeComputeRbBits(params)ComputeRbBitsparams->lgblockComputeLgBlockBROTLI_MAX(int, BROTLI_MIN_INPUT_BLOCK_BITS, lgblock)(brotli_max_int((16), (lgblock)))FAST_ONE_PASS_COMPRESSION_QUALITYFAST_TWO_PASS_COMPRESSION_QUALITYMIN_QUALITY_FOR_BLOCK_SPLITSanitizeParamsBROTLI_MAX(int, BROTLI_MIN_QUALITY, params->quality)(brotli_max_int((0), (params->quality)))params->qualityMAX_QUALITY_FOR_STATIC_ENTROPY_CODESmax_lgwinMaxZopfliCandidatesMaxZopfliLenMAX_ZOPFLI_LEN_QUALITY_10MaxHashTableSizeMAX_NUM_DELAYED_SYMBOLS0x2FFFMIN_QUALITY_FOR_HQ_BLOCK_SPLITTINGMIN_QUALITY_FOR_HQ_CONTEXT_MODELINGMIN_QUALITY_FOR_CONTEXT_MODELINGMIN_QUALITY_FOR_OPTIMIZE_HISTOGRAMSMIN_QUALITY_FOR_NONZERO_DISTANCE_PARAMSHQ_ZOPFLIFICATION_QUALITYZOPFLIFICATION_QUALITYBROTLI_ENC_QUALITY_H_/* BROTLI_ENC_QUALITY_H_ *//* Different hashers for large window brotli: not for qualities <= 2,
       these are too fast for large window. Not for qualities >= 10: their
       hasher already works well with large window. So the changes are:
       H3 --> H35: for quality 3.
       H54 --> H55: for quality 4 with size hint > 1MB
       H6 --> H65: for qualities 5, 6, 7, 8, 9. *//* When searching for backward references and have not seen matches for a long
   time, we can skip some match lookups. Unsuccessful match lookups are very
   expensive and this kind of a heuristic speeds up compression quite a lot.
   At first 8 byte strides are taken and every second byte is put to hasher.
   After 4x more literals stride by 16 bytes, every put 4-th byte to hasher.
   Applied only to qualities 2 to 9. *//* Returns log2 of the size of main ring buffer area.
   Allocate at least lgwin + 1 bits for the ring buffer so that the newly
   added block fits there completely and we still get lgwin bits and at least
   read_block_size_bits + 1 bits because the copy tail length needs to be
   smaller than ring-buffer size. *//* Returns optimized lg_block value. *//* Number of best candidates to evaluate to expand Zopfli chain. *//* Do not thoroughly search when a long copy is found. *//* The maximum length for which the zopflification uses distinct distances. *//* Returns hash-table size for quality levels 0 and 1. *//* For quality below MIN_QUALITY_FOR_BLOCK_SPLIT there is no block splitting,
   so we buffer at most this much literals and commands. *//* Constants and formulas that affect speed-ratio trade-offs and thus define
   quality levels. */hparamsBlockSplitlengths_alloc_sizetypes_alloc_sizelengthstypesnum_blocksnum_typesBROTLI_ENC_BLOCK_SPLITTER_H_/* BROTLI_ENC_BLOCK_SPLITTER_H_ *//* Amount of values in types and length *//* Amount of distinct types */SplitByteVectorLiteralSplitByteVectornum_histogramshistogramssplit->typessplit->types_alloc_sizesplit->num_blocks + 1split->lengthssplit->lengths_alloc_sizeHistogramLiteral1040BROTLI_IS_NULL(histograms)InitialEntropyCodesRefineEntropyCodesblock_idsbitmapleninsert_costdata_size * num_histogramsswitch_signallength * bitmaplennew_iditersBROTLI_IS_NULL(block_ids)BROTLI_IS_NULL(insert_cost)BROTLI_IS_NULL(cost)BROTLI_IS_NULL(switch_signal)BROTLI_IS_NULL(new_id)FindBlocksRemapBlockIdsBuildBlockHistogramsliterals_per_histogrammax_histogramssampling_stride_lengthblock_switch_costsplitClusterBlocksClusterBlocksLiteralhistogram_symbolsblock_lengthsexpected_num_clustersall_histograms_sizeall_histograms_capacityall_histogramscluster_size_sizecluster_size_capacitycluster_sizenum_clustersBROTLI_MIN(size_t, num_blocks, HISTOGRAMS_PER_BATCH)(brotli_min_size_t((num_blocks), (64)))max_num_pairsHISTOGRAMS_PER_BATCH * HISTOGRAMS_PER_BATCHpairs_capacityHistogramPairHistogramPair *pairsclustersnum_final_clusterskInvalidIndexnew_indexuint32_t[64]sizesnew_clustersremapBROTLI_IS_NULL(histogram_symbols)BROTLI_IS_NULL(block_lengths)BROTLI_IS_NULL(all_histograms)BROTLI_IS_NULL(cluster_size)BROTLI_IS_NULL(pairs)sizeof(uint32_t)block_idxblock_idx < num_blocksblock_idx == num_blocksnum_blocks - iHistogramClearHistogramAddBrotliHistogramCombineall_histograms_size + num_new_clusterscluster_size_size + num_new_clustersnum_clusters == cluster_size_sizenum_clusters == all_histograms_sizenum_to_combinenum_new_clusters64 * num_clusters(num_clusters / 2) * num_clustersmax_num_pairs + 1BROTLI_IS_NULL(clusters)BROTLI_IS_NULL(new_index)next_indexBrotliHistogramBitCostDistancebest_outbest_bitscur_bitscur_lengthmax_typeBuildBlockHistogramsLiteralClearHistogramsRemapBlockIdsLiteralkInvalidIdnext_idblock_ids[i] < num_histogramsnext_id <= num_histogramsFindBlocksLiteralsizeof(insert_cost[0])sizeof(cost[0])sizeof(switch_signal[0])(k >> 3) < bitmaplenbyte_ixinsert_cost_ix9.999999999999999673e+98 1e9920000.77000000000000001780.770.070000000000000006660.072000.0cur_id((size_t)cur_id >> 3) < bitmaplennum_histograms <= 256RefineEntropyCodesLiteraliterRandomSampleHistogramAddHistogramRandomSampleLiteralHistogramAddVectorInitialEntropyCodesLiteralblock_switch_bitcostblock_idstride/* Find a good path through literals with the good entropy codes. *//* Find good entropy codes. *//* Trace back from the last position and switch at the marked places. *//* More blocks for the beginning. *//* We are coding the symbol in data[byte_ix] with entropy code k. *//* After each iteration of this loop, cost[k] will contain the difference
     between the minimum cost of arriving at the current byte position using
     entropy code k, and the minimum cost of arriving at the current byte
     position. This difference is capped at the block switch cost, and if it
     reaches block switch cost, it means that when we trace back from the last
     position, we need to switch here. *//* Assigns a block id from the range [0, num_histograms) to each data element
   in data[0..length) and fills in block_id[0..length) with the assigned values.
   Returns the number of blocks, i.e. one plus the number of block switches. *//* template parameters: FN, DataType */SplitByteVectorCommandHistogramCommand2832ClusterBlocksCommandBuildBlockHistogramsCommandRemapBlockIdsCommandFindBlocksCommandRefineEntropyCodesCommandRandomSampleCommandInitialEntropyCodesCommandSplitByteVectorDistanceHistogramDistance2192ClusterBlocksDistanceBuildBlockHistogramsDistanceRemapBlockIdsDistanceFindBlocksDistanceRefineEntropyCodesDistanceRandomSampleDistanceInitialEntropyCodesDistance/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/entropy_encode.hSortHuffmanTreeItemsHuffmanTree *const HuffmanTreeconst HuffmanTree *const size_t[6]unsigned long[6]const size_t *BrotliConvertBitDepthsToSymbolsBrotliWriteHuffmanTreeBrotliOptimizeHuffmanCountsForRleBrotliCreateHuffmanTreeBrotliSetDepthInitHuffmanTreeHuffmanTreeComparatorHuffmanTreeindex_right_or_value_index_left_total_count_kBrotliShellGapsBROTLI_ENC_ENTROPY_ENCODE_H_/* BROTLI_ENC_ENTROPY_ENCODE_H_ *//* Shell sort. *//* Insertion sort. *//* Input size optimized Shell sort. *//* Get the actual bit values for a tree of bit depths. *//* Write a Huffman tree from bit depths into the bit-stream representation
   of a Huffman tree. The generated Huffman tree is to be compressed once
   more using a Huffman tree *//* Change the population counts in a way that the consequent
   Huffman tree compression, especially its RLE-part will be more
   likely to compress this data more efficiently.

   length contains the size of the histogram.
   counts contains the population counts.
   good_for_rle is a buffer of at least length size *//* This function will create a Huffman tree.

   The (data,length) contains the population counts.
   The tree_limit is the maximum bit depth of the Huffman codes.

   The depth contains the tree, i.e., how many bits are used for
   the symbol.

   The actual Huffman tree is constructed in the tree[] array, which has to
   be at least 2 * length + 1 long.

   See http://en.wikipedia.org/wiki/Huffman_coding *//* Returns 1 is assignment of depths succeeded, otherwise 0. *//* A node of a Huffman tree. *//* Entropy encoding (Huffman) utilities. */comparatorrighttree_sizetreeextra_bits_datacountsgood_for_rletree_limitpool"./histogram_inc.h"BrotliBuildHistogramsWithContextconst BlockSplitconst BlockSplit *const ContextTypeconst ContextType *ContextType *DATA_SIZEBROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLSBROTLI_ENC_HISTOGRAM_H_/* BROTLI_ENC_HISTOGRAM_H_ *//* The distance symbols effectively used by "Large Window Brotli" (32-bit). *//* memset *//* Models the histograms of literals, commands and distance codes. */prev_byteprev_byte2literal_histogramsinsert_and_copy_histogramscopy_dist_histograms/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/metablock.hBrotliInitDistanceParamsBrotliOptimizeHistogramsMetaBlockSplit *BrotliBuildMetaBlockGreedyBrotliBuildMetaBlockDestroyMetaBlockSplitmb->literal_context_mapmb->distance_context_mapmb->literal_histogramsmb->command_histogramsmb->distance_histogramsInitMetaBlockSplitMetaBlockSplitdistance_histograms_sizedistance_histogramscommand_histograms_sizecommand_histogramsliteral_histograms_sizedistance_context_map_sizedistance_context_mapliteral_context_map_sizeliteral_context_mapdistance_splitcommand_splitBROTLI_ENC_METABLOCK_H_/* BROTLI_ENC_METABLOCK_H_ *//* Uses a fast greedy block splitter that tries to merge current block with the
   last or the second last block and uses a static context clustering which
   is the same for all block types. *//* Uses the slow shortest-path block splitter and does context clustering.
   The distance parameters are dynamically selected based on the commands
   which get recomputed under the new distance parameters. The new distance
   parameters are stored into *params. *//* Algorithms for distributing the literals and commands of a metablock between
   block types and contexts. */mbnum_distance_codesnum_contextsstatic_context_mapn_commandsliteral_context_mode/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/brotli_bit_stream.h"./metablock.h""./entropy_encode.h"BROTLI_ENC_BROTLI_BIT_STREAM_H_BrotliStoreUncompressedMetaBlockuint8_t *__restrict__BrotliStoreMetaBlockFastBrotliStoreMetaBlockTrivialBrotliStoreMetaBlockconst MetaBlockSplitconst MetaBlockSplit *BrotliBuildAndStoreHuffmanTreeFastBrotliStoreHuffmanTree/* BROTLI_ENC_BROTLI_BIT_STREAM_H_ *//* This is for storing uncompressed blocks (simple raw storage of
   bytes-as-bytes).
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* Same as above, but uses static prefix codes for histograms with a only a few
   symbols, and uses static code length prefix codes for all other histograms.
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* Stores the meta-block without doing any block splitting, just collects
   one histogram per block category and uses that for entropy coding.
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* REQUIRES: length <= (1 << 24) *//* REQUIRES: length > 0 *//* All Store functions here will use a storage_ix, which is always the bit
   position for the current storage. *//* Functions to convert brotli-related data structures into the
   brotli bit stream. The functions here operate under
   assumption that there is enough space in the storage, i.e., there are
   no out-of-range checks anywhere.

   These functions do bit addressing into a byte array. The byte array
   is called "storage" and the index to the bit is called storage_ix
   in function arguments. *//* Copyright 2014 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/is_final_blockinputstorage_ixstoragehistogram_totaldepths/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/write_bits.hBrotliWriteBitsPrepareStorage("WriteBitsPrepareStorage            %10d\n", (int)pos)(pos & 7) == 0BrotliWriteBits("WriteBits  %2d  0x%08x%08x  %10d\n", (int)n_bits, (uint32_t)(bits >> 32), (uint32_t)(bits & 0xFFFFFFFF), (int)*pos)(bits >> n_bits) == 0n_bits <= 56BROTLI_ENC_WRITE_BITS_H_defined(BROTLI_LITTLE_ENDIAN)/* BROTLI_ENC_WRITE_BITS_H_ *//* implicit & 0xFF is assumed for uint8_t arithmetics *//* Set some bits. *//* Zero-extend 8 to 64 bits. *//* This branch of the code can write up to 56 bits at a time,
     7 bits are lost by being perhaps already in *p and at least
     1 bit is needed to initialize the bit-stream ahead (i.e. if 7
     bits are in *p and we write 57 bits, then the next write will
     access a byte that was never initialized). *//* This function writes bits into bytes in increasing addresses, and within
   a byte least-significant-bit first.

   The function can write up to 56 bits in one go with WriteBits
   Example: let's assume that 3 bits (Rs below) have been written already:

   BYTE-0     BYTE+1       BYTE+2

   0000 0RRR    0000 0000    0000 0000

   Now, we could write 5 or less bits in MSB by just shifting by 3
   and OR'ing to BYTE-0.

   For n bits, we take the last 5 bits, OR that with high bits in BYTE-0,
   and locate the rest in BYTE+1, BYTE+2, etc. *//* Write bits into a byte array. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/entropy_encode_static.h"./write_bits.h"StoreStaticDistanceHuffmanTree572692510x0369DC03uStoreStaticCommandHuffmanTree0x926244U0x16307003U95934124120339079705395237227315541203391169327107BROTLI_MAKE_UINT64_T(0x926244U, 0x16307003U)0x00000000UStoreStaticCodeLengthCode0x0000FFu0x55555554u109521666048014316557641096648316244BROTLI_MAKE_UINT64_T(0x0000FFu, 0x55555554u)const uint16_t[64]kStaticDistanceCodeBitsconst uint16_t[704]unsigned short[704]kStaticCommandCodeBitsconst uint32_t[704]kNonZeroRepsDepthconst uint64_t[704]unsigned long[704]kNonZeroRepsBitskZeroRepsDepthkZeroRepsBitsconst uint32_t[18]kCodeLengthBitsconst uint8_t[64]kStaticDistanceCodeDepthconst uint8_t[704]unsigned char[704]kStaticCommandCodeDepthkCodeLengthDepthBROTLI_ENC_ENTROPY_ENCODE_STATIC_H_/* BROTLI_ENC_ENTROPY_ENCODE_STATIC_H_ *//* Static entropy codes used for faster meta-block encoding. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/block_encoder_inc.hBuildAndStoreEntropyCodesLiteralBlockEncoder *BuildAndStoreEntropyCodes/* Creates entropy codes for all block types and stores them to the bit
   stream. */histograms_sizeBuildAndStoreEntropyCodesCommandBuildAndStoreEntropyCodesDistance/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/brotli_bit_stream.c"./block_encoder_inc.h""./entropy_encode_static.h""./brotli_bit_stream.h"masked_posnum_distance_symbolsdistance_alphabet_bitslit_depthuint16_t[256]lit_bitslit_histocmd_histodist_histouint8_t[704]cmd_depthuint16_t[704]cmd_bitsuint8_t[140]unsigned char[140]dist_depthuint16_t[140]unsigned short[140]dist_bitsMAX_HUFFMAN_TREE_SIZE(2 * 704 + 1)1408140911272BROTLI_IS_NULL(tree)StoreDataWithHuffmanCodesBuildHistogramsnum_effective_distance_symbolsliteral_enccommand_encdistance_encnum_effective_distance_symbols <= BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLSJumpToByteBoundary7u4294967288~7uStoreSymbolWithContextblock_ixblock_lenBlockSplitCode *histo_ixStoreSymbolBuildAndStoreBlockSwitchEntropyCodesCleanupBlockEncoderself->depths_self->bits_InitBlockEncoderBlockTypeCodeCalculator *StoreTrivialContextMaprepeat_coderepeat_bitsuint32_t[272]uint8_t[272]unsigned char[272]uint16_t[272]unsigned short[272]sizeof(histogram[0])BuildAndStoreBlockSplitCodeuint32_t[258]unsigned int[258]type_histouint32_t[26]unsigned int[26]length_histotype_code_calculatorsizeof(type_histo[0])sizeof(length_histo)type_codeuint8_t[258]unsigned char[258]uint16_t[258]context_bitshistogram_lengthblock_typesuint8_t[26]unsigned char[26]uint16_t[26]unsigned short[26]StoreBlockSwitchtypecodelencodelen_nextralen_extraEncodeContextMaprle_symbolsnum_rle_symbolskSymbolMaskBROTLI_IS_NULL(rle_symbols)const uint32_t *__restrict__uint32_t *__restrict__1088sizeof(histogram)use_rlemax_run_length_prefix > 0rle_symbolextra_bits_valSYMBOL_BITS1u << SYMBOL_BITS(1u << SYMBOL_BITS)(1u << SYMBOL_BITS) - 1uRunLengthCodeZerosmax_repsmax_prefix*max_run_length_prefix*out_size <= irun_length_prefixMoveToFrontTransformmax_valuemtf_sizeindex < mtf_sizemax_value < 256uMoveToFrontIndexOfsize_t[4]unsigned long[4]sizeof(depth[0])max_tree_sizeis_first_blockin_sizeout_sizev_inv_sizev_outcount_limithistogram[l] >= count_limitsentinelprevious_valueSortHuffmanTreev0->total_count_ < v1->total_count_BuildAndStoreHuffmanTrees4max_bits_counterhuffman_treehuffman_tree_extra_bitshuffman_tree_sizecode_length_bitdepthuint16_t[18]unsigned short[18]code_length_bitdepth_symbolshuffman_tree_histogramnum <= BROTLI_NUM_COMMAND_SYMBOLSStoreSimpleHuffmanTreeBrotliStoreHuffmanTreeToBitMaskBrotliStoreHuffmanTreeOfHuffmanTreeToBitMaskkStorageOrderconst uint8_t[6]kHuffmanBitLengthHuffmanCodeSymbolskHuffmanBitLengthHuffmanCodeBitLengthsskip_somecodes_to_storeBrotliStoreUncompressedMetaBlockHeaderlenbitsnlenbitsnibblesbitsStoreCompressedMetaBlockHeaderStoreVarLenUint8StoreCommandExtracopylen_codeinsnumextrainsextravalcopyextravalBrotliEncodeMlenlgmnibbleslength > 0length <= (1 << 24)lg <= 24NextBlockTypeCode0uInitBlockTypeCodeCalculatorGetBlockLengthPrefixCodeBlockLengthPrefixCodenumbitscalculatorn_extra(BROTLI_NUM_BLOCK_LEN_SYMBOLS - 1)BlockEncoderBlockSplitCodeBlockTypeCodeCalculatorbits_depths_entropy_ix_block_len_block_ix_block_split_code_num_blocks_block_lengths_block_types_num_block_types_histogram_length_length_bitslength_depthstype_bitstype_depthssecond_last_typelast_typeMAX_SIMPLE_DISTANCE_ALPHABET_SIZEBROTLI_DISTANCE_ALPHABET_SIZE(0, 0, BROTLI_LARGE_MAX_DISTANCE_BITS)(2 * BROTLI_NUM_COMMAND_SYMBOLS + 1)/* isempty *//* islast *//* Since the uncompressed block itself may not be the final block, add an
     empty one after this. *//* We need to clear the next 4 bytes to continue to be
     compatible with BrotliWriteBits. *//* This is for storing uncompressed blocks (simple raw storage of
   bytes-as-bytes). *//* max_bits = *//* Stores the next symbol with the entropy code of the current block type and
   context value.
   Updates the block type and block length at block boundaries. *//* Stores the next symbol with the entropy code of the current block type.
   Updates the block type and block length at block boundaries. *//* Creates entropy codes of block lengths and block types and stores them
   to the bit stream. *//* Not owned. *//* Manages the encoding of one block category (literal, command or distance). *//* Write IMTF (inverse-move-to-front) bit. *//* Write RLEMAX. *//* Stores a context map where the histogram type is always the block type. *//* TODO: else? could StoreBlockSwitch occur? *//* Builds a BlockSplitCode data structure from the block split given by the
   vector of block types and block lengths and stores it to the bit stream. *//* Stores the block switch command with index block_ix to the bit stream. *//* use move-to-front *//* Finds runs of zeros in v[0..in_size) and replaces them with a prefix code of
   the run length plus extra bits (lower 9 bits is the prefix code and the rest
   are the extra bits). Non-zero values in v[] are shifted by
   *max_length_prefix. Will not create prefix codes bigger than the initial
   value of *max_run_length_prefix. The prefix code of run length L is simply
   Log2Floor(L) and the number of extra bits is the same as the prefix code. *//* Actual RLE coding. *//* Complex Huffman Tree *//* tree-select *//* NSYM - 1 *//* value of 1 indicates a simple Huffman code *//* We need to pack the Huffman tree in 14 bits. If this was not
             successful, add fake entities to the lowest values and retry. *//* Add back the last sentinel node. *//* The sentinel node becomes the parent node. *//* The nodes are:
           [0, n): the sorted leaf nodes that we start with.
           [n]: we add a sentinel here.
           [n + 1, 2n): new parent nodes are added here, starting from
                        (n+1). These are naturally in ascending order.
           [2n]: we add a sentinel at the end as well.
           There will be (2n+1) elements at the end. *//* Points to the next non-leaf node. *//* Points to the next leaf node. *//* Builds a Huffman tree from histogram[0:length] into depth[0:length] and
   bits[0:length] and stores the encoded tree to the bit stream. *//* Store the real Huffman tree now. *//* Now, we have all the data, let's start storing it *//* Calculate another Huffman tree to use for compressing both the
     earlier Huffman tree with. *//* Calculate the statistics of the Huffman tree in brotli-representation. *//* Write the Huffman tree into the brotli-representation.
     The command alphabet is the largest, so this allocation will fit all
     alphabets. *//* num = alphabet size
   depths = symbol depths *//* Extra bits *//* skips three. *//* skips two. *//* Throw away trailing zeros: *//* skips none. *//* The bit lengths of the Huffman code over the code length alphabet
     are compressed with the following static Huffman code:
       Symbol   Code
       ------   ----
       0          00
       1        1110
       2         110
       3          01
       4          10
       5        1111 *//* Write ISUNCOMPRESSED bit. *//* Write ISLAST bit.
     Uncompressed block cannot be the last one, so set to 0. *//* Stores the uncompressed meta-block header.
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* Write ISEMPTY bit. *//* Write ISLAST bit. *//* Stores the compressed meta-block header.
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* Stores a number between 0 and 255. *//* Data structure that stores almost everything that is needed to encode each
   block switch command. *//* |nibblesbits| represents the 2 bits to encode MNIBBLES (0-3)
   REQUIRES: length > 0
   REQUIRES: length <= (1 << 24) *//* MAX_SIMPLE_DISTANCE_ALPHABET_SIZE == 140 *//* The maximum size of Huffman dictionary for distances assuming that
   NPOSTFIX = 0 and NDIRECT = 0. *//* Brotli bit stream functions to support the low level format. There are no
   compression algorithms here, just the right ordering of bits to match the
   specs. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/cluster.c"./cluster_inc.h"ClusterCostDiffsize_cHistogramPairIsLessconst HistogramPairconst HistogramPair *p1->cost_diff > p2->cost_diff(p1->idx2 - p1->idx1) > (p2->idx2 - p2->idx1)CODECODE(X)X/* Returns entropy reduction of the context map when we combine two clusters. *//* BrotliPopulationCost *//* Functions for clustering similar histograms together. */size_asize_bHistogramDataSizeLiteralHistogramAddHistogramLiteralHistogramAddVectorLiteralHistogramAddLiteralClearHistogramsLiteralHistogramClearLiteralsizeof(self->data_)__builtin_huge_valHUGE_VALbit_cost_data_/* A simple container for histograms of data in blocks. *//* template parameters: Histogram, DATA_SIZE, DataType */HistogramDataSizeCommandHistogramAddHistogramCommandHistogramAddVectorCommandHistogramAddCommandClearHistogramsCommandHistogramClearCommandHistogramDataSizeDistanceHistogramAddHistogramDistanceHistogramAddVectorDistanceHistogramAddDistanceClearHistogramsDistanceHistogramClearDistanceBrotliClusterHistogramsLiteralBrotliClusterHistogramsBrotliHistogramReindexLiteralBrotliHistogramReindexBrotliHistogramRemapLiteralBrotliHistogramRemapBrotliHistogramBitCostDistanceLiteralBrotliHistogramCombineLiteralBrotliCompareAndPushToQueueLiteralBrotliCompareAndPushToQueue{ uint32_t* cluster_size = BROTLI_ALLOC(m, uint32_t, in_size); uint32_t* clusters = BROTLI_ALLOC(m, uint32_t, in_size); size_t num_clusters = 0; const size_t max_input_histograms = 64; size_t pairs_capacity = max_input_histograms * max_input_histograms / 2; HistogramPair* pairs = BROTLI_ALLOC(m, HistogramPair, pairs_capacity + 1); size_t i; if (BROTLI_IS_OOM(m) || BROTLI_IS_NULL(cluster_size) || BROTLI_IS_NULL(clusters) || BROTLI_IS_NULL(pairs)) { return; } for (i = 0; i < in_size; ++i) { cluster_size[i] = 1; } for (i = 0; i < in_size; ++i) { out[i] = in[i]; out[i].bit_cost_ = FN(BrotliPopulationCost)(&in[i]); histogram_symbols[i] = (uint32_t)i; } for (i = 0; i < in_size; i += max_input_histograms) { size_t num_to_combine = BROTLI_MIN(size_t, in_size - i, max_input_histograms); size_t num_new_clusters; size_t j; for (j = 0; j < num_to_combine; ++j) { clusters[num_clusters + j] = (uint32_t)(i + j); } num_new_clusters = FN(BrotliHistogramCombine)(out, cluster_size, &histogram_symbols[i], &clusters[num_clusters], pairs, num_to_combine, num_to_combine, max_histograms, pairs_capacity); num_clusters += num_new_clusters; } { size_t max_num_pairs = BROTLI_MIN(size_t, 64 * num_clusters, (num_clusters / 2) * num_clusters); BROTLI_ENSURE_CAPACITY( m, HistogramPair, pairs, pairs_capacity, max_num_pairs + 1); if (BROTLI_IS_OOM(m)) return; num_clusters = FN(BrotliHistogramCombine)(out, cluster_size, histogram_symbols, clusters, pairs, num_clusters, in_size, max_histograms, max_num_pairs); } BROTLI_FREE(m, pairs); BROTLI_FREE(m, cluster_size); FN(BrotliHistogramRemap)(in, in_size, clusters, num_clusters, out, histogram_symbols); BROTLI_FREE(m, clusters); *out_size = FN(BrotliHistogramReindex)(m, out, histogram_symbols, in_size); if (BROTLI_IS_OOM(m)) return; }{ static const uint32_t kInvalidIndex = BROTLI_UINT32_MAX; uint32_t* new_index = BROTLI_ALLOC(m, uint32_t, length); uint32_t next_index; HistogramType* tmp; size_t i; if (BROTLI_IS_OOM(m) || BROTLI_IS_NULL(new_index)) return 0; for (i = 0; i < length; ++i) { new_index[i] = kInvalidIndex; } next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == kInvalidIndex) { new_index[symbols[i]] = next_index; ++next_index; } } tmp = BROTLI_ALLOC(m, HistogramType, next_index); if (BROTLI_IS_OOM(m) || BROTLI_IS_NULL(tmp)) return 0; next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == next_index) { tmp[next_index] = out[symbols[i]]; ++next_index; } symbols[i] = new_index[symbols[i]]; } BROTLI_FREE(m, new_index); for (i = 0; i < next_index; ++i) { out[i] = tmp[i]; } BROTLI_FREE(m, tmp); return next_index; }{ size_t i; for (i = 0; i < in_size; ++i) { uint32_t best_out = i == 0 ? symbols[0] : symbols[i - 1]; double best_bits = FN(BrotliHistogramBitCostDistance)(&in[i], &out[best_out]); size_t j; for (j = 0; j < num_clusters; ++j) { const double cur_bits = FN(BrotliHistogramBitCostDistance)(&in[i], &out[clusters[j]]); if (cur_bits < best_bits) { best_bits = cur_bits; best_out = clusters[j]; } } symbols[i] = best_out; } for (i = 0; i < num_clusters; ++i) { FN(HistogramClear)(&out[clusters[i]]); } for (i = 0; i < in_size; ++i) { FN(HistogramAddHistogram)(&out[symbols[i]], &in[i]); } }{ if (histogram->total_count_ == 0) { return 0.0; } else { HistogramType tmp = *histogram; FN(HistogramAddHistogram)(&tmp, candidate); return FN(BrotliPopulationCost)(&tmp) - candidate->bit_cost_; } }{ double cost_diff_threshold = 0.0; size_t min_cluster_size = 1; size_t num_pairs = 0; { size_t idx1; for (idx1 = 0; idx1 < num_clusters; ++idx1) { size_t idx2; for (idx2 = idx1 + 1; idx2 < num_clusters; ++idx2) { FN(BrotliCompareAndPushToQueue)(out, cluster_size, clusters[idx1], clusters[idx2], max_num_pairs, &pairs[0], &num_pairs); } } } while (num_clusters > min_cluster_size) { uint32_t best_idx1; uint32_t best_idx2; size_t i; if (pairs[0].cost_diff >= cost_diff_threshold) { cost_diff_threshold = 1e99; min_cluster_size = max_clusters; continue; } best_idx1 = pairs[0].idx1; best_idx2 = pairs[0].idx2; FN(HistogramAddHistogram)(&out[best_idx1], &out[best_idx2]); out[best_idx1].bit_cost_ = pairs[0].cost_combo; cluster_size[best_idx1] += cluster_size[best_idx2]; for (i = 0; i < symbols_size; ++i) { if (symbols[i] == best_idx2) { symbols[i] = best_idx1; } } for (i = 0; i < num_clusters; ++i) { if (clusters[i] == best_idx2) { memmove(&clusters[i], &clusters[i + 1], (num_clusters - i - 1) * sizeof(clusters[0])); break; } } --num_clusters; { size_t copy_to_idx = 0; for (i = 0; i < num_pairs; ++i) { HistogramPair* p = &pairs[i]; if (p->idx1 == best_idx1 || p->idx2 == best_idx1 || p->idx1 == best_idx2 || p->idx2 == best_idx2) { continue; } if (HistogramPairIsLess(&pairs[0], p)) { HistogramPair front = pairs[0]; pairs[0] = *p; pairs[copy_to_idx] = front; } else { pairs[copy_to_idx] = *p; } ++copy_to_idx; } num_pairs = copy_to_idx; } for (i = 0; i < num_clusters; ++i) { FN(BrotliCompareAndPushToQueue)(out, cluster_size, best_idx1, clusters[i], max_num_pairs, &pairs[0], &num_pairs); } } return num_clusters; }{ BROTLI_BOOL is_good_pair = BROTLI_FALSE; HistogramPair p; p.idx1 = p.idx2 = 0; p.cost_diff = p.cost_combo = 0; if (idx1 == idx2) { return; } if (idx2 < idx1) { uint32_t t = idx2; idx2 = idx1; idx1 = t; } p.idx1 = idx1; p.idx2 = idx2; p.cost_diff = 0.5 * ClusterCostDiff(cluster_size[idx1], cluster_size[idx2]); p.cost_diff -= out[idx1].bit_cost_; p.cost_diff -= out[idx2].bit_cost_; if (out[idx1].total_count_ == 0) { p.cost_combo = out[idx2].bit_cost_; is_good_pair = BROTLI_TRUE; } else if (out[idx2].total_count_ == 0) { p.cost_combo = out[idx1].bit_cost_; is_good_pair = BROTLI_TRUE; } else { double threshold = *num_pairs == 0 ? 1e99 : BROTLI_MAX(double, 0.0, pairs[0].cost_diff); HistogramType combo = out[idx1]; double cost_combo; FN(HistogramAddHistogram)(&combo, &out[idx2]); cost_combo = FN(BrotliPopulationCost)(&combo); if (cost_combo < threshold - p.cost_diff) { p.cost_combo = cost_combo; is_good_pair = BROTLI_TRUE; } } if (is_good_pair) { p.cost_diff += p.cost_combo; if (*num_pairs > 0 && HistogramPairIsLess(&pairs[0], &p)) { if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = pairs[0]; ++(*num_pairs); } pairs[0] = p; } else if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = p; ++(*num_pairs); } } }/* Convert the context map to a canonical form. *//* Find the optimal map from original histograms to the final ones. *//* Collapse similar histograms. *//* For the second pass, we limit the total number of histogram pairs.
       After this limit is reached, we only keep searching for the best pair. *//* For the first pass of clustering, we allow all pairs. *//* TODO: by using idea of "cycle-sort" we can avoid allocation of
     tmp and reduce the number of copying by the factor of 2. *//* Reorders elements of the out[0..length) array and changes values in
   symbols[0..length) array in the following way:
     * when called, symbols[] contains indexes into out[], and has N unique
       values (possibly N < length)
     * on return, symbols'[i] = f(symbols[i]) and
                  out'[symbols'[i]] = out[symbols[i]], for each 0 <= i < length,
       where f is a bijection between the range of symbols[] and [0..N), and
       the first occurrences of values in symbols'[i] come in consecutive
       increasing order.
   Returns N, the number of unique values in symbols[]. *//* Recompute each out based on raw and symbols. *//* Find the best 'out' histogram for each of the 'in' histograms.
   When called, clusters[0..num_clusters) contains the unique values from
   symbols[0..in_size), but this property is not preserved in this function.
   Note: we assume that out[]->bit_cost_ is already up-to-date. *//* What is the bit cost of moving histogram from cur_symbol to candidate. *//* Push new pairs formed with the combined histogram to the heap. *//* Replace the top of the queue if needed. *//* Remove invalid pair from the queue. *//* Remove pairs intersecting the just combined best pair. *//* Take the best pair from the top of heap. *//* We maintain a vector of histogram pairs, with the property that the pair
       with the maximum bit cost reduction is the first. *//* Computes the bit cost reduction by combining out[idx1] and out[idx2] and if
   it is below a threshold, stores the pair (idx1, idx2) in the *pairs queue. *//* template parameters: FN, CODE */candidatesymbols_sizemax_clustersidx1idx2num_pairsBrotliClusterHistogramsCommandBrotliHistogramReindexCommandBrotliHistogramRemapCommandBrotliHistogramBitCostDistanceCommandBrotliHistogramCombineCommandBrotliCompareAndPushToQueueCommandBrotliClusterHistogramsDistanceBrotliHistogramReindexDistanceBrotliHistogramRemapDistanceBrotliHistogramBitCostDistanceDistanceBrotliHistogramCombineDistanceBrotliCompareAndPushToQueueDistancecost_diffcost_comboBROTLI_ENC_CLUSTER_H_/* BROTLI_ENC_CLUSTER_H_ *//* Declaration */BitsEntropyretvalShannonEntropypopulation_endodd_number_of_elements_leftBROTLI_ENC_BIT_COST_H_/* BROTLI_ENC_BIT_COST_H_ *//* At least one bit per literal is needed. */population{ uint32_t* cluster_size = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); uint32_t* clusters = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); size_t num_clusters = 0; const size_t max_input_histograms = 64; size_t pairs_capacity = max_input_histograms * max_input_histograms / 2; HistogramPair* pairs = ((pairs_capacity + 1) > 0 ? ((HistogramPair*)BrotliAllocate((m), (pairs_capacity + 1) * sizeof(HistogramPair))) : ((void *)0)); size_t i; if ((!!0) || (!!0) || (!!0) || (!!0)) { return; } for (i = 0; i < in_size; ++i) { cluster_size[i] = 1; } for (i = 0; i < in_size; ++i) { out[i] = in[i]; out[i].bit_cost_ = BrotliPopulationCostLiteral(&in[i]); histogram_symbols[i] = (uint32_t)i; } for (i = 0; i < in_size; i += max_input_histograms) { size_t num_to_combine = (brotli_min_size_t((in_size - i), (max_input_histograms))); size_t num_new_clusters; size_t j; for (j = 0; j < num_to_combine; ++j) { clusters[num_clusters + j] = (uint32_t)(i + j); } num_new_clusters = BrotliHistogramCombineLiteral(out, cluster_size, &histogram_symbols[i], &clusters[num_clusters], pairs, num_to_combine, num_to_combine, max_histograms, pairs_capacity); num_clusters += num_new_clusters; } { size_t max_num_pairs = (brotli_min_size_t((64 * num_clusters), ((num_clusters / 2) * num_clusters))); { if (pairs_capacity < (max_num_pairs + 1)) { size_t _new_size = (pairs_capacity == 0) ? (max_num_pairs + 1) : pairs_capacity; HistogramPair* new_array; while (_new_size < (max_num_pairs + 1)) _new_size *= 2; new_array = ((_new_size) > 0 ? ((HistogramPair*)BrotliAllocate(((m)), (_new_size) * sizeof(HistogramPair))) : ((void *)0)); if (!(!!0) && !(!!0) && pairs_capacity != 0) memcpy(new_array, pairs, pairs_capacity * sizeof(HistogramPair)); { BrotliFree(((m)), (pairs)); pairs = ((void *)0); }; pairs = new_array; pairs_capacity = _new_size; } }; if ((!!0)) return; num_clusters = BrotliHistogramCombineLiteral(out, cluster_size, histogram_symbols, clusters, pairs, num_clusters, in_size, max_histograms, max_num_pairs); } { BrotliFree((m), (pairs)); pairs = ((void *)0); }; { BrotliFree((m), (cluster_size)); cluster_size = ((void *)0); }; BrotliHistogramRemapLiteral(in, in_size, clusters, num_clusters, out, histogram_symbols); { BrotliFree((m), (clusters)); clusters = ((void *)0); }; *out_size = BrotliHistogramReindexLiteral(m, out, histogram_symbols, in_size); if ((!!0)) return; }max_input_histogramspairs_capacity + 1in_size - i{ static const uint32_t kInvalidIndex = (~((uint32_t)0)); uint32_t* new_index = ((length) > 0 ? ((uint32_t*)BrotliAllocate((m), (length) * sizeof(uint32_t))) : ((void *)0)); uint32_t next_index; HistogramLiteral* tmp; size_t i; if ((!!0) || (!!0)) return 0; for (i = 0; i < length; ++i) { new_index[i] = kInvalidIndex; } next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == kInvalidIndex) { new_index[symbols[i]] = next_index; ++next_index; } } tmp = ((next_index) > 0 ? ((HistogramLiteral*)BrotliAllocate((m), (next_index) * sizeof(HistogramLiteral))) : ((void *)0)); if ((!!0) || (!!0)) return 0; next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == next_index) { tmp[next_index] = out[symbols[i]]; ++next_index; } symbols[i] = new_index[symbols[i]]; } { BrotliFree((m), (new_index)); new_index = ((void *)0); }; for (i = 0; i < next_index; ++i) { out[i] = tmp[i]; } { BrotliFree((m), (tmp)); tmp = ((void *)0); }; return next_index; }{ size_t i; for (i = 0; i < in_size; ++i) { uint32_t best_out = i == 0 ? symbols[0] : symbols[i - 1]; double best_bits = BrotliHistogramBitCostDistanceLiteral(&in[i], &out[best_out]); size_t j; for (j = 0; j < num_clusters; ++j) { const double cur_bits = BrotliHistogramBitCostDistanceLiteral(&in[i], &out[clusters[j]]); if (cur_bits < best_bits) { best_bits = cur_bits; best_out = clusters[j]; } } symbols[i] = best_out; } for (i = 0; i < num_clusters; ++i) { HistogramClearLiteral(&out[clusters[i]]); } for (i = 0; i < in_size; ++i) { HistogramAddHistogramLiteral(&out[symbols[i]], &in[i]); } }{ if (histogram->total_count_ == 0) { return 0.0; } else { HistogramLiteral tmp = *histogram; HistogramAddHistogramLiteral(&tmp, candidate); return BrotliPopulationCostLiteral(&tmp) - candidate->bit_cost_; } }{ double cost_diff_threshold = 0.0; size_t min_cluster_size = 1; size_t num_pairs = 0; { size_t idx1; for (idx1 = 0; idx1 < num_clusters; ++idx1) { size_t idx2; for (idx2 = idx1 + 1; idx2 < num_clusters; ++idx2) { BrotliCompareAndPushToQueueLiteral(out, cluster_size, clusters[idx1], clusters[idx2], max_num_pairs, &pairs[0], &num_pairs); } } } while (num_clusters > min_cluster_size) { uint32_t best_idx1; uint32_t best_idx2; size_t i; if (pairs[0].cost_diff >= cost_diff_threshold) { cost_diff_threshold = 1e99; min_cluster_size = max_clusters; continue; } best_idx1 = pairs[0].idx1; best_idx2 = pairs[0].idx2; HistogramAddHistogramLiteral(&out[best_idx1], &out[best_idx2]); out[best_idx1].bit_cost_ = pairs[0].cost_combo; cluster_size[best_idx1] += cluster_size[best_idx2]; for (i = 0; i < symbols_size; ++i) { if (symbols[i] == best_idx2) { symbols[i] = best_idx1; } } for (i = 0; i < num_clusters; ++i) { if (clusters[i] == best_idx2) { memmove(&clusters[i], &clusters[i + 1], (num_clusters - i - 1) * sizeof(clusters[0])); break; } } --num_clusters; { size_t copy_to_idx = 0; for (i = 0; i < num_pairs; ++i) { HistogramPair* p = &pairs[i]; if (p->idx1 == best_idx1 || p->idx2 == best_idx1 || p->idx1 == best_idx2 || p->idx2 == best_idx2) { continue; } if (HistogramPairIsLess(&pairs[0], p)) { HistogramPair front = pairs[0]; pairs[0] = *p; pairs[copy_to_idx] = front; } else { pairs[copy_to_idx] = *p; } ++copy_to_idx; } num_pairs = copy_to_idx; } for (i = 0; i < num_clusters; ++i) { BrotliCompareAndPushToQueueLiteral(out, cluster_size, best_idx1, clusters[i], max_num_pairs, &pairs[0], &num_pairs); } } return num_clusters; }cost_diff_thresholdmin_cluster_sizebest_idx1best_idx2copy_to_idxfront{ int is_good_pair = 0; HistogramPair p; p.idx1 = p.idx2 = 0; p.cost_diff = p.cost_combo = 0; if (idx1 == idx2) { return; } if (idx2 < idx1) { uint32_t t = idx2; idx2 = idx1; idx1 = t; } p.idx1 = idx1; p.idx2 = idx2; p.cost_diff = 0.5 * ClusterCostDiff(cluster_size[idx1], cluster_size[idx2]); p.cost_diff -= out[idx1].bit_cost_; p.cost_diff -= out[idx2].bit_cost_; if (out[idx1].total_count_ == 0) { p.cost_combo = out[idx2].bit_cost_; is_good_pair = 1; } else if (out[idx2].total_count_ == 0) { p.cost_combo = out[idx1].bit_cost_; is_good_pair = 1; } else { double threshold = *num_pairs == 0 ? 1e99 : (brotli_max_double((0.0), (pairs[0].cost_diff))); HistogramLiteral combo = out[idx1]; double cost_combo; HistogramAddHistogramLiteral(&combo, &out[idx2]); cost_combo = BrotliPopulationCostLiteral(&combo); if (cost_combo < threshold - p.cost_diff) { p.cost_combo = cost_combo; is_good_pair = 1; } } if (is_good_pair) { p.cost_diff += p.cost_combo; if (*num_pairs > 0 && HistogramPairIsLess(&pairs[0], &p)) { if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = pairs[0]; ++(*num_pairs); } pairs[0] = p; } else if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = p; ++(*num_pairs); } } }is_good_pairthresholdpairs[0].cost_diffcombo{ uint32_t* cluster_size = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); uint32_t* clusters = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); size_t num_clusters = 0; const size_t max_input_histograms = 64; size_t pairs_capacity = max_input_histograms * max_input_histograms / 2; HistogramPair* pairs = ((pairs_capacity + 1) > 0 ? ((HistogramPair*)BrotliAllocate((m), (pairs_capacity + 1) * sizeof(HistogramPair))) : ((void *)0)); size_t i; if ((!!0) || (!!0) || (!!0) || (!!0)) { return; } for (i = 0; i < in_size; ++i) { cluster_size[i] = 1; } for (i = 0; i < in_size; ++i) { out[i] = in[i]; out[i].bit_cost_ = BrotliPopulationCostCommand(&in[i]); histogram_symbols[i] = (uint32_t)i; } for (i = 0; i < in_size; i += max_input_histograms) { size_t num_to_combine = (brotli_min_size_t((in_size - i), (max_input_histograms))); size_t num_new_clusters; size_t j; for (j = 0; j < num_to_combine; ++j) { clusters[num_clusters + j] = (uint32_t)(i + j); } num_new_clusters = BrotliHistogramCombineCommand(out, cluster_size, &histogram_symbols[i], &clusters[num_clusters], pairs, num_to_combine, num_to_combine, max_histograms, pairs_capacity); num_clusters += num_new_clusters; } { size_t max_num_pairs = (brotli_min_size_t((64 * num_clusters), ((num_clusters / 2) * num_clusters))); { if (pairs_capacity < (max_num_pairs + 1)) { size_t _new_size = (pairs_capacity == 0) ? (max_num_pairs + 1) : pairs_capacity; HistogramPair* new_array; while (_new_size < (max_num_pairs + 1)) _new_size *= 2; new_array = ((_new_size) > 0 ? ((HistogramPair*)BrotliAllocate(((m)), (_new_size) * sizeof(HistogramPair))) : ((void *)0)); if (!(!!0) && !(!!0) && pairs_capacity != 0) memcpy(new_array, pairs, pairs_capacity * sizeof(HistogramPair)); { BrotliFree(((m)), (pairs)); pairs = ((void *)0); }; pairs = new_array; pairs_capacity = _new_size; } }; if ((!!0)) return; num_clusters = BrotliHistogramCombineCommand(out, cluster_size, histogram_symbols, clusters, pairs, num_clusters, in_size, max_histograms, max_num_pairs); } { BrotliFree((m), (pairs)); pairs = ((void *)0); }; { BrotliFree((m), (cluster_size)); cluster_size = ((void *)0); }; BrotliHistogramRemapCommand(in, in_size, clusters, num_clusters, out, histogram_symbols); { BrotliFree((m), (clusters)); clusters = ((void *)0); }; *out_size = BrotliHistogramReindexCommand(m, out, histogram_symbols, in_size); if ((!!0)) return; }{ static const uint32_t kInvalidIndex = (~((uint32_t)0)); uint32_t* new_index = ((length) > 0 ? ((uint32_t*)BrotliAllocate((m), (length) * sizeof(uint32_t))) : ((void *)0)); uint32_t next_index; HistogramCommand* tmp; size_t i; if ((!!0) || (!!0)) return 0; for (i = 0; i < length; ++i) { new_index[i] = kInvalidIndex; } next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == kInvalidIndex) { new_index[symbols[i]] = next_index; ++next_index; } } tmp = ((next_index) > 0 ? ((HistogramCommand*)BrotliAllocate((m), (next_index) * sizeof(HistogramCommand))) : ((void *)0)); if ((!!0) || (!!0)) return 0; next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == next_index) { tmp[next_index] = out[symbols[i]]; ++next_index; } symbols[i] = new_index[symbols[i]]; } { BrotliFree((m), (new_index)); new_index = ((void *)0); }; for (i = 0; i < next_index; ++i) { out[i] = tmp[i]; } { BrotliFree((m), (tmp)); tmp = ((void *)0); }; return next_index; }{ size_t i; for (i = 0; i < in_size; ++i) { uint32_t best_out = i == 0 ? symbols[0] : symbols[i - 1]; double best_bits = BrotliHistogramBitCostDistanceCommand(&in[i], &out[best_out]); size_t j; for (j = 0; j < num_clusters; ++j) { const double cur_bits = BrotliHistogramBitCostDistanceCommand(&in[i], &out[clusters[j]]); if (cur_bits < best_bits) { best_bits = cur_bits; best_out = clusters[j]; } } symbols[i] = best_out; } for (i = 0; i < num_clusters; ++i) { HistogramClearCommand(&out[clusters[i]]); } for (i = 0; i < in_size; ++i) { HistogramAddHistogramCommand(&out[symbols[i]], &in[i]); } }{ if (histogram->total_count_ == 0) { return 0.0; } else { HistogramCommand tmp = *histogram; HistogramAddHistogramCommand(&tmp, candidate); return BrotliPopulationCostCommand(&tmp) - candidate->bit_cost_; } }{ double cost_diff_threshold = 0.0; size_t min_cluster_size = 1; size_t num_pairs = 0; { size_t idx1; for (idx1 = 0; idx1 < num_clusters; ++idx1) { size_t idx2; for (idx2 = idx1 + 1; idx2 < num_clusters; ++idx2) { BrotliCompareAndPushToQueueCommand(out, cluster_size, clusters[idx1], clusters[idx2], max_num_pairs, &pairs[0], &num_pairs); } } } while (num_clusters > min_cluster_size) { uint32_t best_idx1; uint32_t best_idx2; size_t i; if (pairs[0].cost_diff >= cost_diff_threshold) { cost_diff_threshold = 1e99; min_cluster_size = max_clusters; continue; } best_idx1 = pairs[0].idx1; best_idx2 = pairs[0].idx2; HistogramAddHistogramCommand(&out[best_idx1], &out[best_idx2]); out[best_idx1].bit_cost_ = pairs[0].cost_combo; cluster_size[best_idx1] += cluster_size[best_idx2]; for (i = 0; i < symbols_size; ++i) { if (symbols[i] == best_idx2) { symbols[i] = best_idx1; } } for (i = 0; i < num_clusters; ++i) { if (clusters[i] == best_idx2) { memmove(&clusters[i], &clusters[i + 1], (num_clusters - i - 1) * sizeof(clusters[0])); break; } } --num_clusters; { size_t copy_to_idx = 0; for (i = 0; i < num_pairs; ++i) { HistogramPair* p = &pairs[i]; if (p->idx1 == best_idx1 || p->idx2 == best_idx1 || p->idx1 == best_idx2 || p->idx2 == best_idx2) { continue; } if (HistogramPairIsLess(&pairs[0], p)) { HistogramPair front = pairs[0]; pairs[0] = *p; pairs[copy_to_idx] = front; } else { pairs[copy_to_idx] = *p; } ++copy_to_idx; } num_pairs = copy_to_idx; } for (i = 0; i < num_clusters; ++i) { BrotliCompareAndPushToQueueCommand(out, cluster_size, best_idx1, clusters[i], max_num_pairs, &pairs[0], &num_pairs); } } return num_clusters; }{ int is_good_pair = 0; HistogramPair p; p.idx1 = p.idx2 = 0; p.cost_diff = p.cost_combo = 0; if (idx1 == idx2) { return; } if (idx2 < idx1) { uint32_t t = idx2; idx2 = idx1; idx1 = t; } p.idx1 = idx1; p.idx2 = idx2; p.cost_diff = 0.5 * ClusterCostDiff(cluster_size[idx1], cluster_size[idx2]); p.cost_diff -= out[idx1].bit_cost_; p.cost_diff -= out[idx2].bit_cost_; if (out[idx1].total_count_ == 0) { p.cost_combo = out[idx2].bit_cost_; is_good_pair = 1; } else if (out[idx2].total_count_ == 0) { p.cost_combo = out[idx1].bit_cost_; is_good_pair = 1; } else { double threshold = *num_pairs == 0 ? 1e99 : (brotli_max_double((0.0), (pairs[0].cost_diff))); HistogramCommand combo = out[idx1]; double cost_combo; HistogramAddHistogramCommand(&combo, &out[idx2]); cost_combo = BrotliPopulationCostCommand(&combo); if (cost_combo < threshold - p.cost_diff) { p.cost_combo = cost_combo; is_good_pair = 1; } } if (is_good_pair) { p.cost_diff += p.cost_combo; if (*num_pairs > 0 && HistogramPairIsLess(&pairs[0], &p)) { if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = pairs[0]; ++(*num_pairs); } pairs[0] = p; } else if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = p; ++(*num_pairs); } } }{ uint32_t* cluster_size = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); uint32_t* clusters = ((in_size) > 0 ? ((uint32_t*)BrotliAllocate((m), (in_size) * sizeof(uint32_t))) : ((void *)0)); size_t num_clusters = 0; const size_t max_input_histograms = 64; size_t pairs_capacity = max_input_histograms * max_input_histograms / 2; HistogramPair* pairs = ((pairs_capacity + 1) > 0 ? ((HistogramPair*)BrotliAllocate((m), (pairs_capacity + 1) * sizeof(HistogramPair))) : ((void *)0)); size_t i; if ((!!0) || (!!0) || (!!0) || (!!0)) { return; } for (i = 0; i < in_size; ++i) { cluster_size[i] = 1; } for (i = 0; i < in_size; ++i) { out[i] = in[i]; out[i].bit_cost_ = BrotliPopulationCostDistance(&in[i]); histogram_symbols[i] = (uint32_t)i; } for (i = 0; i < in_size; i += max_input_histograms) { size_t num_to_combine = (brotli_min_size_t((in_size - i), (max_input_histograms))); size_t num_new_clusters; size_t j; for (j = 0; j < num_to_combine; ++j) { clusters[num_clusters + j] = (uint32_t)(i + j); } num_new_clusters = BrotliHistogramCombineDistance(out, cluster_size, &histogram_symbols[i], &clusters[num_clusters], pairs, num_to_combine, num_to_combine, max_histograms, pairs_capacity); num_clusters += num_new_clusters; } { size_t max_num_pairs = (brotli_min_size_t((64 * num_clusters), ((num_clusters / 2) * num_clusters))); { if (pairs_capacity < (max_num_pairs + 1)) { size_t _new_size = (pairs_capacity == 0) ? (max_num_pairs + 1) : pairs_capacity; HistogramPair* new_array; while (_new_size < (max_num_pairs + 1)) _new_size *= 2; new_array = ((_new_size) > 0 ? ((HistogramPair*)BrotliAllocate(((m)), (_new_size) * sizeof(HistogramPair))) : ((void *)0)); if (!(!!0) && !(!!0) && pairs_capacity != 0) memcpy(new_array, pairs, pairs_capacity * sizeof(HistogramPair)); { BrotliFree(((m)), (pairs)); pairs = ((void *)0); }; pairs = new_array; pairs_capacity = _new_size; } }; if ((!!0)) return; num_clusters = BrotliHistogramCombineDistance(out, cluster_size, histogram_symbols, clusters, pairs, num_clusters, in_size, max_histograms, max_num_pairs); } { BrotliFree((m), (pairs)); pairs = ((void *)0); }; { BrotliFree((m), (cluster_size)); cluster_size = ((void *)0); }; BrotliHistogramRemapDistance(in, in_size, clusters, num_clusters, out, histogram_symbols); { BrotliFree((m), (clusters)); clusters = ((void *)0); }; *out_size = BrotliHistogramReindexDistance(m, out, histogram_symbols, in_size); if ((!!0)) return; }{ static const uint32_t kInvalidIndex = (~((uint32_t)0)); uint32_t* new_index = ((length) > 0 ? ((uint32_t*)BrotliAllocate((m), (length) * sizeof(uint32_t))) : ((void *)0)); uint32_t next_index; HistogramDistance* tmp; size_t i; if ((!!0) || (!!0)) return 0; for (i = 0; i < length; ++i) { new_index[i] = kInvalidIndex; } next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == kInvalidIndex) { new_index[symbols[i]] = next_index; ++next_index; } } tmp = ((next_index) > 0 ? ((HistogramDistance*)BrotliAllocate((m), (next_index) * sizeof(HistogramDistance))) : ((void *)0)); if ((!!0) || (!!0)) return 0; next_index = 0; for (i = 0; i < length; ++i) { if (new_index[symbols[i]] == next_index) { tmp[next_index] = out[symbols[i]]; ++next_index; } symbols[i] = new_index[symbols[i]]; } { BrotliFree((m), (new_index)); new_index = ((void *)0); }; for (i = 0; i < next_index; ++i) { out[i] = tmp[i]; } { BrotliFree((m), (tmp)); tmp = ((void *)0); }; return next_index; }{ size_t i; for (i = 0; i < in_size; ++i) { uint32_t best_out = i == 0 ? symbols[0] : symbols[i - 1]; double best_bits = BrotliHistogramBitCostDistanceDistance(&in[i], &out[best_out]); size_t j; for (j = 0; j < num_clusters; ++j) { const double cur_bits = BrotliHistogramBitCostDistanceDistance(&in[i], &out[clusters[j]]); if (cur_bits < best_bits) { best_bits = cur_bits; best_out = clusters[j]; } } symbols[i] = best_out; } for (i = 0; i < num_clusters; ++i) { HistogramClearDistance(&out[clusters[i]]); } for (i = 0; i < in_size; ++i) { HistogramAddHistogramDistance(&out[symbols[i]], &in[i]); } }{ if (histogram->total_count_ == 0) { return 0.0; } else { HistogramDistance tmp = *histogram; HistogramAddHistogramDistance(&tmp, candidate); return BrotliPopulationCostDistance(&tmp) - candidate->bit_cost_; } }{ double cost_diff_threshold = 0.0; size_t min_cluster_size = 1; size_t num_pairs = 0; { size_t idx1; for (idx1 = 0; idx1 < num_clusters; ++idx1) { size_t idx2; for (idx2 = idx1 + 1; idx2 < num_clusters; ++idx2) { BrotliCompareAndPushToQueueDistance(out, cluster_size, clusters[idx1], clusters[idx2], max_num_pairs, &pairs[0], &num_pairs); } } } while (num_clusters > min_cluster_size) { uint32_t best_idx1; uint32_t best_idx2; size_t i; if (pairs[0].cost_diff >= cost_diff_threshold) { cost_diff_threshold = 1e99; min_cluster_size = max_clusters; continue; } best_idx1 = pairs[0].idx1; best_idx2 = pairs[0].idx2; HistogramAddHistogramDistance(&out[best_idx1], &out[best_idx2]); out[best_idx1].bit_cost_ = pairs[0].cost_combo; cluster_size[best_idx1] += cluster_size[best_idx2]; for (i = 0; i < symbols_size; ++i) { if (symbols[i] == best_idx2) { symbols[i] = best_idx1; } } for (i = 0; i < num_clusters; ++i) { if (clusters[i] == best_idx2) { memmove(&clusters[i], &clusters[i + 1], (num_clusters - i - 1) * sizeof(clusters[0])); break; } } --num_clusters; { size_t copy_to_idx = 0; for (i = 0; i < num_pairs; ++i) { HistogramPair* p = &pairs[i]; if (p->idx1 == best_idx1 || p->idx2 == best_idx1 || p->idx1 == best_idx2 || p->idx2 == best_idx2) { continue; } if (HistogramPairIsLess(&pairs[0], p)) { HistogramPair front = pairs[0]; pairs[0] = *p; pairs[copy_to_idx] = front; } else { pairs[copy_to_idx] = *p; } ++copy_to_idx; } num_pairs = copy_to_idx; } for (i = 0; i < num_clusters; ++i) { BrotliCompareAndPushToQueueDistance(out, cluster_size, best_idx1, clusters[i], max_num_pairs, &pairs[0], &num_pairs); } } return num_clusters; }{ int is_good_pair = 0; HistogramPair p; p.idx1 = p.idx2 = 0; p.cost_diff = p.cost_combo = 0; if (idx1 == idx2) { return; } if (idx2 < idx1) { uint32_t t = idx2; idx2 = idx1; idx1 = t; } p.idx1 = idx1; p.idx2 = idx2; p.cost_diff = 0.5 * ClusterCostDiff(cluster_size[idx1], cluster_size[idx2]); p.cost_diff -= out[idx1].bit_cost_; p.cost_diff -= out[idx2].bit_cost_; if (out[idx1].total_count_ == 0) { p.cost_combo = out[idx2].bit_cost_; is_good_pair = 1; } else if (out[idx2].total_count_ == 0) { p.cost_combo = out[idx1].bit_cost_; is_good_pair = 1; } else { double threshold = *num_pairs == 0 ? 1e99 : (brotli_max_double((0.0), (pairs[0].cost_diff))); HistogramDistance combo = out[idx1]; double cost_combo; HistogramAddHistogramDistance(&combo, &out[idx2]); cost_combo = BrotliPopulationCostDistance(&combo); if (cost_combo < threshold - p.cost_diff) { p.cost_combo = cost_combo; is_good_pair = 1; } } if (is_good_pair) { p.cost_diff += p.cost_combo; if (*num_pairs > 0 && HistogramPairIsLess(&pairs[0], &p)) { if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = pairs[0]; ++(*num_pairs); } pairs[0] = p; } else if (*num_pairs < max_num_pairs) { pairs[*num_pairs] = p; ++(*num_pairs); } } }/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/command.c32658210943225781090DictWordtransformconst DictWord[31705]DictWord[31705]31705kStaticDictionaryWordsconst uint16_t[32768]unsigned short[32768]kStaticDictionaryBucketskDictHashMul32kDictNumBitsBROTLI_ENC_STATIC_DICT_LUT_H_/* BROTLI_ENC_STATIC_DICT_LUT_H_ *//* Highest bit is used to indicate end of bucket. *//* Lookup table for static dictionary and transforms. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/compress_fragment.hBROTLI_ENC_COMPRESS_FRAGMENT_H_BrotliCompressFragmentFastuint8_t[128]uint16_t[128]/* BROTLI_ENC_COMPRESS_FRAGMENT_H_ *//* Compresses "input" string to the "*storage" buffer as one or more complete
   meta-blocks, and updates the "*storage_ix" bit position.

   If "is_last" is 1, emits an additional empty last meta-block.

   "cmd_depth" and "cmd_bits" contain the command and distance prefix codes
   (see comment in encode.h) used for the encoding of this input fragment.
   If "is_last" is 0, they are updated to reflect the statistics
   of this input fragment, to be used for the encoding of the next fragment.

   "*cmd_code_numbits" is the number of bits of the compressed representation
   of the command and distance prefix codes, and "cmd_code" is an array of
   at least "(*cmd_code_numbits + 7) >> 3" size that contains the compressed
   command and distance prefix codes. If "is_last" is 0, these are also
   updated to represent the updated "cmd_depth" and "cmd_bits".

   REQUIRES: "input_size" is greater than zero, or "is_last" is 1.
   REQUIRES: "input_size" is less or equal to maximal metablock size (1 << 24).
   REQUIRES: All elements in "table[0..table_size-1]" are initialized to zero.
   REQUIRES: "table_size" is an odd (9, 11, 13, 15) power of two
   OUTPUT: maximal copy distance <= |input_size|
   OUTPUT: maximal copy distance <= BROTLI_MAX_BACKWARD_LIMIT(18) *//* Function for fast encoding of an input fragment, independently from the input
   history. This function uses one-pass processing: when we find a backward
   match, we immediately emit the corresponding command and literal codes to
   the bit stream. */cmd_code_numbits/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/compress_fragment.c"./compress_fragment.h"initial_storage_ixBrotliCompressFragmentFastImpl15BAKE_METHOD_PARAM_BrotliCompressFragmentFastImpl13BrotliCompressFragmentFastImpl11BrotliCompressFragmentFastImpl9BrotliCompressFragmentFastImpluint32_t[128]ip_endnext_emitbase_ipkFirstBlockSizekMergeBlockSizekInputMarginByteskMinMatchLenmetablock_startblock_size98304total_block_sizemlen_storage_ixliteral_ratioemit_commandssizeof(kCmdHistoSeed)block_size >= kInputMarginBytesblock_size - kMinMatchLeninput_size - kInputMarginBytesnext_emit < iphash == Hash(next_ip, shift)next_ip > ip_limitcandidate < ipcandidate >= base_ip!IsMatch(ip, candidate)0 == memcmp(base, candidate, matched)insert < 6210ip >= ip_limitlen_limitip_limitnext_hashnext_iptrawlbytes_between_hash_lookups262128insertinput_bytesprev_hashcur_hashemit_remaindertotal_block_size > (1 << 16)next_blocknext_emit <= ip_end3 << 15EmitUncompressedMetaBlockShouldUseUncompressedModecompressedliteral_ratio > MIN_RATIOliteral_ratio > 980980ShouldMergeBlocksize_t[256]unsigned long[256]kSampleRatebeginstorage_ix_start200.0r >= 0.0RewindBitPositionbitposUpdateBits8 - n_unchanged_bitsbyte_posn_unchanged_bitsn_changed_bitstotal_bitsunchanged_bitschanged_bitsBrotliStoreMetaBlockHeadernibbles1U << 16(1U << 16)1U << 20(1U << 20)EmitLiteralsconst uint8_t[256]const uint16_t[256]litEmitDistanceconst uint8_t[128]const uint16_t[128]EmitCopyLenLastDistancetail2120EmitCopyLenEmitLongInsertLenEmitInsertLennew_storage_ixBuildAndStoreCommandPrefixCodeconst uint32_t[128]HuffmanTree[129]uint16_t[64]448BuildAndStoreLiteralPrefixCodehistogram[i]11uadjustBrotliUnalignedRead32(p1) == BrotliUnalignedRead32(p2) && p1[4] == p2[4]HashBytesAtOffsetoffset >= 0offset <= 3HashkCmdHistoSeedFOR_TABLE_BITS_CASE_(B)case B: BrotliCompressFragmentFastImpl ## B( m, input, input_size, is_last, table, cmd_depth, cmd_bits, cmd_code_numbits, cmd_code, storage_ix, storage); break;BAKE_METHOD_PARAM_(B)static BROTLI_NOINLINE void BrotliCompressFragmentFastImpl ## B( MemoryManager* m, const uint8_t* input, size_t input_size, BROTLI_BOOL is_last, int* table, uint8_t cmd_depth[128], uint16_t cmd_bits[128], size_t* cmd_code_numbits, uint8_t* cmd_code, size_t* storage_ix, uint8_t* storage) { BrotliCompressFragmentFastImpl(m, input, input_size, is_last, table, B, cmd_depth, cmd_bits, cmd_code_numbits, cmd_code, storage_ix, storage); }FOR_TABLE_BITS_(X)X(9) X(11) X(13) X(15)MIN_RATIOMAX_DISTANCE(long)BROTLI_MAX_BACKWARD_LIMIT(18)/* If output is larger than single uncompressed block, rewrite it. *//* If this is not the last block, update the command and distance prefix
       codes for the next block and store the compressed forms. *//* No block splits, no contexts. *//* Save the bit position of the MLEN field of the meta-block header, so that
       we can update it later if we decide to extend this meta-block. *//* If we have more data, write a new meta-block header and prefix codes and
     then continue emitting commands. *//* Emit the remaining bytes as literals. *//* Update the size of the current meta-block and continue emitting commands.
       We can do this because the current size and the new size both have 5
       nibbles. *//* Decide if we want to continue this meta-block instead of emitting the
     last insert-only command. *//* We could immediately start working at ip now, but to improve
           compression we first update "table" with the hashes of some positions
           within the last copy. *//* > 0 *//* We have a 5-byte match at ip, and no need to emit any literal bytes
           prior to ip. *//* We have a 5-byte match at ip, and we need to emit bytes in
           [next_emit, ip). *//* Step 2: Emit the found match together with the literal bytes from
         "next_emit" to the bit stream, and then see if we can find a next match
         immediately afterwards. Repeat until we find no match for the input
         without emitting some literal bytes. *//* Check copy distance. If candidate is not feasible, continue search.
         Checking is done outside of hot loop to reduce overhead. *//* Step 1: Scan forward in the input looking for a 5-byte-long match.
         If we get close to exhausting the input then goto emit_remainder.

         Heuristic match skipping: If 32 bytes are scanned with no matches
         found, start looking only at every other byte. If 32 more bytes are
         scanned, look at every third byte, etc.. When a match is found,
         immediately go back to looking at every byte. This is a small loss
         (~5% performance, ~0.1% density) for compressible data due to more
         bookkeeping, but for non-compressible data (such as JPEG) it's a huge
         win since the compressor quickly "realizes" the data is incompressible
         and doesn't bother looking for matches everywhere.

         The "skip" variable keeps track of how many bytes there are since the
         last match; dividing it by 32 (i.e. right-shifting by five) gives the
         number of bytes to move ahead for each iteration. *//* For the last block, we need to keep a 16 bytes margin so that we can be
       sure that all distances are at most window size - 16.
       For all other blocks, we only need to keep a margin of 5 bytes so that
       we don't go over the block size with a copy. *//* "ip" is the input pointer. *//* Initialize the command and distance histograms. We will gather
     statistics of command and distance codes during the processing
     of this block and use it to update the command and distance
     prefix codes for the next block. *//* Store the pre-compressed command and distance prefix codes. *//* Save the bit position of the MLEN field of the meta-block header, so that
     we can update it later if we decide to extend this meta-block. *//* Save the start of the first block for position and distance computations.
  *//* "next_emit" is a pointer to the first byte that is not covered by a
     previous copy. Bytes between "next_emit" and the start of the next copy or
     the end of the input will be emitted as literal bytes. *//* Acceptable loss for uncompressible speedup is 2% *//* ISUNCOMPRESSED *//* ISLAST *//* REQUIRES: len <= 1 << 24. *//* REQUIRES: insertlen < 6210 *//* only 64 first values were used *//* Create the bit length array for the full command alphabet. *//* We have to jump through a few hoops here in order to compute
     the command bits because the symbols are in a different order than in
     the full alphabet. This looks complicated, but having the symbols
     in this order in the command bits saves a few branches in the Emit*
     functions. *//* Tree size for building a tree over 64 symbols is 2 * 64 + 1. *//* Builds a command and distance prefix code (each 64 symbols) into "depth" and
   "bits" based on "histogram" and stores it into the bit stream. *//* Estimated encoding ratio, millibytes per symbol. *//* We add 1 to each population count to avoid 0 bit depths (since this is
         only a sample and we don't know if the symbol appears or not), and we
         weigh the first 11 samples with weight 3 to account for the balancing
         effect of the LZ77 phase on the histogram (more frequent symbols are
         more likely to be in backward references instead as literals). *//* We weigh the first 11 samples with weight 3 to account for the
         balancing effect of the LZ77 phase on the histogram. *//* Builds a literal prefix code into "depths" and "bits" based on the statistics
   of the "input" string and stores it into the bit stream.
   Note that the prefix code here is built from the pre-LZ77 input, therefore
   we can only approximate the statistics of the actual literal stream.
   Moreover, for long inputs we build a histogram from a sample of the input
   and thus have to assign a non-zero depth for each literal.
   Returns estimated compression ratio millibytes/char for encoding given input
   with generated code. *//* memcmp, memcpy, memset *//* Function for fast encoding of an input fragment, independently from the input
   history. This function uses one-pass processing: when we find a backward
   match, we immediately emit the corresponding command and literal codes to
   the bit stream.

   Adapted from the CompressFragment() function in
   https://github.com/google/snappy/blob/master/snappy.cc *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/compress_fragment_two_pass.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/compress_fragment_two_pass.c"./compress_fragment_two_pass.h"BrotliCompressFragmentTwoPassBrotliCompressFragmentTwoPassImpl17min_matchBrotliCompressFragmentTwoPassImpl16BrotliCompressFragmentTwoPassImpl15BrotliCompressFragmentTwoPassImpl14BrotliCompressFragmentTwoPassImpl13BrotliCompressFragmentTwoPassImpl12BrotliCompressFragmentTwoPassImpl11BrotliCompressFragmentTwoPassImpl10BrotliCompressFragmentTwoPassImpl9BrotliCompressFragmentTwoPassImpl8command_bufliteral_bufBrotliCompressFragmentTwoPassImplkCompressFragmentTwoPassBlockSizeuint32_t **unsigned int **ShouldCompresscorpus_sizeBitsEntropy(literal_histo, 256) < max_total_bit_cost0.9799999999999999822literal_histomax_total_bit_cost8.0SAMPLE_RATE43.0StoreCommandskInsertOffsetlit_depthscmd_depthscode < 128CreateCommandsblock_size - min_matchhash == Hash(ip, shift, min_match)!IsMatch(ip, candidate, min_match)p1[4] == p2[4] && p1[5] == p2[5]offset <= 8 - lengthcase B: BrotliCompressFragmentTwoPassImpl ## B( m, input, input_size, is_last, command_buf, literal_buf, table, storage_ix, storage); break;static BROTLI_NOINLINE void BrotliCompressFragmentTwoPassImpl ## B( MemoryManager* m, const uint8_t* input, size_t input_size, BROTLI_BOOL is_last, uint32_t* command_buf, uint8_t* literal_buf, int* table, size_t* storage_ix, uint8_t* storage) { size_t min_match = (B <= 15) ? 4 : 6; BrotliCompressFragmentTwoPassImpl(m, input, input_size, is_last, command_buf, literal_buf, table, B, min_match, storage_ix, storage); }X(8) X(9) X(10) X(11) X(12) X(13) X(14) X(15) X(16) X(17)0.98/* Since we did not find many backward references and the entropy of
         the data is close to 8 bits, we can simply emit an uncompressed block.
         This makes compression speed of uncompressible data about 3x faster. *//* We could immediately start working at ip now, but to improve
             compression we first update "table" with the hashes of some
             positions within the last copy. *//* We have a 6-byte match at ip, and no need to emit any
           literal bytes prior to ip. *//* We have a 6-byte match at ip, and we need to emit bytes in
           [next_emit, ip). *//* Step 2: Emit the found match together with the literal bytes from
         "next_emit", and then see if we can find a next match immediately
         afterwards. Repeat until we find no match for the input
         without emitting some literal bytes. *//* Step 1: Scan forward in the input looking for a 6-byte-long match.
         If we get close to exhausting the input then goto emit_remainder.

         Heuristic match skipping: If 32 bytes are scanned with no matches
         found, start looking only at every other byte. If 32 more bytes are
         scanned, look at every third byte, etc.. When a match is found,
         immediately go back to looking at every byte. This is a small loss
         (~5% performance, ~0.1% density) for compressible data due to more
         bookkeeping, but for non-compressible data (such as JPEG) it's a huge
         win since the compressor quickly "realizes" the data is incompressible
         and doesn't bother looking for matches everywhere.

         The "skip" variable keeps track of how many bytes there are since the
         last match; dividing it by 32 (ie. right-shifting by five) gives the
         number of bytes to move ahead for each iteration. *//* Function for fast encoding of an input fragment, independently from the input
   history. This function uses two-pass processing: in the first pass we save
   the found backward matches and literal bytes into a buffer, and in the
   second pass we emit them into the bit stream using prefix codes built based
   on the actual command and literal byte histograms. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/dictionary_hash.cconst uint8_t[32768]unsigned char[32768]kStaticDictionaryHashLengthskStaticDictionaryHashWords/* Hash table on the 4-byte prefixes of static dictionary words. */BROTLI_ENC_DICTIONARY_HASH_H_/* BROTLI_ENC_DICTIONARY_HASH_H_ */BROTLI_ENC_BACKWARD_REFERENCES_H_/* BROTLI_ENC_BACKWARD_REFERENCES_H_ *//* "commands" points to the next output command to write to, "*num_commands" is
   initially the total amount of commands output by previous
   CreateBackwardReferences calls, and must be incremented by the amount written
   by this call. */BROTLI_ENC_COMPRESS_FRAGMENT_TWO_PASS_H_/* BROTLI_ENC_COMPRESS_FRAGMENT_TWO_PASS_H_ *//* Compresses "input" string to the "*storage" buffer as one or more complete
   meta-blocks, and updates the "*storage_ix" bit position.

   If "is_last" is 1, emits an additional empty last meta-block.

   REQUIRES: "input_size" is greater than zero, or "is_last" is 1.
   REQUIRES: "input_size" is less or equal to maximal metablock size (1 << 24).
   REQUIRES: "command_buf" and "literal_buf" point to at least
              kCompressFragmentTwoPassBlockSize long arrays.
   REQUIRES: All elements in "table[0..table_size-1]" are initialized to zero.
   REQUIRES: "table_size" is a power of two
   OUTPUT: maximal copy distance <= |input_size|
   OUTPUT: maximal copy distance <= BROTLI_MAX_BACKWARD_LIMIT(18) *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/ringbuffer.hRingBufferWriteRingBuffer *masked_pos + n <= rb->size_rb->total_size_ - masked_posnot_first_lap1u << 31(1u << 31)rb_pos_mask(1u << 31) - 1RingBufferWriteTailmasked_pos < rb->tail_size_rb->tail_size_ - masked_posRingBufferInitBufferkSlackForEightByteHashingEverywhere2 + buflen + kSlackForEightByteHashingEverywherenew_dataBROTLI_IS_NULL(new_data)rb->data_RingBufferFreeRingBufferSetuptail_bitsRingBufferInitRingBufferbuffer_pos_cur_size_total_size_tail_size_mask_size_BROTLI_ENC_RINGBUFFER_H_/* BROTLI_ENC_RINGBUFFER_H_ *//* Wrap, but preserve not-a-first-lap feature. *//* Copy into the beginning of the buffer *//* Split into two writes.
         Copy into the end of the buffer, including the tail buffer. *//* A single write fits. *//* The length of the writes is limited so that we do not need to worry
       about a write *//* Initialize tail; might be touched by "best_len++" optimization when
       ring buffer is "full". *//* Initialize the last two bytes to zero, so that we don't have to worry
       later when we copy the last two bytes to the first two positions. *//* Lazily allocate the full buffer. *//* Special case for the first write: to process the first block, we don't
       need to allocate the whole ring-buffer and we don't need the tail
       either. However, we do this memory usage optimization only if the
       first write is less than the tail size, which is also the input block
       size, otherwise it is likely that other blocks will follow and we
       will need to reallocate to the full size anyway. *//* Push bytes into the ring buffer. *//* Just fill the tail buffer with the beginning data. *//* Allocates or re-allocates data_ to the given length + plus some slack
   region before and after. Fills the slack regions with zeros. *//* The start of the ring-buffer. *//* The actual ring buffer containing the copy of the last two bytes, the data,
     and the copy of the beginning as a tail. *//* Position to write in the ring buffer. *//* Size of the ring-buffer is (1 << window_bits) + tail_size_. *//* A RingBuffer(window_bits, tail_bits) contains `1 << window_bits' bytes of
   data in a circular manner: writing a byte writes it to:
     `position() % (1 << window_bits)'.
   For convenience, the RingBuffer array contains another copy of the
   first `1 << tail_bits' bytes:
     buffer_[i] == buffer_[i + (1 << window_bits)], if i < (1 << tail_bits),
   and another copy of the last two bytes:
     buffer_[-1] == buffer_[(1 << window_bits) - 1] and
     buffer_[-2] == buffer_[(1 << window_bits) - 2]. *//* Sliding window over the input data. */bytesrbbuflen/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/utf8_util.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/encode.c"./utf8_util.h""./ringbuffer.h"consumed_sizes->available_out_s->available_out_ != 0s->stream_state_ == BROTLI_STREAM_FINISHED && !BrotliEncoderHasMoreOutput(s)BROTLI_STREAM_METADATA_HEADBROTLI_STREAM_METADATA_BODYBROTLI_STREAM_PROCESSINGremaining_block_size*available_in(*available_in == 0) && op == BROTLI_OPERATION_FINISH(*available_in == 0) && op == BROTLI_OPERATION_FLUSHcopy_input_sizeBROTLI_FLINT_WAITING_FOR_FLUSHINGBROTLI_FLINT_DONEforce_flushBROTLI_STREAM_FLUSH_REQUESTEDBROTLI_STREAM_FINISHEDUpdateSizeHint1u << 30ProcessMetadata(1u << 24)s->remaining_metadata_bytes_*available_outuint8_t[16]copyBrotliEncoderCompressStreamFastblock_size_limitBROTLI_MIN(size_t, *available_in, block_size_limit)(brotli_min_size_t((*available_in), (block_size_limit)))buf_sizetmp_command_buftmp_literal_bufs->command_buf_s->literal_buf_BROTLI_IS_NULL(s->command_buf_)BROTLI_IS_NULL(s->literal_buf_)BROTLI_IS_NULL(tmp_command_buf)BROTLI_IS_NULL(tmp_literal_buf)out_bytes <= *available_out(storage_ix & 7) == 0 || out_bytes < *available_outmax_out_size503inplaceuint8_t[512]unsigned char[512]out_bytesCheckFlushCompleteInjectFlushOrPushOutputcopy_output_sizeInjectBytePaddingBlocksealseal_bitsdestination0x6uinput_startoutput_startBROTLI_MAX(int, 16, lgwin)(brotli_max_int((16), (lgwin)))lg_winokfallbackMakeUncompressedStreamchunk_size1u << 16(1u << 16)1u << 20(1u << 20)num_large_blocksoverheadBrotliCompressBufferQuality10memory_managersaved_dist_cachetotal_out_sizelast_byteslast_bytes_bitsBROTLI_MAX_BACKWARD_LIMIT(lgwin) + BROTLI_WINDOW_GAP(((size_t)1 << (lgwin)) - 16) + 16hasher_eff_sizelgwin + 1lgmetablockmax_block_sizemax_metablock_sizemax_literals_per_metablockmax_commands_per_metablockmetablock_start + max_metablock_sizemetablock_end - block_startblock_size + 1expected_num_commandsnum_commands + path_size + 1new_cmd_alloc_sizenew_commandsmetablock_start + metablock_size == input_sizemetablock_size + 162 * metablock_size + 503metablock_endmetablock_sizecmd_alloc_sizepath_sizeBROTLI_IS_NULL(new_commands)sizeof(Command)outputBROTLI_IS_NULL(storage)block_paramsoominput_size <= mask + 1WriteMetadataHeaderEncodeDatawrapped_last_processed_posnewsizes->commands_s->params.hasher.type == 10max_literalsmax_commandsprocessed_bytesnext_input_fits_metablockprocessed_bytes + InputBlockSize(s) <= max_lengthshould_flushs->params.quality < MIN_QUALITY_FOR_BLOCK_SPLIT && s->num_literals_ + s->num_commands_ >= MAX_NUM_DELAYED_SYMBOLSs->params.quality < 4 && s->num_literals_ + s->num_commands_ >= 0x2FFF12287sizeof(s->saved_dist_cache_)s->input_pos_ >= s->last_flush_pos_s->input_pos_ > s->last_flush_pos_ || is_lasts->input_pos_ - s->last_flush_pos_ <= 1u << 24ExtendLastCommandlast_command(uint64_t)1((uint64_t)1)last_copy_lenlast_processed_poscmd_dist(last_command->dist_prefix_ & 0x3FF) == 0(BROTLI_NUM_DISTANCE_SHORT_CODES - 1)UpdateLastProcessedPoswrapped_input_poswrapped_input_pos < wrapped_last_processed_posCopyInputToRingBufferringbuffer_BrotliEncoderCleanupStates->storage_s->large_table_6560sizeof(BrotliEncoderState)BrotliEncoderInitStateBrotliEncoderInitParamsBROTLI_DISTANCE_ALPHABET_SIZE(0, 0, BROTLI_MAX_DISTANCE_BITS)67108860EnsureInitialized&s->memory_manager_BROTLI_IS_OOM(&s->memory_manager_)BROTLI_FLINT_NEEDS_2_BYTESs->params.stream_offsetBROTLI_MAX_BACKWARD_LIMIT(lgwin)(((size_t)1 << (lgwin)) - 16)ChooseDistanceParamsndirect_msbWriteMetaBlockInternalwrapped_last_flush_poslast_flush_posnum_literal_contextsconst uint32_t ***storage_ix <= 14ChooseContextMode0.75kMinUTF8Ratio0.98999999999999999110.99kMinEntropy7.9199999999999999297.92bit_cost_threshold13.0DecideOverLiteralContextModelingend_posuint32_t[9]unsigned int[9]bigram_prefix_histoconst int[4]lutstride_end_posShouldUseComplexStaticContextMapconst uint32_t[64]kStaticContextMapComplexUTF8prev1prev2utf8_lutcombined_histouint32_t[13][32]unsigned int[13][32]context_histodouble[3]entropyuint32_t(*)[32]unsigned int(*)[32]0.20000000000000001110.2ChooseContextMapkStaticContextMapContinuationkStaticContextMapSimpleUTF8monogram_histotwo_prefix_histodouble[4]10.00.020000000000000000420.02total != 0bigram_histoInitCommandPrefixCodeskDefaultCommandDepthskDefaultCommandBitskDefaultCommandCodekDefaultCommandCodeNumBitsconst uint8_t[57]unsigned char[57]0xd50xbf0xe70xde0xea0x9e0x5d0xc60xbc0xd80xcb0x8c0xe00xc30xc10xb20xaa0xcc0xa10xce0xe10xb00xd00x4e0xf7EncodeWindowBitsGetHashTablehtsize6990500xAAAAAint[1024]1 << 10sizeof(s->small_table_)sizeof(s->small_table_[0])sizeof(s->small_table_) / sizeof(s->small_table_[0])BROTLI_IS_NULL(s->large_table_)sizeof(*table)max_table_size >= 256HashTableSizeGetBrotliStorageBROTLI_IS_NULL(s->storage_)WrapPositiongb(1u << 30)(1u << 30) - 1((1u << 30) - 1)RemainingInputBlockSizeUnprocessedInputSizeInputBlockSizeBrotliEncoderFlintStateBROTLI_FLINT_NEEDS_1_BYTEBROTLI_FLINT_WAITING_FOR_PROCESSINGBrotliEncoderStreamStateis_initialized_is_last_block_emitted_stream_state_remaining_metadata_bytes_tiny_buf_uint64_t[2]unsigned long[2]total_out_available_out_next_out_literal_buf_command_buf_cmd_code_numbits_cmd_code_cmd_bits_cmd_depths_large_table_size_large_table_small_table_hasher_storage_storage_size_prev_byte2_prev_byte_flint_last_bytes_bits_last_bytes_saved_dist_cache_dist_cache_last_processed_pos_last_flush_pos_last_insert_len_num_literals_num_commands_commands_cmd_alloc_size_input_pos_memory_manager_COPY_ARRAY(dst,src)memcpy(dst, src, sizeof(src));/* Force emitting (uncompressed) piece containing flint. *//* Compress data only when internal output buffer is empty, stream is not
       finished and there is no pending flush request. *//* Exit the "emit flint" workflow. *//* Shorten input to flint size. *//* First data metablock might be emitted here. *//* Unfinished metadata block; check requirements. *//* This guarantees progress in "TakeOutput" workflow. *//* Directly copy input to output. *//* Exit workflow only when there is no more input and no more output.
         Otherwise client may continue producing empty metadata blocks. *//* Switch to metadata block workflow, if required. *//* Compress block only when internal output buffer is empty, stream is not
       finished, there is no pending flush request, and there is either
       additional input or pending operation. *//* Injects padding bits or pushes compressed data to output.
   Returns false if nothing is done. *//* If we have already created storage, then append to it.
     Storage is valid until next block is being compressed. *//* is_last = 0, data_nibbles = 11, reserved = 0, meta_nibbles = 00 *//* TODO: Implement this direct path for all quality levels. *//* Handle the special case of empty input. *//* Output buffer needs at least one byte. *//* empty metadata, padding *//* window bits = 10, is_last = false *//* Wraps data to uncompressed brotli stream with minimal window size.
   |output| should point at region with at least BrotliEncoderMaxCompressedSize
   addressable bytes.
   Returns the length of stream. *//* [window bits / empty metadata] + N * [uncompressed] + [last empty] *//* Save the state of the distance cache in case we need to restore it for
       emitting an uncompressed block. *//* Restore the distance cache and last byte. *//* The number of distance symbols effectively used for distance
           histograms. It might be less than distance alphabet size
           for "Large Window Brotli" (32-bit). *//* Restore the distance cache, as its last update by
         CreateBackwardReferences is now unused. *//* Write the ISLAST and ISEMPTY bits. *//* We allocate a command buffer in the first iteration of this loop that
         will be likely big enough for the whole metablock, so that for most
         inputs we will not have to reallocate in later iterations. We do the
         allocation here and not before the loop, because if the input is small,
         this will be allocated after the Zopfli cost model is freed, so this
         will not increase peak memory usage.
         TODO: If the first allocation is too small, increase command
         buffer size exponentially. *//* Dumps remaining output bits and metadata header to |header|.
   Returns number of produced bytes.
   REQUIRED: |header| should be 8-byte aligned and at least 16 bytes long.
   REQUIRED: |block_size| <= (1 << 24). *//* We have no new input data and we don't have to finish the stream, so
       nothing to do. *//* Create the last insert-only command. *//* Merge with next input block. Everything will happen later. *//* If block splitting is not used, then flush as soon as there is some
       amount of commands / literals produced. *//* TODO: Postpone decision until next block arrives? *//* If maximal possible additional block doesn't fit metablock, flush now. *//* Reserve a bit more memory to allow merging with a next block
         without reallocation: that would impact speed. *//* Theoretical max number of commands is 1 per 2 bytes. *//* We have no new input data and we don't have to finish the stream, so
         nothing to do. *//* Adding more blocks after "last" block is forbidden. *//*
   Processes the accumulated input data and sets |*out_size| to the length of
   the new output meta-block, or to zero if no new output meta-block has been
   created (in this case the processed input data is buffered internally).
   If |*out_size| is positive, |*output| points to the start of the output
   data. If |is_last| or |force_flush| is BROTLI_TRUE, an output meta-block is
   always created. However, until |is_last| is BROTLI_TRUE encoder may retain up
   to 7 bits of the last byte of output. To force encoder to dump the remaining
   bits use WriteMetadata() to append an empty meta-data block.
   Returns BROTLI_FALSE if the size of the input data is larger than
   input_block_size().
 *//* The copy length is at most the metablock size, and thus expressible. *//* Marks all input as processed.
   Returns true if position wrapping occurs. *//* This is the first time when the ring buffer is being written.
       We clear 7 bytes just after the bytes that have been copied from
       the input buffer.

       The ring-buffer has a "tail" that holds a copy of the beginning,
       but only once the ring buffer has been fully written once, i.e.,
       pos <= mask. For the first time, we need to write values
       in this tail (where index may be larger than mask), so that
       we have exactly defined behavior and don't read uninitialized
       memory. Due to performance reasons, hashing reads data using a
       LOAD64, which can go 7 bytes beyond the bytes written in the
       ring-buffer. *//* TL;DR: If needed, initialize 7 more bytes in the ring buffer to make the
     hashing not depend on uninitialized data. This makes compression
     deterministic and it prevents uninitialized memory warnings in Valgrind.
     Even without erasing, the output would be valid (but nondeterministic).

     Background information: The compressor stores short (at most 8 bytes)
     substrings of the input already read in a hash table, and detects
     repetitions by looking up such substrings in the hash table. If it
     can find a substring, it checks whether the substring is really there
     in the ring buffer (or it's just a hash collision). Should the hash
     table become corrupt, this check makes sure that the output is
     still valid, albeit the compression ratio would be bad.

     The compressor populates the hash table from the ring buffer as it's
     reading new bytes from the input. However, at the last few indexes of
     the ring buffer, there are not enough bytes to build full-length
     substrings from. Since the hash table always contains full-length
     substrings, we erase with dummy zeros here to make sure that those
     substrings will contain zeros at the end instead of uninitialized
     data.

     Please note that erasing is not necessary (because the
     memory region is already initialized since he ring buffer
     has a `tail' that holds a copy of the beginning,) so we
     skip erasing if we have already gone around at least once in
     the ring buffer.

     Only clear during the first round of ring-buffer writes. On
     subsequent rounds data in the ring-buffer would be affected. *//*
   Copies the given input data to the internal ring buffer of the compressor.
   No processing of the data occurs at this time and this function can be
   called multiple times before calling WriteBrotliData() to process the
   accumulated input. At most input_block_size() bytes of input data can be
   copied to the ring buffer, otherwise the next WriteBrotliData() will fail.
 *//* Deinitializes and frees BrotliEncoderState instance. *//* BROTLI_DUMP(); *//* Save the state of the distance cache in case we need to restore it for
     emitting an uncompressed block. *//* Initialize distance cache. *//* Bigger values have the same effect, but could cause overflows. *//* Initialize last byte with stream header. *//* Poison the distance cache. -16 +- 3 is still less than zero (invalid). *//* The number of distance symbols effectively used for distance
         histograms. It might be less than distance alphabet size
         for "Large Window Brotli" (32-bit). *//* Restore the distance cache, as its last update by
       CreateBackwardReferences is now unused. *//* We only do the computation for the option of something else than
     CONTEXT_UTF8 for the highest qualities *//* Chooses the literal context mode for a metablock *//* TODO: find more precise minimal block overhead. *//* Gather bi-gram data of the UTF8 byte prefixes. To make the analysis of
       UTF8 data faster we only examine 64 byte long strides at every 4kB
       intervals. *//* Context map was already set, nothing else to do. *//* The triggering heuristics below were tuned by compressing the individual
       files of the silesia corpus. If we skip this kind of context modeling
       for not very well compressible input (i.e. entropy using context modeling
       is 60% of maximal entropy) or if expected savings by symbol are less
       than 0.2 bits, then in every case when it triggers, the final compression
       ratio is improved. Note however that this heuristics might be too strict
       for some cases and could be tuned further. *//* To make the analysis of the data faster we only examine 64 byte long
         strides at every 4kB intervals. *//* To make entropy calculations faster and to fit on the stack, we collect
       histograms over the 5 most significant bits of literals. One histogram
       without context and 13 additional histograms for each context value. *//* Try the more complex static context map only for long data. *//* [a-z] *//* [A-Z] *//* [0..9] *//* > *//* . *//* :; *//* }]) *//* ({[ *//* % *//* " *//* !, first after space/lf and after something else. *//* 8 space *//* 4 lf *//* 0 special *//* Decide if we want to use a more complex static context map containing 13
   context values, based on the entropy reduction of histograms over the
   first 5 bits of literals. *//* If expected savings by symbol are less than 0.2 bits, skip the
     context modeling -- in exchange for faster decoding speed. *//* 3 context models is a bit slower, don't use it at lower qualities. *//* Decide about the context map based on the ability of the prediction
   ability of the previous byte UTF8-prefix on the next byte. The
   prediction ability is calculated as Shannon entropy. Here we need
   Shannon entropy instead of 'BitsEntropy' since the prefix will be
   encoded with the remaining 6 bits of the following byte, and
   BitsEntropy will assume that symbol to be stored alone using Huffman
   coding. *//* Initialize the pre-compressed form of the command and distance prefix
     codes. *//* Initializes the command and distance prefix codes for the first block. *//* Only odd shifts are supported by fast-one-pass. *//* Use smaller hash table when input.size() is smaller, since we
     fill the table, incurring O(hash table size) overhead for
     compression, and if the input is short, we won't need that
     many hash table entries anyway. *//* Wrap every 2GiB; The first 3GB are continuous. *//* Wraps 64-bit input position to 32-bit ring-buffer position preserving
   "not-a-first-lap" feature. *//* TODO: Validate/clamp parameters here. *//* Changing parameters on the fly is not implemented yet. *//* Temporary buffer for padding flush bits or metadata block header / body. *//* Command and literal buffers for FAST_TWO_PASS_COMPRESSION_QUALITY. *//* The compressed form of the command and distance prefix codes for the next
     block in FAST_ONE_PASS_COMPRESSION_QUALITY. *//* Command and distance prefix codes (each 64 symbols, stored back-to-back)
     used for the next block in FAST_ONE_PASS_COMPRESSION_QUALITY. The command
     prefix code is over a smaller alphabet with the following 64 symbols:
        0 - 15: insert length code 0, copy length code 0 - 15, same distance
       16 - 39: insert length code 0, copy length code 0 - 23
       40 - 63: insert length code 0 - 23, copy length code 0
     Note that symbols 16 and 40 represent the same code in the full alphabet,
     but we do not use either of them in FAST_ONE_PASS_COMPRESSION_QUALITY. *//* Allocated only when needed *//* 4KiB *//* Hash table for FAST_ONE_PASS_COMPRESSION_QUALITY mode. *//* "Flint" is a tiny uncompressed block emitted before the continuation
     block to unwire literal context from previous data. Despite being int8_t,
     field is actually BrotliEncoderFlintState enum. *//* Writing metadata block body. *//* Flushing compressed block and writing meta-data block header. *//* Last metablock was produced; no more input is acceptable. *//* Intermediate state; after next block is emitted, byte-padding should be
     performed before getting back to default state. *//* Default state. *//* Implementation of Brotli compressor. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/encoder_dict.cStitchToPreviousBlockH10StitchToPreviousBlocki_start + num_bytesBROTLI_WINDOW_GAP - 116 - 1position - iStoreAndFindMatchesi_starti_endsize_t *const __restrict__BackwardMatch *__restrict__StoreRangeH10StoreH10FindAllMatchesH10FindAllMatchesBackwardMatch *constorig_matchesshort_match_max_backwarduint32_t[38]dict_matchesbackward > max_backwardminlenbest_len + 1maxlendict_idStoreAndFindMatchesH10max_comp_lenmax_length >= MAX_TREE_COMP_LENGTHmax_length >= 128should_reroot_treeHashBytesforestLeftChildIndexnode_leftRightChildIndexnode_rightbest_len_leftbest_len_rightdepth_remainingcur_len <= MAX_TREE_COMP_LENGTH0 == memcmp(&data[cur_ix_masked], &data[prev_ix_masked], len)prev_ix_maskedcur_lenix_startix_endring_buffer_maskdictionary_distanceRightChildIndexH10LeftChildIndexH10HashMemAllocInBytesH10HashMemAllocInBytesnum_nodesBUCKET_SIZEsizeof(uint32_t) * BUCKET_SIZE2 * sizeof(uint32_t)PrepareH10Prepareinvalid_posInitializeH10InitializeHashBytesH1032 - BUCKET_BITS(32 - BUCKET_BITS)StoreLookaheadH10HashTypeLengthH10forest_invalid_pos_buckets_window_mask_HashToBinaryTree(1 << BUCKET_BITS)/* We know that i + MAX_TREE_COMP_LENGTH <= position + num_bytes, i.e. the
         end of the current block and that we have at least
         MAX_TREE_COMP_LENGTH tail in the ring-buffer. *//* Maximum distance is window size - 16, see section 9.1. of the spec.
         Furthermore, we have to make sure that we don't look further back
         from the start of the next block than the window size, otherwise we
         could access already overwritten areas of the ring-buffer. *//* Store the last `MAX_TREE_COMP_LENGTH - 1` positions in the hasher.
       These could not be calculated before, since they require knowledge
       of both the previous and the current block. *//* Maximum distance is window size - 16, see section 9.1. of the spec. *//* Stores the hash of the next 4 bytes and re-roots the binary tree at the
   current sequence, without returning any matches.
   REQUIRES: ix + MAX_TREE_COMP_LENGTH <= end-of-current-block *//* Finds all backward matches of &data[cur_ix & ring_buffer_mask] up to the
   length of max_length and stores the position cur_ix in the hash table.

   Sets *num_matches to the number of matches found, and stores the found
   matches in matches[0] to matches[*num_matches - 1]. The matches will be
   sorted by strictly increasing length and (non-strictly) increasing
   distance. *//* The match length of the leftmost node of the right subtree of the new
     root, updated as we traverse and re-root the tree of the hash bucket. *//* The match length of the rightmost node of the left subtree of the new
     root, updated as we traverse and re-root the tree of the hash bucket. *//* The forest index of the leftmost node of the right subtree of the new
     root, updated as we traverse and re-root the tree of the hash bucket. *//* The forest index of the rightmost node of the left subtree of the new
     root, updated as we traverse and re-root the tree of the hash bucket. *//* Stores the hash of the next 4 bytes and in a single tree-traversal, the
   hash bucket's binary tree is searched for matches and is re-rooted at the
   current position.

   If less than MAX_TREE_COMP_LENGTH data is available, the hash bucket of the
   current position is searched for matches, but the state of the hash table
   is not changed, since we can not know the final sorting order of the
   current (incomplete) sequence.

   This function must be called with increasing cur_ix positions. *//* uint32_t[2 * num_nodes] *//* The union of the binary trees of each hash bucket. The root of the tree
     corresponding to a hash is a sequence starting at buckets_[hash] and
     the left and right children of a sequence starting at pos are
     forest_[2 * pos] and forest_[2 * pos + 1]. *//* --- Dynamic size members --- *//* A position used to mark a non-existent sequence, i.e. a tree is empty if
     its root is at invalid_pos_ and a node is a leaf if both its children
     are at invalid_pos_. *//* uint32_t[BUCKET_SIZE]; *//* Hash table that maps the 4-byte hashes of the sequence to the last
     position where this hash was found, which is the root of the binary
     tree of sequences that share this hash bucket. *//* The window size minus 1 *//* A (forgetful) hash table where each hash bucket contains a binary tree of
   sequences whose first 4 bytes share the same hash code.
   Each sequence is MAX_TREE_COMP_LENGTH long and is identified by its starting
   position in the input data. The binary tree is sorted by the lexicographic
   order of the sequences, and it is also a max-heap with respect to the
   starting positions. *//* template parameters: FN, BUCKET_BITS, MAX_TREE_COMP_LENGTH,
                        MAX_TREE_SEARCH_DEPTH */FindLongestMatchH2best_len_incompare_charkey_outmin_scorebest_scorecached_backwardBUCKET_SWEEPbackward == 0 || backward > max_backwardsize_t[1]unsigned long[1]BUCKET_MASKBUCKET_SWEEP_MASKPrepareDistanceCacheH2StitchToPreviousBlockH2StoreRangeH2StoreH2offHashMemAllocInBytesH2PrepareH2partial_prepare_thresholdInitializeH2HashBytesH28 * HASH_LEN64 - 8 * HASH_LEN(64 - 8 * HASH_LEN)64 - BUCKET_BITS(64 - BUCKET_BITS)StoreLookaheadH2HashTypeLengthH2HashLongestMatchQuickly((BUCKET_SWEEP - 1) << 3)(1 << BUCKET_SWEEP_BITS)(BUCKET_SIZE - 1)/* Only one to look for, don't bother to prepare for a loop. *//* Find a longest backward match of &data[cur_ix & ring_buffer_mask]
   up to the length of max_length and stores the position cur_ix in the
   hash table.

   Does not look for matches longer than max_length.
   Does not look for matches further away than max_backward.
   Writes the best match into |out|.
   |out|->score is updated only if a better match is found. *//* Prepare the hashes for three last bytes of the last write.
       These could not be calculated before, since they require knowledge
       of both the previous and the current block. *//* Wiggle the value with the bucket sweep range. *//* Look at 5 bytes at &data[ix & mask].
   Compute a hash from these, and store the value somewhere within
   [ix .. ix+3]. *//* It is not strictly necessary to fill this buffer here, but
       not filling will make the results of the compression stochastic
       (but correct). This is because random data would cause the
       system to find accidentally good backward references here and there. *//* Partial preparation is 100 times slower (per socket). *//* Shortcuts. *//* A (forgetful) hash table to the data seen by the compressor, to
   help create backward references to previous data.

   This is a hash map of fixed size (BUCKET_SIZE). *//* HashBytes is the function that chooses the bucket to place
   the address in. The HashLongestMatch and HashLongestMatchQuickly
   classes have separate, different implementations of hashing. *//* template parameters: FN, BUCKET_BITS, BUCKET_SWEEP_BITS, HASH_LEN,
                        USE_DICTIONARY
 */FindLongestMatchH3size_t[2]PrepareDistanceCacheH3StitchToPreviousBlockH3StoreRangeH3StoreH3HashMemAllocInBytesH3PrepareH3InitializeH3HashBytesH3StoreLookaheadH3HashTypeLengthH3FindLongestMatchH4PrepareDistanceCacheH4StitchToPreviousBlockH4StoreRangeH4StoreH4HashMemAllocInBytesH4PrepareH4InitializeH4HashBytesH4StoreLookaheadH4HashTypeLengthH4FindLongestMatchH5uint16_t *__restrict__downPrepareDistanceCacheH5StitchToPreviousBlockH5StoreRangeH5StoreH5minor_ixHashMemAllocInBytesH5bucket_sizesizeof(uint16_t)PrepareH5sizeof(num[0])InitializeH5NumH5NumHashBytesH5StoreLookaheadH5HashTypeLengthH5num_common_num_last_distances_to_check_block_bits_block_mask_hash_shift_block_size_bucket_size_HashLongestMatch/* Comparing for >= 3 does not change the semantics, but just saves
             for a few unnecessary binary logarithms in backward reference
             score, since we are not interested in such short matches. *//* Comparing for >= 2 does not change the semantics, but just saves for
           a few unnecessary binary logarithms in backward reference score,
           since we are not interested in such short matches. *//* Try last distance first. *//* Don't accept a short copy from far away. *//* Find a longest backward match of &data[cur_ix] up to the length of
   max_length and stores the position cur_ix in the hash table.

   REQUIRES: FN(PrepareDistanceCache) must be invoked for current distance cache
             values; if this method is invoked repeatedly with the same distance
             cache values, it is enough to invoke FN(PrepareDistanceCache) once.

   Does not look for matches longer than max_length.
   Does not look for matches further away than max_backward.
   Writes the best match into |out|.
   |out|->score is updated only if a better match is found. *//* Look at 4 bytes at &data[ix & mask].
   Compute a hash from these, and store the value of ix at that position. *//* uint32_t[bucket_size * block_size]; *//* Buckets containing block_size_ of backward references. *//* uint16_t[bucket_size]; *//* Number of entries in a particular bucket. *//* Mask for accessing entries in a block (in a ring-buffer manner). *//* Left-shift for computing hash bucket index from hash value. *//* Only block_size_ newest backward references are kept,
     and the older are forgotten. *//* Number of hash buckets. *//* HashBytes is the function that chooses the bucket to place the address in. *//* A (forgetful) hash table to the data seen by the compressor, to
   help create backward references to previous data.

   This is a hash map of fixed size (bucket_size_) to a ring buffer of
   fixed size (block_size_). The ring buffer contains the last block_size_
   index positions of the given hash key in the compressed data. */FindLongestMatchH6PrepareDistanceCacheH6StitchToPreviousBlockH6StoreRangeH6StoreH6HashMemAllocInBytesH6PrepareH6InitializeH60U(uint64_t)0U((uint64_t)0U)~((uint64_t)0U)(~((uint64_t)0U))HashBytesH6StoreLookaheadH6HashTypeLengthH6hash_mask_/* Mask for selecting the next 4-8 bytes of input */FindLongestMatchH40AddraddrHeadTinyHashtiny_hashesBanksBankBankH40 *BankH40 *__restrict__bankstiny_hashbank(NUM_BANKS - 1)hopsCAPPED_CHAINSSlotH40[65536]BANK_SIZESlotH40 *PrepareDistanceCacheH40StitchToPreviousBlockH40StoreRangeH40StoreH40uint16_t[1]unsigned short[1](BANK_SIZE - 1)HashMemAllocInBytesH40sizeof(uint16_t) * BUCKET_SIZE196608sizeof(uint32_t) * BUCKET_SIZE + sizeof(uint16_t) * BUCKET_SIZEsizeof(uint8_t)sizeof(uint8_t) * 65536sizeof(uint32_t) * BUCKET_SIZE + sizeof(uint16_t) * BUCKET_SIZE +
         sizeof(uint8_t) * 65536sizeof(FN(Bank))sizeof(FN(Bank)) * NUM_BANKSsizeof(uint32_t) * BUCKET_SIZE + sizeof(uint16_t) * BUCKET_SIZE +
         sizeof(uint8_t) * 65536 + sizeof(FN(Bank)) * NUM_BANKSPrepareH4034359738360xCCCCCCCC524280xCCCCsizeof(self->free_slot_idx)InitializeH40BanksH40TinyHashH40HeadH40AddrH40HashBytesH40StoreLookaheadH40HashTypeLengthH40BankH40SlotH40Slotmax_hopsfree_slot_idxslotsHashForgetfulChain(1 << BANK_BITS)/* For distance code 0 we want to consider 2-byte matches. *//* Look at 4 bytes at &data[ix & mask]. Compute a hash from these, and prepend
   node to corresponding chain; also update tiny_hash for current position. *//* Fill |addr| array with 0xCCCCCCCC value. Because of wrapping, position
       processed by hasher never reaches 3GB + 64M; this makes all new chains
       to be terminated after the first node. *//* See InitEmpty comment. *//* FN(Bank) banks[NUM_BANKS]; *//* uint8_t tiny_hash[65536];*//* Truncated hash used for quick rejection of "distance cache" candidates. *//* uint16_t head[BUCKET_SIZE]; *//* uint32_t addr[BUCKET_SIZE]; *//* Up to 1KiB. Move to dynamic? *//* HashBytes is the function that chooses the bucket to place the address in.*//* A (forgetful) hash table to the data seen by the compressor, to
   help create backward references to previous data.

   Hashes are stored in chains which are bucketed to groups. Group of chains
   share a storage "bank". When more than "bank size" chain nodes are added,
   oldest nodes are replaced; this way several chains may share a tail. *//* template parameters: FN, BUCKET_BITS, NUM_BANKS, BANK_BITS,
                        NUM_LAST_DISTANCES_TO_CHECK */FindLongestMatchH41BankH41 *BankH41 *__restrict__SlotH41[65536]SlotH41 *PrepareDistanceCacheH41StitchToPreviousBlockH41StoreRangeH41StoreH41HashMemAllocInBytesH41PrepareH41InitializeH41BanksH41TinyHashH41HeadH41AddrH41HashBytesH41StoreLookaheadH41HashTypeLengthH41BankH41SlotH41FindLongestMatchH42BankH42 *BankH42 *__restrict__SlotH42[512]SlotH42 *PrepareDistanceCacheH42StitchToPreviousBlockH42StoreRangeH42StoreH42uint16_t[512]unsigned short[512]HashMemAllocInBytesH42PrepareH42InitializeH42BanksH42TinyHashH42HeadH42AddrH42HashBytesH42StoreLookaheadH42HashTypeLengthH42BankH42SlotH42FindLongestMatchH54PrepareDistanceCacheH54StitchToPreviousBlockH54StoreRangeH54StoreH54HashMemAllocInBytesH54PrepareH54InitializeH54HashBytesH54StoreLookaheadH54HashTypeLengthH54FindLongestMatchHROLLING_FASTHROLLING_FAST *HROLLING_FAST *__restrict__(JUMP - 1)kInvalidPosHashRollingFunctionaddfound_ixfound_ix_maskedPrepareDistanceCacheHROLLING_FASTStitchToPreviousBlockHROLLING_FASTposition_maskedavailableStoreRangeHROLLING_FASTStoreHROLLING_FASTHashMemAllocInBytesHROLLING_FASTPrepareHROLLING_FASTHashRollingFunctionInitialInitializeHROLLING_FASTkRollingHashMul3269069HashRollingFunctionHROLLING_FASTHashByteHashRollingFunctionInitialHROLLING_FASTHashByteHROLLING_FASTStoreLookaheadHROLLING_FASTHashTypeLengthHROLLING_FASTfactor_removefactorchunk_lennext_ixkInvalidPosHROLLING_FAST0xffffffffkRollingHashMul32HROLLING_FASTHashRolling/* NOTE: this hasher does not search in the dictionary. It is used as
     backup-hasher, the main hasher already searches in it. *//* The cast to 32-bit makes backward distances up to 4GB work even
           if cur_ix is above 4GB, despite using 32-bit values in the table. *//* Not enough lookahead *//* wrapping around ringbuffer not handled. *//* In this case we must re-initialize the hasher from scratch from the
     current position. *//* Too small size, cannot use this hasher. *//* Compute the factor of the oldest byte to remove: factor**steps modulo
     0xffffffff (the multiplications rely on 32-bit overflow) *//* Computes a code from a single byte. A lookup table of 256 values could be
   used, but simply adding 1 works about as good. *//* This hasher uses a longer forward length, but returning a higher value here
   will hurt compression by the main hasher when combined with a composite
   hasher. The hasher tests for forward itself instead. *//* Rolling hash for long distance long string matches. Stores one position
   per bucket, bucket key is computed over a long region. *//* JUMP = skip bytes for speedup *//* NUMBUCKETS / (MASK + 1) = probability of storing and using hash code. *//* template parameters: FN, JUMP, NUMBUCKETS, MASK, CHUNKLEN *//* Copyright 2018 Google Inc. All Rights Reserved.

   Distributed under MIT license.
   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/byteFindLongestMatchHROLLINGHROLLING *HROLLING *__restrict__PrepareDistanceCacheHROLLINGStitchToPreviousBlockHROLLINGStoreRangeHROLLINGStoreHROLLINGHashMemAllocInBytesHROLLINGPrepareHROLLINGInitializeHROLLINGHashRollingFunctionHROLLINGHashRollingFunctionInitialHROLLINGHashByteHROLLINGStoreLookaheadHROLLINGHashTypeLengthHROLLINGkInvalidPosHROLLINGkRollingHashMul32HROLLINGFindLongestMatchH35PrepareDistanceCacheH35StitchToPreviousBlockH35StoreRangeH35StoreH35HashMemAllocInBytesH35PrepareH35InitializeH35StoreLookaheadH35HashTypeLengthH35freshhb_commonhbhaHashCompositeFN_B(X)EXPAND_CAT(X, HASHER_B)FN_A(X)EXPAND_CAT(X, HASHER_A)/* TODO: Initialize of the hashers is defered to Prepare (and params
     remembered here) because we don't get the one_shot and input_size params
     here that are needed to know the memory size of them. Instead provide
     those params to all hashers FN(Initialize) *//* Composite hasher: This hasher allows to combine two other hashers, HASHER_A
   and HASHER_B. *//* template parameters: FN, HASHER_A, HASHER_B */FindLongestMatchH55PrepareDistanceCacheH55StitchToPreviousBlockH55StoreRangeH55StoreH55HashMemAllocInBytesH55PrepareH55InitializeH55StoreLookaheadH55HashTypeLengthH55FindLongestMatchH65PrepareDistanceCacheH65StitchToPreviousBlockH65StoreRangeH65StoreH65HashMemAllocInBytesH65PrepareH65InitializeH65StoreLookaheadH65HashTypeLengthH65const size_t[]/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/entropy_encode.cMAX_HUFFMAN_BITSbl_countnext_codeconst size_t[16]kLutuse_rle_for_non_zerouse_rle_for_zeronew_lengthDecideOverRleUsetotal_reps_zerototal_reps_non_zerocount_reps_zerocount_reps_non_zerototal_reps_non_zero > count_reps_non_zero * 2total_reps_zero > count_reps_zero * 2nonzero_countstreak_limit1240nonzerossmallest_nonzero1 << 30zeros420num_bits24802 * streak_limitBrotliWriteHuffmanTreeRepetitionsZerosBrotliWriteHuffmanTreeRepetitionsrepetitions > 0Reversedata[i]j_endv0->index_right_or_value_ > v1->index_right_or_value_stackmax_depth <= 15/* In Brotli, all bit depths are [1..15]
     0 bit depth means that the symbol does not exist. *//* 0..15 are values for bits *//* Pre-reversed 4-bit values. *//* Find RLE coding for longer codes.
       Shorter codes seem not to benefit from RLE. *//* First gather statistics on if it is a good idea to do RLE. *//* Throw away trailing zeros. *//* at least when non-zeros. *//* All interesting strides have a count of at least 4, *//* We don't want to change value at counts[i],
             that is already belonging to the next stride. Thus - 1. *//* Don't make an all zeros stride to be upgraded to ones. *//* The stride must end, collapse what we have, if we have enough (4). *//* 3) Let's replace those population counts that lead to more RLE codes.
     Math here is in 24.8 fixed point representation. *//* Let's not spoil any of the existing good RLE codes.
       Mark any seq of 0's that is longer as 5 as a good_for_rle.
       Mark any seq of non-0's that is longer as 7 as a good_for_rle. *//* 2) Let's mark all population counts that already can be encoded
     with an RLE code. *//* Small histogram will model it well. *//* Now counts[0..length - 1] does not have trailing zeros. *//* All zeros. *//* Let's make the Huffman code more compatible with RLE encoding. *//* We need to pack the Huffman tree in tree_limit bits. If this was not
         successful, add fake entities to the lowest values and retry. *//* The nodes are:
       [0, n): the sorted leaf nodes that we start with.
       [n]: we add a sentinel here.
       [n + 1, 2n): new parent nodes are added here, starting from
                    (n+1). These are naturally in ascending order.
       [2n]: we add a sentinel at the end as well.
       There will be (2n+1) elements at the end. *//* Only one element. *//* For block sizes below 64 kB, we never need to do a second iteration
     of this loop. Probably all of our block sizes will be smaller than
     that, so this loop is mostly of academic interest. If we actually
     would need this, we would be better off with the Katajainen algorithm. *//* This function will create a Huffman tree.

   The catch here is that the tree cannot be arbitrarily deep.
   Brotli specifies a maximum depth of 15 bits for "code trees"
   and 7 bits for "code length code trees."

   count_limit is the value that is to be faked as the minimum value
   and this minimum value is raised until the tree matches the
   maximum length requirement.

   This algorithm is not of excellent performance for very long data blocks,
   especially when population counts are longer than 2**tree_limit, but
   we are not planning to use this with extremely long blocks.

   See http://en.wikipedia.org/wiki/Huffman_coding *//* Sort the root nodes, least popular first. */repetitions__DECL_SIMD_tanf128x__DECL_SIMD_tanf64x__DECL_SIMD_tanf32x__DECL_SIMD_tanf128__DECL_SIMD_tanf64__DECL_SIMD_tanf32__DECL_SIMD_tanf16__DECL_SIMD_tanl__DECL_SIMD_tanf__DECL_SIMD_tan__DECL_SIMD_erfcf128x__DECL_SIMD_erfcf64x__DECL_SIMD_erfcf32x__DECL_SIMD_erfcf128__DECL_SIMD_erfcf64__DECL_SIMD_erfcf32__DECL_SIMD_erfcf16__DECL_SIMD_erfcl__DECL_SIMD_erfcf__DECL_SIMD_erfc__DECL_SIMD_asinhf128x__DECL_SIMD_asinhf64x__DECL_SIMD_asinhf32x__DECL_SIMD_asinhf128__DECL_SIMD_asinhf64__DECL_SIMD_asinhf32__DECL_SIMD_asinhf16__DECL_SIMD_asinhl__DECL_SIMD_asinhf__DECL_SIMD_asinh__DECL_SIMD_tanhf128x__DECL_SIMD_tanhf64x__DECL_SIMD_tanhf32x__DECL_SIMD_tanhf128__DECL_SIMD_tanhf64__DECL_SIMD_tanhf32__DECL_SIMD_tanhf16__DECL_SIMD_tanhl__DECL_SIMD_tanhf__DECL_SIMD_tanh__DECL_SIMD_erff128x__DECL_SIMD_erff64x__DECL_SIMD_erff32x__DECL_SIMD_erff128__DECL_SIMD_erff64__DECL_SIMD_erff32__DECL_SIMD_erff16__DECL_SIMD_erfl__DECL_SIMD_erff__DECL_SIMD_erf__DECL_SIMD_acoshf128x__DECL_SIMD_acoshf64x__DECL_SIMD_acoshf32x__DECL_SIMD_acoshf128__DECL_SIMD_acoshf64__DECL_SIMD_acoshf32__DECL_SIMD_acoshf16__DECL_SIMD_acoshl__DECL_SIMD_acoshf__DECL_SIMD_acosh__DECL_SIMD_atanhf128x__DECL_SIMD_atanhf64x__DECL_SIMD_atanhf32x__DECL_SIMD_atanhf128__DECL_SIMD_atanhf64__DECL_SIMD_atanhf32__DECL_SIMD_atanhf16__DECL_SIMD_atanhl__DECL_SIMD_atanhf__DECL_SIMD_atanh__DECL_SIMD_log1pf128x__DECL_SIMD_log1pf64x__DECL_SIMD_log1pf32x__DECL_SIMD_log1pf128__DECL_SIMD_log1pf64__DECL_SIMD_log1pf32__DECL_SIMD_log1pf16__DECL_SIMD_log1pl__DECL_SIMD_log1pf__DECL_SIMD_log1p__DECL_SIMD_log2f128x__DECL_SIMD_log2f64x__DECL_SIMD_log2f32x__DECL_SIMD_log2f128__DECL_SIMD_log2f64__DECL_SIMD_log2f32__DECL_SIMD_log2f16__DECL_SIMD_log2l__DECL_SIMD_log2f__DECL_SIMD_log2__DECL_SIMD_log10f128x__DECL_SIMD_log10f64x__DECL_SIMD_log10f32x__DECL_SIMD_log10f128__DECL_SIMD_log10f64__DECL_SIMD_log10f32__DECL_SIMD_log10f16__DECL_SIMD_log10l__DECL_SIMD_log10f__DECL_SIMD_log10__DECL_SIMD_atan2f128x__DECL_SIMD_atan2f64x__DECL_SIMD_atan2f32x__DECL_SIMD_atan2f128__DECL_SIMD_atan2f64__DECL_SIMD_atan2f32__DECL_SIMD_atan2f16__DECL_SIMD_atan2l__DECL_SIMD_atan2f__DECL_SIMD_atan2__DECL_SIMD_cbrtf128x__DECL_SIMD_cbrtf64x__DECL_SIMD_cbrtf32x__DECL_SIMD_cbrtf128__DECL_SIMD_cbrtf64__DECL_SIMD_cbrtf32__DECL_SIMD_cbrtf16__DECL_SIMD_cbrtl__DECL_SIMD_cbrtf__DECL_SIMD_cbrt__DECL_SIMD_sinhf128x__DECL_SIMD_sinhf64x__DECL_SIMD_sinhf32x__DECL_SIMD_sinhf128__DECL_SIMD_sinhf64__DECL_SIMD_sinhf32__DECL_SIMD_sinhf16__DECL_SIMD_sinhl__DECL_SIMD_sinhf__DECL_SIMD_sinh__DECL_SIMD_expm1f128x__DECL_SIMD_expm1f64x__DECL_SIMD_expm1f32x__DECL_SIMD_expm1f128__DECL_SIMD_expm1f64__DECL_SIMD_expm1f32__DECL_SIMD_expm1f16__DECL_SIMD_expm1l__DECL_SIMD_expm1f__DECL_SIMD_expm1__DECL_SIMD_coshf128x__DECL_SIMD_coshf64x__DECL_SIMD_coshf32x__DECL_SIMD_coshf128__DECL_SIMD_coshf64__DECL_SIMD_coshf32__DECL_SIMD_coshf16__DECL_SIMD_coshl__DECL_SIMD_coshf__DECL_SIMD_cosh__DECL_SIMD_exp10f128x__DECL_SIMD_exp10f64x__DECL_SIMD_exp10f32x__DECL_SIMD_exp10f128__DECL_SIMD_exp10f64__DECL_SIMD_exp10f32__DECL_SIMD_exp10f16__DECL_SIMD_exp10l__DECL_SIMD_exp10f__DECL_SIMD_exp10__DECL_SIMD_exp2f128x__DECL_SIMD_exp2f64x__DECL_SIMD_exp2f32x__DECL_SIMD_exp2f128__DECL_SIMD_exp2f64__DECL_SIMD_exp2f32__DECL_SIMD_exp2f16__DECL_SIMD_exp2l__DECL_SIMD_exp2f__DECL_SIMD_exp2__DECL_SIMD_hypotf128x__DECL_SIMD_hypotf64x__DECL_SIMD_hypotf32x__DECL_SIMD_hypotf128__DECL_SIMD_hypotf64__DECL_SIMD_hypotf32__DECL_SIMD_hypotf16__DECL_SIMD_hypotl__DECL_SIMD_hypotf__DECL_SIMD_hypot__DECL_SIMD_asinf128x__DECL_SIMD_asinf64x__DECL_SIMD_asinf32x__DECL_SIMD_asinf128__DECL_SIMD_asinf64__DECL_SIMD_asinf32__DECL_SIMD_asinf16__DECL_SIMD_asinl__DECL_SIMD_asinf__DECL_SIMD_asin__DECL_SIMD_atanf128x__DECL_SIMD_atanf64x__DECL_SIMD_atanf32x__DECL_SIMD_atanf128__DECL_SIMD_atanf64__DECL_SIMD_atanf32__DECL_SIMD_atanf16__DECL_SIMD_atanl__DECL_SIMD_atanf__DECL_SIMD_atan__DECL_SIMD_acosf128x__DECL_SIMD_acosf64x__DECL_SIMD_acosf32x__DECL_SIMD_acosf128__DECL_SIMD_acosf64__DECL_SIMD_acosf32__DECL_SIMD_acosf16__DECL_SIMD_acosl__DECL_SIMD_acosf__DECL_SIMD_acos__DECL_SIMD_powf128x__DECL_SIMD_powf64x__DECL_SIMD_powf32x__DECL_SIMD_powf128__DECL_SIMD_powf64__DECL_SIMD_powf32__DECL_SIMD_powf16__DECL_SIMD_powl__DECL_SIMD_powf__DECL_SIMD_pow__DECL_SIMD_expf128x__DECL_SIMD_expf64x__DECL_SIMD_expf32x__DECL_SIMD_expf128__DECL_SIMD_expf64__DECL_SIMD_expf32__DECL_SIMD_expf16__DECL_SIMD_expl__DECL_SIMD_expf__DECL_SIMD_exp__DECL_SIMD_logf128x__DECL_SIMD_logf64x__DECL_SIMD_logf32x__DECL_SIMD_logf128__DECL_SIMD_logf64__DECL_SIMD_logf32__DECL_SIMD_logf16__DECL_SIMD_logl__DECL_SIMD_logf__DECL_SIMD_log__DECL_SIMD_sincosf128x__DECL_SIMD_sincosf64x__DECL_SIMD_sincosf32x__DECL_SIMD_sincosf128__DECL_SIMD_sincosf64__DECL_SIMD_sincosf32__DECL_SIMD_sincosf16__DECL_SIMD_sincosl__DECL_SIMD_sincosf__DECL_SIMD_sincos__DECL_SIMD_sinf128x__DECL_SIMD_sinf64x__DECL_SIMD_sinf32x__DECL_SIMD_sinf128__DECL_SIMD_sinf64__DECL_SIMD_sinf32__DECL_SIMD_sinf16__DECL_SIMD_sinl__DECL_SIMD_sinf__DECL_SIMD_sin__DECL_SIMD_cosf128x__DECL_SIMD_cosf64x__DECL_SIMD_cosf32x__DECL_SIMD_cosf128__DECL_SIMD_cosf64__DECL_SIMD_cosf32__DECL_SIMD_cosf16__DECL_SIMD_cosl__DECL_SIMD_cosf__DECL_SIMD_cos_BITS_LIBM_SIMD_DECL_STUBS_H_MATH_H/* Needed definitions could be generated with:
   for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |\
		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
     echo "#define __DECL_SIMD_${func}";
     echo "#define __DECL_SIMD_${func}f";
     echo "#define __DECL_SIMD_${func}l";
   done
 *//* Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
   Copyright (C) 2014-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/libm-simd-decl-stubs.h>defined __x86_64__ && defined __FAST_MATH__defined _OPENMP && _OPENMP >= 201307__GNUC_PREREQ (6,0)__DECL_SIMD_x86_64/* W/o OpenMP use GCC 6.* __attribute__ ((__simd__)).  *//* OpenMP case.  *//* Get default empty definitions for simd declarations.  *//* Platform-specific SIMD declarations of math functions.
   Copyright (C) 2014-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__GLIBC_FLT_EVAL_METHOD__FLT_EVAL_METHOD____FLT_EVAL_METHOD__ == -1/* Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__FP_LOGBNAN_IS_MIN__FP_LOGB0_IS_MIN/* Define __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.  x86 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__FP_FAST_FMA__FP_FAST_FMAF__FP_FAST_FMAL/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  *//* Define FP_FAST_* macros.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__issignaling__iseqsig__isnan__finite__isinf__signbit__fpclassify(_Mdouble_ __value)(double __value)issignaling(_Mdouble_ __x, _Mdouble_ __y)(double __x, double __y)iseqsigisnanfiniteisinfsignbitfpclassify/* Test for signaling NaN.  *//* Test equality.  *//* Return nonzero if VALUE is not a number.  *//* Return nonzero if VALUE is finite and not NaN.  Used by isfinite macro.  *//* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  *//* Test for negative number.  *//* Classify given number.  *//* Prototype declarations for math classification macros helpers.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__y__scalbscalb__fmafma__fminfmin__fmaxfmax__fdimfdim__llroundllround__lroundlround__llrintllrint__lrintlrint__remquoremquo__trunctrunc__roundround__nearbyintnearbyint__scalblnscalbln__ilogbilogb__scalbnscalbn__remainderremainder__nexttowardnexttoward__nextafternextafter__rintrint__lgamma_rlgamma_r__gammagamma__tgammatgamma__lgammalgamma__erfcerfc__erferf__ynyn__y1y1__y0y0__jnjn__j1j1__j0j0__nannan__copysigncopysign__significandsignificand__dremdrem__fmodfmod__floorfloor__fabsfabs__ceilceil__cbrtcbrt__hypothypot__sqrtsqrt__powpow__log2log2__exp2exp2__logblogb__log1plog1p__expm1expm1__modfmodf__log10log10__loglog__ldexpldexp__frexpfrexp__expexp__atanhatanh__asinhasinh__acoshacosh__tanhtanh__sinhsinh__coshcosh__tantan__sinsin__coscos__atan2atan2__atanatan__asinasin__acosacosdefined __USE_XOPEN_EXTENDED || defined __USE_ISOC99__GLIBC_USE (IEC_60559_FUNCS_EXT_C2X)defined __USE_XOPEN || defined __USE_ISOC99((!defined __cplusplus \!__MATH_DECLARING_FLOATNdefined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)defined __USE_MISC || (defined __USE_XOPEN && __MATH_DECLARING_DOUBLE)defined __USE_ISOC99 && !defined __LDBL_COMPAT && !__MATH_DECLARING_FLOATN__GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN!__MATH_DECLARING_FLOATN || defined __USE_GNU || !__GLIBC_USE (ISOC2X)(__GLIBC_USE (IEC_60559_BFP_EXT)				\__GLIBC_USE (IEC_60559_EXT) || __MATH_DECLARING_FLOATN(defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \(_Mdouble_ __x, _Mdouble_ __n)(double __x, double __n)_Mdouble___CONCAT(__,scalb)(_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z)(double __x, double __y, double __z)__CONCAT(__,fma)(__const__)__CONCAT(__,fmin)__CONCAT(__,fmax)__CONCAT(__,fdim)long long int(_Mdouble_ __x)(double __x)__CONCAT(__,llround)__CONCAT(__,lround)__CONCAT(__,llrint)__CONCAT(__,lrint)(_Mdouble_ __x, _Mdouble_ __y, int *__quo)(double __x, double __y, int *__quo)__CONCAT(__,remquo)__CONCAT(__,trunc)__CONCAT(__,round)__CONCAT(__,nearbyint)(_Mdouble_ __x, long int __n)(double __x, long int __n)__CONCAT(__,scalbln)__CONCAT(__,ilogb)(_Mdouble_ __x, int __n)(double __x, int __n)__CONCAT(__,scalbn)__CONCAT(__,remainder)(_Mdouble_ __x, long double __y)(double __x, long double __y)__CONCAT(__,nexttoward)__CONCAT(__,nextafter)__CONCAT(__,rint)_r(_Mdouble_, int *__signgamp)(double, int *__signgamp)__CONCAT(__,lgamma)(_Mdouble_)(double)__CONCAT(__,gamma)__CONCAT(__,tgamma)__CONCAT(__,erfc)__CONCAT(__,erf)(int, _Mdouble_)(int, double)__CONCAT(__,yn)__CONCAT(__,y1)__CONCAT(__,y0)__CONCAT(__,jn)__CONCAT(__,j1)__CONCAT(__,j0)(const char *__tagb)__CONCAT(__,nan)__CONCAT(__,copysign)__CONCAT(__,significand)__CONCAT(__,drem)__CONCAT(__,fmod)__CONCAT(__,floor)__CONCAT(__,fabs)__CONCAT(__,ceil)__CONCAT(__,cbrt)__CONCAT(__,hypot)__CONCAT(__,sqrt)__CONCAT(__,pow)__CONCAT(__,log2)__CONCAT(__,exp2)__CONCAT(__,logb)__CONCAT(__,log1p)__CONCAT(__,expm1)(_Mdouble_ __x, _Mdouble_ *__iptr)(double __x, double *__iptr)__CONCAT(__,modf)__CONCAT(__,log10)__CONCAT(__,log)(_Mdouble_ __x, int __exponent)(double __x, int __exponent)__CONCAT(__,ldexp)(_Mdouble_ __x, int *__exponent)(double __x, int *__exponent)__CONCAT(__,frexp)__CONCAT(__,exp)__CONCAT(__,atanh)__CONCAT(__,asinh)__CONCAT(__,acosh)__CONCAT(__,tanh)__CONCAT(__,sinh)__CONCAT(__,cosh)__CONCAT(__,tan)__CONCAT(__,sin)__CONCAT(__,cos)(_Mdouble_ __y, _Mdouble_ __x)(double __y, double __x)__CONCAT(__,atan2)__CONCAT(__,atan)__CONCAT(__,asin)__CONCAT(__,acos)__IEC_60559_EXT__MATH_PRECNAME (erfc, )__DECL_SIMD___MATH_PRECNAME (erf, )__MATH_PRECNAME (cos, )__MATH_PRECNAME (atan2, )__MATH_PRECNAME (atan, )__MATH_PRECNAME (asin, )__MATH_PRECNAME (acos, )__MATH_PRECNAME (expm1, )IEC_60559_FUNCS_EXT_C2X__MATH_PRECNAME (log10, )__MATH_PRECNAME (log, )__MATH_PRECNAME (cbrt, )__MATH_PRECNAME (hypot, )__MATH_PRECNAME (pow, )__MATH_PRECNAME (log2, )__MATH_PRECNAME (exp2, )__MATH_PRECNAME (log1p, )__MATH_PRECNAME (exp, )__MATH_PRECNAME (atanh, )__MATH_PRECNAME (asinh, )__MATH_PRECNAME (acosh, )__MATH_PRECNAME (tanh, )__MATH_PRECNAME (sinh, )__MATH_PRECNAME (cosh, )__MATH_PRECNAME (tan, )__MATH_PRECNAME (sin, )/* Return X times (2 to the Nth power).  *//* Set signaling NaN payload.  *//* Set quiet NaN payload.  *//* Get NaN payload.  *//* Total order operation on absolute values.  *//* Total order operation.  *//* Return numeric value with minimum magnitude.  *//* Return numeric value with maximum magnitude.  *//* Return value with minimum magnitude.  *//* Return value with maximum magnitude.  *//* Return minimum numeric value from X and Y.  *//* Return maximum numeric value from X and Y.  *//* Return minimum value from X and Y.  *//* Return maximum value from X and Y.  *//* Canonicalize floating-point representation.  *//* Round X to nearest unsigned integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest signed integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest unsigned integer value, not raising inexact,
   with control of rounding direction and width of result.  *//* Round X to nearest signed integer value, not raising inexact, with
   control of rounding direction and width of result.  *//* Round X to nearest integer value, rounding halfway cases to even.  *//* Use ISO C99.  *//* Multiply-add function computed as a ternary operation.  *//* Return positive difference between X and Y.  *//* Round X to nearest integral value, rounding halfway cases away from
   zero.  *//* Round X to nearest integral value according to current rounding
   direction.  *//* Conversion functions.  *//* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  *//* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  *//* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  *//* Like ilogb, but returning long int.  *//* Return the binary exponent of X, which must be nonzero.  *//* Return the remainder of integer divison X / Y with infinite precision.  *//* Return X + epsilon.  *//* Return X - epsilon.  *//* Return X + epsilon if X < Y, X - epsilon if X > Y.  *//* Return the integer nearest X in the direction of the
   prevailing rounding mode.  *//* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  *//* Obsolete alias for `lgamma'.  *//* True gamma function.  *//* Error and gamma functions.  *//* Bessel functions.  *//* isnanf or isnanl don't.  *//* isnan conflicts with C++11.  *//* Return representation of qNaN for double type.  *//* Return X with its signed changed to Y's.  *//* Return the fractional part of X after dividing out `ilogb (X)'.  *//* Return the remainder of X/Y.  *//* Return nonzero if VALUE is finite and not NaN.  *//* isinff or isinfl don't.  *//* isinf conflicts with C++11.  *//* Floating-point modulo remainder of X/Y.  *//* Largest integer not greater than X.  *//* Absolute value of X.  *//* Smallest integral value not less than X.  *//* Nearest integer, absolute value, and remainder functions.  *//* Return the cube root of X.  *//* Return `sqrt(X*X + Y*Y)'.  *//* Return the square root of X.  *//* Return X to the Y power.  *//* Power functions.  *//* Compute base-2 logarithm of X.  *//* Compute base-2 exponential of X.  *//* Return the base 2 signed integral exponent of X.  *//* Return log(1 + X).  *//* Return exp(X) - 1.  *//* Compute exponent to base ten.  *//* Break VALUE into integral and fractional parts.  *//* Base-ten logarithm of X.  *//* Natural logarithm of X.  *//* X times (two to the EXP power).  *//* Break VALUE into a normalized fraction and an integral power of 2.  *//* Exponential function of X.  *//* Exponential and logarithmic functions.  *//* Hyperbolic arc tangent of X.  *//* Hyperbolic arc sine of X.  *//* Hyperbolic arc cosine of X.  *//* Cosine and sine of X.  *//* Hyperbolic tangent of X.  *//* Hyperbolic sine of X.  *//* Hyperbolic cosine of X.  *//* Hyperbolic functions.  *//* Tangent of X.  *//* Sine of X.  *//* Cosine of X.  *//* Arc tangent of Y/X.  *//* Arc tangent of X.  *//* Arc sine of X.  *//* Arc cosine of X.  *//* Trigonometric functions.  *//* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  *//* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__z__quo__signgamp__tagb__iptr__exponent__issignalingf__iseqsigf__isnanf__finitef__isinff__signbitf__fpclassifyf(float __value)(float __x, float __y)__scalbfscalbf__fmaffmaf__fminffminf__fmaxffmaxf__fdimffdimf__llroundfllroundf__lroundflroundf__llrintfllrintf__lrintflrintf__remquofremquof__truncftruncf__roundfroundf__nearbyintfnearbyintf__scalblnfscalblnf__ilogbfilogbf__scalbnfscalbnf__remainderfremainderf__nexttowardfnexttowardf__nextafterfnextafterf__rintfrintf__lgammaf_rlgammaf_r__gammafgammaf__tgammaftgammaf__lgammaflgammaf__erfcferfcf__erfferff__ynfynf__y1fy1f__y0fy0f__jnfjnf__j1fj1f__j0fj0fisnanf__nanfnanf__copysignfcopysignf__significandfsignificandf__dremfdremffinitefisinff__fmodffmodf__floorffloorf__fabsffabsf__ceilfceilf__cbrtfcbrtf__hypotfhypotf__sqrtfsqrtf__powfpowf__log2flog2f__exp2fexp2f__logbflogbf__log1pflog1pf__expm1fexpm1f__modffmodff__log10flog10f__logflogf__ldexpfldexpf__frexpffrexpf__expfexpf__atanhfatanhf__asinhfasinhf__acoshfacoshf__tanhftanhf__sinhfsinhf__coshfcoshf__tanftanf__sinfsinf__cosfcosf__atan2fatan2f__atanfatanf__asinfasinf__acosfacosf(float __x, float __n)(float __x, float __y, float __z)(float __x)(float __x, float __y, int *__quo)(float __x, long int __n)(float __x, int __n)(float __x, long double __y)(float, int *__signgamp)(float)(int, float)(float __x, float *__iptr)(float __x, int __exponent)(float __x, int *__exponent)(float __y, float __x)<bits/mathcalls-helper-functions.h><bits/mathcalls.h><bits/fp-fast.h><bits/fp-logb.h><bits/flt-eval-method.h><bits/math-vector.h>FP_NANFP_INFINITEFP_ZEROFP_SUBNORMALFP_NORMALdouble_tfloat_tsigngamisunordered(x,y)__builtin_isunordered(x, y)islessgreater(x,y)__builtin_islessgreater(x, y)islessequal(x,y)__builtin_islessequal(x, y)isless(x,y)__builtin_isless(x, y)isgreaterequal(x,y)__builtin_isgreaterequal(x, y)isgreater(x,y)__builtin_isgreater(x, y)M_SQRT1_20.70710678118654752440M_SQRT21.41421356237309504880M_2_SQRTPI1.12837916709551257390M_2_PI0.63661977236758134308M_1_PI0.31830988618379067154M_PI_40.78539816339744830962M_PI_21.57079632679489661923M_PI3.14159265358979323846M_LN102.30258509299404568402M_LN20.69314718055994530942M_LOG10E0.43429448190325182765M_LOG2E1.4426950408889634074M_E2.7182818284590452354math_errhandling(MATH_ERRNO | MATH_ERREXCEPT)MATH_ERREXCEPTMATH_ERRNOisinf(x)__builtin_isinf_sign (x)isnan(x)__builtin_isnan (x)isnormal(x)__builtin_isnormal (x)isfinite(x)__builtin_isfinite (x)signbit(x)__builtin_signbit (x)fpclassify(x)__builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)__MATH_TG(TG_ARG,FUNC,ARGS)_Generic ((TG_ARG), float: FUNC ## f ARGS, __MATH_TG_F32 (FUNC, ARGS) default: FUNC ARGS, long double: FUNC ## l ARGS, __MATH_TG_F64X (FUNC, ARGS) _Float128: FUNC ## f128 ARGS)__MATH_TG_F64X(FUNC,ARGS)_Float64x: FUNC ## l ARGS,__MATH_TG_F32(FUNC,ARGS)_Float32: FUNC ## f ARGS,__MATHCALL_NARROW__MATHCALL_NARROW_REDIR__MATHCALL_NARROW_NORMAL__MATHCALL_NARROW_ARGS_3__MATHCALL_NARROW_ARGS_2__MATHCALL_NARROW_ARGS_1__MATHCALL_NARROW(func,redir,nargs)__MATHCALL_NARROW_NORMAL (func, nargs)__MATHCALL_NARROW_REDIR(func,redir,nargs)extern _Mret_ __REDIRECT_NTH (func, __MATHCALL_NARROW_ARGS_ ## nargs, redir)__MATHCALL_NARROW_NORMAL(func,nargs)extern _Mret_ func __MATHCALL_NARROW_ARGS_ ## nargs __THROW(_Marg_ __x, _Marg_ __y, _Marg_ __z)(_Marg_ __x, _Marg_ __y)(_Marg_ __x)__MATHCALL__MATHDECL__MATHDECL_ALIAS__MATHDECL_1__MATHDECL_1_IMPL__MATH_DECLARING_FLOATN__MATH_DECLARING_DOUBLE__MATH_PRECNAME__MATH_PRECNAME(name,r)name ## f64x ## r_Float64xname ## f32x ## r_Float32xname ## f128 ## r_Float128name ## f64 ## r_Float64name ## f32 ## r_Float32__MATH_DECLARE_LDOUBLEname ## l ## rlong doublename ## f ## r__CONCAT(name,r)__MATHREDIR(type,function,suffix,args,to)extern type __REDIRECT_NTH (__MATH_PRECNAME (function, suffix), args, to)__MATHDECL_ALIAS(type,function,suffix,args,alias)__MATHDECL_1(type, function, suffix, args)__MATHDECL_1(type,function,suffix,args)__MATHDECL_1_IMPL(type, function, suffix, args)__MATHDECL_1_IMPL(type,function,suffix,args)extern type __MATH_PRECNAME(function,suffix) args __THROW__MATHDECLX(type,function,suffix,args,attrib)__MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)__MATHCALLX(function,suffix,args,attrib)__MATHDECLX (_Mdouble_,function,suffix, args, attrib)__MATHDECL(type,function,suffix,args)__MATHDECL_1(type, function,suffix, args); __MATHDECL_1(type, __CONCAT(__,function),suffix, args)__MATHCALL(function,suffix,args)__MATHDECL (_Mdouble_,function,suffix, args)__MATHDECL_VEC(type,function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHDECL(type, function,suffix, args)__MATHCALL_VEC(function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHCALL (function, suffix, args)__SIMD_DECL(function)__CONCAT (__DECL_SIMD_, function)FP_ILOGBNAN(-2147483647 - 1)FP_ILOGB0NAN(__builtin_nanf (""))INFINITY(__builtin_inff ())HUGE_VALL(__builtin_huge_vall ())HUGE_VALF(__builtin_huge_valf ())(__builtin_huge_val ())defined log && defined __GNUC____GNUC_PREREQ (3, 3)__GLIBC_USE (IEC_60559_BFP_EXT)(__HAVE_FLOAT16					\(__HAVE_FLOAT32					\(__HAVE_FLOAT64					\(__HAVE_FLOAT128					\(__HAVE_FLOAT32X					\(__HAVE_FLOAT64X					\(__HAVE_FLOAT128X					\__GLIBC_FLT_EVAL_METHOD == 0 || __GLIBC_FLT_EVAL_METHOD == 16__GLIBC_FLT_EVAL_METHOD == 1__GLIBC_FLT_EVAL_METHOD == 2__GLIBC_FLT_EVAL_METHOD == 32__GLIBC_FLT_EVAL_METHOD == 33__GLIBC_FLT_EVAL_METHOD == 64__GLIBC_FLT_EVAL_METHOD == 65__GLIBC_FLT_EVAL_METHOD == 128__GLIBC_FLT_EVAL_METHOD == 129__WORDSIZE == 32!(defined __NO_LONG_DOUBLE_MATH && defined _LIBC) \__LDBL_COMPAT__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1defined __LDBL_COMPAT \__HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !defined _LIBC)__HAVE_DISTINCT_FLOAT16__GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !defined _LIBC)__HAVE_DISTINCT_FLOAT32__HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !defined _LIBC)__HAVE_DISTINCT_FLOAT64__HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !defined _LIBC)__HAVE_DISTINCT_FLOAT128__HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !defined _LIBC)__HAVE_DISTINCT_FLOAT32X__HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !defined _LIBC)__HAVE_DISTINCT_FLOAT64X__HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !defined _LIBC)__HAVE_DISTINCT_FLOAT128X__HAVE_FLOAT16 && __HAVE_FLOAT32__HAVE_FLOAT16 && __HAVE_FLOAT32X__HAVE_FLOAT16 && __HAVE_FLOAT64__HAVE_FLOAT16 && __HAVE_FLOAT64X__HAVE_FLOAT16 && __HAVE_FLOAT128__HAVE_FLOAT16 && __HAVE_FLOAT128X__HAVE_FLOAT32 && __HAVE_FLOAT32X__HAVE_FLOAT32 && __HAVE_FLOAT64__HAVE_FLOAT32 && __HAVE_FLOAT64X__HAVE_FLOAT32 && __HAVE_FLOAT128__HAVE_FLOAT32 && __HAVE_FLOAT128X__HAVE_FLOAT32X && __HAVE_FLOAT64__HAVE_FLOAT32X && __HAVE_FLOAT64X__HAVE_FLOAT32X && __HAVE_FLOAT128__HAVE_FLOAT32X && __HAVE_FLOAT128X__HAVE_FLOAT64 && __HAVE_FLOAT64X__HAVE_FLOAT64 && __HAVE_FLOAT128__HAVE_FLOAT64 && __HAVE_FLOAT128X__HAVE_FLOAT64X && __HAVE_FLOAT128__HAVE_FLOAT64X && __HAVE_FLOAT128X__HAVE_FLOAT128 && __HAVE_FLOAT128X(__HAVE_DISTINCT_FLOAT16			\__NO_LONG_DOUBLE_MATH__HAVE_GENERIC_SELECTION__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT32__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT64X__HAVE_FLOAT64X_LONG_DOUBLE__HAVE_FLOATN_NOT_TYPEDEF((__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__)		      \__GNUC_PREREQ (6,0) || __glibc_clang_prereq (3,3)defined __cplusplus__GNUC_PREREQ (4,0)(__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__) \__HAVE_DISTINCT_FLOAT128 && !__GNUC_PREREQ (7,0) \__FAST_MATH__defined __NO_MATH_ERRNO____HAVE_FLOAT128_UNLIKE_LDBL__SUPPORT_SNAN____HAVE_FLOAT16 && defined __USE_GNU__HAVE_FLOAT32 && defined __USE_GNU__HAVE_FLOAT64 && defined __USE_GNU__HAVE_FLOAT128 && defined __USE_GNU__HAVE_FLOAT32X && defined __USE_GNU__HAVE_FLOAT64X && defined __USE_GNU__HAVE_FLOAT128X && defined __USE_GNU__GNUC_PREREQ (3, 1)__FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ > 64__FLT_EVAL_METHOD__ == 1 || __FLT_EVAL_METHOD__ > 32__FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 32!defined __cplusplus || (__cplusplus < 201103L && !defined __GNUC__)__cplusplus >= 201103L/* math.h  *//* extern "C++" *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
     in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  Moreover,
   the comparison macros from ISO C take two floating-point arguments,
   which need not have the same type.  Choosing what underlying function
   to call requires evaluating the formats of the arguments, then
   selecting which is wider.  The macro __MATH_EVAL_FMT2 provides this
   information, however, only the type of the macro expansion is
   relevant (actually evaluating the expression would be incorrect).
   Thus, the type is used as a template parameter for __iseqsig_type,
   which calls the appropriate underlying function.  *//* Return X == Y but raising "invalid" and setting errno if X or Y is
   a NaN.  *//* An expression whose type has the widest of the evaluation formats
   of X and Y (which are of floating-point types).  *//* isunordered must always check both operands first for signaling NaNs.  *//* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in 2.97, but not all cpus added their patterns until 3.1.  Therefore
   we enable the builtins from 3.1 onwards and use a generic implementation
   othwerwise.  *//* 1/sqrt(2) *//* sqrt(2) *//* 2/sqrt(pi) *//* 2/pi *//* 1/pi *//* pi/4 *//* pi/2 *//* pi *//* log_e 10 *//* log_e 2 *//* log_10 e *//* log_2 e *//* e *//* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  *//* GNU extension to provide float constants with similar names.  *//* Some useful constants.  *//* X/Open wants another strange constant.  *//* Use IEC_60559_BFP_EXT.  *//* extern C++ *//* Return nonzero value if X is zero.  *//* Return nonzero value if X is subnormal.  *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
   in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
      __builtin_types_compatible_p, which is a C-only builtin.  On the
      other hand, overloading provides the means to distinguish between
      the floating-point types.  The overloading resolution will match
      the correct parameter (regardless of type qualifiers (i.e.: const
      and volatile)).  *//* Return nonzero value if X is a signaling NaN.  *//* By default all math functions support both errno and exception handling
   (except for soft floating point implementations which may only support
   errno handling).  If errno handling is disabled, exceptions are still
   supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
   nonconforming but it is more useful than leaving it undefined).  *//* Exceptions raised by math functions.  *//* errno set by math functions.  *//* Bitmasks for the math_errhandling macro.  *//* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,
      use the helper function, __isinff128, with older compilers.  This is
      only provided for C mode, because in C++ mode, GCC has no support
      for __builtin_types_compatible_p (and when in C++ mode, this macro is
      not used anyway, because libstdc++ headers undefine it).  *//* Return nonzero value if X is positive or negative infinity.  *//* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  *//* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  *//* Return nonzero value if X is not +-Inf or NaN.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
     __builtin_types_compatible_p, which is a C-only builtin.
     The check for __cplusplus allows the use of the builtin instead of
     __MATH_TG. This is provided for libstdc++, only to let its configure
     test work. No further use of this definition of signbit is expected
     in C++ mode, since libstdc++ provides its own version of signbit
     in cmath (which undefines signbit). *//* Return nonzero value if sign of X is negative.  *//* The check for __cplusplus allows the use of the builtin, even
	when optimization for size is on.  This is provided for
	libstdc++, only to let its configure test work when it is built
	with -Os.  No further use of this definition of fpclassify is
	expected in C++ mode, since libstdc++ provides its own version
	of fpclassify in cmath (which undefines fpclassify).  *//* Return number of classification appropriate for X.  *//* GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
   so disable builtins if this is enabled.  When fixed in a newer GCC,
   the __SUPPORT_SNAN__ check may be skipped for those versions.  *//* All floating-point numbers can be put in one of these categories.  *//* ISO C99 defines some generic macros which work on any data type.  *//* Depending on the type of TG_ARG, call an appropriately suffixed
   version of FUNC with arguments (including parentheses) ARGS.
   Suffixed functions may not exist for long double if it has the same
   format as double, or for other types with the same format as float,
   double or long double.  The behavior is undefined if the argument
   does not have a real floating type.  The definition may use a
   conditional expression, so all suffixed versions of FUNC must
   return the same type (FUNC may include a cast if necessary rather
   than being a single identifier).  *//* This variable is used by `gamma' and `lgamma'.  *//* Declare functions returning a narrower type.  *//* __HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !_LIBC).  *//* Include the file of declarations for _FloatN and _FloatNx
   types.  *//* !(__NO_LONG_DOUBLE_MATH && _LIBC) || __LDBL_COMPAT *//* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  *//* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  *//* Ignore the alias by default.  The alias is only useful with
   redirections.  *//* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  *//* Rounding direction macros for fromfp functions.  *//* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.
*//* Define macros for the return values of ilogb and llogb, based on
   __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.
    FP_LLOGB0	Expands to a value returned by `llogb (0.0)'.
    FP_LLOGBNAN	Expands to a value returned by `llogb (NAN)'.

*//* Define the following typedefs.

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions
*//* Get __GLIBC_FLT_EVAL_METHOD.  *//* Signaling NaN macros, if supported.  *//* __USE_ISOC99 *//* This will raise an "invalid" exception outside static initializers,
   but is the best that can be done in ISO C while remaining a
   constant expression.  *//* IEEE Not A Number.  *//* IEEE positive infinity.  *//* This may provoke compiler warnings, and may not be rounded to
   +Infinity in all IEEE 754 rounding modes, but is the best that can
   be done in ISO C while remaining a constant expression.  10,000 is
   greater than the maximum (decimal) exponent for all supported
   floating-point formats and widths.  *//* Value returned on overflow.  With IEEE 754 floating point, this is
   +Infinity, otherwise the largest representable positive value.  *//* Gather machine dependent type support.  *//* Get machine-dependent vector math functions declarations.  *//* Get definitions of __intmax_t and __uintmax_t.  *//*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 *//* Declarations for math functions.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/fast_log.c/* ", ".join(["%.16ff" % x for x in [0.0]+[log2(x) for x in range(1, 256)]]) *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/histogram.cliteral_itinsert_and_copy_itdist_itBlockSplitIterator *context_modes[context]BlockSplitIteratorNextInitBlockSplitIteratorBlockSplitIteratorlength_type_split_/* TODO: unwrap iterator blocks. *//* Build per-context histograms of literals, commands and distance codes. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/literal_cost.cBrotliEstimateBitCostsForLiteralswindow_halfin_windowlit_cost0.029000000000000001470.029EstimateBitCostsForLiteralsUTF8max_utf8size_t[3][256]unsigned long[3][256]495in_window_utf8last_cutf8_possize_t(*)[256]unsigned long(*)[256]utf8_pos20.029049999999999999430.029050.69999999999999995560.70.34999999999999997780.35DecideMultiByteStatsLevel500UTF8Positionclamp/* Add a byte in the future. *//* Remove a byte in the past. *//* Compute bit costs with sliding window. *//* Bootstrap histogram. *//* Make the first bytes more expensive -- seems to help, not sure why.
         Perhaps because the entropy source is changing its properties
         rapidly in the beginning of the file, perhaps because the beginning
         of the data is a statistical "anomaly". *//* Bootstrap histograms. *//* max_utf8 is 0 (normal ASCII single byte modeling),
     1 (for 2-byte UTF-8 modeling), or 2 (for 3-byte UTF-8 modeling). *//* should be 2, but 1 compresses better. *//* Next one is the 'Byte 3' of utf-8 encoding. *//* Completed two or three byte coding. *//* Let's decide over the last byte if this ends the sequence. *//* Next one is the 'Byte 2' of utf-8 encoding. *//* Next one is the 'Byte 1' again. *//* Literal cost model to allow backward reference replacement to be efficient.
*/BROTLI_ENC_LITERAL_COST_H_/* BROTLI_ENC_LITERAL_COST_H_ *//* Estimates how many bits the literals in the interval [pos, pos + len) in the
   ring-buffer (data, mask) will take entropy coded and writes these estimates
   to the cost[0..len) array. */__issignalingl__iseqsigl__isnanl__finitel__isinfl__signbitl__fpclassifyl(long double __value)(long double __x, long double __y)__scalblscalbl__fmalfmal__fminlfminl__fmaxlfmaxl__fdimlfdiml__llroundlllroundl__lroundllroundl__llrintlllrintl__lrintllrintl__remquolremquol__truncltruncl__roundlroundl__nearbyintlnearbyintl__scalblnlscalblnl__ilogblilogbl__scalbnlscalbnl__remainderlremainderl__nexttowardlnexttowardl__nextafterlnextafterl__rintlrintl__lgammal_rlgammal_r__gammalgammal__tgammaltgammal__lgammallgammal__erfclerfcl__erflerfl__ynlynl__y1ly1l__y0ly0l__jnljnl__j1lj1l__j0lj0lisnanl__nanlnanl__copysignlcopysignl__significandlsignificandl__dremldremlfinitelisinfl__fmodlfmodl__floorlfloorl__fabslfabsl__ceillceill__cbrtlcbrtl__hypotlhypotl__sqrtlsqrtl__powlpowl__log2llog2l__exp2lexp2l__logbllogbl__log1pllog1pl__expm1lexpm1l__modfllong double *modfl__log10llog10l__logllogl__ldexplldexpl__frexplfrexpl__explexpl__atanhlatanhl__asinhlasinhl__acoshlacoshl__tanhltanhl__sinhlsinhl__coshlcoshl__tanltanl__sinlsinl__coslcosl__atan2latan2l__atanlatanl__asinlasinl__acoslacosl(long double __x, long double __n)(long double __x, long double __y, long double __z)(long double __x)(long double __x, long double __y, int *__quo)(long double __x, long int __n)(long double __x, int __n)(long double, int *__signgamp)(long double)(int, long double)(long double __x, long double *__iptr)(long double __x, int __exponent)(long double __x, int *__exponent)(long double __y, long double __x)__issignalingf128__iseqsigf128__isnanf128__finitef128__isinff128__signbitf128__fpclassifyf128(_Float128 __value)(_Float128 __x, _Float128 __y)/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/memory.cNEW_FREED_OFFSET(MAX_PERM_ALLOCATED + MAX_NEW_ALLOCATED)NEW_ALLOCATED_OFFSETMAX_PERM_ALLOCATEDPERM_ALLOCATED_OFFSETMAX_NEW_FREEDMAX_NEW_ALLOCATED/* Now all unfreed pointers are in perm-allocated list. *//* exit, free, malloc *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/metablock_inc.h/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/metablock.c"./metablock_inc.h"BrotliBuildMetaBlockGreedyInternallit_blockscmd_blocksdist_blocksBlockSplitterLiteral *HistogramLiteral **400.0ContextBlockSplitter *BlockSplitterCommand *HistogramCommand **500.0BlockSplitterDistance *HistogramDistance **100.0MapStaticContextsmb->literal_context_map_sizeBROTLI_IS_NULL(mb->literal_context_map)mb->literal_context_map == 0ContextBlockSplitterAddSymbolContextBlockSplitterFinishBlocklast_entropydouble[26]BROTLI_MAX_STATIC_CONTEXTS2 * BROTLI_MAX_STATIC_CONTEXTS2 * num_contextsself->last_histogram_ix_double[13]is_finalcombined_entropydouble[2]BROTLI_IS_NULL(combined_histo)curr_histo_ixjxlast_histogram_ixInitContextBlockSplittermax_num_blocksmax_num_typesself->max_block_types_ + 1*histograms_sizemin_block_sizesplit_threshold*histogramsBROTLI_IS_NULL(*histograms)num_contexts <= BROTLI_MAX_STATIC_CONTEXTS*histograms == 0kMaxNumberOfHistogramsliteral_context_modesliteral_context_multipliercheck_origbest_dist_costorig_paramsnew_paramsmb->literal_split.num_types1 << BROTLI_LITERAL_CONTEXT_BITSBROTLI_IS_NULL(literal_context_modes)BROTLI_IS_NULL(literal_histograms)BROTLI_IS_NULL(distance_histograms)mb->command_histograms_sizeBROTLI_IS_NULL(mb->command_histograms)mb->literal_histograms_sizeBROTLI_IS_NULL(mb->literal_histograms)(1 << BROTLI_LITERAL_CONTEXT_BITS)mb->distance_context_map_sizeBROTLI_IS_NULL(mb->distance_context_map)mb->distance_histograms_sizeBROTLI_IS_NULL(mb->distance_histograms)mb->command_histograms == 0mb->literal_histograms == 0mb->distance_context_map == 0mb->distance_histograms == 0ComputeDistanceCostequal_paramsdist_prefixdist_extraRecomputeDistancePrefixesdist_paramsContextBlockSplitterplainmerge_last_count_last_entropy_last_histogram_ix_curr_histogram_ix_target_block_size_histograms_size_histograms_split_threshold_min_block_size_max_block_types_num_contexts_alphabet_size_/* is_final = *//* Adds the next symbol to the current block type and context. When the
   current block reaches the target size, decides on merging the block. *//* Combine this block with last block. *//* Combine this block with second last block. *//* Create new block. *//* Try merging the set of histograms for the current block type with the
       respective set of histograms for the last and second last block types.
       Decide over the split based on the total reduction of entropy across
       all contexts. *//* Create first block. *//* Does either of three things:
     (1) emits the current block with a new block type;
     (2) emits the current block with the type of the second last block;
     (3) merges the current block with the last block. *//* Clear only current histogram. *//* We have to allocate one more histogram than the maximum number of block
     types for the current histogram when the meta-block is too big. *//* The number of times we merged the current block with the last one. *//* Entropy of the previous two block types. *//* Offset of the histograms of the previous two block types. *//* Offset of the current histogram. *//* The number of symbols in the current histogram. *//* The number of symbols that we want to collect before deciding on whether
     or not to merge the block with a previous one or emit a new block. *//* not owned *//* We merge histograms A and B if
       entropy(A+B) < entropy(A) + entropy(B) + split_threshold_,
     where A is the current histogram and B is the histogram of the last or the
     second last block type. *//* We collect at least this many symbols for each block. *//* Alphabet size of particular block category. *//* Greedy block splitter for one block category (literal, command or distance).
   Gathers histograms for all context buckets. *//* Distribute assignment to all contexts. *//* best_dist_cost = dist_cost; *//* NB: currently unused; uncomment when more param tuning is added. *//* Histogram ids need to fit in one byte. */BlockSplitterAddSymbolLiteralBlockSplitterAddSymbolBlockSplitterBlockSplitterFinishBlockBlockSplitterFinishBlockLiteralself->block_size_self->min_block_size_HistogramLiteral[2]InitBlockSplitterLiteralInitBlockSplitterBROTLI_MAX_NUMBER_OF_BLOCK_TYPES + 1BlockSplitterLiteral/* Adds the next symbol to the current histogram. When the current histogram
   reaches the target size, decides on merging the block. *//* Greedy block splitter for one block category (literal, command or distance).
*/BlockSplitterAddSymbolCommandBlockSplitterFinishBlockCommandHistogramCommand[2]InitBlockSplitterCommandBlockSplitterCommandBlockSplitterAddSymbolDistanceBlockSplitterFinishBlockDistanceHistogramDistance[2]InitBlockSplitterDistanceBlockSplitterDistance/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/static_dict.chas_found_matchl - 9l - 2w.transform != BROTLI_TRANSFORM_UPPERCASE_FIRST'i''n''g'' ''s''t''d''b''y''f''o''r''m''h''e''w''"''>''.''T'',''\n''\t'']''\''':''(''=''l''u''v'is_all_capsdata[0] == ' 'is_space'c'FindMatchLengthWithLimit(dict, data, w.len) == w.lendict[0] >= 'a' && dict[0] <= 'z' && (dict[0] ^ 32) == data[0] && FindMatchLengthWithLimit(&dict[1], &data[1], w.len - 1u) == w.len - 1uDictMatchLengthAddMatchmatches[len]32 - kDictNumBits(32 - kDictNumBits)/* Transforms with prefixes " the " and ".com/" *//* Transforms with prefixes "e ", "s ", ", " and "\xC2\xA0" *//* Transforms " " + kUppercase{First,All} + <suffix> *//* Transforms " " + kUppercase{First,All} + "" *//* Set is_all_caps=0 for BROTLI_TRANSFORM_UPPERCASE_FIRST and
               is_all_caps=1 otherwise (BROTLI_TRANSFORM_UPPERCASE_ALL)
           transform. *//* Transforms " " + BROTLI_TRANSFORM_IDENTITY + <suffix> and
                      "." + BROTLI_TRANSFORM_IDENTITY + <suffix>
        *//* Transforms " " + BROTLI_TRANSFORM_IDENTITY + "" and
                      "." + BROTLI_TRANSFORM_IDENTITY + "" *//* Transforms with prefixes " " and "." *//* Transforms "" + kUppercase{First,All} + <suffix> *//* Transform "" + kUppercase{First,All} + "" *//* Transforms "" + BROTLI_TRANSFORM_IDENTITY + <suffix> *//* Transform "" + BROTLI_TRANSFORM_OMIT_LAST_# + "" (# = 2 .. 9) *//* Transforms "" + BROTLI_TRANSFORM_OMIT_LAST_1 + "" and
                      "" + BROTLI_TRANSFORM_OMIT_LAST_1 + "ing " *//* Transform "" + BROTLI_TRANSFORM_IDENTITY + "" *//* Match against uppercase all transform.
         Note that there are only ASCII uppercase words in the lookup table. *//* Match against uppercase first transform.
         Note that there are only ASCII uppercase words in the lookup table. *//* Match against base dictionary word. *//home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/enc/utf8_util.cBrotliIsMostlyUTF8size_utf8bytes_read11141120x110000(double)size_utf8 > min_fraction * (double)lengthBrotliParseAsUTF80x7FF11141110x10FFFF/* Returns 1 if at least min_fraction of the data is UTF8-encoded.*//* Not UTF8, emit a special symbol above the UTF8-code space *//* 4-byte UFT8 *//* 3-byte UFT8 *//* 2-byte UTF8 *//* ASCII *//* Heuristics for deciding about the UTF8-ness of strings. */min_fractionBROTLI_ENC_UTF8_UTIL_H_/* BROTLI_ENC_UTF8_UTIL_H_ *//* Returns 1 if at least min_fraction of the bytes between pos and
   pos + length in the (data, mask) ring-buffer is UTF8-encoded, otherwise
   returns 0. */ERANGEEDOMEPIPEEMLINKEROFSESPIPEEFBIGETXTBSYENOTTYEMFILEENFILEEISDIRENOTDIRENODEVEXDEVEBUSYENOTBLKEFAULTEACCESENOMEMEAGAINECHILDEBADFENOEXECE2BIGENXIOEIOESRCHEPERM_ASM_GENERIC_ERRNO_BASE_H/* Math result not representable *//* Math argument out of domain of func *//* Broken pipe *//* Too many links *//* Read-only file system *//* Illegal seek *//* No space left on device *//* File too large *//* Text file busy *//* Not a typewriter *//* Too many open files *//* File table overflow *//* Invalid argument *//* Is a directory *//* Not a directory *//* No such device *//* Cross-device link *//* File exists *//* Device or resource busy *//* Block device required *//* Bad address *//* Permission denied *//* Out of memory *//* Try again *//* No child processes *//* Bad file number *//* Exec format error *//* Argument list too long *//* No such device or address *//* I/O error *//* Interrupted system call *//* No such process *//* No such file or directory *//* Operation not permitted *//* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note *//usr/include/asm-generic<asm-generic/errno-base.h>EHWPOISONERFKILLENOTRECOVERABLEEOWNERDEADEKEYREJECTEDEKEYREVOKEDEKEYEXPIREDENOKEYECANCELEDEMEDIUMTYPEENOMEDIUMEDQUOTEREMOTEIOEISNAMENAVAILENOTNAMEUCLEANESTALEEINPROGRESSEALREADYEHOSTUNREACHEHOSTDOWNECONNREFUSEDETIMEDOUTETOOMANYREFSESHUTDOWNENOTCONNEISCONNENOBUFSECONNRESETECONNABORTEDENETRESETENETUNREACHENETDOWNEADDRNOTAVAILEADDRINUSEEAFNOSUPPORTEPFNOSUPPORTEOPNOTSUPPESOCKTNOSUPPORTEPROTONOSUPPORTENOPROTOOPTEPROTOTYPEEMSGSIZEEDESTADDRREQENOTSOCKEUSERSESTRPIPEERESTARTEILSEQELIBEXECELIBMAXELIBSCNELIBBADELIBACCEREMCHGEBADFDENOTUNIQEOVERFLOWEBADMSGEDOTDOTEMULTIHOPEPROTOECOMMESRMNTEADVENOLINKEREMOTEENOPKGENONETENOSRETIMEENODATAENOSTREBFONTEDEADLOCKEDEADLKEBADSLTEBADRQCENOANOEXFULLEBADREBADEEL2HLTENOCSIEUNATCHELNRNGEL3RSTEL3HLTEL2NSYNCECHRNGEIDRMENOMSGEWOULDBLOCKELOOPENOTEMPTYENOSYSENOLCKENAMETOOLONG_ASM_GENERIC_ERRNO_H/* Memory page has hardware error *//* Operation not possible due to RF-kill *//* State not recoverable *//* Owner died *//* for robust mutexes *//* Key was rejected by service *//* Key has been revoked *//* Key has expired *//* Required key not available *//* Operation Canceled *//* Wrong medium type *//* No medium found *//* Quota exceeded *//* Remote I/O error *//* Is a named type file *//* No XENIX semaphores available *//* Not a XENIX named type file *//* Structure needs cleaning *//* Stale file handle *//* Operation now in progress *//* Operation already in progress *//* No route to host *//* Host is down *//* Connection refused *//* Connection timed out *//* Too many references: cannot splice *//* Cannot send after transport endpoint shutdown *//* Transport endpoint is not connected *//* Transport endpoint is already connected *//* No buffer space available *//* Connection reset by peer *//* Software caused connection abort *//* Network dropped connection because of reset *//* Network is unreachable *//* Network is down *//* Cannot assign requested address *//* Address already in use *//* Address family not supported by protocol *//* Protocol family not supported *//* Operation not supported on transport endpoint *//* Socket type not supported *//* Protocol not supported *//* Protocol not available *//* Protocol wrong type for socket *//* Message too long *//* Destination address required *//* Socket operation on non-socket *//* Too many users *//* Streams pipe error *//* Interrupted system call should be restarted *//* Illegal byte sequence *//* Cannot exec a shared library directly *//* Attempting to link in too many shared libraries *//* .lib section in a.out corrupted *//* Accessing a corrupted shared library *//* Can not access a needed shared library *//* Remote address changed *//* File descriptor in bad state *//* Name not unique on network *//* Value too large for defined data type *//* Not a data message *//* RFS specific error *//* Multihop attempted *//* Protocol error *//* Communication error on send *//* Srmount error *//* Advertise error *//* Link has been severed *//* Object is remote *//* Package not installed *//* Machine is not on the network *//* Out of streams resources *//* Timer expired *//* No data available *//* Device not a stream *//* Bad font file format *//* Invalid slot *//* Invalid request code *//* No anode *//* Exchange full *//* Invalid request descriptor *//* Invalid exchange *//* Level 2 halted *//* No CSI structure available *//* Protocol driver not attached *//* Link number out of range *//* Level 3 reset *//* Level 3 halted *//* Level 2 not synchronized *//* Channel number out of range *//* Identifier removed *//* No message of desired type *//* Operation would block *//* Too many symbolic links encountered *//* Directory not empty *//* Invalid system call number *//*
 * This error code is special: arch syscall entry code will return
 * -ENOSYS if users try to call a syscall that doesn't exist.  To keep
 * failures of syscalls that really do exist distinguishable from
 * failures due to attempts to use a nonexistent syscall, syscall
 * implementations should refrain from returning -ENOSYS.
 *//* No record locks available *//* File name too long *//* Resource deadlock would occur */<asm-generic/errno.h>/usr/include/asm<asm/errno.h>/usr/include/linux<linux/errno.h>ENOTSUP_BITS_ERRNO_H!defined _ERRNO_H/* bits/errno.h.  *//* Older Linux headers do not define these constants.  *//* Error constants.  Linux specific version.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/fcntl-linux.hPOSIX_FADV_NOREUSE__POSIX_FADV_NOREUSEPOSIX_FADV_DONTNEED__POSIX_FADV_DONTNEEDPOSIX_FADV_WILLNEEDPOSIX_FADV_SEQUENTIALPOSIX_FADV_RANDOMPOSIX_FADV_NORMALFNDELAYO_NDELAYFNONBLOCKO_NONBLOCKFASYNCO_ASYNCFFSYNCO_FSYNCFAPPENDO_APPENDLOCK_UNLOCK_NBLOCK_EXLOCK_SHF_SHLCKF_EXLCKF_UNLCKF_WRLCKF_RDLCKFD_CLOEXECF_DUPFD_CLOEXEC1030__F_GETOWN_EX__F_SETOWN_EX__F_GETSIG__F_SETSIGF_GETOWN__F_GETOWNF_SETOWN__F_SETOWNF_SETFLF_GETFLF_SETFDF_GETFDF_DUPFDO_RSYNCO_SYNCO_DSYNC__O_DSYNCO_CLOEXEC__O_CLOEXECO_NOFOLLOW__O_NOFOLLOWO_DIRECTORY__O_DIRECTORYF_SETLKWF_SETLKF_GETLK__O_TMPFILE(020000000 | __O_DIRECTORY)010000__O_PATH010000000__O_NOATIME01000000__O_DIRECT0400000200000004000000200000020000040100000400002000O_TRUNC01000O_NOCTTY0400O_EXCL0200O_CREAT0100O_RDWR02O_WRONLY01O_RDONLY00O_ACCMODE0003_FCNTL_H__O_LARGEFILEF_GETLK64defined __USE_POSIX199309 || defined __USE_UNIX98defined __O_RSYNC/* Open file using the file handle.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Map file name to file handle.  *//* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* In-kernel implementation of tee for pipe buffers.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Splice two files together.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Splice address range into a pipe.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Selective file content synch'ing.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Provide kernel hint to read ahead.  *//* Maximum handle size (for now).  *//* File identifier.  *//* File handle structure.  *//* Flags for fallocate.  *//* Pages passed in are a gift.  *//* Expect more data.  *//* Don't block on the pipe splicing
					   (but we may still block on the fd
					   we splice from/to).  *//* Move pages instead of copying.  *//* Flags for SPLICE and VMSPLICE.  *//* SYNC_FILE_RANGE_WRITE_AND_WAIT ensures all pages in the range are
   written to disk before returning.  *//* Wait upon writeout of all pages in
					     the range after performing the
					     write.  *//* Initiate writeout of all those
					     dirty pages in the range which are
					     not presently under writeback.  *//* Wait upon writeout of all pages
					     in the range before performing the
					     write.  *//* Flags for SYNC_FILE_RANGE.  *//* Data will be accessed once.  *//* Don't need these pages.  *//* Will need these pages.  *//* Expect sequential page references.  *//* Expect random page references.  *//* No further special treatment.  *//* Advise to `posix_fadvise'.  *//* Define some more compatibility macros to be backward compatible with
   BSD systems which did not managed to hide these kernel macros.  *//* Hint values for F_{GET,SET}_RW_HINT.  *//* Prevent future writes while
					   mapped.  *//* Prevent writes.  *//* Prevent file from growing.  *//* Prevent file from shrinking.  *//* Prevent further seals from being set.  *//* Types of seals.  *//* ID of owner.  *//* Owner type of ID.  *//* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  *//* Alternative, obsolete name.  *//* Process group.  *//* Process.  *//* Kernel thread.  *//* Owner types.  *//* Don't remove notifier.  *//* File changed attributes.  *//* File renamed.  *//* File removed.  *//* File created.  *//* File modified.  *//* File accessed.  *//* Types of directory notifications that may be requested with F_NOTIFY.  *//* ... Which allows concurrent read & write operations.  *//* ... which allows concurrent write operations.  *//* ... which allows concurrent read operations.  *//* This is a mandatory flock:  *//* Remove lock.  *//* Or'd with one of the above to prevent
				   blocking.  *//* Exclusive lock.  *//* Shared lock.  *//* Operations for BSD flock, also used by the kernel implementation.  *//* or 4 *//* or 3 *//* For old implementation of BSD flock.  *//* Write lock.  *//* Read lock.  *//* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  *//* Actually anything with low bit set goes *//* For F_[GET|SET]FD.  *//* Duplicate file descriptor with
				   close-on-exit set.  *//* Set / get write life time hints.  *//* Get seals for file.  *//* Add seals to file.  *//* Set pipe page size array.  *//* Request notifications on a directory.  *//* Enquire what lease is active.  *//* Set a lease.  *//* Set owner (thread receiving SIGIO).  *//* Get owner (thread receiving SIGIO).  *//* Get number of signal to be sent.  *//* Set number of signal to be sent.  *//* Set owner (process receiving SIGIO).  *//* Get owner (process receiving SIGIO).  *//* Set file status flags.  *//* Get file status flags.  *//* Set file descriptor flags.  *//* Get file descriptor flags.  *//* Duplicate file descriptor.  *//* Values for the second argument to `fcntl'.  *//* Synchronize read operations.  *//* Synchronize data.  *//* For now, Linux has no separate synchronicity options for read
   operations.  We define O_RSYNC therefore as the same as O_SYNC
   since this is a superset.  *//* Atomically create nameless file.  *//* Resolve pathname but do not open file.  *//* Do not set atime.  *//* Direct disk access.  *//* Set close_on_exec.  *//* Do not follow links.  *//* Must be a directory.  *//* open file description locks.

   Usually record locks held by a process are released on *any* close and are
   not inherited across a fork.

   These cmd values will set locks that conflict with process-associated record
   locks, but are "owned" by the opened file description, not the process.
   This means that they are inherited across fork or clone with CLONE_FILES
   like BSD (flock) locks, and they are only released automatically when the
   last reference to the the file description against which they were acquired
   is put. *//* Set record locking info (blocking).  *//* Set record locking info (non-blocking).  *//* Get record locking info.  *//* Set record locking info (non-blocking).*//* Not fcntl.  *//* open/fcntl.  *//* This file contains shared definitions between Linux architectures
   and is included by <bits/fcntl.h> to declare them.  The various
   #ifndef cases allow the architecture specific file to define those
   values with different values.

   A minimal <bits/fcntl.h> contains just:

   struct flock {...}
   #ifdef __USE_LARGEFILE64
   struct flock64 {...}
   #endif
   #include <bits/fcntl-linux.h>
*//* O_*, F_*, FD_* bit values for Linux.
   Copyright (C) 2001-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/fcntl.h<bits/fcntl-linux.h>flockl_pidl_lenl_startl_whencel_typeF_SETLKW64F_SETLK64/* Include generic Linux declarations.  *//* Process holding the lock.  *//* Size of the locked area; zero means until EOF.  *//* Offset where the lock begins.  *//* Where `l_start' is relative to (like `lseek').  *//* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*//* Set record locking info (blocking).	*//* Not necessary, we always have 64-bit offsets.  *//* O_*, F_*, FD_* bit values for Linux/x86.
   Copyright (C) 2001-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/struct_stat.h__syscall_slong_t[3]long[3]__glibc_reservedst_ctimst_mtimst_atimst_blocksst_blksizest_sizest_rdev__pad0st_gidst_uidst_modest_nlinkst_inost_dev_STATBUF_ST_NSEC_STATBUF_ST_RDEV_STATBUF_ST_BLKSIZEst_ctimest_ctim.tv_secst_mtimest_mtim.tv_secst_atimest_atim.tv_sec_BITS_STRUCT_STAT_H!defined _SYS_STAT_H && !defined _FCNTL_Hdefined __x86_64__ || !defined __USE_FILE_OFFSET64defined __x86_64__  || !defined __USE_FILE_OFFSET64/* _BITS_STRUCT_STAT_H  *//* Nanosecond resolution time values are supported.  *//* Tell code we have these members.  *//* __USE_TIME_BITS64  *//* File serial number.		*//* Nsecs of last status change.  *//* Time of last status change.  *//* Nsecs of last modification.  *//* Time of last modification.  *//* Nscecs of last access.  *//* Time of last access.  *//* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  *//* Nr. 512-byte blocks allocated.  *//* Optimal block size for I/O.  *//* Size of file, in bytes.  *//* Device number, if device.  *//* Group ID of the file's group.*//* User ID of the file's owner.	*//* Link count.  *//* File mode.  *//* 32bit file serial number.	*//* File serial number.  *//* Device.  *//* Note stat64 has the same shape as stat for x86-64.  *//* File serial number.	*//* Number 512-byte blocks allocated. *//* Definition for struct stat.
   Copyright (C) 2020-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/stat.h<bits/struct_stat.h>UTIME_OMIT((1l << 30) - 2l)UTIME_NOW((1l << 30) - 1l)__S_IEXEC__S_IWRITE__S_IREAD__S_ISVTX__S_ISGID__S_ISUID__S_TYPEISSHM(buf)((buf)->st_mode - (buf)->st_mode)__S_TYPEISSEM(buf)__S_TYPEISMQ(buf)__S_IFSOCK0140000__S_IFLNK0120000__S_IFIFO0010000__S_IFREG0100000__S_IFBLK0060000__S_IFCHR0020000__S_IFDIR0040000__S_IFMT0170000_BITS_STAT_H/* bits/stat.h *//* Execute by owner.  *//* Write by owner.  *//* Read by owner.  *//* Save swapped text after use (sticky).  *//* Set group ID on execution.  *//* Set user ID on execution.  *//* Protection bits.  *//* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
   they do it by enforcing the correct use of the macros.  *//* Socket.  *//* Symbolic link.  *//* FIFO.  *//* Regular file.  *//* Block device.  *//* Character device.  *//* Directory.  *//* File types.  *//* These bits determine file type.  *//* Encoding of the file mode.  *//* Copyright (C) 1992-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/fcntl.h<bits/stat.h><bits/fcntl.h>posix_fallocateposix_fadviselockfcreatopenatopenfcntlF_TESTF_TLOCKF_LOCKF_ULOCKAT_EACCESSAT_SYMLINK_FOLLOWAT_REMOVEDIRAT_SYMLINK_NOFOLLOWAT_FDCWD-100F_OKX_OKW_OKR_OKS_IRWXO(S_IRWXG >> 3)S_IXOTH(S_IXGRP >> 3)S_IWOTH(S_IWGRP >> 3)S_IROTH(S_IRGRP >> 3)S_IRWXG(S_IRWXU >> 3)S_IXGRP(S_IXUSR >> 3)S_IWGRP(S_IWUSR >> 3)S_IRGRP(S_IRUSR >> 3)S_IRWXU(__S_IREAD|__S_IWRITE|__S_IEXEC)S_IXUSRS_IWUSRS_IRUSRS_ISVTXS_ISGIDS_ISUIDS_IFSOCKS_IFLNKS_IFIFOS_IFREGS_IFBLKS_IFCHRS_IFDIRS_IFMT__OPEN_NEEDS_MODE(oflag)(((oflag) & O_CREAT) != 0 || ((oflag) & __O_TMPFILE) == __O_TMPFILE)(defined __USE_UNIX98 || defined __USE_XOPEN2K8) && defined __S_IFSOCK!defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \__USE_FORTIFY_LEVEL > 0 && defined __fortify_function \/* fcntl.h  *//* Advice the system about the expected behaviour of the application with
   respect to the file associated with FD.  *//* Test a region for other processes locks.  *//* Test and lock a region for exclusive use.  *//* Lock a region for exclusive use.  *//* Unlock a previously locked region.  *//* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.  *//* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  *//* Create and open FILE, with mode MODE.  This takes an `int' MODE
   argument because that is what `mode_t' will be widened to.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Similar to `open' but a relative path name is interpreted relative to
   the directory for which FD is a descriptor.

   NOTE: some other `openat' implementation support additional functionality
   through this interface, especially using the O_XATTR flag.  This is not
   yet supported here.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Open FILE and return a new file descriptor for it, or -1 on error.
   OFLAG determines the type of access used.  If O_CREAT or O_TMPFILE is set
   in OFLAG, the third argument is taken as a `mode_t', the mode of the
   created file.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* __USE_TIME_BITS64 *//* Do the file control operation described by CMD on FD.
   The remaining arguments are interpreted depending on CMD.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Test access permitted for
					   effective IDs, not real IDs.  *//* Apply to the entire subtree.  *//* Allow empty relative pathname.  *//* Suppress terminal automount
					   traversal.  *//* Follow symbolic links.  *//* Remove directory instead of
					   unlinking file.  *//* Do not follow symbolic links.  *//* Special value used to indicate
					   the *at functions should use the
					   current working directory. *//* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EACCESS
   is meaningful only to faccessat, while AT_REMOVEDIR is meaningful only to
   unlinkat.  The two functions do completely different things and therefore,
   the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to
   faccessat would be undefined behavior and thus treating it equivalent to
   AT_EACCESS is valid undefined behavior.  *//* XPG *//* XPG wants the following symbols.   <stdio.h> has the same definitions.  *//* Test for existence.  *//* Test for execute permission.  *//* Test for write permission.  *//* Test for read permission.  *//* Values for the second argument to access.
   These may be OR'd together.  *//* Verbatim from <unistd.h>.  Ugh.  *//* Read, write, and execute by others.  *//* Execute by others.  *//* Write by others.  *//* Read by others.  *//* Read, write, and execute by group.  *//* Execute by group.  *//* Write by group.  *//* Read by group.  *//* Read, write, and execute by owner.  *//* Save swapped text after use (sticky bit).  This is pretty well obsolete.  *//* For XPG all symbols from <sys/stat.h> should also be available.  *//* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
   Earlier POSIX standards permitted any type ending in `_t' to be defined
   by any POSIX header, so we don't conditionalize the definitions here.  *//* Detect if open needs mode as a third argument (or for openat as a fourth
   argument).  *//* Get the definitions of O_*, F_*, FD_*: all the
   numbers and flag bits for `open', `fcntl', et al.  *//* Get __mode_t, __dev_t and __off_t  .*//* This must be early so <bits/fcntl.h> can define types winningly.  *//*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */__offset__advise__cmd__file__gnuc_va_list__GNUC_VA_LIST_STDARG_H_ANSI_STDARG_H_!defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L \_BSD_VA_LISTdefined(__svr4__) || (defined(_SCO_DS) && !defined(__VA_LIST))_VA_LIST___i860___VA_LIST_SCO_DS!defined (_VA_LIST_) || defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__) || defined(WINNT)_VA_LIST_T_H__va_list__!(defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__))/* not _STDARG_H *//* not _ANSI_STDARG_H_ *//* _STDARG_H *//* not __svr4__ *//* not _VA_LIST_, except on certain systems *//* not _VA_LIST_DEFINED *//* not _VA_LIST *//* not _VA_LIST_T_H *//* not __va_list__ *//* The macro __va_list__ is used by BeOS.  *//* The macro _VA_LIST_T_H is used in the Bull dpx2  *//* The macro _VA_LIST is used in SCO Unix 3.2.  *//* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  *//* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  *//* not __svr4__ || _SCO_DS *//* _VA_LIST_ *//* __i860__ *//* SVR4.2 uses _VA_LIST for an internal alias for va_list,
   so we must avoid testing it and setting it here.
   SVR4 uses _VA_LIST as a flag in stdarg.h, but we should
   have no conflict with that.  *//* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  *//* Define va_list, if desired, from __gnuc_va_list. *//* Define the standard macros for the user,
   if this invocation was from the user program.  *//* Define __gnuc_va_list.  *//* not __need___va_list *//*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */__mbstate_t__wchb__wch____mbstate_t_definedunsigned int/* Value so far.  *//* Conversion state information.  *//* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */<bits/types/__mbstate_t.h>__fpos_t_G_fpos_t_____fpos_t_defined/* The tag name of this struct is _G_fpos_t to preserve historic
   C++ mangled names for functions taking fpos_t arguments.
   That name should not be used in new code.  */__fpos64_t_G_fpos64_t_____fpos64_t_defined/* The tag name of this struct is _G_fpos64_t to preserve historic
   C++ mangled names for functions taking fpos_t and/or fpos64_t
   arguments.  That name should not be used in new code.  */__FILE____FILE_defined_IO_FILEFILE__FILE_defined/* The opaque type of streams.  This is the definition used elsewhere.  */_IO_wide_data_IO_codecvt_IO_lock_t_IO_markersizeof (int)15 * sizeof (int)4 * sizeof (void *)15 * sizeof (int) - 4 * sizeof (void *)sizeof (size_t)15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)_unused2_mode__pad5_freeres_buf_freeres_list_IO_wide_data *_wide_data_IO_codecvt *_codecvt_offset_IO_lock_t *_lockchar[1]_shortbuf_vtable_offset_cur_column_old_offset_flags2_fileno_chain_IO_marker *_markers_IO_save_end_IO_backup_base_IO_save_base_IO_buf_end_IO_buf_base_IO_write_end_IO_write_ptr_IO_write_base_IO_read_base_IO_read_end_IO_read_ptr_flags_IO_USER_LOCK__ferror_unlocked_body(_fp)(((_fp)->_flags & _IO_ERR_SEEN) != 0)_IO_ERR_SEEN__feof_unlocked_body(_fp)(((_fp)->_flags & _IO_EOF_SEEN) != 0)_IO_EOF_SEEN__putc_unlocked_body(_ch,_fp)(__glibc_unlikely ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) ? __overflow (_fp, (unsigned char) (_ch)) : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))__getc_unlocked_body(_fp)(__glibc_unlikely ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end) ? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)__struct_FILE_defineddefined _IO_USE_OLD_IO_FILE && !defined _LIBCdefined _IO_lock_t_defined && !defined _LIBC_IO_lock_t_defined_IO_USE_OLD_IO_FILE/* Many more flag bits are defined internally.  *//* These macros are used by bits/stdio.h and internal headers.  *//* Make sure we don't get into trouble again.  *//* Wide character stream stuff.  *//* 1+column number of pbase(); 0 is unknown. *//* This used to be _offset but it's too small.  *//* Pointer to end of non-current get area. *//* Pointer to first valid character of backup area *//* Pointer to start of non-current get area. *//* The following fields are used to support backing up and undo. *//* End of reserve area. *//* Start of reserve area. *//* End of put area. *//* Current put pointer. *//* Start of put area. *//* Start of putback+get area. *//* End of get area. *//* Current read pointer *//* The following pointers correspond to the C++ streambuf protocol. *//* High-order word is _IO_MAGIC; rest is flags. *//* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  *//* During the build of glibc itself, _IO_lock_t will already have been
   defined by internal headers.  *//* Caution: The contents of this file are not part of the official
   stdio.h API.  However, much of it is part of the official *binary*
   interface, and therefore cannot be changed.  */FOPEN_MAXL_ctermidFILENAME_MAXTMP_MAX238328_BITS_STDIO_LIM_H!defined __USE_XOPEN2K || defined __USE_GNU/* bits/stdio_lim.h *//* Copyright (C) 1994-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */_G_fpos_t */usr/include/sys/stat.hfutimensconst timespec[2]timespec[2]utimensatmkfifoatmkfifomknodatmknodmkdiratmkdirumaskfchmodatfchmodlchmodchmodlstatstat *stat *__restrict__fstatatfstatS_BLKSIZEDEFFILEMODE(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)ALLPERMS(S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)ACCESSPERMS(S_IRWXU|S_IRWXG|S_IRWXO)S_IEXECS_IWRITES_IREADS_TYPEISSHM(buf)S_TYPEISSEM(buf)S_TYPEISMQ(buf)S_ISSOCK(mode)__S_ISTYPE((mode), __S_IFSOCK)S_ISLNK(mode)__S_ISTYPE((mode), __S_IFLNK)S_ISFIFO(mode)__S_ISTYPE((mode), __S_IFIFO)S_ISREG(mode)__S_ISTYPE((mode), __S_IFREG)S_ISBLK(mode)__S_ISTYPE((mode), __S_IFBLK)S_ISCHR(mode)__S_ISTYPE((mode), __S_IFCHR)S_ISDIR(mode)__S_ISTYPE((mode), __S_IFDIR)__S_ISTYPE(mode,mask)(((mode) & __S_IFMT) == (mask))_SYS_STAT_Hdefined __USE_XOPEN || defined __USE_XOPEN2K(defined __USE_MISC || defined __USE_XOPEN_EXTENDED) \defined __USE_MISC && !defined __S_IFLNK(defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K) \defined __USE_XOPEN2Kdefined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2Kdefined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED/* sys/stat.h  *//* Set file access and modification times of the file associated with FD.  *//* Set file access and modification times relative to directory file
   descriptor.  *//* Like mkfifo, create a new FIFO with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  *//* Create a new FIFO named PATH, with permission bits MODE.  *//* Like mknod, create a new device file with permission bits MODE and
   device number DEV.  But interpret relative PATH names relative to
   the directory associated with FD.  *//* Create a device file named PATH, with permission and special bits MODE
   and device number DEV (which can be constructed from major and minor
   device numbers with the `makedev' macro above).  *//* Like mkdir, create a new directory with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  *//* Create a new directory named PATH, with permission bits MODE.  *//* Get the current `umask' value without changing it.
   This function is only available under the GNU Hurd.  *//* Set the file creation mask of the current process to MASK,
   and return the old creation mask.  *//* Use ATFILE.  *//* Set file access permissions of FILE relative to
   the directory FD is open on.  *//* Set file access permissions of the file FD is open on to MODE.  *//* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects the link itself
   rather than its target.  *//* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects its target instead.  *//* Get file attributes about FILE and put them in BUF.
   If FILE is a symbolic link, do not follow it.  *//* Similar to stat, get the attributes for FILE and put them in BUF.
   Relative path names are interpreted relative to FD unless FD is
   AT_FDCWD.  *//* Get file attributes for the file, device, pipe, or socket
   that file descriptor FD is open on and put them in BUF.  *//* Get file attributes for FILE and put them in BUF.  *//* Block size for `st_blocks'.  *//* 0666*//* 07777 *//* 0777 *//* Macros for common mode bit masks.  *//* These are from POSIX.1b.  If the objects are not implemented using separate
   distinct file types, the macros always will evaluate to zero.  Unlike the
   other S_* macros the following three take a pointer to a `struct stat'
   object as the argument.  *//* Test macros for file types.	*//* Unix98 *//* X/Open *//* The Single Unix specification says that some more types are
   available here.  *//* For __mode_t and __dev_t.  *//*
 *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
 */__times__path__dev__flagtmtm_zonetm_gmtofftm_isdsttm_ydaytm_wdaytm_yeartm_montm_mdaytm_hourtm_mintm_sec__struct_tm_defined/* Timezone abbreviation.  *//* Seconds east of UTC.  *//* DST.		[-1/0/1]*//* Days in year.[0-365]	*//* Day of week.	[0-6] *//* Year	- 1900.  *//* Month.	[0-11] *//* Day.		[1-31] *//* Hours.	[0-23] *//* Minutes.	[0-59] *//* Seconds.	[0-60] (1 leap second) *//* ISO C `broken-down time' structure.  */itimerspecit_valueit_interval__itimerspec_defined/* POSIX.1b structure for timer start values and intervals.  *//usr/include/bits/posix_opt.h_POSIX_TYPED_MEMORY_OBJECTS_POSIX_TRACE_LOG_POSIX_TRACE_INHERIT_POSIX_TRACE_EVENT_FILTER_POSIX_TRACE_POSIX_THREAD_SPORADIC_SERVER_POSIX_SPORADIC_SERVER_POSIX2_CHAR_TERM_POSIX_RAW_SOCKETS_POSIX_IPV6_POSIX_ADVISORY_INFO_POSIX_CLOCK_SELECTION_POSIX_MONOTONIC_CLOCK_POSIX_THREAD_PROCESS_SHARED_POSIX_MESSAGE_PASSING_POSIX_BARRIERS_POSIX_TIMERS_POSIX_SPAWN_POSIX_SPIN_LOCKS_POSIX_TIMEOUTS_POSIX_SHELL_POSIX_READER_WRITER_LOCKS_POSIX_REGEXP_POSIX_THREAD_CPUTIME_POSIX_CPUTIME_POSIX_SHARED_MEMORY_OBJECTS_LFS64_STDIO_LFS64_LARGEFILE_LFS_LARGEFILE_LFS64_ASYNCHRONOUS_IO_POSIX_PRIORITIZED_IO_LFS_ASYNCHRONOUS_IO_POSIX_ASYNC_IO_POSIX_ASYNCHRONOUS_IO_POSIX_REALTIME_SIGNALS_POSIX_SEMAPHORES_POSIX_THREAD_ROBUST_PRIO_PROTECT_POSIX_THREAD_ROBUST_PRIO_INHERIT_POSIX_THREAD_PRIO_PROTECT_POSIX_THREAD_PRIO_INHERIT_POSIX_THREAD_ATTR_STACKADDR_POSIX_THREAD_ATTR_STACKSIZE_POSIX_THREAD_PRIORITY_SCHEDULING_POSIX_THREAD_SAFE_FUNCTIONS_POSIX_REENTRANT_FUNCTIONS_POSIX_THREADS_XOPEN_SHM_XOPEN_REALTIME_THREADS_XOPEN_REALTIME_POSIX_NO_TRUNC_POSIX_VDISABLE'\0'_POSIX_CHOWN_RESTRICTED_POSIX_MEMORY_PROTECTION_POSIX_MEMLOCK_RANGE_POSIX_MEMLOCK_POSIX_MAPPED_FILES_POSIX_FSYNC_POSIX_SYNCHRONIZED_IO_POSIX_PRIORITY_SCHEDULING_POSIX_SAVED_IDS_POSIX_JOB_CONTROL_BITS_POSIX_OPT_H/* bits/posix_opt.h *//* Typed memory objects are not available.  *//* trace.h is not available.  *//* Neither process nor thread sporadic server interfaces is available.  *//* We have at least one terminal.  *//* Raw socket support is available.  *//* IPv6 support is available.  *//* Advisory information interfaces are available.  *//* The clock selection interfaces are available.  *//* The monotonic clock might be available.  *//* Thread process-shared synchronization is supported.  *//* POSIX message queues are available.  *//* The barrier functions are available.  *//* We have POSIX timers.  *//* The `spawn' function family is supported.  *//* We support spinlocks.  *//* We support the Timeouts option.  *//* We have a POSIX shell.  *//* Reader/Writer locks are available.  *//* GNU libc provides regular expression handling.  *//* Clock support in threads must be also checked at runtime.  *//* CPU-time clocks support needs to be checked at runtime.  *//* POSIX shared memory objects are implemented.  *//* The rest of the LFS is also available.  *//* The LFS support in asynchronous I/O is also available.  *//* Support for prioritization is also available.  *//* Alternative name for Unix98.  *//* We support asynchronous I/O.  *//* Real-time signals are supported.  *//* We support POSIX.1b semaphores.  *//* We do not support priority protection for robust mutexes.  *//* We support priority inheritence for robust mutexes.  *//* We support priority protection, though only for non-robust
   mutexes.  *//* We support priority inheritence.  *//* We support user-defined stacks.  *//* We support user-defined stack sizes.  *//* We provide priority scheduling for threads.  *//* We have the reentrant functions described in POSIX.  *//* Tell we have POSIX threads.  *//* XPG4.2 shared memory is supported.  *//* X/Open thread realtime support is available.  *//* X/Open realtime support is available.  *//* Filenames are not silently truncated.  *//* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  *//* Some filesystems allow all users to change file ownership.  *//* Setting of memory protections is supported.  *//* Locking of ranges of memory is supported.  *//* Locking of all memory is supported.  *//* Mapping of files to memory is supported.  *//* The fsync function is present.  *//* Synchronizing file data is supported.  *//* Priority scheduling is not supported with the correct semantics,
   but GNU/Linux applications expect that the corresponding interfaces
   are available, even though the semantics do not meet the POSIX
   requirements.  See glibc bug 14829.  *//* Processes have a saved set-user-ID and a saved set-group-ID.  *//* Job control is supported.  *//* Define POSIX options for Linux.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <https://www.gnu.org/licenses/>.  *//usr/include/bits/environments.h__LP64_OFF64_LDFLAGS"-m64"__LP64_OFF64_CFLAGS__ILP32_OFFBIG_LDFLAGS"-m32"__ILP32_OFFBIG_CFLAGS"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"__ILP32_OFF32_LDFLAGS__ILP32_OFF32_CFLAGS_XBS5_LP64_OFF64_POSIX_V6_LP64_OFF64_POSIX_V7_LP64_OFF64_XBS5_LPBIG_OFFBIG_POSIX_V6_LPBIG_OFFBIG_POSIX_V7_LPBIG_OFFBIG_UNISTD_H__WORDSIZE == 64defined __x86_64__ && defined __ILP32__/* __WORDSIZE == 32 *//* Environments with 64-bit wide pointers can be provided,
   so these macros aren't defined:
   # undef _POSIX_V7_LP64_OFF64
   # undef _POSIX_V7_LPBIG_OFFBIG
   # undef _POSIX_V6_LP64_OFF64
   # undef _POSIX_V6_LPBIG_OFFBIG
   # undef _XBS5_LP64_OFF64
   # undef _XBS5_LPBIG_OFFBIG
   and sysconf tests for it at runtime.  *//* We optionally provide an environment with the above size but an 64-bit
   side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  *//* -m32 has 32-bit wide `off_t'.  *//* We have 32-bit wide `int', `long int' and pointers and all platforms
   support LFS.  -mx32 has 64-bit wide `off_t'.  *//* By default we have 64-bit wide `long int', pointers and `off_t'.  *//* We also have no use (for now) for an environment with bigger pointers
   and offsets.  *//* Environments with 32-bit wide pointers are optionally provided.
   Therefore following macros aren't defined:
   # undef _POSIX_V7_ILP32_OFF32
   # undef _POSIX_V7_ILP32_OFFBIG
   # undef _POSIX_V6_ILP32_OFF32
   # undef _POSIX_V6_ILP32_OFFBIG
   # undef _XBS5_ILP32_OFF32
   # undef _XBS5_ILP32_OFFBIG
   and users need to check at runtime.  *//* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*//* Copyright (C) 1999-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/confname.h_CS_PATH_CS_V6_WIDTH_RESTRICTED_ENVS_CS_GNU_LIBC_VERSION_CS_GNU_LIBPTHREAD_VERSION_CS_V5_WIDTH_RESTRICTED_ENVS_CS_V7_WIDTH_RESTRICTED_ENVS_CS_LFS_CFLAGS1000_CS_LFS_LDFLAGS1001_CS_LFS_LIBS1002_CS_LFS_LINTFLAGS1003_CS_LFS64_CFLAGS1004_CS_LFS64_LDFLAGS1005_CS_LFS64_LIBS1006_CS_LFS64_LINTFLAGS1007_CS_XBS5_ILP32_OFF32_CFLAGS1100_CS_XBS5_ILP32_OFF32_LDFLAGS1101_CS_XBS5_ILP32_OFF32_LIBS1102_CS_XBS5_ILP32_OFF32_LINTFLAGS1103_CS_XBS5_ILP32_OFFBIG_CFLAGS1104_CS_XBS5_ILP32_OFFBIG_LDFLAGS1105_CS_XBS5_ILP32_OFFBIG_LIBS1106_CS_XBS5_ILP32_OFFBIG_LINTFLAGS1107_CS_XBS5_LP64_OFF64_CFLAGS1108_CS_XBS5_LP64_OFF64_LDFLAGS1109_CS_XBS5_LP64_OFF64_LIBS1110_CS_XBS5_LP64_OFF64_LINTFLAGS1111_CS_XBS5_LPBIG_OFFBIG_CFLAGS1112_CS_XBS5_LPBIG_OFFBIG_LDFLAGS1113_CS_XBS5_LPBIG_OFFBIG_LIBS1114_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS1115_CS_POSIX_V6_ILP32_OFF32_CFLAGS1116_CS_POSIX_V6_ILP32_OFF32_LDFLAGS1117_CS_POSIX_V6_ILP32_OFF32_LIBS1118_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS1119_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS1120_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS1121_CS_POSIX_V6_ILP32_OFFBIG_LIBS1122_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS1123_CS_POSIX_V6_LP64_OFF64_CFLAGS1124_CS_POSIX_V6_LP64_OFF64_LDFLAGS1125_CS_POSIX_V6_LP64_OFF64_LIBS1126_CS_POSIX_V6_LP64_OFF64_LINTFLAGS1127_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS1128_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS1129_CS_POSIX_V6_LPBIG_OFFBIG_LIBS1130_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS1131_CS_POSIX_V7_ILP32_OFF32_CFLAGS1132_CS_POSIX_V7_ILP32_OFF32_LDFLAGS1133_CS_POSIX_V7_ILP32_OFF32_LIBS1134_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS1135_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS1136_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS1137_CS_POSIX_V7_ILP32_OFFBIG_LIBS1138_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS1139_CS_POSIX_V7_LP64_OFF64_CFLAGS1140_CS_POSIX_V7_LP64_OFF64_LDFLAGS1141_CS_POSIX_V7_LP64_OFF64_LIBS1142_CS_POSIX_V7_LP64_OFF64_LINTFLAGS1143_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS1144_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS1145_CS_POSIX_V7_LPBIG_OFFBIG_LIBS1146_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS1147_CS_V6_ENV1148_CS_V7_ENV1149_SC_ARG_MAX_SC_CHILD_MAX_SC_CLK_TCK_SC_NGROUPS_MAX_SC_OPEN_MAX_SC_STREAM_MAX_SC_TZNAME_MAX_SC_JOB_CONTROL_SC_SAVED_IDS_SC_REALTIME_SIGNALS_SC_PRIORITY_SCHEDULING_SC_TIMERS_SC_ASYNCHRONOUS_IO_SC_PRIORITIZED_IO_SC_SYNCHRONIZED_IO_SC_FSYNC_SC_MAPPED_FILES_SC_MEMLOCK_SC_MEMLOCK_RANGE_SC_MEMORY_PROTECTION_SC_MESSAGE_PASSING_SC_SEMAPHORES_SC_SHARED_MEMORY_OBJECTS_SC_AIO_LISTIO_MAX_SC_AIO_MAX_SC_AIO_PRIO_DELTA_MAX_SC_DELAYTIMER_MAX_SC_MQ_OPEN_MAX_SC_MQ_PRIO_MAX_SC_VERSION_SC_PAGESIZE_SC_RTSIG_MAX_SC_SEM_NSEMS_MAX_SC_SEM_VALUE_MAX_SC_SIGQUEUE_MAX_SC_TIMER_MAX_SC_BC_BASE_MAX_SC_BC_DIM_MAX_SC_BC_SCALE_MAX_SC_BC_STRING_MAX_SC_COLL_WEIGHTS_MAX_SC_EQUIV_CLASS_MAX_SC_EXPR_NEST_MAX_SC_LINE_MAX_SC_RE_DUP_MAX_SC_CHARCLASS_NAME_MAX_SC_2_VERSION_SC_2_C_BIND_SC_2_C_DEV_SC_2_FORT_DEV_SC_2_FORT_RUN_SC_2_SW_DEV_SC_2_LOCALEDEF_SC_PII_SC_PII_XTI_SC_PII_SOCKET_SC_PII_INTERNET_SC_PII_OSI_SC_POLL_SC_SELECT_SC_UIO_MAXIOV_SC_IOV_MAX_SC_PII_INTERNET_STREAM_SC_PII_INTERNET_DGRAM_SC_PII_OSI_COTS_SC_PII_OSI_CLTS_SC_PII_OSI_M_SC_T_IOV_MAX_SC_THREADS_SC_THREAD_SAFE_FUNCTIONS_SC_GETGR_R_SIZE_MAX_SC_GETPW_R_SIZE_MAX_SC_LOGIN_NAME_MAX_SC_TTY_NAME_MAX_SC_THREAD_DESTRUCTOR_ITERATIONS_SC_THREAD_KEYS_MAX_SC_THREAD_STACK_MIN_SC_THREAD_THREADS_MAX_SC_THREAD_ATTR_STACKADDR_SC_THREAD_ATTR_STACKSIZE_SC_THREAD_PRIORITY_SCHEDULING_SC_THREAD_PRIO_INHERIT_SC_THREAD_PRIO_PROTECT_SC_THREAD_PROCESS_SHARED_SC_NPROCESSORS_CONF_SC_NPROCESSORS_ONLN_SC_PHYS_PAGES_SC_AVPHYS_PAGES_SC_ATEXIT_MAX_SC_PASS_MAX_SC_XOPEN_VERSION_SC_XOPEN_XCU_VERSION_SC_XOPEN_UNIX_SC_XOPEN_CRYPT_SC_XOPEN_ENH_I18N_SC_XOPEN_SHM_SC_2_CHAR_TERM_SC_2_C_VERSION_SC_2_UPE_SC_XOPEN_XPG2_SC_XOPEN_XPG3_SC_XOPEN_XPG4_SC_CHAR_BIT_SC_CHAR_MAX_SC_CHAR_MIN_SC_INT_MAX_SC_INT_MIN_SC_LONG_BIT_SC_WORD_BIT_SC_MB_LEN_MAX_SC_NZERO_SC_SSIZE_MAX_SC_SCHAR_MAX_SC_SCHAR_MIN_SC_SHRT_MAX_SC_SHRT_MIN_SC_UCHAR_MAX_SC_UINT_MAX_SC_ULONG_MAX_SC_USHRT_MAX_SC_NL_ARGMAX_SC_NL_LANGMAX_SC_NL_MSGMAX_SC_NL_NMAX_SC_NL_SETMAX_SC_NL_TEXTMAX_SC_XBS5_ILP32_OFF32_SC_XBS5_ILP32_OFFBIG_SC_XBS5_LP64_OFF64_SC_XBS5_LPBIG_OFFBIG_SC_XOPEN_LEGACY_SC_XOPEN_REALTIME_SC_XOPEN_REALTIME_THREADS_SC_ADVISORY_INFO_SC_BARRIERS_SC_BASE_SC_C_LANG_SUPPORT_SC_C_LANG_SUPPORT_R_SC_CLOCK_SELECTION_SC_CPUTIME_SC_THREAD_CPUTIME_SC_DEVICE_IO_SC_DEVICE_SPECIFIC_SC_DEVICE_SPECIFIC_R_SC_FD_MGMT_SC_FIFO_SC_PIPE_SC_FILE_ATTRIBUTES_SC_FILE_LOCKING_SC_FILE_SYSTEM_SC_MONOTONIC_CLOCK_SC_MULTI_PROCESS_SC_SINGLE_PROCESS_SC_NETWORKING_SC_READER_WRITER_LOCKS_SC_SPIN_LOCKS_SC_REGEXP_SC_REGEX_VERSION_SC_SHELL_SC_SIGNALS_SC_SPAWN_SC_SPORADIC_SERVER_SC_THREAD_SPORADIC_SERVER_SC_SYSTEM_DATABASE_SC_SYSTEM_DATABASE_R_SC_TIMEOUTS_SC_TYPED_MEMORY_OBJECTS_SC_USER_GROUPS_SC_USER_GROUPS_R_SC_2_PBS_SC_2_PBS_ACCOUNTING_SC_2_PBS_LOCATE_SC_2_PBS_MESSAGE_SC_2_PBS_TRACK_SC_SYMLOOP_MAX_SC_STREAMS_SC_2_PBS_CHECKPOINT_SC_V6_ILP32_OFF32_SC_V6_ILP32_OFFBIG_SC_V6_LP64_OFF64_SC_V6_LPBIG_OFFBIG_SC_HOST_NAME_MAX_SC_TRACE_SC_TRACE_EVENT_FILTER_SC_TRACE_INHERIT_SC_TRACE_LOG_SC_LEVEL1_ICACHE_SIZE_SC_LEVEL1_ICACHE_ASSOC_SC_LEVEL1_ICACHE_LINESIZE_SC_LEVEL1_DCACHE_SIZE_SC_LEVEL1_DCACHE_ASSOC_SC_LEVEL1_DCACHE_LINESIZE_SC_LEVEL2_CACHE_SIZE_SC_LEVEL2_CACHE_ASSOC_SC_LEVEL2_CACHE_LINESIZE_SC_LEVEL3_CACHE_SIZE_SC_LEVEL3_CACHE_ASSOC_SC_LEVEL3_CACHE_LINESIZE_SC_LEVEL4_CACHE_SIZE_SC_LEVEL4_CACHE_ASSOC_SC_LEVEL4_CACHE_LINESIZE_SC_IPV6_SC_RAW_SOCKETS_SC_V7_ILP32_OFF32_SC_V7_ILP32_OFFBIG_SC_V7_LP64_OFF64_SC_V7_LPBIG_OFFBIG_SC_SS_REPL_MAX_SC_TRACE_EVENT_NAME_MAX_SC_TRACE_NAME_MAX_SC_TRACE_SYS_MAX_SC_TRACE_USER_EVENT_MAX_SC_XOPEN_STREAMS_SC_THREAD_ROBUST_PRIO_INHERIT_SC_THREAD_ROBUST_PRIO_PROTECT_SC_MINSIGSTKSZ_SC_SIGSTKSZ_PC_LINK_MAX_PC_MAX_CANON_PC_MAX_INPUT_PC_NAME_MAX_PC_PATH_MAX_PC_PIPE_BUF_PC_CHOWN_RESTRICTED_PC_NO_TRUNC_PC_VDISABLE_PC_SYNC_IO_PC_ASYNC_IO_PC_PRIO_IO_PC_SOCK_MAXBUF_PC_FILESIZEBITS_PC_REC_INCR_XFER_SIZE_PC_REC_MAX_XFER_SIZE_PC_REC_MIN_XFER_SIZE_PC_REC_XFER_ALIGN_PC_ALLOC_SIZE_MIN_PC_SYMLINK_MAX_PC_2_SYMLINKS_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS_SC_PAGE_SIZE/* The default search path.  *//* Values for the NAME argument to `confstr'.  *//* Leave room here, maybe we need a few more cache levels some day.  *//* Values according to POSIX 1003.1c (POSIX threads).  *//* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  *//* Values for the argument to `sysconf'.  *//* Values for the NAME argument to `pathconf' and `fpathconf'.  *//* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/getopt_core.hgetoptoptoptopterroptindoptarg_GETOPT_CORE_H/* getopt_core.h *//* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, 'optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in 'optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU 'getopt'.

   The argument '--' causes premature termination of argument
   scanning, explicitly telling 'getopt' that there are no more
   options.

   If OPTS begins with '-', then non-option arguments are treated as
   arguments to the option '\1'.  This behavior is specific to the GNU
   'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in
   the environment, then do not permute arguments.

   For standards compliance, the 'argv' argument has the type
   char *const *, but this is inaccurate; if argument permutation is
   enabled, the argv array (not the strings it points to) must be
   writable.  *//* Set to an option character which was unrecognized.  *//* Callers store zero here to inhibit the error message 'getopt' prints
   for unrecognized options.  *//* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to 'getopt'.

   On entry to 'getopt', zero means this is the first call; initialize.

   When 'getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, 'optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  *//* For communication from 'getopt' to the caller.
   When 'getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when 'ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  *//* This header should not be used directly; include getopt.h or
   unistd.h instead.  Unlike most bits headers, it does not have
   a protective #error, because the guard macro for getopt.h in
   gnulib is not fixed.  *//* Declarations for getopt (basic, portable features only).
   Copyright (C) 1989-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library and is also part of gnulib.
   Patches to this file should be submitted to both projects.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */___argc___argv__shortopts/usr/include/bits/getopt_posix.h<bits/getopt_core.h>_GETOPT_POSIX_H!defined _UNISTD_H && !defined _STDIO_Hdefined __USE_POSIX2 && !defined __USE_POSIX_IMPLICITLY \/* getopt_posix.h *//* GNU getopt has more functionality than POSIX getopt.  When we are
   explicitly conforming to POSIX and not GNU, and getopt.h (which is
   not part of POSIX) has not been included, the extra functionality
   is disabled.  *//* Declarations for getopt (POSIX compatibility shim).
   Copyright (C) 1989-2022 Free Software Foundation, Inc.
   Unlike the bulk of the getopt implementation, this file is NOT part
   of gnulib.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/unistd_ext.h__has_include__has_include ("linux/close_range.h")CLOSE_RANGE_UNSHARECLOSE_RANGE_CLOEXEC/* __USE_GNU  *//* Set the FD_CLOEXEC bit instead of closing the file descriptor.  *//* Unshare the file descriptor table before closing file descriptors.  *//* Return the kernel thread ID (TID) of the current thread.  The
   returned value is not subject to caching.  Most Linux system calls
   accept a TID in place of a PID.  Using the TID to change properties
   of a thread that has been created using pthread_create can lead to
   undefined behavior (comparable to manipulating file descriptors
   directly that have not been created explicitly).  Note that a TID
   uniquely identifies a thread only while this thread is running; a
   TID can be reused once a thread has exited, even if the thread is
   not detached and has not been joined.  *//* System-specific extensions of <unistd.h>, Linux version.
   Copyright (C) 2019-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/unistd.h<bits/unistd_ext.h><bits/getopt_posix.h><bits/confname.h><bits/environments.h><bits/posix_opt.h>getentropycryptfdatasyncsyscallsbrkbrkftruncatetruncategetdtablesizegetpagesizegethostidfsyncgetpasschrootdaemonsetusershellendusershellgetusershellacctprofilrevokevhangupsetdomainnamegetdomainnamesethostidsethostnamegethostnamesetlogingetlogin_rgetlogintcsetpgrptcgetpgrprmdirunlinkatunlinkreadlinkatsymlinkatreadlinksymlinklinkatttyslotisattyttyname_rttynamevforkforksetegidsetregidsetgidseteuidsetreuidsetuidgetgroups__gid_t[]getegidgetgidgeteuidgetuidgetsidsetsidsetpgrpsetpgidgetpgid__getpgidgetpgrpgetppidgetpidconfstrsysconffpathconfpathconf_exitniceexeclpexecvpchar *const[]char *[]execlexecleexecvfexecveexecvedup2dupgetwdgetcwdfchdirchdirfchownatlchownfchownchownpauseusleepualarmsleepalarmpipeint[2]pwritepreadwritereadclosefromcloselseekfaccessatsocklen_t__environL_XTNDL_INCRL_SET__socklen_t_definedSTDERR_FILENOSTDOUT_FILENOSTDIN_FILENO_XOPEN_LEGACY_XOPEN_ENH_I18N_XOPEN_UNIX_XOPEN_XPG4_XOPEN_XPG3_XOPEN_XPG2_XOPEN_XCU_VERSION_XOPEN_VERSION_POSIX2_LOCALEDEF__POSIX2_THIS_VERSION_POSIX2_SW_DEV_POSIX2_C_DEV_POSIX2_C_BIND_POSIX2_C_VERSION_POSIX2_VERSION_POSIX_VERSIONdefined __USE_POSIX199506defined __USE_POSIX199309defined __USE_UNIX98__intptr_t_defineddefined __USE_MISC && !defined L_SETdefined __USE_MISCdefined __USE_MISC || !defined __USE_XOPEN2Kdefined __USE_POSIX199309 \(defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCKdefined __USE_XOPEN && !defined __USE_XOPEN2Kdefined __USE_UNIX98 && !defined __USE_XOPEN2K(__write_only__, 2, 1)(__write_only__, 3, 4)(__read_only__, 2, 3)/* unistd.h  *//* System-specific extensions.  *//* Close all file descriptors in the range FD up to MAX_FD.  The flag FLAGS
   are define by the CLOSE_RANGE prefix.  This function behaves like close
   on the range and gaps where the file descriptor is invalid or errors
   encountered while closing file descriptors are ignored.   Returns 0 on
   successor or -1 for failure (and sets errno accordingly).  *//* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
   success or -1 on error.  *//* Unix98 requires this function to be declared here.  In other
   standards it is in <pthread.h>.  *//* Prior to Issue 6, the Single Unix Specification required these
   prototypes to appear in this header.  They are also found in
   <stdio.h>.  *//* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  *//* One-way hash PHRASE, returning a string suitable for storage in the
   user database.  SALT selects the one-way function to use, and
   ensures that no two users' hashes are the same, even if they use
   the same passphrase.  The return value points to static storage
   which will be overwritten by the next call to crypt.  *//* Use POSIX199309 *//* Synchronize at least the data part of a file with the underlying
   media.  *//* Copy LENGTH bytes from INFD to OUTFD.  *//* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  *//* Use misc and F_LOCK not already defined.  *//* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  *//* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  *//* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  *//* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  *//* Use POSIX.1b || X/Open Unix || XPG6.  *//* Truncate the file FD is open on to LENGTH bytes.  *//* Use X/Open Unix || POSIX 2008.  *//* Truncate FILE to LENGTH bytes.  *//* Use misc || X/Open Unix.  *//* Return the maximum number of file descriptors
   the current process could possibly have.  *//* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  *//* Make all changes done to all files actually appear on disk.  *//* Return identifier for the current host.  *//* Make all changes done to all files on the file system associated
   with FD actually appear on disk.  *//* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Use misc || X/Open.  *//* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  *//* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  *//* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  *//* Rewind and re-read the file.  *//* Discard cached info.  *//* Successive calls return the shells listed in `/etc/shells'.  *//* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  *//* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  *//* Revoke the access of all descriptors currently open on FILE.  *//* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  *//* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  *//* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  *//* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  *//* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  *//* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  *//* Set the login name returned by `getlogin'.  *//* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Set the foreground process group ID of FD set PGRP_ID.  *//* Return the foreground process group ID of FD.  *//* Remove the directory PATH.  *//* Remove the link NAME relative to FD.  *//* Remove the link NAME.  *//* Like readlink but a relative PATH is interpreted relative to FD.  *//* Like symlink but a relative path in TO is interpreted relative to TOFD.  *//* Use POSIX.1-2001.  *//* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  *//* Make a symbolic link to FROM named TO.  *//* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  *//* Make a link to FROM named TO.  *//* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  *//* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  *//* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  *//* This is similar to fork, however it does not run the atfork handlers
   neither reinitialize any internal locks in multithread case.
   Different than fork, _Fork is async-signal-safe.  *//* Use misc or XPG < 7. *//* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  *//* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  *//* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  *//* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  *//* Set the effective group ID of the calling process to GID. X  O    