/* Set the effective group ID of the calling process to GID.  *//* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  *//* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  *//* Set the effective user ID of the calling process to UID.  *//* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  *//* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  *//* Return nonzero iff the calling process is in group GID.  *//* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  *//* Get the effective group ID of the calling process.  *//* Get the real group ID of the calling process.  *//* Get the effective user ID of the calling process.  *//* Get the real user ID of the calling process.  *//* Return the session ID of the given process.  *//* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  *//* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  *//* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   GNU provides the POSIX.1 function.  *//* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  *//* Get the process group ID of process PID.  *//* Get the process group ID of the calling process.  *//* Get the process ID of the calling process's parent.  *//* Get the process ID of the calling process.  *//* Get the value of the string-valued system variable NAME.  *//* Get the value of the system variable NAME.  *//* Get file-specific configuration about descriptor FD.  *//* Get file-specific configuration information about PATH.  *//* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  *//* Terminate program execution with the low-order 8 bits of STATUS.  *//* Add INC to priority of the current process.  *//* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  *//* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  *//* Execute PATH with arguments ARGV and environment from `environ'.  *//* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  *//* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  *//* NULL-terminated array of "NAME=VALUE" environment variables.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same file.  *//* Duplicate FD, returning a new file descriptor on the same file.  *//* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  *//* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  *//* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  *//* Change the process's working directory to the one FD is open on.  *//* Change the process's working directory to PATH.  *//* Change the owner and group of FILE relative to the directory FD is open
   on.  *//* Use X/Open Unix.  *//* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  *//* Change the owner and group of the file that FD is open on.  *//* Change the owner and group of FILE.  *//* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  *//* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  *//* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  *//* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Close all open file descriptors greater than or equal to LOWFD.
   Negative LOWFD is clamped to 0.  *//* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  *//* Old BSD names for the same constants; just for compatibility.  *//* <stdio.h> has the same definitions.  *//* Values for the WHENCE argument to lseek.  *//* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  *//* Execute program relative to a directory file descriptor.  *//* An alias for `euidaccess', used by some other systems.  *//* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  *//* Test for access to NAME using the real UID and real GID.  *//* All functions that are not declared anywhere else.  *//* Standard error output.  *//* Standard output.  *//* Standard input.  *//* Standard file descriptors.  *//* Get the environment definitions from Unix98.  *//* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   *//* The legacy interfaces are also available.  *//* The enhanced internationalization capabilities according to XPG4.2
   are present.  *//* The X/Open Unix extensions are available.  *//* We are compatible with the old published standards as well.  *//* Commands and utilities from XPG4 are available.  *//* X/Open version number to which the library conforms.  It is selectable.  *//* If defined, the implementation supports the
   creation of locales with the localedef utility.  *//* If defined, the implementation supports the
   Software Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Bindings Option.  *//* This symbol was required until the 2001 edition of POSIX.  *//* The utilities on GNU systems also correspond to this version.  *//* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  *//* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  *//*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */__length__salt__fildes__sysno__delta__prompt__nochdir__noclose__sample_buffer__id__name_len__pgrp_id__from__tofd__to__fromfd__gid__rgid__egid__uid__ruid__euid__list__pgid__inc__argv__envp__fd2__owner__group__useconds__interval__seconds__pipedes__nbytes__lowfd/usr/include/utime.hutimeconst utimbufconst utimbuf *utimbuf *utimbufmodtimeactime_UTIME_H/* utime.h *//* Set the access and modification times of FILE to those given in
   *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  *//* Modification time.  *//* Access time.  *//* Structure describing file times.  *//*
 *	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>
 */__file_times/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/tools/brotli.c<utime.h><unistd.h><sys/stat.h><fcntl.h>maincommandis_ok.brDEFAULT_SUFFIXMAX_OPTIONSint[20]Context *COMMAND_COMPRESSCOMMAND_DECOMPRESSCOMMAND_TEST_INTEGRITYmodified_path_lenkFileBufferSizekFileBufferSize * 2out of memory
"out of memory\n"COMMAND_NOOPCOMMAND_VERSIONCOMMAND_HELPCOMMAND_INVALIDCompressFilesDEFAULT_LGWINUse -h help. Use -f to force output to a terminal.
"Use -h help. Use -f to force output to a terminal.\n"char[52]CompressFileis_eoffailed to compress data [%s]
"failed to compress data [%s]\n"char[30]Compressed "Compressed "
"\n"char[2]DecompressFilesUse -h help. Use -f to force input from a terminal.
"Use -h help. Use -f to force input from a terminal.\n"DecompressFilecorrupt input [%s]
"corrupt input [%s]\n"has_more_input/home/atharvakale/390r-debugging-setup/p7zip/C/brotli/c/toolsargcargvDecompressed "Decompressed "PrintFileProcessingProgress[%s]: "[%s]: " -> " -> "char[5]PrintBytes%d B"%d B"%0.3f KiB"%0.3f KiB"1024.0%0.3f MiB"%0.3f MiB"1048576.0%0.3f GiB"%0.3f GiB"1073741824.0FlushOutputProvideOutputWriteOutputfailed to write output [%s]: %s
"failed to write output [%s]: %s\n"char[33]ProvideInputfailed to read input [%s]: %s
"failed to read input [%s]: %s\n"char[31]HasMoreInputInitializeBuffersCloseFilesfclose failed [%s]: %s
"fclose failed [%s]: %s\n"OpenFilesFILE **_IO_FILE **NextFileargarg_len'-'namename_suffixname_lenempty output file name for [%s] input file
"empty output file name for [%s] input file\n"char[44]input file [%s] suffix mismatch
"input file [%s] suffix mismatch\n"CopyStatstatbuftimes504(S_IRWXU | S_IRWXG | S_IRWXO)setting access bits failed for [%s]: %s
"setting access bits failed for [%s]: %s\n"char[41](uid_t)-1setting group failed for [%s]: %s
"setting group failed for [%s]: %s\n"char[35](gid_t)-1setting user failed for [%s]: %s
"setting user failed for [%s]: %s\n"char[34]FileSize"rb"char[3]successinput_pathoutput_pathpath0LOpenOutputFilefdMAKE_BINARY(STDOUT_FILENO)wb"wb"failed to open output file [%s]: %s
"failed to open output file [%s]: %s\n"char[37]OpenInputFileMAKE_BINARY(STDIN_FILENO)failed to open input file [%s]: %s
"failed to open input file [%s]: %s\n"char[36]PrintablePathcon"con"PrintHelpmediaUsage: %s [OPTION]... [FILE]...
"Usage: %s [OPTION]... [FILE]...\n"Options:
  -#                          compression level (0-9)
  -c, --stdout                write on standard output
  -d, --decompress            decompress
  -f, --force                 force output file overwrite
  -h, --help                  display this help and exit
"Options:\n"
"  -#                          compression level (0-9)\n"
"  -c, --stdout                write on standard output\n"
"  -d, --decompress            decompress\n"
"  -f, --force                 force output file overwrite\n"
"  -h, --help                  display this help and exit\n"char[275]  -j, --rm                    remove source file(s)
  -k, --keep                  keep source file(s) (default)
  -n, --no-copy-stat          do not copy source file(s) attributes
  -o FILE, --output=FILE      output file (only if 1 input file)
"  -j, --rm                    remove source file(s)\n"
"  -k, --keep                  keep source file(s) (default)\n"
"  -n, --no-copy-stat          do not copy source file(s) attributes\n"
"  -o FILE, --output=FILE      output file (only if 1 input file)\n"char[246]  -q NUM, --quality=NUM       compression level (%d-%d)
"  -q NUM, --quality=NUM       compression level (%d-%d)\n"char[57]  -t, --test                  test compressed file integrity
  -v, --verbose               verbose mode
"  -t, --test                  test compressed file integrity\n"
"  -v, --verbose               verbose mode\n"char[105]  -w NUM, --lgwin=NUM         set LZ77 window size (0, %d-%d)
                              window size = 2**NUM - 16
                              0 lets compressor choose the optimal value
"  -w NUM, --lgwin=NUM         set LZ77 window size (0, %d-%d)\n"
"                              window size = 2**NUM - 16\n"
"                              0 lets compressor choose the optimal value\n"char[192]  --large_window=NUM          use incompatible large-window brotli
                              bitstream with window size (0, %d-%d)
                              WARNING: this format is not compatible
                              with brotli RFC 7932 and may not be
                              decodable with regular brotli decoders
"  --large_window=NUM          use incompatible large-window brotli\n"
"                              bitstream with window size (0, %d-%d)\n"
"                              WARNING: this format is not compatible\n"
"                              with brotli RFC 7932 and may not be\n"
"                              decodable with regular brotli decoders\n"char[340]  -S SUF, --suffix=SUF        output file suffix (default:'%s')
"  -S SUF, --suffix=SUF        output file suffix (default:'%s')\n"char[65]  -V, --version               display version and exit
  -Z, --best                  use best compression level (11) (default)
Simple options could be coalesced, i.e. '-9kf' is equivalent to '-9 -k -f'.
With no FILE, or when FILE is -, read standard input.
All arguments after '--' are treated as files.
"  -V, --version               display version and exit\n"
"  -Z, --best                  use best compression level (11) (default)\n"
"Simple options could be coalesced, i.e. '-9kf' is equivalent to '-9 -k -f'.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"All arguments after '--' are treated as files.\n"char[305]PrintVersionmajorminor(BROTLI_VERSION >> 12)0xFFF(BROTLI_VERSION >> 12) & 0xFFFpatchbrotli %d.%d.%d
"brotli %d.%d.%d\n"ParseParamsnext_option_indexinput_countlongest_path_lencommand_setquality_setoutput_setkeep_setlgwin_setsuffix_setafter_dash_dashc == 'j'(MAX_OPTIONS - 2)too many options passed
"too many options passed\n"char[25]'0''9'quality already set
"quality already set\n"char[21]write to standard output already set
"write to standard output already set\n"char[38]command already set when parsing -d
"command already set when parsing -d\n"force output overwrite already set
"force output overwrite already set\n"'j''k'argument --rm / -j or --keep / -k already set
"argument --rm / -j or --keep / -k already set\n"char[47]argument --no-copy-stat / -n already set
"argument --no-copy-stat / -n already set\n"char[42]command already set when parsing -t
"command already set when parsing -t\n"argument --verbose / -v already set
"argument --verbose / -v already set\n"'V''q''D''S'invalid argument -%c
"invalid argument -%c\n"expected parameter for argument -%c
"expected parameter for argument -%c\n"write to standard output already set (-o)
"write to standard output already set (-o)\n"char[43]error parsing quality value [%s]
"error parsing quality value [%s]\n"lgwin parameter already set
"lgwin parameter already set\n"char[29]error parsing lgwin value [%s]
"error parsing lgwin value [%s]\n"lgwin parameter (%d) smaller than the minimum (%d)
"lgwin parameter (%d) smaller than the minimum (%d)\n"suffix already set
"suffix already set\n""best"decompress"decompress"command already set when parsing --decompress
"command already set when parsing --decompress\n""force"char[6]help"help"keep"keep"no-copy-stat"no-copy-stat"char[13]rm"rm""stdout"test"test"command already set when parsing --test
"command already set when parsing --test\n"verbose"verbose"version"version"key_lenmust pass the parameter as --%s=value
"must pass the parameter as --%s=value\n"char[39]"lgwin""large_window""output"write to standard output already set (--output)
"write to standard output already set (--output)\n"char[49]"quality""suffix"invalid parameter: [%s]
"invalid parameter: [%s]\n"'\\'ParseAliasunbrotli"unbrotli"unbrotli_lenterminatorFileNameseparator_positionParseIntContexttotal_infoutfininput_file_lengthcurrent_output_pathcurrent_input_pathiterator_errorignoreiteratormodified_pathnot_input_indicestest_integritywrite_to_stdoutcopy_statjunk_sourceforce_overwriteverbosity1 << 19".br"MAKE_BINARY(FILENO)(FILENO)_CRT_SECURE_NO_WARNINGS!defined(_CRT_SECURE_NO_WARNINGS)!defined(_WIN32)!defined(__MINGW32__)/* Use file size to limit lgwin. *//* 0, or not specified by user; could be chosen by compressor. *//* Do not enable "large-window" extension, if not required. *//* Specified by user. *//* Should detect OOM? *//* This allows decoding "large-window" streams. Though it creates
       fragmentation (new builds decode streams that old builds don't),
       it is better from used experience perspective. *//* Internal: should be used only in Provide-/Flush-Output. *//* This method might give the false-negative result.
   However, after an empty / incomplete read it should tell the truth. *//* TOCTOU violation, but otherwise it is impossible to set file times. *//* If output is not specified, input path suffix should match. *//* Read from console. *//* Iterator now points to the input file name. *//* All args are scanned already. *//* Skip option arguments. *//* Either write to the specified path, or to console. *//* No input path; read from console. *//* Iterator points to last used arg; increment to search for the next one. *//* Copy file times and permissions.
   TODO: this is a "best effort" implementation; honest cross-platform
   fully featured implementation is way too hacky; add more hacks by request. *//* String is cut to pieces with length less than 509, to conform C90 spec. *//* This option is intentionally not mentioned in help. *//* key=value *//* Don't parse further. *//* Double-dash. *//* o/q/w/D/S with parameter is expected *//* Simple / coalesced options. *//* '--' entry stop parsing arguments. *//* Not a file entry. *//* Input file entry. *//* Too many options. The expected longest option list is:
       "-q 0 -w 10 -o f -D d -S b -d -f -k -n -v --", i.e. 16 items in total.
       This check is an additional guard that is never triggered, but provides
       a guard for future changes. *//* C99 5.1.2.2.1: "members argv[0] through argv[argc-1] inclusive shall
       contain pointers to strings"; NULL and 0-length are not forbidden. *//* Partial comparison. On Windows there could be ".exe" suffix. *//* TODO: cast name to lower case? *//* Detect if the program name is a special alias that infers a command type. *//* Returns "base file name" or its tail, if it contains '/' or '\'. *//* Parse up to 5 decimal digits. *//* size_t would be large enough,
     until 4GiB+ files are compressed / decompressed on 32-bit CPUs. *//* Reporting *//* I/O buffers *//* -1, if impossible to calculate *//* Storage for path with appended / cut suffix *//* Inner state *//* Parameters *//* WIN32 *//* Mute strerror/strcpy warnings. *//* Command line interface for Brotli library. *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fast-lzma2.hFL2_estimateDStreamSizeFL2_estimateDCtxSizeFL2_getDictSizeFromPropFL2_estimateCStreamSize_usingCStreamconst FL2_CStreamconst FL2_CStream *FL2_CCtx_s *FL2_estimateCStreamSize_byParamsconst FL2_compressionParametersconst FL2_compressionParameters *FL2_estimateCStreamSizeFL2_estimateCCtxSize_usingCCtxconst FL2_CCtxconst FL2_CCtx *FL2_estimateCCtxSize_byParamsFL2_estimateCCtxSizeFL2_getLevelParametersFL2_compressionParameters *FL2_CStream_getParameterFL2_CStream *FL2_CStream_setParameterFL2_CCtx_getParameterFL2_CCtx *FL2_CCtx_setParameterFL2_decompressStreamFL2_DStream *FL2_DStream_s *FL2_outBuffer *FL2_inBuffer *FL2_initDStream_withPropFL2_initDStreamFL2_getDStreamProgressconst FL2_DStreamconst FL2_DStream *FL2_cancelDStreamFL2_waitDStreamFL2_setDStreamTimeoutFL2_setDStreamMemoryLimitMtFL2_freeDStreamFL2_createDStreamMtFL2_createDStreamFL2_endStreamFL2_flushStreamFL2_remainingOutputSizeFL2_cancelCStreamFL2_waitCStreamFL2_getCStreamProgressFL2_getNextCompressedBufferFL2_cBuffer *FL2_updateDictionaryFL2_getDictionaryBufferFL2_dictBuffer *FL2_copyCStreamOutputFL2_compressStreamFL2_setCStreamTimeoutFL2_initCStreamFL2_freeCStreamFL2_createCStreamMtFL2_createCStreamFL2_decompressDCtxFL2_DCtx *FL2_DCtx_s *FL2_initDCtxFL2_getDCtxThreadCountconst FL2_DCtxconst FL2_DCtx *FL2_freeDCtxFL2_createDCtxMtFL2_createDCtxFL2_getCCtxDictPropFL2_compressCCtxFL2_getCCtxThreadCountFL2_freeCCtxFL2_createCCtxMtFL2_createCCtxFL2_maxHighCLevelFL2_maxCLevelFL2_getErrorNameFL2_isTimedOutFL2_isErrorFL2_compressBoundFL2_findDecompressedSizeFL2_decompressMtFL2_decompressFL2_compressMtFL2_compressFL2_versionStringFL2_versionNumberFL2_cParameterFL2_p_compressionLevelFL2_p_highCompressionFL2_p_dictionaryLogFL2_p_dictionarySizeFL2_p_overlapFractionFL2_p_resetIntervalFL2_p_bufferResizeFL2_p_hybridChainLogFL2_p_hybridCyclesFL2_p_searchDepthFL2_p_fastLengthFL2_p_divideAndConquerFL2_p_strategyFL2_p_literalCtxBitsFL2_p_literalPosBitsFL2_p_posBitsFL2_p_omitPropertiesFL2_p_doXXHashFL2_compressionParametersFL2_strategyFL2_fastFL2_optFL2_ultraFL2_DStreamFL2_DStream_sFL2_CStreamFL2_cBufferFL2_dictBufferFL2_outBufferFL2_inBufferFL2_DCtxFL2_DCtx_sFL2_CCtxFL2_CCtx_sstrategydivideAndConquerfastLengthsearchDepthcyclesLogchainLogoverlapFractiondictionarySizeFL2_LCLP_MAXFL2_PB_MAXFL2_PB_MINFL2_LP_MAXFL2_LP_MINFL2_LC_MAXFL2_LC_MINFL2_FASTLENGTH_MAXFL2_FASTLENGTH_MINFL2_SEARCH_DEPTH_MAXFL2_SEARCH_DEPTH_MINFL2_HYBRIDCYCLES_MAXFL2_HYBRIDCYCLES_MINFL2_CHAINLOG_MAXFL2_CHAINLOG_MINFL2_BUFFER_RESIZE_DEFAULTFL2_BUFFER_RESIZE_MAXFL2_BUFFER_RESIZE_MINFL2_RESET_INTERVAL_MAXFL2_RESET_INTERVAL_MINFL2_BLOCK_OVERLAP_MAXFL2_BLOCK_OVERLAP_MINFL2_DICTSIZE_MIN(1U << FL2_DICTLOG_MIN)FL2_DICTSIZE_MAX(1U << FL2_DICTLOG_MAX)FL2_DICTLOG_MAX((unsigned)(sizeof(size_t) == 4 ? FL2_DICTLOG_MAX_32 : FL2_DICTLOG_MAX_64))FL2_DICTLOG_MAX_64FL2_DICTLOG_MAX_32FL2_DICTLOG_MINFL2_CONTENTSIZE_ERROR(size_t)-1FL2_MAXTHREADSFL2_VERSION_STRINGFL2_EXPAND_AND_QUOTE(FL2_LIB_VERSION)FL2_EXPAND_AND_QUOTE(str)FL2_QUOTE(str)#strFL2_LIB_VERSIONFL2_VERSION_MAJOR.FL2_VERSION_MINOR.FL2_VERSION_RELEASEFL2_VERSION_NUMBER(FL2_VERSION_MAJOR *100*100 + FL2_VERSION_MINOR *100 + FL2_VERSION_RELEASE)FL2_VERSION_RELEASEFL2_VERSION_MINORFL2_VERSION_MAJORFL2LIB_CALLFL2LIB_APIFL2LIB_VISIBILITYFAST_LZMA2_Hdefined (__cplusplus)defined(__GNUC__) && (__GNUC__ >= 4)defined(FL2_DLL_EXPORT) && (FL2_DLL_EXPORT==1)defined(FL2_DLL_IMPORT) && (FL2_DLL_IMPORT==1)!defined _WIN32 || defined __x86_64__s || defined _M_X64 || (defined __SIZEOF_POINTER__ && __SIZEOF_POINTER__ == 8)NO_XXHASHRMF_REFERENCE/* FAST_LZMA2_H *//*!<  obtain dictSize from FL2_getDictSizeFromProp() *//*! FL2_estimateDStreamSize() :
 *  Estimate decompression memory use from the dictionary size and number of threads.
 *  For nbThreads == 0 the number of available cores will be used.
 *  Obtain dictSize by passing the property byte to FL2_getDictSizeFromProp. *//*! FL2_estimateDCtxSize() :
 *  The size of a DCtx does not include a dictionary buffer because the caller must supply one. *//*! FL2_getDictSizeFromProp() :
 *  Get the dictionary size from the property byte for a stream. The property byte is the first byte
*   in the stream, unless omitProperties was enabled, in which case the caller must store it. *//*!< memory usage determined by settings *//*!< memory usage determined by params *//*!< memory usage determined by level *//*! FL2_estimate*() :
*  These functions estimate memory usage of a CCtx before its creation or before any operation has begun.
*  FL2_estimateCCtxSize() will provide a budget large enough for any compression level up to selected one.
*  To use FL2_estimateCCtxSize_usingCCtx, set the compression level and any other settings for the context,
*  then call the function. Some allocation occurs when the context is created, but the large memory buffers
*  used for string matching are allocated only when compression is initialized. *//***************************************
*  Context memory usage
***************************************//*! FL2_getLevelParameters() :
 *  Get all compression parameter values defined by the preset compressionLevel.
 *  @result : the values in a FL2_compressionParameters struct, or the parameter_outOfBound error code
 *            (which can be tested with FL2_isError()) if compressionLevel is invalid. *//*! FL2_CStream_getParameter() :
 *  Get one compression parameter, selected by enum FL2_cParameter.
 *  @result : the parameter value, or the parameter_unsupported error code
 *            (which can be tested with FL2_isError()). *//*! FL2_CStream_setParameter() :
 *  Set one compression parameter, selected by enum FL2_cParameter.
 *  @result : informational value (typically, the one being set, possibly corrected),
 *            or an error code (which can be tested with FL2_isError()). *//*! FL2_CCtx_getParameter() :
 *  Get one compression parameter, selected by enum FL2_cParameter.
 *  @result : the parameter value, or the parameter_unsupported error code
 *            (which can be tested with FL2_isError()). *//*! FL2_CCtx_setParameter() :
 *  Set one compression parameter, selected by enum FL2_cParameter.
 *  @result : informational value (typically, the one being set, possibly corrected),
 *            or an error code (which can be tested with FL2_isError()). *//* Use the reference matchfinder for development purposes. SLOW. *//* Calculate a 32-bit xxhash value from the input data and store it 
                             * after the stream terminator. The value will be checked on decompression.
                             * 0 = do not calculate; 1 = calculate (default) *//* A stream compressed under this setting cannot be decoded by this library. *//* or other containers which store the property byte elsewhere. *//* Omit the property byte at the start of the stream. For use within 7-zip *//* pb value for LZMA2 encoder
                             * Default = 2 *//* lp value for LZMA2 encoder
                             * Default = 0 *//* lc value for LZMA2 encoder
                             * Default = 3 *//* 1 = fast; 2 = optimized, 3 = ultra (hybrid mode).
                             * The higher the value of the selected strategy, the more complex it is,
                             * resulting in stronger and slower compression.
                             * Default = ultra *//* Split long chains of 2-byte matches into shorter chains with a small overlap
                             * for further processing. Allows buffering of all chains at length 2.
                             * Faster, less compression. Generally a good tradeoff.
                             * Default = enabled *//* Only useful for strategies >= opt.
                             * Length of match considered "good enough" to stop search.
                             * Larger values make compression stronger and slower.
                             * Default = 48 *//* Match finder will resolve string matches up to this length. If a longer
                             * match exists further back in the input, it will not be found.
                             * Default = 42 *//* Number of search attempts made by the HC3 match finder.
                             * Used only by the hybrid "ultra" strategy.
                             * More attempts result in slightly better and slower compression.
                             * Default = 1 *//* Size of the hybrid mode HC3 hash chain, as a power of 2.
                             * Resulting table size is (1 << (chainLog+2)) bytes.
                             * Larger tables result in better and slower compression.
                             * This parameter is only used by the hybrid "ultra" strategy.
                             * Default = 9 *//* Buffering speeds up the matchfinder. Buffer resize determines the percentage of
                             * the normal buffer size used, which depends on dictionary size.
                             * 0=50, 1=75, 2=100, 3=150, 4=200. Higher number = slower, better
                             * compression, higher memory usage. A CPU with a large memory cache
                             * may make effective use of a larger buffer.
                             * Default = 2 *//* For multithreaded decompression. A dictionary reset will occur
                             * after each dictionarySize * resetInterval bytes of input.
                             * Default = 4 *//* The radix match finder is block-based, so some overlap is retained from
                             * each block to improve compression of the next. This value is expressed
                             * as n / 16 of the block size (dictionary size). Larger values are slower.
                             * Values above 2 mostly yield only a small improvement in compression.
                             * A large value for a small dictionary may worsen multithreaded compression.
                             * Default = 2 *//* Same as above but expressed as an absolute value. 
                             * Must be clamped between FL2_DICTSIZE_MIN and FL2_DICTSIZE_MAX.
                             * Default = 16 Mb *//* Maximum allowed back-reference distance, expressed as power of 2.
                             * Must be clamped between FL2_DICTLOG_MIN and FL2_DICTLOG_MAX.
                             * Default = 24 *//* Maximize compression ratio for a given dictionary size.
                             * Levels 1..10 = dictionaryLog 20..29 (1 Mb..512 Mb).
                             * Typically provides a poor speed/ratio tradeoff. *//* Update all compression parameters according to pre-defined cLevel table
                             * Default level is FL2_CLEVEL_DEFAULT==6.
                             * Setting FL2_p_highCompression to 1 switches to an alternate cLevel table. *//* compression parameters *//* encoder strategy : fast, optimized or ultra (hybrid) *//* split long chains of 2-byte matches into shorter chains with a small overlap : faster, somewhat less compression; enabled by default *//* acceptable match size for parser : larger == more compression, slower; fast bytes parameter from 7-Zip *//* maximum depth for resolving string matches : larger == more compression, slower *//* nb of searches : larger == more compression, slower; hybrid mode only (ultra) *//* HC3 sliding window : larger == more compression, slower; hybrid mode only (ultra) *//* overlap between consecutive blocks in 1/16 units: larger == more compression, slower *//* largest match distance : larger == more compression, more memory needed during decompression; > 64Mb == more memory per byte, slower *//* only used by optimizer *//* small enough to fit FL2_DICTSIZE_MAX * FL2_RESET_INTERVAL_MAX in 32-bit size_t *//*-***************************************************************************
 *  Compression parameters
 *
 *  Any function that takes a 'compressionLevel' parameter will replace any
 *  parameters affected by compression level that are already set.
 *  To use a preset level and modify it, call FL2_CCtx_setParameter with
 *  FL2_p_compressionLevel to set the level, then call FL2_CCtx_setParameter again
 *  with any other settings to change.
 *  Specify a compressionLevel of 0 when calling a compression function to keep
 *  the current parameters.
 * *******************************************************************************//*! FL2_decompressStream() :
 *  Reads data from input and decompresses to output.
 *  Returns 1 if the stream is unfinished, 0 if the terminator was encountered (he'll be back)
 *  and all data was written to output, or an error code. Call this function repeatedly if
 *  necessary, removing data from output and/or loading data into input before each call. *//*! FL2_initDStream() :
 *  Call this function before decompressing a stream. FL2_initDStream_withProp()
 *  must be used for streams which do not include a property byte at position zero.
 *  The caller is responsible for storing and passing the property byte.
 *  Returns 0 if okay, or an error if the stream object is still in use from a
 *  previous call to FL2_decompressStream() (see timeout info above). *//*===== Streaming decompression functions =====*//*! FL2_getDStreamProgress() :
 *  Returns the number of bytes decoded since the stream was initialized. *//*! FL2_cancelDStream() :
 *  Frees memory allocated for MT decoding. If a timeout is set and the caller is waiting
 *  for completion of MT decoding, decompression in progress will be canceled. *//*! FL2_waitDStream() :
 *  Waits for decompression to end after a timeout has occurred. This function returns after the
 *  timeout set using FL2_setDStreamTimeout() has elapsed, or when decompression of available input is
 *  complete. Unnecessary when no timeout is set.
 *  Returns 0 if the stream is complete, 1 if not complete, or an error code. *//*! FL2_setDStreamTimeout() :
 *  Sets a timeout in milliseconds. Zero disables the timeout. If a nonzero timout is set,
 *  FL2_decompressStream() may return a timeout code before decompression of the available data
 *  completes. FL2_isError() returns true for the timeout code, so check the code with FL2_isTimedOut()
 *  before testing for errors. After a timeout occurs, do not call FL2_decompressStream() again unless
 *  a call to FL2_waitDStream() returns 1. A typical application for timeouts is to update the user on
 *  decompression progress. *//*! FL2_setDStreamMemoryLimitMt() :
 *  Set a total size limit for multithreaded decoder input and output buffers. MT decoder memory
 *  usage is unknown until the input is parsed. If the limit is exceeded, the decoder switches to
 *  using a single thread.
 *  MT decoding memory usage is typically dictionary_size * 4 * nbThreads for the output
 *  buffers plus the size of the compressed input for that amount of output. *//*===== FL2_DStream management functions =====*//*-***************************************************************************
 *  Streaming decompression
 *
 *  A FL2_DStream object is required to track streaming operations.
 *  Use FL2_createDStream() and FL2_freeDStream() to create/release resources.
 *  FL2_DStream objects can be re-used multiple times.
 *
 *  Use FL2_initDStream() to start a new decompression operation.
 *  @return : zero or an error code
 *
 *  Use FL2_decompressStream() repetitively to consume your input.
 *  The function will update both `pos` fields.
 *  If `input.pos < input.size`, some input has not been consumed.
 *  It's up to the caller to present again the remaining data.
 *  If `output.pos < output.size`, decoder has flushed everything it could.
 *  @return : 0 when a stream is completely decoded and fully flushed,
 *            1, which means there is still some decoding to do to complete the stream,
 *            or an error code, which can be tested using FL2_isError().
 * *******************************************************************************//*! FL2_endStream() :
 *  Compress all data remaining in the dictionary buffer(s) and write the stream end marker. It may
 *  be necessary to call FL2_endStream() more than once. If output == NULL the compressed data must
 *  be read from the CStream object after each call.
 *  Returns 0 when compression is complete and all output has been flushed, 1 if not complete, or
 *  an error code. *//*! FL2_flushStream() :
 *  Compress all data remaining in the dictionary buffer(s). It may be necessary to call
 *  FL2_flushStream() more than once. If output == NULL the compressed data must be read from the
 *  CStream object after each call.
 *  Flushing is not normally useful and produces larger output.
 *  Returns 1 if input or output still exists in the CStream object, 0 if complete, or an error code. *//*! FL2_remainingOutputSize() :
 *  The amount of compressed data remaining to be read from the CStream object. *//*! FL2_cancelCStream() :
 *  Cancels any compression operation underway. Useful only when dual buffering and/or timeouts
 *  are enabled. The stream will be returned to an uninitialized state. *//*! FL2_waitCStream() :
 *  Waits for compression to end. This function returns after the timeout set using
 *  FL2_setCStreamTimeout has elapsed. Unnecessary when no timeout is set.
 *  Returns 1 if compressed output is available, 0 if not, or the timeout code. *//*! FL2_getCStreamProgress() :
 *  Returns the number of bytes processed since the stream was initialized. This is a synthetic
 *  estimate because the match finder does not proceed sequentially through the data. If
 *  outputSize is not NULL, returns the number of bytes of compressed data generated. *//******//*! FL2_getNextCompressedBuffer() :
 *  Returns a buffer containing a slice of the compressed data. Call this function and process the data
 *  until the function returns zero. In most cases it will return a buffer for each compression thread
 *  used. It is sometimes less but never more than nbThreads. If asynchronous compression is in progress,
 *  this function will wait for completion before returning, or it will return the timeout code. *//*! FL2_updateDictionary() :
 *  Informs the CStream how much data was added to the buffer. Compression begins if the dictionary
 *  was filled. Returns 1 to indicate compressed data must be read, 0 if not, or an error code. *//*! FL2_getDictionaryBuffer() :
 *  Returns a buffer in the FL2_outBuffer object, which the caller can directly read data into.
 *  Applications will normally pass this buffer to an I/O read function or upstream filter.
 *  Returns 0, or an error or timeout code. *//*** Push/pull functions ***//*! FL2_copyCStreamOutput() :
 *  Copies compressed data to the output buffer until the buffer is full or all available data is copied.
 *  If asynchronous compression is in progress, the function returns 0 without waiting.
 *  Returns 1 to indicate some compressed data remains, or 0 otherwise. *//*! FL2_compressStream() :
 *  Reads data from input into the dictionary buffer. Compression will begin if the buffer fills up.
 *  A dual buffering stream will fill the second buffer while compression proceeds on the first.
 *  A call to FL2_compressStream() will wait for ongoing compression to complete if all dictionary space
 *  is filled. FL2_compressStream() must not be called with output == NULL unless the caller has read all
 *  compressed data from the CStream object.
 *  Returns 1 to indicate compressed data must be read (or output is full), or 0 otherwise. *//*! FL2_setCStreamTimeout() :
 *  Sets a timeout in milliseconds. Zero disables the timeout (default). If a nonzero timout is set, functions
 *  FL2_compressStream(), FL2_getDictionaryBuffer(), FL2_updateDictionary(), FL2_getNextCompressedBuffer(),
 *  FL2_flushStream(), and FL2_endStream() may return a timeout code before compression of the current
 *  dictionary of data completes. FL2_isError() returns true for the timeout code, so check the code with
 *  FL2_isTimedOut() before testing for errors. With the exception of FL2_updateDictionary(), the above
 *  functions may be called again to wait for completion. A typical application for timeouts is to update the
 *  user on compression progress. *//*! FL2_initCStream() :
 *  Call this function before beginning a new compressed data stream. To keep the stream object's
 *  current parameters, specify zero for the compression level. The object is set to the default
 *  level upon creation. *//*===== Streaming compression functions =====*//*===== FL2_CStream management functions =====*//*-***********************************************************************
 *  Streaming compression
 *
 *  A FL2_CStream object is required to track streaming operation.
 *  Use FL2_createCStream() and FL2_freeCStream() to create/release resources.
 *  FL2_CStream objects can be reused multiple times on consecutive compression operations.
 *  It is recommended to re-use FL2_CStream in situations where many streaming operations will be done
 *  consecutively, since it will reduce allocation and initialization time.
 *
 *  Call FL2_createCStreamMt() with a nonzero dualBuffer parameter to use two input dictionary buffers.
 *  The stream will not block on FL2_compressStream() and continues to accept data while compression is
 *  underway, until both buffers are full. Useful when I/O is slow.
 *  To compress with a single thread with dual buffering, call FL2_createCStreamMt with nbThreads=1.
 *
 *  Use FL2_initCStream() on the FL2_CStream object to start a new compression operation.
 *
 *  Use FL2_compressStream() repetitively to consume input stream.
 *  The function will automatically update the `pos` field.
 *  It will always consume the entire input unless an error occurs or the dictionary buffer is filled,
 *  unlike the decompression function.
 *
 *  The radix match finder allows compressed data to be stored in its match table during encoding.
 *  Applications may call streaming compression functions with output == NULL. In this case,
 *  when the function returns 1, the compressed data must be read from the internal buffers.
 *  Call FL2_getNextCompressedBuffer() repeatedly until it returns 0.
 *  Each call returns buffer information in the FL2_inBuffer parameter. Applications typically will 
 *  passed this to an I/O write function or downstream filter.
 *  Alternately, applications may pass an FL2_outBuffer object pointer to receive the output. In this
 *  case the return value is 1 if the buffer is full and more compressed data remains.
 *
 *  FL2_endStream() instructs to finish a stream. It will perform a flush and write the LZMA2
 *  termination byte (required). Call FL2_endStream() repeatedly until it returns 0.
 *
 *  Most functions may return a size_t error code, which can be tested using FL2_isError().
 *
 * *******************************************************************//**< size of compressed data *//**< start of compressed data *//**< size of dict remaining *//**< start of available dict buffer *//*** Push/pull structs ***//**< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size *//**< size of output buffer *//**< start of output buffer *//**< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size *//**< size of input buffer *//**< start of input buffer *//****************************
*  Streaming
****************************//*! FL2_decompressDCtx() :
 *  Same as FL2_decompress(), requires an allocated FL2_DCtx (see FL2_createDCtx()) *//*! FL2_initDCtx() :
 *  Use only when a property byte is not present at input byte 0. No init is necessary otherwise.
 *  The caller must store the result from FL2_getCCtxDictProp() and pass it to this function. *//*= Decompression context
 *  When decompressing many times, it is recommended to allocate a context only once,
 *  and re-use it for each successive decompression operation. This will make the workload
 *  friendlier for the system's memory.
 *  The context may not allocate the number of threads requested if the library is
 *  compiled for single-threaded compression or nbThreads > FL2_MAXTHREADS.
 *  Call FL2_getDCtxThreadCount to obtain the actual number allocated.
 *  At least nbThreads dictionary resets must exist in the stream to use all of the
 *  threads. Dictionary resets are inserted into the stream according to the
 *  FL2_p_resetInterval parameter used in the compression context. *//****************************
*  Decompression
****************************//*! FL2_getCCtxDictProp() :
 *  Get the dictionary size property.
 *  Intended for use with the FL2_p_omitProperties parameter for creating a
 *  7-zip or XZ compatible LZMA2 stream. *//*! FL2_compressCCtx() :
 *  Same as FL2_compress(), but requires an allocated FL2_CCtx (see FL2_createCCtx()). *//*= Compression context
 *  When compressing many times, it is recommended to allocate a context just once,
 *  and re-use it for each successive compression operation. This will make workload
 *  friendlier for system's memory. The context may not use the number of threads requested
 *  if the library is compiled for single-threaded compression or nbThreads > FL2_MAXTHREADS.
 *  Call FL2_getCCtxThreadCount to obtain the actual number allocated. *//***************************************
*  Explicit memory management
***************************************//*!< maximum compression level available in high mode *//*!< maximum compression level available *//*!< provides readable string from an error code *//*!< tells if a `size_t` function result is the timeout code *//*!< tells if a `size_t` function result is an error code *//*!< maximum compressed size in worst case scenario *//*======  Helper functions  ======*//*! FL2_findDecompressedSize()
 *  `src` should point to the start of a LZMA2 encoded stream.
 *  `srcSize` must be at least as large as the LZMA2 stream including end marker.
 *  A property byte is assumed to exist at position 0 in `src`. If the stream was created without one,
 *  subtract 1 byte from `src` when passing it to the function.
 *  @return : - decompressed size of the stream in `src`, if known
 *            - FL2_CONTENTSIZE_ERROR if an error occurred (e.g. corruption, srcSize too small)
 *   note 1 : a 0 return value means the stream is valid but "empty".
 *   note 2 : decompressed size can be very large (64-bits value),
 *            potentially larger than what local system can handle as a single memory segment.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified.
 *            Always ensure return value fits within application's authorized limits.
 *            Each application can set its own limits. *//*! FL2_decompress() :
 *  Decompresses a single LZMA2 compressed stream from `src` into already allocated `dst`.
 *  `compressedSize` : must be at least the size of the LZMA2 stream.
 *  `dstCapacity` is the original, uncompressed size to regenerate, returned by calling
 *  FL2_findDecompressedSize().
 *  Call FL2_decompressMt() to use > 1 thread. Specify nbThreads = 0 to use all cores. The stream
 *  must contain dictionary resets to use multiple threads. These are inserted during compression by
 *  default. The frequency can be changed/disabled with the FL2_p_resetInterval parameter setting.
 *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
 *            or an errorCode if it fails (which can be tested using FL2_isError()). *//*! FL2_compress() :
 *  Compresses `src` content as a single LZMA2 compressed stream into already allocated `dst`.
 *  Call FL2_compressMt() to use > 1 thread. Specify nbThreads = 0 to use all cores.
 *  @return : compressed size written into `dst` (<= `dstCapacity),
 *            or an error code if it fails (which can be tested using FL2_isError()). *//***************************************
*  Simple API
***************************************//**< useful to check dll version *//*------   Version   ------*//*******************************************************************************************************
Introduction

*********************************************************************************************************//* ======   Calling convention   ======*//* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*//* =====   FL2LIB_API : control library symbols visibility   ===== *//* size_t *//* ======   Dependency   ======*//*
 * Copyright (c) 2017-present, Conor McCarthy
 * All rights reserved.
 * Based on zstd.h copyright Yann Collet
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
*//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2nbThreadsfcsdualBuffercompressionLevelcctxfdstimeoutoutputSizecbufaddedSizedstCapacitydctxcompressedSize/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/mem.hMEM_writeBESTMEM_readBESTMEM_writeBE64MEM_readBE64MEM_writeBE32MEM_readBE32MEM_writeLESTMEM_readLESTMEM_writeLE64MEM_readLE64MEM_writeLE32MEM_readLE32MEM_writeLE24BYTE *MEM_readLE24const BYTEconst BYTE *MEM_writeLE16MEM_readLE16MEM_swapSTMEM_swap64MEM_swap32MEM_write64unalign64 *MEM_write32unalign32 *MEM_write16unalign16 *MEM_readSTconst unalignArchconst unalignArch *MEM_read64const unalign64const unalign64 *MEM_read32const unalign32const unalign32 *MEM_read16const unalign16const unalign16 *MEM_isLittleEndianconst union <unnamed>BYTE[4]MEM_64bitssizeof(size_t)==8MEM_32bitssizeof(size_t)==4MEM_check(sizeof(size_t)==4) || (sizeof(size_t)==8)MEM_static_assertunalignArchpackedunalign64unalign32unalign16S64U64S32U32S16U16BYTEMEM_FORCE_MEMORY_ACCESSMEM_STATIC_ASSERT(c){ enum { MEM_static_assert = 1/(int)(!!(c)) }; }MEM_STATICstatic __inline __attribute__((unused))MEM_H_MODULEdefined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)!defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)CHAR_BIT != 8USHRT_MAX != 65535UINT_MAX != 4294967295defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )defined(__INTEL_COMPILER) || defined(__GNUC__)defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==2)defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==1)defined(_MSC_VER) || (defined(__INTEL_COMPILER) && defined(WIN32))(defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \/* MEM_H_MODULE *//*=== Big endian r/w ===*//*=== Little endian r/w ===*//* Visual Studio *//* MEM_FORCE_MEMORY_ACCESS *//* default method, safe and standard.
   can sometimes prove slower *//* currently only defined for gcc and icc *//* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers *//* violates C standard, by lying on structure alignment.
Only use if no other choice to achieve best performance on target platform *//* don't use static : performance detrimental  *//* can be defined externally, on command line for example *//* MEM_FORCE_MEMORY_ACCESS :
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (i.e., not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets depending on alignment.
 *            In some circumstances, it's the only known way to get the most performance (i.e. GCC + ARMv6)
 * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//*-**************************************************************
*  Memory I/O
*****************************************************************//* note : there are no limits defined for long long type in C90.
 * limits exist in C99, however, in such case, <stdint.h> is preferred *//* C99 *//*-**************************************************************
*  Basic Types
*****************************************************************//* code only tested on 32 and 64 bits systems *//* compat. with non-clang compilers *//* this version may generate warnings for unused static functions; disable the relevant warning *//* _byteswap_* *//* _byteswap_ulong *//*-****************************************
*  Compiler specifics
******************************************//* size_t, ptrdiff_t *//*-****************************************
*  Dependencies
******************************************//*
 * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */memPtrval64val32/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/data_block.h"mem.h"FL2_dataBlockFL2_DATA_BLOCK_H_/* FL2_DATA_BLOCK_H_ *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/xxhash.hXXH64_hashFromCanonicalconst XXH64_canonical_tconst XXH64_canonical_t *XXH32_hashFromCanonicalconst XXH32_canonical_tconst XXH32_canonical_t *XXH64_canonicalFromHashXXH64_canonical_t *XXH32_canonicalFromHashXXH32_canonical_t *XXH64_copyStateXXH64_state_t *XXH64_state_s *XXH64_state_t *__restrict__const XXH64_state_tconst XXH64_state_t *const XXH64_state_t *__restrict__XXH32_copyStateXXH32_state_t *XXH32_state_s *XXH32_state_t *__restrict__const XXH32_state_tconst XXH32_state_t *const XXH32_state_t *__restrict__XXH64_digestXXH64_updateXXH64_resetXXH32_digestXXH32_updateXXH32_resetXXH64_freeStateXXH64_createStateXXH32_freeStateXXH32_createStateXXH64XXH32XXH_versionNumberXXH64_canonical_tXXH32_canonical_tXXH64_state_tXXH64_state_sXXH32_state_tXXH32_state_sXXH64_hash_tXXH32_hash_tXXH_errorcodeXXH_OKXXH_ERRORXXH_VERSION_NUMBER(XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)XXH_VERSION_RELEASEXXH_VERSION_MINORXXH_VERSION_MAJORXXH_PUBLIC_APIXXHASH_H_5627135585666179XXH_PRIVATE_APIXXH_STATIC_LINKING_ONLYXXH_NAMESPACE!(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))defined(XXH_STATIC_LINKING_ONLY) && !defined(XXH_STATIC_H_3543687687345)/* XXH_STATIC_LINKING_ONLY && XXH_STATIC_H_3543687687345 *//* include xxhash functions as `static`, for inlining *//* typedef'd to XXH64_state_t *//* never read nor write, will be removed in a future version *//* buffer defined as U64 for alignment *//* typedef'd to XXH32_state_t *//* buffer defined as U32 for alignment *//* These definitions are only meant to allow allocation of XXH state
   statically, on stack, or in a struct for example.
   Do not use members directly. *//* ================================================================================================
   This section contains definitions which are not guaranteed to remain stable.
   They may change in future versions, becoming incompatible with a different version of the library.
   They shall only be used with static linking.
   Never use these definitions in association with dynamic linking !
=================================================================================================== *//* XXHASH_H_5627135585666179 *//* Default result type for XXH functions are primitive unsigned 32 and 64 bits.
*  The canonical representation uses human-readable write convention, aka big-endian (large digits first).
*  These functions allow transformation of hash result into and from its canonical format.
*  This way, hash values can be written into a file / memory, and remain comparable on different systems and programs.
*//* **************************
*  Canonical representation
****************************//* disable restrict *//* ! C99 *//* **************************
*  Utils
****************************//*
These functions generate the xxHash of an input provided in multiple segments.
Note that, for small input, they are slower than single-call functions, due to state management.
For small input, prefer `XXH32()` and `XXH64()` .

XXH state must first be allocated, using XXH*_createState() .

Start a new hash by initializing state with a seed, using XXH*_reset().

Then, feed the hash state by calling XXH*_update() as many times as necessary.
Obviously, input must be allocated and read accessible.
The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.

Finally, a hash value can be produced anytime, by using XXH*_digest().
This function returns the nn-bits hash as an int or long long.

It's still possible to continue inserting input into the hash state after a digest,
and generate some new hashes later on, by calling again XXH*_digest().

When done, free XXH state space if it was allocated dynamically.
*//* hash streaming *//*! State allocation, compatible with dynamic libraries *//* incomplete type *//* ****************************
*  Streaming Hash Functions
******************************//*!
XXH32() :
    Calculate the 32-bits hash of sequence "length" bytes stored at memory address "input".
    The memory between input & input+length must be valid (allocated and read-accessible).
    "seed" can be used to alter the result predictably.
    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s
XXH64() :
    Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".
    "seed" can be used to alter the result predictably.
    This function runs 2x faster on 64-bits systems, but slower on 32-bits systems (see benchmark).
*//* ****************************
*  Simple Hash Functions
******************************//* *************************************
*  Version
***************************************//*!XXH_NAMESPACE, aka Namespace Emulation :

If you want to include _and expose_ xxHash functions from within your own library,
but also want to avoid symbol collisions with another library which also includes xxHash,

you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
with the value of XXH_NAMESPACE (so avoid to keep it NULL and avoid numeric values).

Note that no change is required within the calling program as long as it includes `xxhash.h` :
regular symbol name will be automatically translated by this header.
*//* XXH_PRIVATE_API *//* do nothing *//** XXH_PRIVATE_API
*   This is useful if you want to include xxhash functions in `static` mode
*   in order to inline them, and remove their symbol from the public list.
*   Methodology :
*     #define XXH_PRIVATE_API
*     #include "xxhash.h"
*   `xxhash.c` is automatically included.
*   It's not useful to compile and link it as a separate module anymore.
*//* ****************************
*  API modifier
******************************//* ****************************
*  Definitions
******************************//* Notice extracted from xxHash homepage :

xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
It also successfully passes all tests from the SMHasher suite.

Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)

Name            Speed       Q.Score   Author
xxHash          5.4 GB/s     10
CrapWow         3.2 GB/s      2       Andrew
MumurHash 3a    2.7 GB/s     10       Austin Appleby
SpookyHash      2.0 GB/s     10       Bob Jenkins
SBox            1.4 GB/s      9       Bret Mulvey
Lookup3         1.2 GB/s      9       Bob Jenkins
SuperFastHash   1.2 GB/s      1       Paul Hsieh
CityHash64      1.05 GB/s    10       Pike & Alakuijala
FNV             0.55 GB/s     5       Fowler, Noll, Vo
CRC32           0.43 GB/s     9
MD5-32          0.33 GB/s    10       Ronald L. Rivest
SHA1-32         0.28 GB/s    10

Q.Score is a measure of quality of the hash function.
It depends on successfully passing SMHasher test set.
10 is a perfect score.

A 64-bits version, named XXH64, is available since r35.
It offers much better speed, but for 64-bits applications only.
Name     Speed on 64 bits    Speed on 32 bits
XXH64       13.8 GB/s            1.9 GB/s
XXH32        6.8 GB/s            6.0 GB/s
*//*
   xxHash - Extremely Fast Hash algorithm
   Header File
   Copyright (C) 2012-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - xxHash source repository : https://github.com/Cyan4973/xxHash
*/dst_statesrc_statestatePtr/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/dict_buffer.h"xxhash.h""data_block.h""fast-lzma2.h"DICT_bufferxxhreset_intervaloverlapasyncBYTE *[2]unsigned char *[2]FL2_DICT_BUFFER_H_DICT_memUsageconst DICT_bufferconst DICT_buffer *const DICT_buffer *constDICT_getDigestDICT_shiftDICT_buffer *DICT_buffer *constDICT_asyncDICT_needShiftDICT_getBlockFL2_dataBlock *FL2_dataBlock *constDICT_hasUnprocessedDICT_availSpaceDICT_putFL2_inBuffer *constDICT_updateDICT_getvoid **constDICT_sizeDICT_destructDICT_initDICT_construct/* FL2_DICT_BUFFER_H_ *//* total size compressed after last dict reset *//* allocation size *//* never < overlap *//* start = 0 (first block) or overlap *//* DICT_buffer structure.
 * Maintains one or two dictionary buffers. In a dual dict configuration (asyc==1), when the
 * current buffer is full, the overlap region will be copied to the other buffer and it
 * becomes the destination for input while the first is compressed. This is useful when I/O
 * is much slower than compression. *//*
* Copyright (c) 2018, Conor McCarthy
* All rights reserved.
*
* This source code is licensed under both the BSD-style license (found in the
* LICENSE file in the root directory of this source tree) and the GPLv2 (found
* in the COPYING file in the root directory of this source tree).
* You may select, at your option, one of the above-listed licenses.
*/added_sizedict_sizereset_multiplierdo_hash/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/compiler.hPREFETCH_AREA(p,s){ const char* const _ptr = (const char*)(p); size_t const _size = (size_t)(s); size_t _pos; for (_pos=0; _pos<_size; _pos+=CACHELINE_SIZE) { PREFETCH_L2(_ptr + _pos); } }CACHELINE_SIZEPREFETCH_L2(ptr)__builtin_prefetch((ptr), 0 , 2 )PREFETCH_L1(ptr)__builtin_prefetch((ptr), 0 , 3 )DYNAMIC_BMI2TARGET_ATTRIBUTE(target)__attribute__((__target__(target)))FORCE_NOINLINEHINT_INLINEstatic INLINE_KEYWORD FORCE_INLINE_ATTRFORCE_INLINE_TEMPLATEFORCE_INLINE_ATTR__attribute__((always_inline))INLINE_KEYWORDFL2_COMPILER_H!defined(FL2_NO_INLINE)defined (__GNUC__) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L!defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 4 && __GNUC_MINOR__ >= 8 && __GNUC__ < 5__has_attribute((defined(__clang__) && __has_attribute(__target__)) \defined(NO_PREFETCH)defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )/* FL2_COMPILER_H *//* disable: C4324: padded structure *//* disable: C4214: non-int bitfields *//* disable: C4204: non-constant aggregate initializer *//* disable: C4127: conditional expression is constant *//* disable: C4100: unreferenced formal parameter *//* For Visual 2005 *//* disable warnings *//* NO_PREFETCH *//* disabled *//* locality *//* rw==read *//* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx *//* _mm_prefetch() is not defined outside of x86/x64 *//* prefetch
 * can be disabled, by declaring NO_PREFETCH build macro *//* Enable runtime BMI2 dispatch based on the CPU.
 * Enabled for clang & gcc >=4.8 on x86 when BMI2 isn't enabled by default.
 *//* Compatibility with non-clang compilers. *//* target attribute *//* force no inlining *//**
 * HINT_INLINE is used to help the compiler generate better code. It is *not*
 * used for "templates", so it can be tweaked based on the compilers
 * performance.
 *
 * gcc-4.8 and gcc-4.9 have been shown to benefit from leaving off the
 * always_inline attribute.
 *
 * clang up to 5.0.0 (trunk) benefit tremendously from the always_inline
 * attribute.
 *//**
 * FORCE_INLINE_TEMPLATE is used to define C "templates", which take constant
 * parameters. They must be inlined for the compiler to eliminate the constant
 * branches.
 *//* force inlining *//*-*******************************************************
*  Compiler specifics
*********************************************************//*
 * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
 * All rights reserved.
 * Modified for FL2 by Conor McCarthy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_internal.h"compiler.h"ZSTD_highbit32val != 0CHECK_E(f,e)do { size_t const errcod = f; if (FL2_isError(errcod)) return FL2_ERROR(e); } while(0)CHECK_F(f)do { size_t const errcod = f; if (FL2_isError(errcod)) return errcod; } while(0)MAX(a,b)((a)>(b) ? (a) : (b))MIN(a,b)((a)<(b) ? (a) : (b))MAXMINDEBUGLOG(l,__VA_ARGS__...){}RAWLOG(l,__VA_ARGS__...)FL2_STATIC_ASSERT(c){ enum { FL2_static_assert = 1/(int)(!!(c)) }; }assert(condition)((void)0)XXHASH_SIZEOFsizeof(XXH32_canonical_t)FL2_LZMA_PROP_MASK0x3FUFL2_PROP_HASH_BITFL2_ERROR(name)((size_t)-PREFIX(name))PREFIX(name)FL2_error_ ## nameFL2_INTERNAL_H_defined(FL2_DEBUG) && (FL2_DEBUG>=1)assertdefined(FL2_DEBUG) && (FL2_DEBUG>=2)defined(__GNUC__) && (__GNUC__ >= 3)/* FL2_INTERNAL_H_ *//* Software version *//* GCC Intrinsic *//* Visual *//* check and send Error code *//* check and Forward error code *//*-*************************************
*  shared macros
***************************************//* recommended values for FL2_DEBUG display levels :
 * 1 : no display, enables assert() only
 * 2 : reserved for currently active debugging path
 * 3 : events once per object lifetime (CCtx, CDict)
 * 4 : events once per frame
 * 5 : events once per block
 * 6 : events once per sequence (*very* verbose) *//*-*************************************
*  Debug
***************************************//*-*************************************
*  Stream properties
***************************************//*-****************************************
*  Error codes handling
******************************************//*-*************************************
*  Dependencies
***************************************//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/dict_buffer.c"fl2_internal.h""dict_buffer.h""Resetting dictionary after %u bytes", (unsigned)buf->total"Copy overlap data : %u bytes from %u", (unsigned)overlap, (unsigned)from"Move overlap data : %u bytes from %u", (unsigned)overlap, (unsigned)fromALIGNMENT_SIZEALIGNMENT_MASKconst BYTE *constBYTE **BYTE *constbuf->size - buf->endinput->size - input->posto_read"CStream : reading %u bytes", (U32)to_read"Added %u bytes to dict buffer %u", (unsigned)added_size, (unsigned)buf->indexbuf->end <= buf->size"Getting dict buffer %u, pos %u, avail %u", (unsigned)buf->index, (unsigned)buf->end, (unsigned)(buf->size - buf->end)(size_t)1 << 31((size_t)1 << 31)(~(size_t)(ALIGNMENT_SIZE-1))16U/* Switch buffers *//* New data will be written after the overlap *//* Copy to the alternate if one exists *//* No overlap means a simple buffer switch *//* Reset the dict if the next compression cycle would exceed the reset interval *//* Shift the overlap amount to the start of either the only dict buffer or the alternate one
 * if it exists *//* Shift occurs when all is processed and end is beyond the overlap size *//* Get the buffer, overlap and end for compression *//* Get the size of uncompressed data. start is set to end after compression *//* Read from input and write to the dict *//* Update with the amount added *//* Get the dictionary buffer for adding input *//* Free any existing buffers *//* Allocate if not yet allocated or existing dict too small *//* DICT_buffer functions *//*
* Copyright (c) 2019, Conor McCarthy
* All rights reserved.
*
* This source code is licensed under both the BSD-style license (found in the
* LICENSE file in the root directory of this source tree) and the GPLv2 (found
* in the COPYING file in the root directory of this source tree).
* You may select, at your option, one of the above-listed licenses.
*//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_errors.hFL2_ErrorCodeFL2_error_no_errorFL2_error_GENERICFL2_error_internalFL2_error_corruption_detectedFL2_error_checksum_wrongFL2_error_parameter_unsupportedFL2_error_parameter_outOfBoundFL2_error_lclpMax_exceededFL2_error_stage_wrongFL2_error_init_missingFL2_error_memory_allocationFL2_error_dstSize_tooSmallFL2_error_srcSize_wrongFL2_error_canceledFL2_error_bufferFL2_error_timedOutFL2_error_maxCodeFL2_ERRORS_H_398273423FL2_getErrorStringFL2_getErrorCode/* FL2_ERRORS_H_398273423 *//**< Same as FL2_getErrorName, but using a `FL2_ErrorCode` enum argument *//*! FL2_getErrorCode() :
    convert a `size_t` function result into a `FL2_ErrorCode` enum type,
    which can be used to compare with enum list published above *//* never EVER use this value directly, it can change in future versions! Use FL2_isError() instead *//*-****************************************
 *  error codes list
 *  note : this API is still considered unstable
 *         and shall not be used with a dynamic library.
 *         only static linking is allowed
 ******************************************//*===== dependency =====*/functionResult/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_mf.hRMF_memoryUsageRMF_getTableAsOutputBufferFL2_matchTable *FL2_matchTable_s *FL2_matchTable *constRMF_limitLengthsRMF_integrityCheckconst FL2_matchTableconst FL2_matchTable *const FL2_matchTable *constRMF_resetIncompleteBuildRMF_cancelBuildRMF_buildTableconst FL2_dataBlockRMF_initTableconst void *constRMF_initProgressRMF_threadCountRMF_applyParametersconst RMF_parametersconst RMF_parameters *const RMF_parameters *constRMF_compatibleParametersRMF_freeMatchTableRMF_createMatchTableRMF_parametersFL2_matchTableFL2_matchTable_sdivide_and_conqueroverlap_fractionmatch_buffer_resizedictionary_sizeRMF_MIN_BYTES_PER_THREADOVERLAP_FROM_DICT_SIZE(d,o)(((d) >> 4) * (o))RADIX_MF_H/* RADIX_MF_H */buffer_resizethread_counttbljobmulti_threaddict_reduce/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/atomic.hFL2_atomicFL2_nonAtomic_increment(n)(n++)FL2_atomic_add(n,a)__sync_fetch_and_add(&n, a)FL2_atomic_increment(n)__sync_fetch_and_add(&n, 1)ATOMIC_INITIAL_VALUEFL2_ATOMIC_H!defined(FL2_SINGLETHREAD) && defined(_WIN32)WINVER_WIN32_WINNTWIN32_LEAN_AND_MEAN!defined(FL2_SINGLETHREAD) && defined(__GNUC__)!defined(FL2_SINGLETHREAD) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)FL2_SINGLETHREAD/* FL2_ATOMIC_H *//* FL2_SINGLETHREAD *//* No atomics *//* C11 *//* atomic add *//*
 * Copyright (c) 2018 Conor McCarthy
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 *
 *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/lzma2_enc.h"atomic.h""radix_mf.h"LZMA2_encMemoryUsageconst FL2_strategyLZMA2_compressBoundLZMA2_getDictSizePropLZMA2_encodeLZMA2_ECtx *LZMA2_ECtx_s *LZMA2_ECtx *constconst FL2_lzma2Parametersconst FL2_lzma2Parameters *const FL2_lzma2Parameters *constFL2_atomic *FL2_atomic *constint *constLZMA2_hashAllocLZMA2_freeECtxLZMA2_createECtxFL2_lzma2ParametersLZMA2_ECtxLZMA2_ECtx_ssecond_dict_bitsmatch_cyclesfast_lengthENC_MIN_BYTES_PER_THREAD0x1C000LZMA2_END_MARKERkFastDistBits12URADYX_LZMA2_ENCODER_H/* RADYX_LZMA2_ENCODER_H *//* Enough for 8 threads, 1 Mb dict, 2/16 overlap *//* lzma2_enc.h -- LZMA2 Encoder
Based on LzmaEnc.h and Lzma2Enc.h : Igor Pavlov
Modified for FL2 by Conor McCarthy
Public domain
*/chain_logsrc_sizeoptionsstream_propprogress_inprogress_outcanceled/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_common.c"lzma2_enc.h""fl2_errors.h"const char *constnotErrorCodeno_errorGENERICinternalcorruption_detectedchecksum_wrongparameter_unsupportedparameter_outOfBoundlclpMax_exceededstage_wronginit_missingmemory_allocationdstSize_tooSmallsrcSize_wrongtimedOutNo error detected"No error detected"Error (generic)"Error (generic)"char[16]Internal error (bug)"Internal error (bug)"Corrupted block detected"Corrupted block detected"Restored data doesn't match checksum"Restored data doesn't match checksum"Unsupported parameter"Unsupported parameter"Parameter is out of bound"Parameter is out of bound"char[26]Parameters lc+lp > 4"Parameters lc+lp > 4"Not possible at this stage of encoding"Not possible at this stage of encoding"Context should be init first"Context should be init first"Allocation error : not enough memory"Allocation error : not enough memory"Destination buffer is too small"Destination buffer is too small"Src size is incorrect"Src size is incorrect"Processing was canceled by a call to FL2_cancelCStream() or FL2_cancelDStream()"Processing was canceled by a call to FL2_cancelCStream() or FL2_cancelDStream()"char[80]Streaming progress halted due to buffer(s) full/empty"Streaming progress halted due to buffer(s) full/empty"char[54]Wait timed out. Timeouts should be handled before errors using FL2_isTimedOut()"Wait timed out. Timeouts should be handled before errors using FL2_isTimedOut()"Unspecified error code"Unspecified error code"char[23](FL2_ErrorCode)018446744073709551601FL2_ERROR(timedOut)IsError18446744073709551596FL2_ERROR(maxCode)1.0.11000010001defined(FL2_DEBUG) && (FL2_DEBUG >= 2)/*! g_debuglog_enable :
 *  turn on/off debug traces (global switch) *//* following error codes are not stable and may be removed or changed in a future version *//*! FL2_getErrorString() :
 *  provides error code string from enum *//*! FL2_getError() :
 *  convert a `size_t` function result into a proper FL2_errorCode enum *//*! FL2_getErrorName() :
 *  provides error code string from function result (useful for debugging) *//*! FL2_isTimedOut() :
 *  tells if a return value is the timeout code *//*! FL2_isError() :
 *  tells if a return value is an error code *//*-****************************************
*  FL2 Error Management
******************************************//*-****************************************
*  Compression helpers
******************************************//*-****************************************
*  Version
******************************************//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/platform.hZSTD_NANOSLEEP_SUPPORTZSTD_SETPRIORITY_SUPPORT(PLATFORM_POSIX_VERSION >= 200112L)ZSTD_START_SYMBOLLIST_FRAMEZSTD_SPARSE_DEFAULTSET_SPARSE_FILE_MODE(file)SET_BINARY_MODE(file)IS_CONSOLE(stdStream)isatty(fileno(stdStream))PLATFORM_POSIX_VERSION__64BIT__PLATFORM_H_MODULE(_MSC_VER <= 1800)defined __ia64 || defined _M_IA64!defined(__64BIT__)!defined(__64BIT__) || defined(__MINGW32__)!defined(_FILE_OFFSET_BITS)!defined(_LARGEFILE_SOURCE)defined(_AIX) || defined(__hpux)(defined(__APPLE__) && defined(__MACH__)) || defined(__SVR4) || defined(_AIX) || defined(__hpux)!defined(_WIN32) \defined(__linux__) || defined(__linux)defined(_POSIX_VERSION)(defined(__linux__) && (PLATFORM_POSIX_VERSION > 1)) \defined(MSDOS) || defined(OS2) || defined(__CYGWIN__)defined(WIN32) || defined(_WIN32)defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(_WIN32)!defined(__DJGPP__)(defined(__APPLE__) && defined(__MACH__))defined __APPLE__(defined(__linux__) && (PLATFORM_POSIX_VERSION >= 199309L)) \_LP64__linux__unix__unix__/* PLATFORM_H_MODULE *//* mandates support of nanosleep() within <time.h> : http://man7.org/linux/man-pages/man2/nanosleep.2.html *//* mandates presence of <sys/resource.h> and support for setpriority() : http://man7.org/linux/man-pages/man2/setpriority.2.html *//* FSCTL_SET_SPARSE *//* DeviceIoControl, HANDLE, FSCTL_SET_SPARSE *//* _setmode, _fileno, _get_osfhandle *//* _O_BINARY *//******************************
*  OS-specific IO behaviors
******************************//* FILE *//* _isatty *//* isatty *//*-*********************************************
*  Detect if isatty() and fileno() are available
************************************************//* PLATFORM_POSIX_VERSION *//* non-unix target platform (like Windows) *//* POSIX compliant *//* declares _POSIX_VERSION *//* feature test macro : https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html *//* try to determine posix version through official unistd.h's _POSIX_VERSION (http://pubs.opengroup.org/onlinepubs/7908799/xsh/unistd.h.html).
 * note : there is no simple way to know in advance if <unistd.h> is present or not on target system,
 * Posix specification mandates its presence and its content, but target system must respect this spec.
 * It's necessary to _not_ #include <unistd.h> whenever target OS is not unix-like
 * otherwise it will block preprocessing stage.
 * The following list of build macros tries to "guess" if target OS is likely unix-like, and therefore can #include <unistd.h>
 *//* exception rule : force posix version to 200112L,
      * note: it's better to use unistd.h's _POSIX_VERSION whenever possible *//* BSD distros *//* POSIX.1-2001 (SUSv3) conformant *//* ************************************************************
*  Detect POSIX version
*  PLATFORM_POSIX_VERSION = 0 for non-Unix e.g. Windows
*  PLATFORM_POSIX_VERSION = 1 for Unix-like but non-POSIX
*  PLATFORM_POSIX_VERSION > 1 is equal to found _POSIX_VERSION
*  Value of PLATFORM_POSIX_VERSION can be forced on command line
***************************************************************//* Large file support on 32-bits AIX and HP-UX *//* Large File Support extension (LFS) - fseeko, ftello *//* obsolete macro, replaced with _FILE_OFFSET_BITS *//* turn off_t into a 64-bit type for ftello, fseeko *//* No point defining Large file for 64 bit but MinGW-w64 requires it *//* *********************************************************
*  Turn on Large Files support (>4GB) for 32-bit Linux/Unix
***********************************************************//* gcc *//* Cray *//* AIX *//* NetBSD, OpenBSD *//* MIPS 64-bit *//* ARM 64-bit *//* x86 64-bit *//* SPARC 64-bit *//* POWER 64-bit *//* Intel Itanium *//* **************************************
*  Detect 64-bit OS
*  http://nadeausoftware.com/articles/2012/02/c_c_tip_how_detect_processor_type_using_compiler_predefined_macros
****************************************//* snprintf unsupported by Visual <= 2013 *//* VS2005 - must be declared before <io.h> and <windows.h> *//* 1800 == Visual Studio 2013 *//* Disable Visual Studio warning messages for fopen, strncpy, strerror *//* **************************************
*  Compiler Options
****************************************//*
 * Copyright (c) 2016-present, Przemyslaw Skibinski, Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//usr/include/bits/types/struct_rusage.hrusage(unknown field)ru_stimeru_utime__ru_nivcsw_wordru_nivcsw__ru_nvcsw_wordru_nvcsw__ru_nsignals_wordru_nsignals__ru_msgrcv_wordru_msgrcv__ru_msgsnd_wordru_msgsnd__ru_oublock_wordru_oublock__ru_inblock_wordru_inblock__ru_nswap_wordru_nswap__ru_majflt_wordru_majflt__ru_minflt_wordru_minflt__ru_isrss_wordru_isrss__ru_idrss_wordru_idrss__ru_ixrss_wordru_ixrss__ru_maxrss_wordru_maxrss__rusage_defined/* Number of involuntary context switches, i.e. a higher priority process
       became runnable or the current process used up its time slice.  *//* Number of voluntary context switches, i.e. because the process
       gave up the process before it had to (usually to wait for some
       resource to be available).  *//* Number of signals delivered.  *//* Number of IPC messages received.  *//* Number of IPC messages sent.  *//* Number of output operations via the file system.  *//* Number of input operations via the file system.  Note: This
       and `ru_oublock' do not include operations with the cache.  *//* Number of times a process was swapped out of physical memory.  *//* Number of hard page faults (i.e. those that required I/O).  *//* Number of soft page faults (i.e. those serviced by reclaiming
       a page from the list of pages awaiting reallocation.  *//* Amount of stack memory used (kilobyte-seconds).  *//* Amount of data segment memory used (kilobyte-seconds).  *//* Amount of sharing of text segment memory
       with other processes (kilobyte-seconds).  *//* Maximum resident set size (in kilobytes).  *//* Total amount of system time used.  *//* Total amount of user time used.  *//* The purpose of all the unions is to have the kernel-compatible layout
   while keeping the API type as 'long int', and among machines where
   __syscall_slong_t is not 'long int', this only does the right thing
   for little-endian ones, like x32.  *//* Structure which says how much of each resource has been used.  If
   the system does not keep track of a particular value, the struct
   field is always zero.  *//* Define struct rusage.
   Copyright (C) 1994-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/resource.h<bits/types/struct_rusage.h>__priority_whichPRIO_PROCESSPRIO_PGRPPRIO_USER__rusage_whoRUSAGE_SELFRUSAGE_CHILDRENrlimitrlim_t__rlimit_resourceRLIMIT_CPURLIMIT_FSIZERLIMIT_DATARLIMIT_STACKRLIMIT_CORE__RLIMIT_RSSRLIMIT_NOFILE__RLIMIT_OFILERLIMIT_AS__RLIMIT_NPROC__RLIMIT_MEMLOCK__RLIMIT_LOCKS__RLIMIT_SIGPENDING__RLIMIT_MSGQUEUE__RLIMIT_NICE__RLIMIT_RTPRIO__RLIMIT_RTTIME__RLIMIT_NLIMITS__RLIM_NLIMITSrlim_maxrlim_curPRIO_MAXPRIO_MINRLIM_SAVED_CURRLIM_INFINITYRLIM_SAVED_MAX((__rlim_t) -1)RLIM_NLIMITSRLIMIT_NLIMITSRLIMIT_RTTIMERLIMIT_RTPRIORLIMIT_NICERLIMIT_MSGQUEUERLIMIT_SIGPENDINGRLIMIT_LOCKSRLIMIT_MEMLOCKRLIMIT_NPROCRLIMIT_OFILERLIMIT_RSS_SYS_RESOURCE_H/* Modify and return resource limits of a process atomically.  *//* WHO is a user ID.  *//* WHO is a process group ID.  *//* WHO is a process ID.  *//* The type of the WHICH argument to `getpriority' and `setpriority',
   indicating what flavor of entity the WHO argument specifies.  *//* Maximum priority a process can have.  *//* Minimum priority a process can have.  *//* Priority limits.  *//* Name for the same functionality on Solaris.  *//* The calling thread.  *//* All of its terminated child processes.  *//* The calling process.  *//* Whose usage statistics do you want?  *//* The hard limit.  *//* The current (soft) limit.  *//* Type for resource quantity measurement.  *//* We can represent all limits.  *//* Value to indicate that there is no limit.  *//* Maximum CPU time in microseconds that a process scheduled under a real-time
     scheduling policy may consume without making a blocking system
     call before being forcibly descheduled.  *//* Maximum realtime priority allowed for non-priviledged
     processes.  *//* Maximum nice priority allowed to raise to.
     Nice levels 19 .. -20 correspond to 0 .. 39
     values of this resource limit.  *//* Maximum bytes in POSIX message queues.  *//* Maximum number of pending signals.  *//* Maximum number of file locks.  *//* Locked-in-memory address space.  *//* Number of processes.  *//* Address space limit.  *//* BSD name for same.  *//* Number of open files.  *//* Largest resident set size, in bytes.
     This affects swapping; processes that are exceeding their
     resident set size will be more likely to have physical memory
     taken from them.  *//* Largest core file that can be created, in bytes.  *//* Maximum size of stack segment, in bytes.  *//* Maximum size of data segment, in bytes.  *//* Largest file that can be created, in bytes.  *//* Per-process CPU limit, in seconds.  *//* Kinds of resource limit.  *//* Transmute defines to enumerations.  The macro re-definitions are
   necessary because some programs want to test for operating system
   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
   definition is a no-op.  *//* Bit values & structures for resource limits.  Linux version.
   Copyright (C) 1994-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/sys/resource.h<bits/resource.h>setprioritygetprioritygetrusagerusage *setrlimitconst rlimitconst rlimit *rlimit *getrlimit__priority_which_t__rusage_who_t__rlimit_resource_tdefined __USE_GNU && !defined __cplusplus/* sys/resource.h  *//* Set the priority of all processes specified by WHICH and WHO (see above)
   to PRIO.  Returns 0 on success, -1 on errors.  *//* Return the highest priority of any process specified by WHICH and WHO
   (see above); if WHO is zero, the current process, process group, or user
   (as specified by WHO) is used.  A lower priority number means higher
   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  *//* Return resource usage information on process indicated by WHO
   and put it in *USAGE.  Returns 0 for success, -1 for failure.  *//* Set the soft and hard limits for RESOURCE to *RLIMITS.
   Only the super-user can increase hard limits.
   Return 0 if successful, -1 if not (and sets errno).  *//* Put the soft and hard limits for RESOURCE in *RLIMITS.
   Returns 0 if successful, -1 if not (and sets errno).  *//* The X/Open standard defines that all the functions below must use
   `int' as the type for the first argument.  When we are compiling with
   GNU extensions we change this slightly to provide better error
   checking.  *//* Get the system-dependent definitions of structures and bit values.  */__which__who__usage__resource__rlimits/usr/include/bits/dirent.hdirentchar[256]d_named_typed_reclend_offd_ino_DIRENT_MATCHES_DIRENT64_DIRENT_HAVE_D_TYPE_DIRENT_HAVE_D_OFF_DIRENT_HAVE_D_RECLEN_DIRENT_HAVE_D_NAMLENd_fileno_DIRENT_Hdefined __OFF_T_MATCHES_OFF64_T && defined __INO_T_MATCHES_INO64_T/* Inform libc code that these two types are effectively identical.  *//* Backwards compatibility.  *//* We must not include limits.h! *//* Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/bits/dirent_ext.h/* Read from the directory descriptor FD into LENGTH bytes at BUFFER.
   Return the number of bytes read on success (0 for end of
   directory), and -1 for failure.  *//* System-specific extensions of <dirent.h>.  Linux version.
   Copyright (C) 2019-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/dirent.h<bits/dirent_ext.h><bits/posix1_lim.h><bits/dirent.h>getdirentries__off_t *__off_t *__restrict__alphasortconst direntconst dirent *dirent *const dirent **dirent **scandirdirent ***dirent ***__restrict__dirfdDIR *__dirstream *telldirseekdirrewinddirreaddir_rDIR *__restrict__dirent *__restrict__dirent **__restrict__readdirfdopendiropendirclosedirDIR__dirstreamDT_UNKNOWNDT_FIFODT_CHRDT_DIRDT_BLKDT_REGDT_LNKDT_SOCKDT_WHTMAXNAMLENNAME_MAXDTTOIF(dirtype)((dirtype) << 12)IFTODT(mode)(((mode) & 0170000) >> 12)_D_ALLOC_NAMLEN(d)(((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])_D_EXACT_NAMLEN(d)(strlen ((d)->d_name))defined __USE_MISC && !defined d_filenodefined __OPTIMIZE__ && defined _DIR_dirfddefined __USE_GNU && defined __USE_LARGEFILE64/* dirent.h  *//* Function to compare two `struct dirent's by name & version.  *//* Read directory entries from FD into BUF, reading at most NBYTES.
   Reading starts at offset *BASEP, and *BASEP is updated with the new
   position after reading.  Returns the number of bytes read; zero when at
   end of directory; or -1 for errors.  *//* Use XPG7.  *//* Function to compare two `struct dirent's alphabetically.  *//* This function is like `scandir' but it uses the 64bit dirent structure.
   Please note that the CMP function must now work with struct dirent64 **.  *//* Similar to `scandir' but a relative DIR name is interpreted relative
   to the directory for which DFD is a descriptor.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Scan the directory DIR, calling SELECTOR on each directory entry.
   Entries for which SELECT returns nonzero are individually malloc'd,
   sorted using qsort with CMP, and collected in a malloc'd array in
   *NAMELIST.  Returns the number of entries selected, or -1 on error.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  *//* Get the definitions of the POSIX.1 limits.  *//* Return the file descriptor used by DIRP.  *//* Return the current position of DIRP.  *//* Seek to position POS on DIRP.  *//* Rewind DIRP to the beginning of the directory.  *//* POSIX or misc *//* Reentrant version of `readdir'.  Return in RESULT a pointer to the
   next entry.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read a directory entry from DIRP.  Return a pointer to a `struct
   dirent' describing the entry, or NULL for EOF or error.  The
   storage returned may be overwritten by a later readdir call on the
   same DIR stream.

   If the Large File Support API is selected we have to use the
   appropriate interface.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Same as opendir, but open the stream on the file descriptor FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Open a directory stream on NAME.
   Return a DIR stream on the directory, or NULL if it could not be opened.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Close the directory stream DIRP.
   Return 0 if successful, -1 if not.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* This is the data type of directory stream objects.
   The actual structure is opaque to users.  *//* Convert between stat structure types and directory types.  *//* File types for `d_type'.  *//* These macros extract size information from a `struct dirent *'.
   They may evaluate their argument multiple times, so it must not
   have side effects.  Each of these may involve a relatively costly
   call to `strlen' on some systems, so these values should be cached.

   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
   its terminating null character.

   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
   that is, the allocation size needed to hold the DP->d_name string.
   Use this macro when you don't need the exact length, just an upper bound.
   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
   *//* This file defines `struct dirent'.

   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
   member that gives the length of `d_name'.

   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
   member that gives the size of the entire directory entry.

   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
   member that gives the file offset of the next directory entry.

   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
   member that gives the type of the file.
 *//*
 *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>
 */__basep__e1__e2__namelist__selector__cmp__dirp__entry/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/util.h<dirent.h><sys/resource.h>"platform.h"UTIL_countPhysicalCoresUTIL_freeFileListconst char **UTIL_createFileListUTIL_prepareFileListUTIL_reallocnewptrUTIL_getTotalFileSizeconst char *const *const char *const *constUTIL_getFileSizeUTIL_isLinkUTIL_getFileStatstat_t *UTIL_isDirectoryUTIL_setFileStatUTIL_isRegularFileUTIL_fileExistUTIL_waitForNextTickUTIL_clockSpanNanoUTIL_clockSpanMicroUTIL_getSpanTimeNanoUTIL_getSpanTimeMicroUTIL_getTimeUTIL_getSpanTimestat_tUTIL_time_tUTIL_freq_tg_utilDisplayLevelUTIL_HAS_CREATEFILELISTUTIL_FILESIZE_UNKNOWN((U64)(-1))SEC_TO_MICRO1000000UTIL_TIME_INITIALIZER{ 0, 0 }UTIL_DISPLAYLEVEL(l,__VA_ARGS__...){ if (g_utilDisplayLevel>=l) { UTIL_DISPLAY(__VA_ARGS__); } }UTIL_DISPLAY(__VA_ARGS__...)fprintf(stderr, __VA_ARGS__)UTIL_STATICstatic __attribute__((unused))LIST_SIZE_INCREASE(8*1024)SET_REALTIME_PRIORITYsetpriority(PRIO_PROCESS, 0, -20)UTIL_sleepMilli(milli){ struct timespec t; t.tv_sec=0; t.tv_nsec=milli*1000000ULL; nanosleep(&t, NULL); }UTIL_sleep(s)sleep(s)UTIL_fseekUTIL_H_MODULE!defined(__64BIT__) && (PLATFORM_POSIX_VERSION >= 200112L)defined(__MINGW32__) && defined(__MSVCRT__) && !defined(__STRICT_ANSI__) && !defined(__NO_MINGW_LFS)PLATFORM_POSIX_VERSION > 0defined(__APPLE__) && defined(__MACH__)(PLATFORM_POSIX_VERSION >= 200112L) \defined(__linux__) || (PLATFORM_POSIX_VERSION >= 200112L)/* UTIL_H_MODULE *//*
 * UTIL_createFileList - takes a list of files and directories (params: inputNames, inputNamesNb), scans directories,
 *                       and returns a new list of files (params: return value, allocatedBuffer, allocatedNamesNb).
 * After finishing usage of the list the structures should be freed with UTIL_freeFileList(params: return value, allocatedBuffer)
 * In case of error UTIL_createFileList returns NULL and UTIL_freeFileList should not be called.
 *//* #ifdef _WIN32 *//* strerror, memcpy *//* opendir, readdir *//* opendir, readdir require POSIX.1-2001 *//*
 * A modified version of realloc().
 * If UTIL_realloc() fails the original block is freed.
*//*-****************************************
*  File functions
******************************************//* returns time span in microseconds *//* relies on standard C (note : clock_t measurements can be wrong when using multi-threading) *//* Windows *//*-****************************************
*  Time functions
******************************************//*-****************************************
*  Console log
******************************************//* disable: message #177: function was declared but never referenced, useful with UTIL_STATIC *//*-*************************************
*  Constants
***************************************//* unknown non-unix operating systen *//* setpriority *//* necessarily defined in platform.h *//* sleep *//* Unix-like operating system *//*-*************************************************
*  Sleep & priority functions: Windows - Posix - others
***************************************************//* No point defining Large file for 64 bit *//*-************************************************************
* Avoid fseek()'s 2GiB barrier with MSVC, macOS, *BSD, MinGW
***************************************************************//* U32, U64 *//* clock_t, clock, CLOCKS_PER_SEC, nanosleep *//* utime *//* chown, stat *//* _chmod *//* stat, chmod *//* stat, utime *//* fprintf *//* malloc, realloc, free *//* PLATFORM_POSIX_VERSION, ZSTD_NANOSLEEP_SUPPORT, ZSTD_SETPRIORITY_SUPPORT */filenameTableallocatedBufferinputNamesinputNamesNballocatedNamesNbfollowLinksdirNamebufStartbufEndfileNamesTablenbFilesinfilenamefilenameclockStartclockEnd/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_internal.hRMF_structuredGetMatchconst FL2_matchTable_sconst FL2_matchTable_s *const FL2_matchTable_s *constsize_t *constRMF_bitpackGetMatchRMF_structuredAsOutputBufferFL2_matchTable_s *constRMF_bitpackAsOutputBufferRMF_structuredLimitLengthsRMF_bitpackLimitLengthsRMF_structuredIntegrityCheckRMF_bitpackIntegrityCheckRMF_recurseListChunkRMF_builder *RMF_builder *constconst U32RMF_structuredBuildTableRMF_bitpackBuildTableRMF_structuredInitRMF_bitpackInitRMF_unitRMF_builderRMF_buildMatchsrc_data_uRMF_tableHeadRMF_listTailUNIT_BITS1 << UNIT_BITSU32[4]linksU32[1]RMF_tableHead[65536]struct <unnamed>[65536]RADIX16_TABLE_SIZElist_headsU32[65536]unsigned int[65536]RMF_builder **buildersRMF_buildMatch[1]struct <unnamed>[1]match_bufferu32charsRMF_listTail[65536]tails_16RMF_tableHead[196608]struct <unnamed>[196608]STACK_SIZERMF_listTail[256]struct <unnamed>[256]RADIX8_TABLE_SIZEtails_8list_countprev_indexmatch_buffer_limitmatch_buffer_sizeU32 *unreduced_dict_sizealloc_structis_structend_indexst_indexRADIX_CANCEL_INDEX(long)(RADIX16_TABLE_SIZE + FL2_MAXTHREADS + 2)UNIT_MASK((1U << UNIT_BITS) - 1)RADIX_NULL_LINK0xFFFFFFFFURADIX_LINK_MASK((1U << RADIX_LINK_BITS) - 1)RADIX_LINK_BITSSTRUCTURED_MAX_LENGTH255UBITPACK_MAX_LENGTH63UMATCH_BUFFER_OVERLAPBUFFER_LINK_MASK0xFFFFFFUMAX_BRUTE_FORCE_LIST_SIZE(RADIX16_TABLE_SIZE * 3)((size_t)1 << 8)((size_t)1 << 16)MAX_REPEATDICTIONARY_SIZE_MAX_32((size_t)1 << DICTIONARY_LOG_MAX_32)DICTIONARY_SIZE_MAX_64((size_t)1 << DICTIONARY_LOG_MAX_64)DICTIONARY_SIZE_MIN((size_t)1 << DICTIONARY_LOG_MIN)DICTIONARY_LOG_MAX_3227UDICTIONARY_LOG_MAX_6430UDICTIONARY_LOG_MINRADIX_INTERNAL_Hdefined(FL2_XZ_BUILD) && defined(TUKLIB_FAST_UNALIGNED_ACCESS)/* RADIX_INTERNAL_H */offset_ptrdata_blockstack_base/usr/include/sys/time.hfutimesconst timevalconst timeval[2]timeval[2]lutimesutimessetitimerconst itimervalconst itimerval *itimerval *const itimerval *__restrict__itimerval *__restrict__getitimeradjtimeconst timeval *settimeofdayconst timezoneconst timezone *timezone *gettimeofday__itimer_which_titimerval__itimer_whichITIMER_REALITIMER_VIRTUALITIMER_PROFtz_dsttimetz_minuteswesttimersub(a,b,result)do { (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; if ((result)->tv_usec < 0) { --(result)->tv_sec; (result)->tv_usec += 1000000; } } while (0)timeradd(a,b,result)do { (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; if ((result)->tv_usec >= 1000000) { ++(result)->tv_sec; (result)->tv_usec -= 1000000; } } while (0)timercmp(a,b,CMP)(((a)->tv_sec == (b)->tv_sec) ? ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))timerclear(tvp)((tvp)->tv_sec = (tvp)->tv_usec = 0)timerisset(tvp)((tvp)->tv_sec || (tvp)->tv_usec)_SYS_TIME_H/* sys/time.h *//* Misc.  *//* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  *//* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  *//* Same as `utimes', but takes an open file descriptor instead of a name.  *//* Same as `utimes', but does not follow symbolic links.  *//* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  *//* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  *//* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  *//* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  *//* Time to the next timer expiration.  *//* Value to put into `it_value' when the timer expires.  *//* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  *//* Timers run when the process is executing and when
       the system is executing on behalf of the process.  *//* Timers run only when the process is executing.  *//* Timers run in real time.  *//* Values for the first argument to `getitimer' and `setitimer'.  *//* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  *//* Set the current time of day and timezone information.
   This call is restricted to the super-user.
   Setting the timezone in this way is obsolete, but we don't yet
   warn about it because it still has some uses for which there is
   no alternative.  *//* Get the current time of day, putting it into *TV.
   If TZ is not null, *TZ must be a struct timezone, and both fields
   will be set to zero.
   Calling this function with a non-null TZ is obsolete;
   use localtime etc. instead.
   This function itself is semi-obsolete;
   most callers should use time or clock_gettime instead. *//* Nonzero if DST is ever in effect.  *//* Minutes west of GMT.  *//* Structure crudely representing a timezone.
   This is obsolete and should never be used.  *//* Macros for converting between `struct timeval' and `struct timespec'.  */__tvp__olddelta__tv__tzsched_param_BITS_TYPES_STRUCT_SCHED_PARAM/* bits/types/struct_sched_param.h *//* Data structure to describe a process' schedulability.  *//* Sched parameter structure.  Generic version.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library;  if not, see
   <https://www.gnu.org/licenses/>.  */__sched_cpufree__sched_cpualloc__sched_cpucountcpu_set_t__cpu_mask__NCPUBITS__bits__CPU_FREE(cpuset)__sched_cpufree (cpuset)__CPU_ALLOC(count)__sched_cpualloc (count)__CPU_ALLOC_SIZE(count)((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))__CPU_OP_S(setsize,destset,srcset1,srcset2,op)(__extension__ ({ cpu_set_t *__dest = (destset); const __cpu_mask *__arr1 = (srcset1)->__bits; const __cpu_mask *__arr2 = (srcset2)->__bits; size_t __imax = (setsize) / sizeof (__cpu_mask); size_t __i; for (__i = 0; __i < __imax; ++__i) ((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i]; __dest; }))__CPU_EQUAL_S(setsize,cpusetp1,cpusetp2)(__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)__CPU_COUNT_S(setsize,cpusetp)__sched_cpucount (setsize, cpusetp)__CPU_ISSET_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] & __CPUMASK (__cpu))) != 0 : 0; }))__CPU_CLR_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] &= ~__CPUMASK (__cpu)) : 0; }))__CPU_SET_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))__CPU_ZERO_S(setsize,cpusetp)do __builtin_memset (cpusetp, '\0', setsize); while (0)__CPUMASK(cpu)((__cpu_mask) 1 << ((cpu) % __NCPUBITS))__CPUELT(cpu)((cpu) / __NCPUBITS)(8 * sizeof (__cpu_mask))_BITS_CPU_SET_H__GNUC_PREREQ (2, 91)/* bits/cpu-set.h *//* Access functions for CPU masks.  *//* Data structure to describe CPU mask.  *//* Basic access functions.  *//* Type for array elements in 'cpu_set_t'.  *//* Size definition for CPU sets.  *//* Definition of the cpu_set_t structure used by the POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__set__setsize__setplong[8]__jmp_buf_BITS_SETJMP_H!defined _SETJMP_H && !defined _PTHREAD_H_ASMdefined  __x86_64__/* bits/setjmp.h *//* Define the machine-dependent type `jmp_buf'.  x86-64 version.  *//* Copyright (C) 2001-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__jmp_buf_tag__saved_mask__jmpbuf__jmp_buf_tag_defined/* Saved signal mask.  *//* Saved the signal mask?  *//* Calling environment.  *//* NOTE: The machine-dependent definitions of `__sigsetjmp'
       assume that a `jmp_buf' begins with a `__jmp_buf' and that
       `__mask_was_saved' follows it.  Do not move these members
       or add others before it.  *//* Calling environment, plus possibly a saved signal mask.  *//* Get `__jmp_buf'.  *//* Define struct __jmp_buf_tag.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_threading.h<sys/time.h>FL2_pthread_cond_timedwaitcondtimemythread_condtime_setnow1000L10000000001000000000LFL2_checkNbThreadsFL2_pthread_join(a,b)pthread_join((a),(b))FL2_pthread_create(a,b,c,d)pthread_create((a), (b), (c), (d))FL2_pthread_tFL2_pthread_cond_broadcast(a)pthread_cond_broadcast((a))FL2_pthread_cond_signal(a)pthread_cond_signal((a))FL2_pthread_cond_wait(a,b)pthread_cond_wait((a), (b))FL2_pthread_cond_destroy(a)pthread_cond_destroy((a))FL2_pthread_cond_init(a,b)pthread_cond_init((a), (b))FL2_pthread_cond_tFL2_pthread_mutex_unlock(a)pthread_mutex_unlock((a))FL2_pthread_mutex_lock(a)pthread_mutex_lock((a))FL2_pthread_mutex_destroy(a)pthread_mutex_destroy((a))FL2_pthread_mutex_init(a,b)pthread_mutex_init((a), (b))FL2_pthread_mutex_tMYTHREAD_POSIXTHREADING_H_938743FL2_XZ_BUILDdefined(HAVE_CONFIG_H)!defined(FL2_SINGLETHREAD) && defined(MYTHREAD_VISTA)!defined(FL2_SINGLETHREAD) && defined(MYTHREAD_POSIX)defined(FL2_SINGLETHREAD)/* THREADING_H_938743 *//* do not use FL2_pthread_t *//* No multithreading support *//* Waits on a condition or until a timeout expires. If the timeout expires,
 * non-zero is returned, otherwise zero is returned.
 *//* tv_nsec must stay in the range [0, 999_999_999]. *//* Sets condtime to the absolute time that is timeout_ms milliseconds
 * in the future.
 *//* Timed wait functions from XZ by Lasse Collin
*//* ===   POSIX Systems   === *//**
 * add here more wrappers as required
 *//* FL2_pthread_create() and FL2_pthread_join() *//* No delete *//* condition variable *//* mutex *//**
 * Windows minimalist Pthread Wrapper, based on :
 * http://www.cse.wustl.edu/~schmidt/win32-cv-1.html
 *//* posix assumed ; need a better detection method *//**
 * Copyright (c) 2016 Tino Reichardt
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 *
 * You can contact the author at:
 * - zstdmt source repository: https://github.com/mcmilk/zstdmt
 */condmutextimeout_ms/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_pool.hFL2POOL_threadsBusyFL2POOL_waitAllFL2POOL_addRangeFL2POOL_addFL2POOL_sizeofFL2POOL_ctx *FL2POOL_ctx_s *FL2POOL_freeFL2POOL_createFL2POOL_functionFL2POOL_ctxFL2POOL_ctx_sFL2POOL_H/*! FL2POOL_add() :
Add the job `function(opaque)` to the thread pool.
FL2POOL_addRange adds multiple jobs with size_t parameter from first to less than end.
Possibly blocks until there is room in the queue.
Note : The function may be executed asynchronously, so `opaque` must live until the function has been completed.
*//*! FL2POOL_function :
The function type that can be added to a thread pool.
*//*! FL2POOL_sizeof() :
return memory usage of pool returned by FL2POOL_create().
*//*! FL2POOL_free() :
Free a thread pool returned by FL2POOL_create().
*//*! FL2POOL_create() :
*  Create a thread pool with at most `numThreads` threads.
* `numThreads` must be at least 1.
* @return : FL2POOL_ctx pointer on success, else NULL.
*//*
* Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
* All rights reserved.
* Modified for FL2 by Conor McCarthy
*
* This source code is licensed under both the BSD-style license (found in the
* LICENSE file in the root directory of this source tree) and the GPLv2 (found
* in the COPYING file in the root directory of this source tree).
* You may select, at your option, one of the above-listed licenses.
*/firstctxVoid/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_compress_internal.h"fl2_pool.h""fl2_threading.h""radix_internal.h"FL2_jobFL2_CCtx_paramsFL2_job[1]jobscSizejobCountlockParamsloopCountendMarkedwrotePropprogressOutprogressInencWeightrmfWeightmatchTablestreamCsizestreamTotaldictMaxoutThreadthreadCountasyncRescurBlockcompressThreadfactoryomitPropdoXXHhighCompressionrParamscParamsFL2_COMPRESS_H/* FL2_COMPRESS_H *//*-*************************************
*  Context memory management
***************************************//*
 * Copyright (c) 2018, Conor McCarthy
 * All rights reserved.
 * Parts based on zstd_compress_internal.h copyright Yann Collet
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//usr/include/bits/posix1_lim.h/usr/include/bits/local_lim.h/usr/include/linux/limits.h/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_compress.c"fl2_compress_internal.h""util.h"const FL2_compressionParameters[11]struct <unnamed>[11]FL2_MAX_CLEVELFL2_CLEVEL_DEFAULT18446744073709551610FL2_memoryUsage_internalFL2_MAX_HIGH_CLEVELFL2_ERROR(parameter_outOfBound)18446744073709551607FL2_ERROR(init_missing)prevOutFL2_flushStream_internal(fcs, 1)errcodFL2_CStream *constFL2_loopCheck(fcs, output != NULL && prevOut == output->pos)FL2_loopCheck(fcs, output != ((void *)0) && prevOut == output->pos)FL2_flushStream_internalfcs->asyncRes"FL2_flushStream_internal : %u to compress, %u to write", (U32)(fcs->buf.end - fcs->buf.start), (U32)FL2_remainingOutputSize(fcs)FL2_compressStream_internal(fcs, ending)FL2_writeEndFL2_job *"Writing property byte : 0x%X", dst[pos]FL2_CCtx *const"Writing end marker""Writing XXH32"canonicalconst FL2_jobconst FL2_job *const U64encodeSizebufferResizeendingFL2_waitCStream(fcs)FL2_compressStream_internal(fcs, 0)prevInFL2_compressStream_input(fcs, input)FL2_loopCheck(fcs, prevIn == input->pos && (output == NULL || prevOut == output->pos))FL2_loopCheck(fcs, prevIn == input->pos && (output == ((void *)0) || prevOut == output->pos))FL2_loopCheckFL2_MAX_LOOPS18446744073709551602FL2_ERROR(buffer)FL2_compressStream_inputtoWrite - fcs->outPos"CStream : writing %u bytes", (U32)toWritedstBuftoWriteFL2_compressStream_internalfcs->dictMaxfcs->curBlock.end"Writing property byte : 0x%X", streamPropFL2_compressCurBlock(fcs, streamProp)streamProp18446744073709551606FL2_ERROR(memory_allocation)"FL2_initCStream level %d", compressionLeveldoHashfcs->params.rParams.dictionary_sizefcs->params.rParams.overlap_fractiondictOverlapFL2_beginFrame(fcs, 0)unchangeddictLog18446744073709551611FL2_ERROR(parameter_unsupported)18446744073709551608FL2_ERROR(stage_wrong)((unsigned)(sizeof(size_t) == 4 ? 27 : 30))(1U << ((unsigned)(sizeof(size_t) == 4 ? 27 : 30)))(unsigned)FL2_ultraconst FL2_compressionParameters *const18446744073709551609FL2_ERROR(lclpMax_exceeded)18446744073709551605FL2_ERROR(dstSize_tooSmall)"FL2_compressCCtx : level %u, %u src => %u avail", cctx->params.compressionLevel, (U32)srcSize, (U32)dstCapacityFL2_beginFrame(cctx, srcSize)void *const"Writing hash"FL2_compressBuffercctx->params.rParams.overlap_fractionblockOverlapblockTotaldictionarySize - cctx->curBlock.startFL2_compressCurBlock(cctx, streamProp)"Write thread %u : %u bytes", (U32)u, (U32)cctx->jobs[u].cSizedictionarySize - blockOverlap"Resetting dictionary after %u bytes", (unsigned)blockTotalFL2_endFrameFL2_beginFrame"Have compatible match table"RMF_parameters *FL2_preBeginFrameFL2_getPropFL2_compressCurBlockcctx->dictMaxcctx->curBlock.enddepthWeightFL2_compressCurBlock_asyncFL2_compressCurBlock_blockingmfThreadscctx->jobCountencodeSize / ENC_MIN_BYTES_PER_THREADencodeSize / 0x1C000114688"FL2_compressCurBlock : %u threads, %u start, %u bytes", (U32)nbThreads, (U32)cctx->curBlock.start, (U32)encodeSizesliceStartsliceSize18446744073709551603FL2_ERROR(canceled)RMF_threadCount(cctx->matchTable)dictReducejobDescriptionerrFL2_lzma2Parameters *FL2_initProgressFL2_initEncodersFL2_compressRadixChunkFL2_buildRadixTable"FL2_freeCCtx : %u threads", cctx->jobCountFL2_createCCtx_internal"FL2_createCCtxMt : %u threads", nbThreads352sizeof(FL2_CCtx)sizeof(FL2_job)FL2_fillParametersFL2_lzma2Parameters *constRMF_parameters *constparams->dictionarySizeFL2_highCParameters1 MB2 MB4 MB8 MB16 MB32 MB64 MB128 MB256 MB512 MBFL2_defaultCParametersCLAMPCHECK(val,min,max)do { if (((val)<(min)) | ((val)>(max))) { return FL2_ERROR(parameter_outOfBound); } } while(0)MAXCHECK(val,max)do { if ((val)>(max)) { return FL2_ERROR(parameter_outOfBound); } } while(0)MB*(1U<<20)10Udefined(FL2_7ZIP_BUILD)RMF_CHECK_INTEGRITY/* no compression occurred *//* Write the properties byte (if required), the hash and the end marker
 * into the output buffer.
 *//* break if the compressor is not available *//* cannot shift single dict during compression *//* read input until the buffer(s) are full *//* If the slice is not flushed, the output is full *//* Copy the compressed output stored in the match table buffer.
 * One slice exists per thread.
 *//* If the LZMA2 property byte is required and not already written,
             * pass it to the compression function 
             *//* no compression can occur while compressed output exists *//* Only free the thread if not dual buffering and compression not underway *//* Free unsuitable objects before reallocating anything new *//* lc, lp, pb can be changed between encoder chunks.
         * A condition where lc+lp > 4 is permitted to allow sequential setting,
         * but will return an error code to alert the calling function.
         * If lc+lp is still >4 when encoding begins, lc will be reduced. *//* No async compression for in-memory function *//* empty LZMA2 stream is byte sequence {0, 0} *//* periodically reset the dictionary for mt decompression *//* Compress a memory buffer which may be larger than the dictionary.
 * The property byte is written first unless the omit flag is set.
 * Return: compressed size.
 *//* Create hash objects together, leaving the (large) match table last *//* Free unsuitable match table before reallocating anything else *//* FL2_getProp() :
 * Get the LZMA2 dictionary size property byte. If xxhash is enabled, includes the xxhash flag bit.
 *//* update largest dict size used *//* FL2_compressCurBlock() :
 * Update total input size.
 * Clear the compressed data buffers.
 * Init progress info.
 * Start compression of cctx->curBlock, and wait for completion if no async compression thread exists.
 *//* FL2_compressCurBlock_async() : FL2POOL_function type *//* initialize to length 2 *//* FL2_compressCurBlock_blocking() :
 * Compress cctx->curBlock and wait until complete.
 * Write streamProp as the first byte if >= 0
 *//* FL2_compressRadixChunk() : FL2POOL_function type *//* FL2_buildRadixTable() : FL2POOL_function type *//* allows for reduced dict in 32-bit version *//* 10 *//* 9 *//* 8 *//* 7 *//* 6 *//* 5 *//* 4 *//* 3 *//* 2 *//* 1 *//*-=====  Pre-defined compression levels  =====-*//*
* Copyright (c) 2018, Conor McCarthy
* All rights reserved.
* Parts based on zstd_compress.c copyright Yann Collet
*
* This source code is licensed under both the BSD-style license (found in the
* LICENSE file in the root directory of this source tree) and the GPLv2 (found
* in the COPYING file in the root directory of this source tree).
* You may select, at your option, one of the above-listed licenses.
*//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/lzma2_dec.hLZMA2_parseInputLZMA2_chunk *LZMA2_chunk *constLZMA2_decodeToBufLZMA2_DCtx *LZMA2_DCtx *constconst LZMA2_finishModeLZMA2_decodeToDicLZMA2_initDecoderLZMA2_decMemoryUsageLZMA2_getUnpackSizeLZMA2_getDictSizeFromPropLZMA_destructDCtxLZMA_constructDCtxLZMA2_chunkLZMA2_parseResCHUNK_MORE_DATACHUNK_CONTINUECHUNK_DICT_RESETCHUNK_FINALCHUNK_ERRORLZMA2_statusLZMA_STATUS_FINISHEDLZMA_STATUS_OUTPUT_FULLLZMA2_finishModeLZMA2_DCtxLZMA2_probLZMA2_propsunpack_sizepack_sizeLZMA2_prob[14272]unsigned int[14272]kLzmaLitSize(U32)kLzmaLitSizekLzma2LcLpMax12288(U32)kLzmaLitSize << kLzma2LcLpMax((U32)kLzmaLitSize << kLzma2LcLpMax)14272pad_ext_dicneed_flushneed_init_propneed_init_state2need_init_stateneed_init_dicremain_lencheck_dic_sizeprocessed_posLZMA2_prob *dic_buf_sizedic_posdic_sizeLZMA2_MT_INPUT_SIZE0x40000LZMA2_CONTENTSIZE_ERROR(pos_state)(pos_state + state)CALC_POS_STATE(processed_pos,pb_mask)(((processed_pos) & (pb_mask)) << 4)(NUM_BASE_PROBS + ((U32)kLzmaLitSize << ((p)->lc + (p)->lp)))LZMA_DEC_PROB16/* not finished; output buffer is full *//* stream was finished *//* 32-bit probs can increase the speed on some CPUs,
   but memory usage for LZMA2_DCtx::probs will be doubled in that case *//* #define LZMA_DEC_PROB16 *//* lzma2_dec.h -- LZMA2 Decoder
2017-04-03 : Igor Pavlov : Public domain
Modified for FL2 by Conor McCarthy */in_bufinfdest_lensrc_lenfinish_modedic_limitdict_prop/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_decompress.c"lzma2_dec.h"57240sizeof(FL2_DCtx)sizeof(FL2_blockDecMt)57304sizeof(FL2_blockDecMt) + sizeof(FL2_DCtx)(sizeof(FL2_blockDecMt) + sizeof(FL2_DCtx))FL2_waitDStream(fds)FL2_decompressStream_asyncFL2_DStream *constFL2_decompressStream_blockingFL2_decMt *FL2_decMt *constdecmtFL2_decompressOverlappedInput(fds, output, input)XXHASH_SIZEOF - fds->xxhPossizeof(XXH32_canonical_t) - fds->xxhPosfds->overlapSize"Checking hash"FL2DEC_STAGE_INITFL2DEC_STAGE_DECOMPFL2_outBuffer *constFL2DEC_STAGE_HASHtoReadBYTE[40]LZMA_OVERLAP_SIZEFL2_ERROR(checksum_wrong)FL2DEC_STAGE_FINISHEDFL2_initDStream(fds)FL2_initDStream_prop(fds, prop)FL2_initDStream_propLZMA2_initDecoder(&fds->dec, prop, NULL, 0)LZMA2_initDecoder(&fds->dec, prop, ((void *)0), 0)"Creating hash state""FL2_initDStream""FL2_freeDStream"57352sizeof(FL2_DStream)"FL2_createDStream"FL2_resetDStreamFL2_decompressStreamMtFL2_decompressBlocksMt(fds)FL2DEC_STAGE_MT_WRITEFL2_decompressFailedMtFL2_decInbuf *FL2_decInbuf_s *"Switching to ST decompression. Memory: %u, limit %u", (unsigned)decmt->memTotal, (unsigned)decmt->memLimitLZMA2_initDecoder(&fds->dec, decmt->prop, NULL, 0)LZMA2_initDecoder(&fds->dec, decmt->prop, ((void *)0), 0)FL2_decJob[1]FL2_decJob *FL2_decInbuf *constBYTE[1]unsigned char[1]FL2_decompressInput(fds, output, &temp)FL2_loadInputMtFL2_decBlock *inBlockinput->posinBlock->last->length - inBlock->endPosLZMA2_MT_INPUT_SIZE - inBlock->last->length0x40000 - inBlock->last->lengthtoreadFL2_decBlock *const18446744073709551613FL2_ERROR(corruption_detected)back262124FL2_handleFinalChunkMtFL2_decJob *constdoneFL2_decompressBlocksMtFL2_decompressBlockFL2_writeStreamBlocksthread->bufSize - decmt->srcPosoutput->size - output->posFL2_decompressBlockMtti"Thread %u: decoding block of size %u", (unsigned)thread, (unsigned)ti->bufSizeLZMA2_initDecoder(dec, decmt->prop, ti->outBuf, ti->bufSize)fds->progress(long)(dec->dic_pos - dicPos)"Found end mark"__sync_fetch_and_add_8FL2_parseMtFL2_lzma2DecMt_create57360sizeof(FL2_decMt)57272sizeof(FL2_decJob)(size_t)1 << 29FL2_createInbufNodesizeof(FL2_decInbuf)262168sizeof(FL2_decInbuf) + LZMA2_MT_INPUT_SIZE262167sizeof(FL2_decInbuf) + LZMA2_MT_INPUT_SIZE - 1FL2_lzma2DecMt_initProp"Using ST decompression due to dict size %u, memory limit %u", (unsigned)dictSize, (unsigned)decmt->memLimit6UFL2_lzma2DecMt_initFL2_lzma2DecMt_freeFL2_lzma2DecMt_cleanupFL2_freeOutputBuffersLZMA2_freeExtraInbufNodesLZMA2_freeInbufNodeChainFL2_decompressOverlappedInputLZMA_OVERLAP_SIZE - fds->overlapSize(20 * 2) - fds->overlapSizeFL2_decompressInput(fds, output, input)FL2_decompressInput"Decoded %u bytes", (U32)destSize(long)destSizemaxThreadssrcBufLZMA2_PROP_UNINITIALIZED"FL2_decompressDCtx : dict prop 0x%X, do hash %u", prop, doHashLZMA2_initDecoder(&dctx->dec, prop, dst, dstCapacity)FL2_blockDecMt *FL2_DCtx *const18446744073709551604FL2_ERROR(srcSize_wrong)FL2_decompressDCtxMtFL2_blockDecMt *constinf.pack_size == 1FL2_resetMtBlocksFL2_decompressCtxBlocksMtLZMA2_initDecoder(blocks[thread].dec, prop, dst + blocks[thread].unpackPos, blocks[thread].unpackSize)LZMA2_initDecoder(blocks[0].dec, prop, dst + blocks[0].unpackPos, blocks[0].unpackSize)dSizeFL2_decompressCtxBlock"Thread %u: decoding block of input size %u, output size %u", (unsigned)n, (unsigned)srcLen, (unsigned)blocks[n].unpackSize"FL2_freeDCtx""FL2_createDCtx"57208sizeof(LZMA2_DCtx)FL2_decStageFL2_decMtFL2_decJobFL2_decBlockFL2_decInbufFL2_decInbuf_sFL2_blockDecMtwaitstagexxhPosxxhInoverlapSizeasyncInputasyncOutputdecompressThreadstartPosfailStateisFinalmemLimitmemTotalsrcThreadlzma2propunpackPospackPos(LZMA_REQUIRED_INPUT_MAX * 2)/* Estimate 50% compression and a block size of 4 * dictSize *//* FL2_decompressStream_async() stores result in asyncRes *//* Wait for completion or a timeout *//* FL2_decompressStream_async will reset fds->wait upon completion *//* Calling FL2_decompressStream() while waiting for decompressThread to fall idle is not allowed *//* FL2_decompressStream_async() : FL2POOL_function type *//* No progress was made *//* NO_XXHASH *//* Must copy buffered data before using input *//* If MT decoding is enabled and the dict is not too large, decoder init will occur elsewhere *//* decompressThread writes the result into asyncRes before sleeping *//* Only free the thread if decompression not underway *//* decompressThread is only used if a timeout is specified *//* res > 0 means all threads have input or the terminator was encountered *//* Failover if allocation failed *//* Allocate and fill the input buffer chain *//* failState is set if the memory limit was hit or allocation failed *//* The last buffer in the chain *//* On first call of this function, free any output buffers already allocated,
         * and set up the read position in the input buffer chain. The main thread's decoder needs initialization too. *//* Handle MT buffer allocation failure.
 * Decompress input from the MT buffer chain
 * until it is possible to switch to the caller's input buffer
 *//* Do not continue if we have an incomplete chunk header *//* Read as much input as possible *//* Create a new buffer if endPos is within the overlap region. The function copies the overlap. *//* rewind input in case data beyond terminator was read. Required for xxhash and container formats *//* end is nonzero if memory limit hit or ready to decode *//* We have a complete series of chunks starting from a dict reset and
                 * ending with another reset or the terminator. Set up the thread job. *//* Continue while input is available or the parse pos is not beyond the end *//* Read input into the buffer chain, adding new nodes when necessary. 
 * The chunks in each buffer are parsed before a new buffer is allocated.
 * No new buffers will be allocated after the terminator is encountered.
 * Returns 1 if the terminator was found or enough work exists for all threads,
 * 0 if input is empty,
 * or FL2_error_corruption_detected, or FL2_error_memory_allocation.
 * The memory limit is enforced by returning FL2_error_memory_allocation.
 *//* Set up the start of the next series of chunks. The first buffer is the last of the those already loaded. *//* Decompressed data will be stored in outBuf *//* Initialize the start and end to the next chunk *//* The last becomes the new head *//* Free all input buffers except the last *//* Do block 0 in the main thread *//* Set the threads to work on the blocks *//* FL2_decompressBlock() : FL2POOL_function type *//*
 * Write the data from the output buffer of each thread.
 *//* Advance the position and switch to the next input buffer in the chain if necessary *//* Flag to indicate this block ends with the terminator *//* Position of the starting chunk. *//* Input buffer node containing the starting chunk. If thread > 0 this is usually
     * the last input buffer node of the previous thread. *//* Decompress an entire block starting with a dict reset and ending with
 * the last chunk before the next dict reset, or the terminator.
 * The input is a chain of buffers.
 *//* Skip the 1-byte end marker if found *//* Read chunk headers and advance inBlock->endPos to the next chunk
 * until it points beyond the available data.
 * Add the size of each chunk to inBlock->unpackSize
 *//* The head always exists and is only freed on deallocation *//* Node buffers overlap by LZMA_REQUIRED_INPUT_MAX *//* Minimum memory is for two threads, one dict size per thread plus a minimal amount of
     * compressed data for each. Compression to < 1/6 is uncommon. *//* Free all buffer nodes except the head *//* Free buffer nodes from node to the end, except keep *//* More input needed if not finished, output not full and input is below minimum.
     * Safe to take all input because stream will be beyond decomp stage if the terminator is present. *//* All src data must be in memory *//* Not the end or a dict reset, so add it to the current block *//* Only excecuted at a dict reset. pos is the location of the reset *//* Input used is the end of data consumed by the last thread *//* Store the unpack size in decoder 0 where it would be in single thread *//* Move to the next thread. Decoding will begin if all threads are used. *//* CHUNK_FINAL means a single 0 byte *//* The finish value will be passed to the decoder *//* CHUNK_DICT_RESET is used to signal block completion except for pos 0 *//* All src data must be in memory so CHUNK_MORE_DATA is an error *//* Decompress an entire stream stored in memory *//* Decompress thread 0 *//* Decompress thread 1..n *//* Initial check for block 0. The others are uncalculated *//* If no error occurred, store into res the dic_pos value, which is the end of the decompressed data in the buffer *//* FL2_decompressCtxBlock() : FL2POOL_function type *//*
* Copyright (c) 2018, Conor McCarthy
* All rights reserved.
* Parts based on zstd_decompress.c copyright Yann Collet
*
* This source code is licensed under both the BSD-style license (found in the
* LICENSE file in the root directory of this source tree) and the GPLv2 (found
* in the COPYING file in the root directory of this source tree).
* You may select, at your option, one of the above-listed licenses.
*//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_pool.cFL2POOL_ctx *const&ctx->queueMutex&ctx->busyCond!ctx->numThreadsBusy&ctx->newJobsCondsizeof(*ctx)sizeof(FL2_pthread_t)FL2POOL_joinctx->threads[i]pthread_t[1]sizeof(FL2POOL_ctx)&ctx->threads[i]&FL2POOL_threadFL2POOL_threadshutdownnewJobsCondbusyCondqueueMutexqueueEndqueueIndexnumThreadsBusy/* Need to test for ctx->queueIndex < ctx->queueEnd in case not all jobs have started *//* Callers always wait for jobs to complete before adding a new set *//* supports sizeof NULL *//* Join all of the threads *//* Wake up sleeping threads *//* Shut down the queue *//*! FL2POOL_join() :
    Shutdown the queue, wake any sleeping threads, and join all of the threads.
*//* Initialize the threads *//* Initialize the busy count and jobs range *//* Allocate the context and zero initialize *//* Check the parameters *//* for (;;) *//* Signal the master thread waiting for jobs to complete *//* Unlock the mutex and run the job *//* Pop a job off the queue *//* empty => shutting down: so stop *//* While the mutex is locked, wait for a non-empty queue or until shutdown *//* FL2POOL_thread() :
   Work thread for the thread pool.
   Waits for jobs and executes them.
   @returns : NULL on failure else non-null.
*//* The threads. Extras to be calloc'd *//* Indicates if the queue is shutting down *//* Condition variable for poppers to wait on when the queue is empty *//* Condition variable for pushers to wait on when the queue is full *//* The mutex protects the queue *//* Indicates the number of threads requested and the values to pass *//* The number of threads working on jobs *//* All threads work on the same function and object during a job *//* Keep track of the threads *//* pthread adaptation *//* malloc, calloc *//* ======   Dependencies   ======= */__fds_bits((set)->__fds_bits)/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fl2_threading.cg_ZSTD_threading_useles_symbol/* ===  Implementation  === *//* ===  Dependencies  === *//* create fake symbol to avoid empty translation unit warning *//**
 * This file will hold wrapper for systems, which do not support pthreads
 *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/lzma2_dec.cLZMA2_GET_LZMA_MODE(control)((control >> 5) & 3)const S32has_propunpack_totalcur_finish_modeout_curin_curin_posLZMA2_decodeChunkToDicp->controlLZMA2_props *LZMA2_props *constptrdiff_t *ptrdiff_t *constinit_dicinit_stateLZMA2_nextChunkInfo*controlLZMA2_GET_LZMA_MODE(*control)((*control >> 5) & 3)LZMA_updateWithUncompressedLZMA2_dictBufSize(size_t)1 << 12((size_t)1 << 12)((size_t)1 << 12) - 1(size_t)1 << 30((size_t)1 << 30)(size_t)1 << 22((size_t)1 << 22)((size_t)1 << 22) - 1(size_t)1 << 20((size_t)1 << 20)((size_t)1 << 20) - 1(size_t)2LZMA_freeDictLZMA_decodeToDicLZMA_decodeReal2(p, dic_limit, buf_limit)buf_limitLZMA_initStateRealnum_probsLZMA_initLZMA_initDicAndStateLZMA_decodeReal2const LZMA2_DCtxconst LZMA2_DCtx *const LZMA2_DCtx *constLZMA_writeRemLZMA_decodeReal_3LZMA_tryDummyconst LZMA2_probconst LZMA2_prob *p->processed_pos(1 << p->prop.pb) - 1pos_stateprob_litprob_lenprob_len + lenpos_slotprob + pos_slotmatch_byteconst U32 *num_direct_bitsLZMA2_stateLZMA2_IS_THERE_PROP(mode)((mode) >= 2)LZMA2_IS_UNCOMPRESSED_STATE(control)((control & LZMA2_CONTROL_LZMA) == 0)ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)if (range < kTopValue) { return 0; }match_byte += match_byte; bit = offs; offs &= match_byte; prob_lit = prob + (offs + bit + symbol); GET_BIT2(prob_lit, symbol, offs ^= bit; , ;)range -= bound; code -= bound; *(p) = (LZMA2_prob)(ttt - (ttt >> kNumMoveBits));range = bound; *(p) = (LZMA2_prob)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)((U32)1 << kNumTopBits)HAVE_SMALLdefined __x86_64__s || defined _M_X64LZMA_SIZE_OPTLZMA2_DEC_OPTUSE_CMOV/* Error conditions:
               1. need input but chunk is finished
               2. have output space, input not needed, but nothing was written*//* error if decoder not finished but chunk output is complete *//*
            that case was checked before with kBadRepCode:
            if (check_dic_size == 0 && processed_pos == 0)
            return 1;
            *//* First LZMA-symbol is always decoded.
And it decodes new LZMA-symbols while (buf < buf_limit), but "buf" is without last normalization
Out:
  Result:
    0 - OK
    1 - Error
*//*
00000000  -  EOS
00000001 U U  -  Uncompressed Reset Dic
00000010 U U  -  Uncompressed No Reset
100uuuuu U U P P  -  LZMA no reset
101uuuuu U U P P  -  LZMA reset state
110uuuuu U U P P S  -  LZMA reset state + new prop
111uuuuu U U P P S  -  LZMA reset state + new prop + reset dic

u, U - Unpack Size
P - Pack Size
S - Props
*//* lzma2_dec.c -- LZMA2 Decoder
Based upon LzmaDec.c 2018-02-28 : Igor Pavlov : Public domain
Modified for FL2 by Conor McCarthy *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/count.hZSTD_countpStartpInLoopLimitsizeof(size_t) - 1(sizeof(size_t) - 1)ZSTD_NbCommonBytes__builtin_clzllZSTD_COUNT_H_defined(_MSC_VER) && defined(_WIN64)/* ZSTD_COUNT_H_ *//* 32 bits *//* calculate this way due to compiler complaining in 32-bits mode *//* Big Endian CPU *//*-*************************************
*  Match length counter
***************************************/pInpMatchpInLimit/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/range_enc.hRC_flushRC_encoder *RC_encoder *constRC_getReverseTreePriceconst LZMA2_prob *constBYTE[128]kPriceTableSizeBYTE[2][128]unsigned char[2][128]BYTE(*)[128]unsigned char(*)[128]RC_getTreePriceRC_encodeBitLZMA2_prob *constnew_boundRC_encodeBit1RC_encodeBit0RC_encodeDirectRC_encodeBitTreeReverseRC_encodeBitTreeRC_shiftLowRC_setOutputBufferRC_resetRC_encodercache_sizeout_indexout_bufferprice_tablekMinLitPriceprice_table[1][(prob) >> kNumMoveReducingBits]price_table[0][(prob) >> kNumMoveReducingBits]GET_PRICE(prob,symbol)price_table[symbol][(prob) >> kNumMoveReducingBits]5U(kBitModelTotal >> 1U)11U(1UL << kNumTopBits)RANGE_ENCODER_HLZMA_ENC_PROB32/* RANGE_ENCODER_H *//*
* Bitwise range encoder by Igor Pavlov
* Modified by Conor McCarthy
*
* Public domain
*/prob_tablebit_countrprob/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/fastpos_table.hconst BYTE[4096]unsigned char[4096]1 << kFastDistBitsdistance_table/* Copied from the XZ project *//* This file has been automatically generated by fastpos_tablegen.c. *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_get.hRMF_getNextMatchtbl->tablepos - 1const RMF_unitconst RMF_unit *const U32 *constRMF_getMatchRMF_structuredExtendMatch(ptrdiff_t)kMatchLenMaxkMatchLenMax"RMF_structuredExtendMatch : pos %u, link %u, init length %u, full length %u", (U32)start_index, link, (U32)length, (U32)(limit - start_index)structTblstart_index"RMF_structuredExtendMatch : pos %u, link %u, init length %u, full length %u", (U32)start_index, link, (U32)length, (U32)(end_index - start_index)RMF_bitpackExtendMatch"RMF_bitpackExtendMatch : pos %u, link %u, init length %u, full length %u", (U32)start_index, link, (U32)length, (U32)(limit - start_index)"RMF_bitpackExtendMatch : pos %u, link %u, init length %u, full length %u", (U32)start_index, link, (U32)length, (U32)(end_index - start_index)RMF_matchGetMatchLength(table,pos)((const RMF_unit*)(table))[(pos) >> UNIT_BITS].lengths[(pos) & UNIT_MASK]GetMatchLink(table,pos)((const RMF_unit*)(table))[(pos) >> UNIT_BITS].links[(pos) & UNIT_MASK]FL2_RADIX_GET_H_/* FL2_RADIX_GET_H_ *//* from HandleRepeat *//* same distance, one byte shorter *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/lzma2_enc.c"radix_get.h""fastpos_table.h""range_enc.h""count.h"out_destBYTE[978]unsigned char[978]834978kTempBufferSizekTempMinOutputkMaxMatchEncodeSize938encode_propertiesincompressibleoptions->lpkNumLiteralPosBitsMaxkLcLpMaxoptions->pbkNumPositionBitsMaxoptions->fast_length(2U + ((1U << 3U) * 2 + (1U << 8U)) - 1U)options->match_cycleskMatchesMax - 165U - 1(ptrdiff_t)1kOptimizerBufferSize577block.endpos + kMaxChunkUncompressedSize - kMatchLenMax + 1pos + (1UL << 21U) - (2U + ((1U << 3U) * 2 + (1U << 8U)) - 1U) + 1pos + kMaxChunkUncompressedSize - kOptimizerBufferSize + 2pos + (1UL << 21U) - ((2U + ((1U << 3U) * 2 + (1U << 8U)) - 1U) * 2U + 32U) + 2pos + kChunkSizepos + ((1UL << 16U) - 2048U)"Storing chunk : was %u => %u", (unsigned)uncompressed_size, (unsigned)compressed_size"Compressed chunk : %u => %u", (unsigned)uncompressed_size, (unsigned)compressed_size*progress_in(long)(next_index - pos)*progress_out(long)(compressed_size + header_size)header_sizekChunkHeaderSizesaved_statescompressed_sizeuncompressed_sizeFL2_ERROR(internal)kChunkSizekMaxChunkCompressedSize65496kMaxChunkUncompressedSizekChunkUncompressedDictResetkChunkUncompressedkChunkCompressedFlagkChunkAllResetkChunkStatePropertiesResetkChunkNothingResetkRandomFilterMarginBitsLZMA2_encodeChunkuncompressed_endLZMA2_isChunkIncompressiblestart + kChunkSizestart + ((1UL << 16U) - 2048U)kMinTestChunkSizeconst U32[3]const size_t[3]60U45U120Uconst size_t[5]const size_t[3][5]unsigned long[3][5]1U << 61U << 141U << 22const size_t[][5]unsigned long[][5]max_dist_tablemargin_divisordev_tablemarginU32[256]char_countchar_totalavg64Usqrt_chunkkSqrtChunkSizeprev_distconst size_t(*)[5]unsigned long(*)[5]sizeof(char_count)LZMA2_isqrt(U32)14294967294~1LZMA_getLcLpPbCodeLZMA2_reset"LZMA encoder reset : max_distance %u", (unsigned)max_distanceLZMA2_encStates *LZMA2_encStates *const91048sizeof(LZMA2_ECtx)65540sizeof(LZMA2_hc3)sizeof(U32)chunk_min_avg29760(kChunkSize / 16U)59520(kChunkSize - (kChunkSize / 16U))(kChunkSize - (kChunkSize / 16U)) / 2Udict_size_propLZMA_encoderStates_ResetkNumRepskNumPositionStatesMaxLZMA2_prob[16]LZMA2_prob[12][16]LZMA2_prob(*)[16]esLZMA2_prob[12]kNumLiteralskNumLitTables(size_t)(kNumLiterals * kNumLitTables)LZMA2_prob[12288]unsigned short[12288](kNumLiterals * kNumLitTables)(kNumLiterals * kNumLitTables) << kLcLpMaxLZMA2_prob[64]LZMA2_prob[4][64]LZMA2_prob(*)[64]LZMA2_prob[114]unsigned short[114]LZMA2_lenStates *LZMA2_lenStates *constLZMA_lengthStates_Reset(kNumPositionStatesMax << (kLenNumLowBits + 1))LZMA2_prob[256]kMatchLenMinLZMA_encodeChunkBestsearch_depthconst RMF_matchkMatchRepriceFrequencykRepLenRepriceFrequencyLZMA_fillDistancesPricesU32 *consttemp_pricesdist_slotfooter_bitsdist_table_size2dist_slot_pricesunsigned int[62]unsigned int[4][62]unsigned int(*)[62]lsstruct_tbl(U32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits)(U32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) << kNumBitPriceShiftBits((U32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) << kNumBitPriceShiftBits)(U32)1 << kNumBitPriceShiftBits((U32)1 << kNumBitPriceShiftBits)slot_priceLZMA_fillAlignPricesLZMA_encodeOptimumSequencelen_endcur + kOptimizerSkipSizecur + 16U"End optimal parse at %u", (U32)curpos_maskLZMA2_node[578]struct <unnamed>[578]LZMA2_node *kOptimizerEndSizeis_hybridreverseLZMA2_node *constkNullDistLZMA_initOptimizerPos0block.end - posdata_2rep_max_indexrep_lenscur_byteis_match_probis_rep_probenc->opt_buf[1]match_pricerep_match_priceshort_rep_pricesizeof(enc->opt_buf[0].reps)rep_lencur_and_len_pricenormal_match_pricematch.lengthrep_lens[rep_max_index]main_lenLZMA_initMatchesPos0Bestenc->fast_lengthlen_teststart_matchRMF_match[65]struct <unnamed>[65]kMatchesMaxRMF_match *match_indexstart_lenbase_lenlen_to_dist_stateLZMA_initMatchesPos0LZMA_optimalParsecur_optbytes_availnext_stateconst BYTE[12]const LZMA2_nodeconst LZMA2_node *const LZMA2_node *constprev_opt2 << 2(2 << 2)1 | (2 << 2)3 << 4(3 << 4)1 | (2 << 2) | (3 << 4)0 << 8(0 << 8)1 | (2 << 2) | (3 << 4)
                | (0 << 8)2 << 10(2 << 10)21051 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10)3 << 12(3 << 12)143931 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)0L << 16(0L << 16)1 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16)1L1L << 18(1L << 18)2765371 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16) | (1L << 18)3L31457283L << 20(3L << 20)34222651 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16) | (1L << 18) | (3L << 20)0L << 24(0L << 24)1 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16) | (1L << 18) | (3L << 20)
                | (0L << 24)1L << 26(1L << 26)705311291 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16) | (1L << 18) | (3L << 20)
                | (0L << 24) | (1L << 26)2L2L << 28(2L << 28)6074020411 | (2 << 2) | (3 << 4)
                | (0 << 8) | (2 << 10) | (3 << 12)
                | (0L << 16) | (1L << 18) | (3L << 20)
                | (0L << 24) | (1L << 26) | (2L << 28)sizeof(cur_opt->reps)next_optcur_pricenext_pricecur_and_lit_pricetry_lit*next_optkOptimizerBufferSize - 1 - cur((2U + ((1U << 3U) * 2 + (1U << 8U)) - 1U) * 2U + 32U) - 1 - curbytes_avail - 1enc->states.is_match[state_2][pos_state_next]enc->states.is_rep[state_2]len_test_2state_2pos_state_nextnext_rep_match_pricecur + len_testlen_test + 1 + fast_lengthpos + len_testdata[len_test - 1]cur_rep_pricerep_indexrep_lit_rep_total_pricecur + length(U32)max_lengthcur + main_lenrep_0_pos + fast_lengthcur_distrep_0_possub_lenmatch_lit_rep_total_priceLZMA_hashGetMatcheshash_dict_3LZMA2_hc3 *LZMA2_hc3 *constchain_mask_3enc->hash_prev_indexpos - hash_dict_3data + enc->hash_prev_indexS32[1]signed int[1]S32 *S32[16384]signed int[16384]kHash3Bits1 << kHash3Bitsfirst_3cyclesmatch_3LZMA_hashCreate"Create hash chain : dict bits %u", dictionary_bits_3sizeof(S32)LZMA_hashResetsizeof(enc->hash_buf->table_3)LZMA_getLiteralPriceprev_symbolprob_table[symbol >> 8](symbol >> 7) & 1LZMA_reverseOptimalChainnext_lennext_distLZMA_encodeChunkFast"Replace match (%u, %u) with rep (%u, %u)", best_match.length, best_match.dist, best_rep.length, best_rep.distblock.end - next"Replace match (%u, %u) with match (%u, %u)", best_match.length, best_match.dist, next_match.length, next_match.dist + kNumRepspos + best_match.length <= block.endconst U32[5]const U32[]best_matchbest_reprep_matchgain2length_limitdictionary_bits_3opt_bufgain1next_match_encodeLZMA_encodeNormalMatch"LZMA_encodeNormalMatch : length %u, dist %u", len, distenc->states.statedist_reducedLZMA_getDistSlot1UL1UL << kFastDistBitsLZMA_fastDistResultLZMA_fastDistShift(kFastDistBits - 1)LZMA_encodeRepMatchLong"LZMA_encodeRepMatchLong : length %u, rep %u", len, repLZMA_encodeRepMatchShort"LZMA_encodeRepMatchShort"LZMA_encodeLengthreplen_prob_tableLZMA_encodeLength_MidHighLZMA_lengthStates_updatePricesls->low[0]unsigned int *constsizeof(ls->prices[0][0])(kLenNumLowSymbols * 2 - 1)LZMA_lengthStates_SetPricesprobs[1]LZMA_encodeLiteralBufLZMA_encodeLiteralMatchedmatch_symboldata_block[pos - 1]prob_indexLZMA_encodeLiteralLZMA_getLiteralPriceMatchedprob_table[offs + (match_byte & offs) + (symbol >> 8)]LZMA_getRepMatch0Pricerep_G0_probrep0_long_probLZMA_getRepPricerep_G1_probrep_G2_probrep_index - 2LZMA_getRepLen1Price"LZMA2_createECtx"start_priceLZMA2_hc3LZMA2_nodeLZMA2_encStatesLZMA2_lenStatesout_bufhash_alloc_3hash_prev_indexchain_mask_2hash_bufhash_chain_3table_3match_countbase_matchdistance_pricesalign_pricesdist_price_table_sizerep_len_price_countmatch_price_countstatesliteral_probsdist_encodersdist_align_encodersdist_slot_encoderslen_statesis_rep_G2is_rep_G1is_rep_G0is_repis_matchis_rep0_longrep_len_stateschoicechunk_limitlit_pos_masklen_end_maxGET_HASH_3(data)((((MEM_readLE32(data)) << 8) * 506832829U) >> (32 - kHash3Bits))IS_LIT_STATE(state)((state) < 7)LEN_TO_DIST_STATE(len)LITERAL_PROBS(enc,pos,prev_symbol)(enc->states.literal_probs + ((((pos) & enc->lit_pos_mask) << enc->lc) + ((prev_symbol) >> (8 - enc->lc))) * kNumLiterals * kNumLitTables)MARK_SHORT_REP(node)(node).dist = 0; (node).extra = 0;MARK_LITERAL(node)(node).dist = kNullDist; (node).extra = 0;SHORT_REP_NEXT_STATE(s)kShortRepNextStates[s]REP_NEXT_STATE(s)kRepNextStates[s]MATCH_NEXT_STATE(s)kMatchNextStates[s]LIT_NEXT_STATE(s)kLiteralNextStates[s]0x4000UkNullLinkkMaxHashDictBits(3U << kChunkResetShift)(2U << kChunkResetShift)kChunkStateReset(1U << kChunkResetShift)0x80UkChunkResetShift(1UL << 21U)(kTempMinOutput + kOptimizerBufferSize + kOptimizerBufferSize / 4U)256U252U(kMaxChunkCompressedSize - 2048U)(1UL << 16U)(U32)-1(1UL << 30U)kOptimizerSkipSize(kMatchLenMax * 2U + kOptimizerEndSize)65U(kMatchLenMin + kLenNumSymbolsTotal - 1U)(1U << kLenNumHighBits)(1U << kLenNumLowBits)kNumLiteralContextBitsMax(1U << kNumPositionBitsMax)(1U << kNumFullDistancesBits)kNumFullDistancesBits(kEndPosModelIndex >> 1U)kNumPosModels(kEndPosModelIndex - kStartPosModelIndex)(kAlignTableSize - 1U)(1U << kNumAlignBits)(kDicLogSizeMax * 2U)31UkDicLogSizeMin18U0x100UTUKLIB_FAST_UNALIGNED_ACCESS/* Update progress concurrently with other encoder threads *//* Test the next chunk for compressibility *//* Restore states if compression was attempted *//* Copy uncompressed data into the output *//* Output an uncompressed chunk if necessary *//* Now encode up to the full chunk size *//* Switch to the match table as output buffer *//* compressed data will never catch up with the table position being read. *//* After kTempMinOutput bytes we can write data to the match table because the *//* First byte of the dictionary *//* Copy states in case chunk is incompressible *//* last byte of opt_buf unused *//* Limit the matches near the end of this slice to not exceed block.end *//* Create a hash chain to put the encoder into hybrid mode *//* write only uncompressed chunks with no properties. *//* Each encoder writes a properties byte because the upstream encoder(s) could *//* Output starts in the temp buffer *//* Template-like inline functions *//* Result base on character count std dev *//* Sum the deviations *//* Expected normal character count * 4 *//* Increment the cost for a short match. The cost is the entire length if it's too far *//* Increase the cost if it's not the same match *//* ultra *//* opt *//* fast *//* "one" starts at the highest power of four <= than the argument. *//* Integer square root from https://stackoverflow.com/a/1101217 *//* Maximum size of data stored in a sequence of uncompressed chunks *//* Minimum average uncompressed size. An average size of half kChunkSize should be assumed
	 * to account for thread_count incomplete end chunks per block. LZMA expansion is < 2% so 1/16
	 * is a safe overestimate. *//* Template-like inline function *//* dist_slot_prices[slot] = RcTree_GetPrice(encoder, kNumPosSlotBits, slot, p->ProbPrices); *//* Do another round if there is a long match pending,
         * because the reps must be checked and the match encoded. *//* Updating i separately for each case may allow a branch to be eliminated *//* Encode the selections in the buffer *//* Skip ahead if a lower or equal price is available at greater distance *//* This is a compromise to favor more distant end points
                     * even if the price is a bit higher *//* Terminate if the farthest calculated price is too near the buffer end *//* len_end == 0 if a match of fast_length was found *//* Set everything up at position 0 *//* Reset all prices that were set last time *//* Hybrid mode *//* Normal mode *//* Test the match prices *//* Test every available length of the rep *//* Test the rep match prices *//* Try 1-byte rep0 *//* Set the price for literal *//* Find any rep matches *//* Test all available options at position 0 of the optimizer buffer.
* The prices at this point are all initialized to kInfinityPrice.
* This function must not be called at a position where no match is
* available. *//* in order of increasing length, and therefore increasing distance too. *//* Test every available match length at the shortest distance. The buffer is sorted *//* Avoids an if..else branch in the loop. [-1] is ok *//* Test every available length of the match *//* Try match + literal + rep0 *//* End the tests if prices for shorter lengths are not lower than those already recorded *//* Test from the full length down to 1 more than the next shorter match *//* Start with a match longer than the best rep if one exists *//* Need to test max_length < 4 because the hash fn reads a U32 *//* Normal mode - single match *//* Try normal match *//* Try rep + literal + rep0.
                 * The second rep may be > fast_length, but it is not worth the extra time to handle this case
                 * and the price table is not filled for it *//* rep + literal + rep0 is not common so this test is skipped for faster, non-hybrid encoding *//* Save time by exluding normal matches not longer than the rep *//* Try rep match *//* Test is limited to fast_length, but it is rare for the RMF to miss the longest match,
             * therefore this function is rarely called when a rep len > fast_length exists *//* Try literal + rep0 *//* If match_byte == cur_byte a rep0 begins at the current position *//* Evaluates as a constant expression due to inlining *//* Try literal *//* cur_and_lit_price is used later for the literal + rep0 test *//* This is a compromise to try to filter out cases where literal + rep0 is unlikely to be cheaper *//* Move the chosen rep to the front.
             * The table is hideous but faster than branching :D *//* Match or rep match *//* Literal or 1-byte rep *//* Update the states according to how this location was reached *//* The speed of this function is critical. The sections have many variables
* in common, so breaking it up into shorter functions is not feasible.
* For each position cur, starting at 1, check some or all possible
* encoding choices - a literal, 1-byte rep 0 match, all rep match lengths, and
* all match lengths at available distances. It also checks the combined
* sequences literal+rep0, rep+lit+rep0 and match+lit+rep0.
* If is_hybrid != 0, this method works in hybrid mode, using the
* hash chain to find shorter matches at near distances. *//* Insert the match from the RMF *//* Update hash tables and chains for any positions that were skipped *//* Find matches nearer than the match from the RMF. If none is at least as long as
 * the RMF match (most likely), insert that match at the end of the list.
 *//* Create a hash chain for hybrid mode if options require one.
 * Used for allocating before compression begins. Any existing table will be reused if
 * it is at least as large as required.
 *//*
 * Create hash table and chain with dict size dictionary_bits_3. Frees any existing object.
 *//* 
 * Reset the hash object for encoding a new slice of a block
 *//*
 * Reverse the direction of the linked list generated by the optimal parser
 *//* Recheck next < uncompressed_end. uncompressed_end could be block.end so decrementing the max chunk size won't obviate the need. *//* raw approx *//* lazy matching scheme from ZSTD *//* Modified ZSTD scheme for estimating cost *//* Encode if it is kMatchLenMax or completes the block *//* Search all of the rep distances *//* Use if near enough *//* Get a match from the table, extended to its full length *//* Table of distance restrictions for short matches *//* * *//* the precalculated table. *//* If it is small enough, we can pick the result directly from *//* 
 * Distance slot functions based on fastpos.h from XZ
 *//* Rare enough that not inlining is faster overall *//* Temp output buffer before space frees up in the match table *//* Allows access to matches[-1] in LZMA_optimalParse *//* Don't encode a symbol beyond this limit (used by fast mode) *//* Finish writing the chunk at this size *//*
 * LZMA2 encoder.
 *//*
 * Table and chain for 3-byte hash. Extra elements in hash_chain_3 are malloced.
 *//*  0   : normal
                     *  1   : LIT : MATCH
                     *  > 1 : MATCH (extra-1) : LIT : REP0 (len) *//* 
 * Linked list item for optimal parsing
 *//* Fields are ordered for speed *//* All probabilities for the encoder. This is a separate from the encoder object
 * so the state can be saved and restored in case a chunk is not compressible.
 *//* low[0] is choice_2. Must be consecutive for speed *//* Probabilities and prices for encoding match lengths.
 * Two objects of this type are needed, one for normal matches
 * and another for rep matches.
 *//* Hard to define where the match table read pos definitely catches up with the output size, but
 * 64 bytes of input expanding beyond 256 bytes right after an encoder reset is most likely impossible.
 * The encoder will error out if this happens. *//* Need to leave sufficient space for expanded output from a full opt buffer with bad starting probs *//* Doesn't need to be larger than FL2_HYBRIDCYCLES_MAX + 1 *//* lzma2_enc.c -- LZMA2 Encoder
Based on LzmaEnc.c and Lzma2Enc.c : Igor Pavlov
Modified for FL2 by Conor McCarthy
Public domain
*//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_engine.h(U32)(end - pos)RADIX_MAX_LENGTHForward link at %X to %u
"Forward link at %X to %u\r\n"char[27]Failed integrity check: pos %X, length %u, actual %u
"Failed integrity check: pos %X, length %u, actual %u\r\n"char[55]Shortened match at %X: %u of %u
"Shortened match at %X: %u of %u\r\n"tbl->params.depthbounded_startMAX_READ_BEYOND_DEPTHnext_progressgetNextListlist_headRMF_tableHead *RMF_tableHead *constRMF_getNextList_sttbl->st_indexRMF_getNextList_mtRMF_recurseLists16table_max_depthdata_srcnext_radix_8next_radix_16reset_listreset_count(U32)next_link(U32)linknext_linkradix_8radix_16RMF_listTail *201326592RMF_bruteForcesize_t[6]buffer[i](U32)buffer[longest_index]depth + (U32)longestlongestlongest_indexRMF_recurseListsBoundbounded_sizeextra_count(U32)bounded_size(U32)tbl->match_buffer_sizeRMF_buildMatch *(U32)2(U32)2 << 24((U32)2 << 24)RMF_listTail *constprev_st_index(U32)(block_size - from)tbl->match_buffer[next].fromRMF_recurseListsBufferedprev_linkrptrpt_tailnext_radixorig_list_counttbl->list_heads[radix_16].headend - 1RMF_handleRepeat2last_2realignrpt_index(U32)(i - 2)4227858432RMF_handleRepeat(U32)(i - 1)RMF_BITPACK/* These occur occasionally due to splitting of chains in the buffer when long repeats are present *//* Not worth buffering or too long *//* initial value of next_progress ensures only thread 0 executes this *//* Get the next to process *//* Iterate the head table concurrently with other threads, and recurse each list until max_depth is reached *//* Non-atomically take a list from the head table *//* Atomically take a list from the head table *//* RMF_REFERENCE *//* Next depth for 1 extra char *//* The current depth *//* Potential stack overflow. Rare. *//* Nothing to do *//* Offset data pointer. This method is only called at depth 2 *//* Simple, slow, complete parsing for reference *//* Odd numbered match length, will be overwritten if 2 chars are matched *//* Last pass is done separately. Both of these values are always even. *//* Last location is done separately *//* and for 2 *//* Quicker to use brute force, each string compared with all previous strings *//* Do the last location *//* Link at length 4, overwriting the 3 *//* This will be overwritten if a 4 is found. *//* Link the previous occurrence to this one at length 3. *//* Initialization doesn't set lengths to 2 because it's a waste of time if buffering is used *//* Pre-load the next link *//* Last one is done separately *//* Load radix values from the data chars *//* Unbuffered complete processing to max_depth.
 * This may be faster on CPUs without a large memory cache.
 *//* Send to the buffer at depth 4 *//* Store a reference to this table location to retrieve the count at the end *//* Offset data pointer. This function is only called at depth 2 *//* RMF_recurseLists16() : 
 * Match strings at depth 2 using a 16-bit radix to lengthen to depth 4
 *//* Test with block_start to avoid wasting time matching strings in the overlap region with each other *//* Pre-load all locations *//* Compare each string with all others to find the best match *//* Copy everything back above the bound *//* Chain starts before the bounded region *//* Nothing to match with *//* Pop an item off the stack *//* Convert radix values on the stack to counts and reset any used tail slots *//* This will be converted to a count at the end *//* Add the new sub list to the stack *//* Link the previous occurrence to this one and record the new length *//* Seen this char before? *//* Create an offset data buffer pointer for reading the next bytes *//* Initialize the next link *//* Record the actual location of this suffix *//* Buffering is used so that parsing can continue below the bound to find a few matches without altering the main table. *//* Parse the list with an upper bound check on data reads. Stop at the point where bound checks are not required. *//* Copy everything back, except the last link which never changes, and any extra overlap *//* Make the last element circular so pre-loading doesn't read past the end. *//* Eliminate the repeat from the linked list to save time *//* Get 4 data characters for later. This doesn't block on a cache miss. *//* Do the usual if the repeat is too short *//* Pre-load next link *//* data characters to be loaded every fourth pass and stored for use in the next 4 passes *//* Copy the list into a buffer and recurse it there. This decreases cache misses and allows *//* Never a match at the last byte *//* Handle the last value *//* Set the previous to this position *//* Link this position to the previous occurrence *//* Pre-load the next value for speed increase on some hardware. Execution can continue while memory read is pending *//* Initial 2-byte radix value *//* Initialization for the reference algortithm *//* Set matches at distance 2 and max length *//* Set matches at distance 2 and available length *//* No point if it's in the overlap region *//* Find the start *//* Normally the last 2 bytes, but may be 4 if depth == 4 *//* If a 2-byte repeat is found, fill that section of the table with matches of distance 2 *//* Set matches at distance 1 and max length *//* Set matches at distance 1 and available length *//* If a repeating byte is found, fill that section of the table with matches of distance 1 *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_bitpack.c"radix_engine.h""RMF_limitLengths : end %u, max length %u", (U32)pos, RADIX_MAX_LENGTHlink >> RADIX_LINK_BITSlink >> 26IsNull(pos)(tbl->table[pos] == RADIX_NULL_LINK)SetNull(pos)tbl->table[pos] = RADIX_NULL_LINKSetMatchLinkAndLength(pos,link,length)tbl->table[pos] = (link) | ((U32)(length) << RADIX_LINK_BITS)SetMatchLength(pos,link,length)SetMatchLink(pos,link,length)GetMatchLength(pos)(tbl->table[pos] >> RADIX_LINK_BITS)GetInitialMatchLink(pos)tbl->table[pos]GetMatchLink(link)(tbl->table[link] & RADIX_LINK_MASK)InitMatchLink(pos,link)tbl->table[pos] = link((a) < (b) ? (a) : (b))/* Restrict the match lengths so that they don't reach beyond pos *//home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_mf.csizeof(RMF_buildMatch)2099248sizeof(RMF_builder)RADIX_CANCEL_INDEX - ATOMIC_INITIAL_VALUE(long)(((size_t)1 << 16) + 200 + 2) - 06573665738"RMF_buildTable : thread %u", (U32)jobRMF_recurseListChunk_genericbase_depth196352rpt_head_nextrpt_distrpt_depthRMF_buildMatch *constRMF_bruteForceBufferedBruteForceMatch[6]struct <unnamed>[6]BruteForceMatch *next_irpt_len"RMF_initTable : size %u", (U32)end"RMF_freeMatchTable"RMF_builder **const"RMF_createMatchTable : is_struct %d, dict %u", is_struct, (U32)dictionary_sizetable_bytessizeof(RMF_unit)786520sizeof(FL2_matchTable)RMF_initListHeadsRMF_reduceDictparams->dictionary_sizeMAX(dict_reduce, DICTIONARY_SIZE_MIN)((dict_reduce)>(((size_t)1 << 12U)) ? (dict_reduce) : (((size_t)1 << 12U)))((size_t)1 << 12U)RMF_applyParameters_internalRMF_calBufSizebuffer_sizeMATCH_BUFFER_ELBOWMATCH_BUFFER_ELBOW_BITS4UL3ULRMF_clampParamsparams.dictionary_sizeMEM_64bits() ? DICTIONARY_SIZE_MAX_64 : DICTIONARY_SIZE_MAX_32MEM_64bits() ? ((size_t)1 << 30U) : ((size_t)1 << 27U)params.match_buffer_resizeparams.overlap_fractionparams.depthRMF_isStruct(size_t)1 << RADIX_LINK_BITS((size_t)1 << RADIX_LINK_BITS)RMF_createBuilderTable"RMF_createBuilderTable : match_buffer_size %u, builders %u", (U32)match_buffer_size, sizesizeof(RMF_builder*)RMF_freeBuilderTableRMF_createBuilderMAX_MATCH_BUFFER_SIZE(1UL << 24)MIN_MATCH_BUFFER_SIZEbuildermatch_tableRMF_initTailTableBruteForceMatchCLAMPMAXCLAMPMAXCLAMP(val,max){ if (val>(max)) val=(max); }CLAMP(val,min,max){ if (val<(min)) val=(min); else if (val>(max)) val=(max); }(1UL << MATCH_BUFFER_ELBOW_BITS)MATCH_BUFFER_SHIFT8;defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 407)GCC diagnostic ignored "-Wmaybe-uninitialized"/* The last element in tbl->match_buffer is circular so this is never an access violation. *//* Pre-load the next link. *//* The last pass at max_depth *//* Last element done separately *//* Pre-load the next link to avoid waiting for RAM access *//* Save the char as a reference to load the count at the end *//* First occurrence in the chain *//* This char has occurred before in the chain. Link the previous (> pos) occurance with this *//* Pre-load the next link and data bytes. On some hardware execution can continue
                 * ahead while the data is retrieved if no operations except move are done on the data. *//* If slot is 3 then chars need to be loaded. *//* Last pass is done separately *//* check for repeats at depth 4,8,16,32 etc unless depth is near max_depth *//* Index into the 4-byte pre-loaded input char cache *//* Stack may not be able to fit all possible new items. This is very rare. *//* Check stack space. The first comparison is unnecessary but it's a constant so should be faster *//* Chain starts in the overlap region which is already encoded *//* Nothing to do if there was no previous *//* Do the last element *//* The last element is done separately and won't be copied back at the end *//* Lengthen and divide buffered chains into smaller chains, save them on a stack and process in turn. 
 * The match finder spends most of its time here.
 *//* If the existing match was extended, store the new link and length info in the match buffer *//* Complete the match length count in the raw input buffer *//* Begin with the remaining chars pulled from the match buffer *//* Load all locations from the match buffer *//* RMF_createMatchTable() :
 * Create a match table. Reduce the dict size to input size if possible.
 * A thread_count of 0 will be raised to 1.
 *//* RMF_reduceDict() : 
 * Reduce dictionary and match buffer size if the total input size is known and < dictionary_size.
 *//* dictionary is allocated with the struct and is immutable *//* RMF_applyParameters_internal() :
 * Set parameters to those specified.
 * Create a builder table if none exists. Free an existing one if incompatible.
 * Set match_buffer_limit and max supported match length.
 * Returns an error if dictionary won't fit.
 *//* RMF_clampParams() :
*  Make param values within valid range.
*  Return : valid RMF_parameters *//* RMF_createBuilderTable() : 
 * Create one match table builder object per thread.
 * max_len : maximum match length supported by the table structure 
 * size : number of threads 
 *//* max buffer size constrained by 24-bit link values *//* min buffer size at least FL2_SEARCH_DEPTH_MAX + 2 for bounded build *//* warning: 'rpt_head_next' may be used uninitialized in this function *//* U32, U64, MEM_64bits *//* malloc, free */RMF_unit *i_u_/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/radix_struct.c(BYTE)length((RMF_unit*)tbl->table)[i].lengths[u](((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].links[(pos) & UNIT_MASK] == RADIX_NULL_LINK)((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].links[(pos) & UNIT_MASK] = RADIX_NULL_LINKdo { size_t i_ = (pos) >> UNIT_BITS, u_ = (pos) & UNIT_MASK; ((RMF_unit*)tbl->table)[i_].links[u_] = (U32)(link); ((RMF_unit*)tbl->table)[i_].lengths[u_] = (BYTE)(length); } while(0)((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].lengths[(pos) & UNIT_MASK] = (BYTE)(length)((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].links[(pos) & UNIT_MASK] = (U32)(link)((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].lengths[(pos) & UNIT_MASK]((RMF_unit*)tbl->table)[(pos) >> UNIT_BITS].links[(pos) & UNIT_MASK]GetMatchLink(pos)RMF_STRUCTURED/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/range_enc.cbit_count > 0bit_count != 0tree_indexbit_count > 1184467440694313615360xFFFFFFFF01000000/* VC15 compiles 'if (low < 0xFF000000 || low > 0xFFFFFFFF)' to this single-branch conditional *//* Generates price_table *//* The first and last elements of these tables are never used */(int ___argc, char *const *___argv, const char *__shortopts)__posix_getopt"__posix_getopt"intptr_t600200112L(stdout)->_IO_write_ptr >= (stdout)->_IO_write_end(__stream)->_IO_write_ptr >= (__stream)->_IO_write_end(stdin)->_IO_read_ptr >= (stdin)->_IO_read_end__fp(__fp)->_IO_read_ptr >= (__fp)->_IO_read_end__va_list_tag *__STDIO_INLINE__extern_inline_BITS_STDIO_H!(__USE_FORTIFY_LEVEL > 0 && defined __fortify_function)defined __USE_MISC && defined __GNUC__ && defined __OPTIMIZE__ \/* bits/stdio.h.  *//* Define helper macro.  *//* Evaluate all parameters once.  *//* Perform some simple optimizations.  *//* Use extern inlines.  *//* Like `getdelim', but reads up to a newline.  *//* This is defined in POSIX.1:1996.  *//* Faster version when locking is not necessary.  *//* Write a character to stdout.  *//* Read a character from stdin.  *//* Write formatted output to stdout from argument list ARG.  *//* For -D_FORTIFY_SOURCE{,=2,=3} bits/stdio2.h will define a different
   inline.  *//* Optimizing macros and inline functions for stdio functions.
   Copyright (C) 1998-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */st_ctimensecst_mtimensecst_atimensec__tm_zone__tm_gmtoff(int __errnum, char *__buf, size_t __buflen)__xpg_strerror_r"__xpg_strerror_r"<bits/stdint-uintn.h><bits/wchar.h>uintmax_tintmax_tuintptr_tuint_fast64_tuint_fast32_tuint_fast16_tuint_fast8_tint_fast64_tint_fast32_tint_fast16_tint_fast8_tuint_least64_tuint_least32_tuint_least16_tuint_least8_tint_least64_tint_least32_tint_least16_tint_least8_tUINTMAX_C(c)c ## ULINTMAX_C(c)c ## LUINT64_C(c)UINT32_C(c)c ## UUINT16_C(c)UINT8_C(c)INT64_C(c)INT32_C(c)INT16_C(c)INT8_C(c)WINT_MAX(4294967295u)WINT_MIN(0u)WCHAR_MAX__WCHAR_MAXWCHAR_MIN__WCHAR_MINSIZE_MAX(18446744073709551615UL)SIG_ATOMIC_MAX(2147483647)SIG_ATOMIC_MIN(-2147483647-1)PTRDIFF_MAX(9223372036854775807L)PTRDIFF_MIN(-9223372036854775807L-1)UINTMAX_MAX(__UINT64_C(18446744073709551615))INTMAX_MAX(__INT64_C(9223372036854775807))INTMAX_MIN(-__INT64_C(9223372036854775807)-1)UINTPTR_MAXINTPTR_MAXINTPTR_MINUINT_FAST64_MAXUINT_FAST32_MAXUINT_FAST16_MAXUINT_FAST8_MAX(255)INT_FAST64_MAXINT_FAST32_MAXINT_FAST16_MAXINT_FAST8_MAX(127)INT_FAST64_MININT_FAST32_MININT_FAST16_MININT_FAST8_MIN(-128)UINT_LEAST64_MAXUINT_LEAST32_MAX(4294967295U)UINT_LEAST16_MAX(65535)UINT_LEAST8_MAXINT_LEAST64_MAXINT_LEAST32_MAXINT_LEAST16_MAX(32767)INT_LEAST8_MAXINT_LEAST64_MININT_LEAST32_MININT_LEAST16_MIN(-32767-1)INT_LEAST8_MINUINT64_MAXUINT32_MAXUINT16_MAXUINT8_MAXINT64_MAXINT32_MAXINT16_MAXINT8_MAXINT64_MININT32_MININT16_MININT8_MIN__UINT64_C(c)__INT64_C(c)_STDINT_H__WORDSIZE32_PTRDIFF_LONG__WORDSIZE32_SIZE_ULONG/* stdint.h *//* Maximal type.  *//* Unsigned.  *//* Signed.  *//* Limits of `wint_t'.  *//* These constants might also be defined in <wchar.h>.  *//* Limits of `wchar_t'.  *//* Limit of `size_t' type.  *//* Limits of `sig_atomic_t'.  *//* Limits of `ptrdiff_t' type.  *//* Limits of other integer types.  *//* Maximum for largest unsigned integral type.  *//* Maximum for largest signed integral type.  *//* Minimum for largest signed integral type.  *//* Values to test for integral types holding `void *' pointer.  *//* Maximum of fast unsigned integral types having a minimum size.  *//* Maximum of fast signed integral types having a minimum size.  *//* Minimum of fast signed integral types having a minimum size.  *//* Maximum of unsigned integral types having a minimum size.  *//* Maximum of signed integral types having a minimum size.  *//* Minimum of signed integral types having a minimum size.  *//* Maximum of unsigned integral types.  *//* Maximum of signed integral types.  *//* Minimum of signed integral types.  *//* Limits of integral types.  *//* Largest integral types.  *//* Types for `void *' pointers.  *//* Fast types.  *//* Small types.  *//* Exact integral types.  *//*
 *	ISO C99: 7.18 Integer types <stdint.h>
 *//* Copyright (C) 1997-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/assert.h/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/util.c<assert.h>numPhysicalCoresFILE *constcpuinfo/proc/cpuinfo"/proc/cpuinfo""r"BUF_SIZEbuffsiblingscpu_coresratio 1"siblings"sepcpu cores"cpu cores"failedconst UTIL_time_tnano1000000000ULLmicro1000000ULL1000ULL"ERROR: Failed to get time\n"UTIL_time_t *ERROR: Failed to get time
bufendfileTablenewListSizesizeof(const char*)direntrydirLengthfnameLengthpathLength"Cannot open directory '%s': %s\n", dirName, strerror(errno)"Cannot open directory '%s': %s\n", dirName, strerror((*__errno_location ()))Cannot open directory '%s': %s
"Warning : %s is a symbolic link, ignoring\n", path..".."."."Warning : %s is a symbolic link, ignoring
"readdir(%s) error: %s\n", dirName, strerror(errno)"readdir(%s) error: %s\n", dirName, strerror((*__errno_location ()))readdir(%s) error: %s
statbuf.st_mode(statbuf.st_mode)6144040960timebuf07777statbuf->st_mode(statbuf->st_mode)stat_error__STRICT_ANSI__defined(_BSD_SOURCE) \defined(__MINGW32__) && defined (__MSVCRT__)defined(_WIN32) || defined(WIN32)defined(__FreeBSD__)__FreeBSD_version >= 1300008defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)/* assume 1 *//* value not queryable, fall back on 1 *//* Use POSIX sysconf
 * see: man 3 sysconf *//* sysctl not present, fall through to older sysconf method *//* freebsd sysctl is native int sized *//* Use physical core sysctl when available
 * see: man 4 smp, man 3 sysctl *//* fall back on the sysconf value *//* formatting was broken? *//* assume the cpu cores/siblings values will be constant across all
         * present processors *//* try to determine if there's hyperthreading *//* parse /proc/cpuinfo
 * siblings / cpu cores should give hyperthreading ratio
 * otherwise fall back on sysconf *//* entry not present, fall back on 1 *//* apple specifies int32_t *//* Use apple-provided syscall
 * see: man 3 sysctl *//* just in case *//* try to fall back on GetSystemInfo *//* some other error *//* count the number of physical cores *//* we could also exit() *//* with final \0 *//* clear errno after UTIL_isDirectory, UTIL_prepareFileList *//* Recursively call "UTIL_prepareFileList" with the new path. *//* include final \0 *//* macro guards, as defined in : https://linux.die.net/man/2/lstat *//* number of errors is returned *//* Copy file permissions *//* Copy ownership *//* set access and modification times *//* No good... *//* Only need to know whether it is a regular file *//* note : ensure that platform.h is included first ! */reservedmemsizemem64v4v3v2total_lenmem32large_lentotal_len_32XXH_STATIC_H_3543687687345/home/atharvakale/390r-debugging-setup/p7zip/C/fast-lzma2/xxhash.csizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t)XXH_static_assertXXH64_hash_t *sizeof(*dst)sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t)XXH32_hash_t *endian_detectedXXH_littleEndianXXH_FORCE_NATIVE_FORMATXXH_bigEndianXXH64_digest_endianconst unsigned long longconst unsigned long long *bEndh642870177450012600261PRIME64_511400714785074694791PRIME64_19650029242287828579PRIME64_414029467366897019727PRIME64_21609587929392839161PRIME64_3XXH64_update_endianstate_inendianXXH32_digest_endianconst unsigned int *h32state->v1state->v2state->v3state->v4374761393PRIME32_53266489917PRIME32_3668265263PRIME32_42654435761PRIME32_12246822519PRIME32_2XXH32_update_endianp32sizeof(state)sizeof(state)-8sizeof(state)-4sizeof(XXH64_state_t)sizeof(XXH32_state_t)XXH_FORCE_ALIGN_CHECKXXH_alignedXXH_unalignedXXH64_endian_alignalignXXH64_mergeRoundXXH64_roundaccXXH32_endian_alignXXH32_roundsizeof(*dstState)602XXH_readBE64XXH_readLE64XXH_readLE64_aligndstStatesrcStateconst U64 *XXH_readBE32XXH_readLE32XXH_readLE32_alignXXH_read64U64 *sizeof(val)XXH_read32XXH_memcpyXXH_freeXXH_mallocXXH_alignmentXXH_endianess2870177450012600261ULL9650029242287828579ULL1609587929392839161ULL14029467366897019727ULL11400714785074694791ULL374761393U668265263U3266489917U2246822519U2654435761Ug_oneXXH_get64bits(p)XXH_readLE64_align(p, endian, align)XXH_get32bits(p)XXH_readLE32_align(p, endian, align)XXH_STATIC_ASSERT(c){ enum { XXH_static_assert = 1/(int)(!!(c)) }; }XXH_CPU_LITTLE_ENDIAN(*(const char*)(&g_one))XXH_swap64XXH_swap32XXH_rotl64(x,r)((x << r) | (x >> (64 - r)))XXH_rotl32(x,r)((x << r) | (x >> (32 - r)))GCC_VERSION(__GNUC__ * 100 + __GNUC_MINOR__)MEM_MODULEXXH_FORCE_MEMORY_ACCESS(defined(__INTEL_COMPILER) && !defined(WIN32)) || \defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)(defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))(defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))GCC_VERSION >= 403XXH_ACCEPT_NULL_INPUT_POINTER/*! Default XXH result types are basic unsigned 32 and 64 bits.
*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
*   These functions allow transformation of hash result into and from its canonical format.
*   This way, hash values can be written into a file or buffer, and remain comparable across different systems and programs.
*//* tmp buffer is full *//* fill in tmp buffer *//* **** XXH64 **** *//* == seed *//* some data left from previous update *//* do not write into reserved, for future removal *//* using a local state to memcpy() in order to avoid strict-aliasing warnings *//*** Hash feed ***//* **************************************************
*  Advanced Hash Functions
****************************************************//* Input is aligned, let's leverage the speed advantage *//* Simple version, good for code maintenance, but unfortunately slow for small inputs *//* Input is 4-bytes aligned, leverage the speed benefit *//* ***************************
*  Simple Hash Functions
*****************************//* *************************************
*  Constants
***************************************//* use only *after* variable declarations *//* *************************************
*  Macros
***************************************//* ***************************
*  Memory reads
*****************************//* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line *//* *************************************
*  Architecture Macros
***************************************//* Note : although _rotl exists for minGW (GCC under windows), performance seems poor *//* ****************************************
*  Compiler-specific Functions and Macros
******************************************//* XXH_FORCE_DIRECT_MEMORY_ACCESS *//* portable and safe solution. Generally efficient.
 * see : http://stackoverflow.com/a/32095106/646947
 *//* Force direct memory access. Only works on CPU which support unaligned memory access in hardware *//* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. *//* *************************************
*  Basic Types
***************************************//* *************************************
*  Compiler Specific Options
***************************************//* for memcpy() *//* for malloc(), free() *//* Modify the local functions below should you wish to use some other memory routines *//* *************************************
*  Includes & Memory related functions
***************************************//* can be defined externally *//*!XXH_FORCE_ALIGN_CHECK :
 * This is a minor performance trick, only useful with lots of very small keys.
 * It means : check for aligned/unaligned input.
 * The check costs one initial branch per hash; set to 0 when the input data
 * is guaranteed to be aligned.
 *//*!XXH_FORCE_NATIVE_FORMAT :
 * By default, xxHash library provides endian-independant Hash values, based on little-endian convention.
 * Results are therefore identical for little-endian and big-endian CPU.
 * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
 * Should endian-independance be of no importance for your application, you may set the #define below to 1,
 * to improve speed for Big-endian CPU.
 * This option has no impact on Little_Endian CPU.
 *//* #define XXH_ACCEPT_NULL_INPUT_POINTER 1 *//*!XXH_ACCEPT_NULL_INPUT_POINTER :
 * If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.
 * When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.
 * By default, this option is disabled. To enable it, uncomment below define :
 *//*!XXH_FORCE_MEMORY_ACCESS :
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
 *            It can generate buggy code on targets which do not support unaligned memory accesses.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See http://stackoverflow.com/a/32095106/646947 for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//* *************************************
*  Tuning parameters
***************************************//*
*  xxHash - Fast Hash algorithm
*  Copyright (C) 2012-2016, Yann Collet
*
*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions are
*  met:
*
*  * Redistributions of source code must retain the above copyright
*  notice, this list of conditions and the following disclaimer.
*  * Redistributions in binary form must reproduce the above
*  copyright notice, this list of conditions and the following disclaimer
*  in the documentation and/or other materials provided with the
*  distribution.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*  You can contact the author at :
*  - xxHash homepage: http://www.xxhash.com
*  - xxHash source repository : https://github.com/Cyan4973/xxHash
*/static_assert_Static_assertassert(expr)(__ASSERT_VOID_CAST (0))__ASSERT_VOID_CAST_ASSERT_Hdefined __cplusplus && __GNUC_PREREQ (2,95)NDEBUG!defined __GNUC__ || defined __STRICT_ANSI__defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901Ldefined __USE_ISOC11 && !defined __cplusplus/* NDEBUG.  *//* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  *//* empty *//* The first occurrence of EXPR is not evaluated due to the sizeof,
   but will trigger any pedantic warnings masked by the __extension__
   for the second occurrence.  The ternary operator is required to
   support function pointers and bit fields in this context, and to
   suppress the evaluation of variable length arrays.  *//* When possible, define assert so that it does not add extra
   parentheses around EXPR.  Otherwise, those added parentheses would
   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  *//* The following is not at all used here but needed for standard
   compliance.  *//* Likewise, but prints the error text for ERRNUM.  *//* This prints an "Assertion failed" message and aborts.  *//* Not NDEBUG.  *//* void assert_perror (int errnum);

   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
   error message with the error text for ERRNUM and abort.
   (This is a GNU extension.) *//* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  *//* assert.h	*//*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 *//usr/lib/gcc/x86_64-redhat-linux/12/include/stdbool.h__bool_true_false_are_definedfalsetruebool_Bool_STDBOOL_Hdefined __STDC_VERSION__ && __STDC_VERSION__ > 201710L/* stdbool.h *//* Signal that all the definitions are present.  *//* Supporting _Bool in C++ is a GCC extension.  *//*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 *//* Copyright (C) 1998-2022 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/blake3.h<stdbool.h>blake3_hash_many_portableconst uint8_t *const *const uint32_t[8]blake3_compress_xof_portableBLAKE3_BLOCK_LENuint8_t[64]blake3_compress_in_place_portablestore_cv_words0 * 41 * 42 * 43 * 45 * 46 * 47 * 4store32load_key_wordsconst uint8_t[32]BLAKE3_KEY_LENload32counter_highcounter_lowround_down_to_power_of_21ULLpopcnthighest_oneblake3_flagsCHUNK_START1 << 0CHUNK_ENDPARENT1 << 2ROOT1 << 3KEYED_HASH1 << 4DERIVE_KEY_CONTEXT1 << 5DERIVE_KEY_MATERIALblake3_hasherblake3_chunk_stateuint8_t[1760]unsigned char[1760]BLAKE3_MAX_DEPTH(BLAKE3_MAX_DEPTH + 1)BLAKE3_OUT_LEN1760(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LENcv_stackcv_stack_lenchunkblocks_compressedbuf_lenchunk_countercvconst uint8_t[7][16]unsigned char[7][16]MSG_SCHEDULEIVMAX_SIMD_DEGREE_OR_2(MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)MAX_SIMD_DEGREEIS_X86_64IS_X86INLINEstatic inline __attribute__((always_inline))BLAKE3_CHUNK_LENBLAKE3_VERSION_STRING"0.3.7"BLAKE3_Hdefined(__i386__) || defined(_M_IX86)defined(IS_X86)defined(BLAKE3_USE_NEON)defined(__GNUC__) || defined(__clang__)defined(_MSC_VER) && defined(IS_X86_64)defined(_MSC_VER) && defined(IS_X86_32)blake3_simd_degreeblake3_hash_manyblake3_compress_xofblake3_compress_in_placeblake3_hasher_finalize_seekconst blake3_hasherconst blake3_hasher *blake3_hasher_finalizeblake3_hasher_updateblake3_hasher *blake3_hasher_init_derive_key_rawblake3_hasher_init_derive_keyblake3_hasher_init_keyedblake3_hasher_initblake3_version/* BLAKE3_H */// Declarations for implementation-specific functions.// when x is 0. // Largest power of two less than or equal to x. As a special case, returns 1// Count the number of 1 bits./* x is assumed to be nonzero.       *//* Find index of the highest set bit */// MAX_SIMD_DEGREE, but also at least 2.// There are some places where we want a static size that's equal to the// MSVC.// This C implementation tries to support recent versions of GCC, Clang, and// internal flags// reference implementation does things.// don't know whether more input is coming. This is different from how the// requires a 4th entry, rather than merging everything down to 1, because we// with 7 chunks, we have 3 entries in the stack. Adding an 8th chunk// The stack size is MAX_DEPTH + 1 because we do lazy merging. For example,// it's part of blake3_hasher below.// This struct is a private implementation detail. It has to be here because/* disable some warnings /TR *//**
 * This work is released into the public domain with CC0 1.0.
 * Alternatively, it is licensed under the Apache License 2.0.
 *
 * Homepage: https://github.com/BLAKE3-team/BLAKE3
 *
 * Copyright (c) 2019-2020 Samuel Neves and Jack O'Connor
 * Copyright (c) 2021 Tino Reichardt
 *//home/atharvakale/390r-debugging-setup/p7zip/C/hashesbytes_outcv_wordskey_wordscounterinputsnum_inputsincrement_counterflags_startflags_endseekout_leninput_lencontext_len/home/atharvakale/390r-debugging-setup/p7zip/C/hashes/blake3.c"blake3.h"hash_oneblock_flagsuint32_t[16]8 * 49 * 410 * 411 * 412 * 413 * 414 * 415 * 4compress_preblock_words4 * 04 * 14 * 34 * 54 * 64 * 74 * 94 * 104 * 114 * 124 * 134 * 144 * 15round_fnscheduleconst uint8_t(*)[16]const blake3_chunk_stateconst blake3_chunk_state *const output_tconst output_t *output_t *cvs_remainingparent_blockblake3_chunk_state *takechunk_cvsubtree_lencount_so_farsubtree_chunkschunk_statey2 * BLAKE3_OUT_LENcv_pairhasher_push_cvhasher_merge_cv_stackpost_merge_stack_lenparent_nodecontext_hashercontext_keycontext_key_wordshasher_init_basecompress_subtree_to_parent_nodecv_arraynum_cvsout_arrayblake3_compress_subtree_wideleft_input_lenright_input_lenright_inputright_chunk_counteruint8_t[1024]2 * MAX_SIMD_DEGREE_OR_22 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LENdegreeright_cvsleft_nright_nnum_chaining_valuescompress_parents_parallelconst uint8_t *[16]unsigned char *[16]parents_arrayparents_array_lencompress_chunks_parallelchunks_arrayinput_positionchunks_array_lenleft_lenfull_chunksnew_cvchild_chaining_valuescontent_lenparent_outputchunk_state_outputchunk_state_updateoutput_root_bytesoutput_block_counteroffset_within_blockwide_bufavailable_bytesmemcpy_lenoutput_chaining_valuemake_outputchunk_state_maybe_start_flagchunk_state_fill_bufchunk_state_lenchunk_state_resetchunk_state_init0.3.7output_tinput_cvdefined(BLAKE3_TESTING)// The dynamically detected SIMD degree of the current platform.// Mix the rows.// Mix the columns.// Select the message schedule based on the round.// There are always at least 2 CVs in the stack in this case.// that.// then the top of the stack is a chunk hash, and we start the merge from// each other first. Otherwise, if there are no bytes in the chunk state,// guarantees that none of the subtrees in the stack need to be merged with// this case, the extra merge loop at the end of blake3_hasher_update// roll-up merge between that chunk hash and every subtree in the stack. In// If there are any bytes in the chunk state, finalize that chunk and do a// If the subtree stack is empty, then the current chunk is the root.//   blake3_hasher_finalize(&hasher, v.data(), v.size());//   std::vector<uint8_t> v;// to memcpy. This comes up in practice with things like:// Explicitly checking for zero avoids causing UB by passing a null pointer// simplifies blake3_hasher_finalize below.// here, because hasher_push_chunk_cv already does its own merge loop, but it// know these merges are non-root. This merge loop isn't strictly necessary// stack doesn't contain any unmerged pairs. The remaining input means we// state. In that case, also do a final merge loop to make sure the subtree// If there's any remaining input less than a full chunk, add it to the chunk// on the caller giving us a long enough input.// This is the high-performance happy path, though getting here depends// chunk by itself. Otherwise, compress the subtree into a pair of CVs.// The shrunken subtree_len might now be 1 chunk long. If so, hash that one// https://github.com/BLAKE3-team/BLAKE3/issues/69.// odd, and we'll never graduate to higher degrees of parallelism. See// stuck always hashing 2 chunks. The total number of chunks will remain// parallelism. The problem with this optimization, is that it gets us// get the right answer in the end, and we might get to use 2-way SIMD// compress_subtree_to_parent_node. Since we'll get 2 CVs back, we'll still// example, if count_so_far is 1, we could pass 2 chunks to// An aside: We don't have to shrink subtree_len quite this much. For//// always be the full length of the input.)// typical, this loop condition will always fail, and subtree_len will// consistently passes power-of-2 inputs of the same size, as is hopefully// trick instead of an actual remainder operation. (Note that if the caller// that subtree_len itself is a power of 2, so we can use a bitmasking// Shrink the subtree_len until it evenly divides the count so far. We know// evenly divide what we already have, this part runs in a loop.// Because we might need to break up the input to form powers of 2, or to//   to complete the current subtree first.//   waiting for 1 more chunk, we can't hash a subtree of 4 chunks. We have//   point (if total is not 0). If the current incomplete subtree is only// - The subtree must evenly divide the total number of chunks up until this//   is going to be until we get to finalize().//   the right edge can be incomplete, and we don't know where the right edge// - The subtree has to be a power-of-2 number of chunks. Only subtrees along// multi-threading) parallelism. Two restrictions:// subtree we can, with the full benefits of SIMD (and maybe in the future,// a single chunk (so, definitely not the root chunk), hash the largest whole// Now the chunk_state is clear, and we have more input. If there's more than// chunk and proceed. In this case we know it's not the root.// If we've filled the current chunk and there's more coming, finalize this// to finish that chunk first.// If we have some partial chunk bytes in the internal chunk_state, we need//   blake3_hasher_update(&hasher, v.data(), v.size());// hashing an input all-at-once.)// remain unmerged. (That also helps us support extendable output when we're// merging with each of them separately, so that the second CV will always// *two* chaining values of the subtree it's compressing. We then do lazy// compress_subtree_to_parent_node(). That function always returns the top// Solving the first problem requires an additional tool,// merge the root node until finalize().// (unmerged) on top of the stack afterwards. This guarantees that we never// added, which is sitting on top of the stack, and we put the new CV// reference impl does. Instead we do merges using the *previous* CV that was// to add a CV to the stack, we don't merge it with anything first, as the// The second problem is solved with "lazy merging". That is, when we're about//    node at the root of the 256 KiB subtree until we know how to finalize it.//    we have 196 KiB (that is, 128 + 64) hashed so far. We can't compress the//    similarly going to be the the root of the whole tree. For example, maybe// 2) This 64 KiB input might complete a larger tree, whose root node is//    compress it until we know.//    of the whole tree, and it would need to be ROOT finalized. We can't//    In this case, the root node of the 64 KiB subtree would be the root node// 1) This 64 KiB input might be the only call that ever gets made to update.// This leads to two problems:// as a single subtree, if at all possible.// If the user gives us 64 KiB, we want to parallelize over all 64 KiB at once// compress_subtree_wide(), without setting aside anything for the chunk_state.// This setting is different. We want to feed as much input as possible to// we know none of the merges are root.// before pushing it. We can do that because we know more input is coming, so// In reference_impl.rs, we merge the new CV with existing CVs from the stack// represented by a 1-bit in the total number of chunks (or bytes) so far.// stack. The principle is the same: each CV that should remain in the stack is// that doesn't require us to retain the subtree size of the CV on top of the// described in the spec, we use a "count the total number of 1-bits" variant// order is maintained. Instead of the "count the trailing 0-bits" algorithm// any power-of-two number of chunks, as long as the smaller-above-larger stack// aren't always merging 1 chunk at a time. Instead, each CV might represent// different from the reference implementation. Another difference is that we// merges until right before the next CV is about to be added. This is// As described in hasher_push_cv() below, we do "lazy merging", delaying// them into 2 by forming parent nodes repeatedly.// compress_subtree_wide() returns more than 2 chaining values. Condense// If MAX_SIMD_DEGREE is greater than 2 and there's enough input,// chunk or less. That's a different codepath.// As with compress_subtree_wide(), this function is not used on inputs of 1// for extended output in the general case.// parent node of that subtree could end up being the root. It's also necessary// first call to update() supplies a complete subtree, because the topmost// concatenated chaining values of its children). This is necessary when the// last parent node, however. Instead, return its message bytes (the// list of chaining values down to a single parent node. Don't compress that// Hash a subtree with compress_subtree_wide(), and then condense the resulting// Otherwise, do one layer of parent node compression.// them directly, to make sure we always have at least two outputs.// right_n=1. Rather than compressing them into a single output, return// The special case again. If simd_degree=1, then we'll have left_n=1 and// future, this is where it will go.// Recurse! If this implementation adds multi-threading support in the// a different codepath.)// level, where we allow degree=1. (Note that the 1-chunk-input case is// sure there are two outputs. Except, as noted above, at the chunk// The special case: We always use a degree of at least two, to make// is 1.// account for the special case of returning 2 outputs when the SIMD degree// Make space for the child outputs. Here we use MAX_SIMD_DEGREE_OR_2 to// of 3 or something, we'll need a more complicated strategy.)// as long as the SIMD degree is a power of 2. If we ever get a SIMD degree// the input into left and right subtrees. (Note that this is only optimal// With more than simd_degree chunks, we need to recurse. Start by dividing// can help performance on smaller platforms.// this gives us the option of multi-threading even the 2-chunk case, which// when it is 1. If this implementation adds multi-threading in the future,// Note that the single chunk case does *not* bump the SIMD degree up to 2// multi-threading parallelism for that update().// of implementing this special rule? Because we don't want to limit SIMD or// Why not just have the caller split the input on the first update(), instead// codepath.// not used when the whole input is only 1 chunk long; that's a different// wouldn't be able to implement exendable ouput.) Note that this function is// root compression. (If it did, it would use the wrong flags, and also we// at least 2 outputs. This guarantees that this function doesn't perform the// As a special case when the SIMD degree is 1, this function will still return// implementation to hash as many parents in parallel as possible.// wide array of chaining values going back up the tree, is to allow the// if the input is shorter than that many chunks. The reason for maintaining a// is the dyanmically detected SIMD degree, at most MAX_SIMD_DEGREE. Or fewer,// and returns the length of that array. The number of chaining values returned// The wide helper function returns (writes out) an array of chaining values// If there's an odd child left over, it becomes an output.// Parents have no end flags.// Parents have no start flags.// Parents always use counter 0.// never empty; those cases use a different codepath.// return it as an additional output.) These parents are never the root and// number of parents hashed. (If there's an odd input chaining value left over,// on a single thread. Write out the parent chaining values and return the// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE parents at the same time// chunk (meaning the empty message) is a different codepath.// Hash the remaining partial chunk, if there is one. Note that the empty// those cases use a different codepath.// number of chunks hashed. These chunks are never the root and never empty;// on a single thread. Write out the chunk chaining values and return the// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE chunks at the same time// should always be greater than BLAKE3_CHUNK_LEN.// Subtract 1 to reserve at least one byte for the right side. content_len// chunks that leaves at least 1 byte for the right subtree.// should go in the left subtree. This is the largest power-of-2 number of// Given some input larger than one chunk, return the number of bytes that// bytes.// bytes. For that reason, chaining values in the CV stack are represented as// interface handles both user input and parent node blocks, so it accepts// conversion overhead in the portable implementation. However, the hash_many// interface) are represented as words. This avoids unnecessary bytes<->words// Chaining values within a given chunk (specifically the compress_in_place/home/atharvakale/390r-debugging-setup/p7zip/C/hashes/hash.h"../7zTypes.h"min(a,b)(((a)>(b))?(b):(a))_UINT64_T_DECLARED_UINT32_T_DECLARED__hash_h__/* __hash_h__ *///#include <stdint.h>/* stuff in common between md4, md5, and sha1 *//* $Id$ *//*
 * Copyright (c) 1999 Kungliga Tekniska Hgskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of KTH nor the names of its contributors may be
 *    used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY KTH AND ITS CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL KTH OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md2.h"hash.h"MD2_CTXmd2checksumMD2_DIGEST_LENGTHHEIM_MD2_HMD2_Finalmd2 *MD2_UpdateMD2_Init/* HEIM_MD2_H *//* lower 16 bytes of X *//* stored unalligned data between Update's *//*
 * Copyright (c) 2006 Kungliga Tekniska Hgskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md2.c"md2.h"padlensizeof(*m)const unsigned charconst unsigned char *calcunsigned char[48]Lconst unsigned char[256]sizeof(x)subst/home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md4.hMD4_CTXmd4saveszMD4_DIGEST_LENGTHHEIM_MD4_HMD4_Finalmd4 *MD4_UpdateMD4_Init/* HEIM_MD4_H *//*
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Hgskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md4.c"md4.h"unsigned char[72]dstartsizeof(zeros)sizeof(zeros) - 1old_sz64 - offsetAABBCCDDAm->counter[0]Bm->counter[1]Cm->counter[2]m->counter[3]F(m->counter[1] & m->counter[2]) | (~m->counter[1] & m->counter[3])(m->counter[0] & m->counter[1]) | (~m->counter[0] & m->counter[2])(m->counter[3] & m->counter[0]) | (~m->counter[3] & m->counter[1])(m->counter[2] & m->counter[3]) | (~m->counter[2] & m->counter[0])0x5A8279990x6ED9EBA1H0x98badcfe0xefcdab89cshift(x << n) | (x >> (32 - n))x32DO3(a,b,c,d,k,s,i)DOIT(a,b,c,d,k,s,i,H)DO2(a,b,c,d,k,s,i)DOIT(a,b,c,d,k,s,i,G)DO1(a,b,c,d,k,s,i)DOIT(a,b,c,d,k,s,i,F)DOIT(a,b,c,d,k,s,i,OP)a = cshift(a + OP(b,c,d) + X[k] + i, s)H(x,y,z)(x ^ y ^ z)G(x,y,z)((x & y) | (x & z) | (y & z))F(x,y,z)CRAYFIX((x & y) | (~x & z))CRAYFIX(X)(X)_CRAYdefined(WORDS_BIGENDIAN)/*
 * From `Performance analysis of MD5' by Joseph D. Touch <touch@isi.edu>
 *//* Round 3 *//* Round 2 *//* Round 1 *//* Vector Crays doesn't have a good 32-bit type, or more precisely,
   int32_t as defined by <bind/bitypes.h> isn't 32 bits, and we don't
   want to depend in being able to redefine this type.  To cope with
   this we have to clamp the result in some places to [0,2^32); no
   need to do this on other machines.  Did I say this was a mess?
   *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md5.hMD5_CTXmd5MD5_DIGEST_LENGTHHEIM_MD5_HMD5_Finalmd5 *MD5_UpdateMD5_Init/* HEIM_MD5_H *//* uint32_t res[4] *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/md5.c"md5.h"0xd76aa47836140903600xe8c7b75639054027100x242070db6061058190xc1bdceee32504419660xf57c0faf41185483990x4787c62a12000804260xa830461328217359550xfd46950142492613130x698098d817700354160x8b44f7af23365528790xffff5bb142949252330x895cd7be23045631340x6b90112218046036820xfd98719342546261950xa679438e27929650060x49b4082112365353290xf61e2562(m->counter[1] & m->counter[3]) | (m->counter[2] & ~m->counter[3])41291707860xc040b340(m->counter[0] & m->counter[2]) | (m->counter[1] & ~m->counter[2])32254656640x265e5a51(m->counter[3] & m->counter[1]) | (m->counter[0] & ~m->counter[1])6437177130xe9b6c7aa(m->counter[2] & m->counter[0]) | (m->counter[3] & ~m->counter[0])39210699940xd62f105d35934086050x2441453380160830xd8a1e68136344889610xe7d3fbc838894294480x21e1cde65684464380xc33707d632751636060xf4d50d8741076033350x455a14ed11635315010xa9e3e90528502858290xfcefa3f842435635120x676f02d917353284730x8d2a4c8a23683595620xfffa394242945887380x8771f68122723928330x6d9d612218390305620xfde5380c42596577400xa4beea4427639752360x4bdecfa912728933530xf6bb4b6041394696640xbebfbc7032002366560x289b7ec66812791740xeaa127fa39364300740xd4ef308535724453170x4881d05760291890xd9d4d03936546028090xe6db99e538731514610x1fa27cf85307425200xc4ac566532996286450xf4292244Im->counter[2] ^ (m->counter[1] | ~m->counter[3])40963364520x432aff97m->counter[1] ^ (m->counter[0] | ~m->counter[2])11268914150xab9423a7m->counter[0] ^ (m->counter[3] | ~m->counter[1])28786123910xfc93a039m->counter[3] ^ (m->counter[2] | ~m->counter[0])42375332410x655b59c317004855710x8f0ccc9223999806900xffeff47d42939157730x85845dd122400444970x6fa87e4f18733133590xfe2ce6e042643555520xa301431427347689160x4e0811a113091516490xf7537e8241494442260xbd3af23531747569170x2ad7d2bb7187872590xeb86d3913951481745DO4(a,b,c,d,k,s,i)DOIT(a,b,c,d,k,s,i,I)a = b + cshift(a + OP(b,c,d) + X[k] + (i), s)I(x,y,z)CRAYFIX(y ^ (x | ~z))CRAYFIX((x & z) | (y & ~z))/* Round 4 *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/sha.hSHA384_CTXSHA512_CTXhc_sha512stateuint64_t[8]unsigned long long[8]SHA384_DIGEST_LENGTHSHA512_DIGEST_LENGTHHEIM_SHA_HSHA384_FinalSHA384_CTX *hc_sha512state *SHA384_UpdateSHA384_InitSHA512_FinalSHA512_CTX *SHA512_UpdateSHA512_Init/* HEIM_SHA_H *//*
 * SHA-2 512
 *//home/atharvakale/390r-debugging-setup/p7zip/C/hashes/sha512.c"sha.h"146805004363401540720xcbbb9d5dc1059ed8ULL71050366234098946630x629a292a367cd507ULL104734038952981865190x9159015a3070dd17ULL15266992153038912570x152fecd8f70e5939ULL74363296378330836970x67332667ffc00b31ULL102829257946253284010x8eb44a8768581511ULL157840414290902752390xdb0c2e0d64f98fa7ULL51671154400728390760x47b5481dbefa4fa4ULLunsigned char[144]128 + 160XFF128 - offsetuint64_t[16]unsigned long long[16]currentx64 *swap_uint64_t183749668594149619200xff00ff00ff00ff00ULL717772142945896950x00ff00ff00ff00ffULL184464626030277427200xffff0000ffff0000ULL2814706818088950x0000ffff0000ffffULLEEFFGGHHuint64_t[80]unsigned long long[80]data[i-2]data[i-15]T1T2const uint64_t[80]76408915769560128080x6a09e667f3bcc908ULL135039538961754785870xbb67ae8584caa73bULL43546855649368453550x3c6ef372fe94f82bULL119120091704709096810xa54ff53a5f1d36f1ULL58406964750780013610x510e527fade682d1ULL111704494019926047030x9b05688c2b3e6c1fULL22708979698028865070x1f83d9abfb41bd6bULL66205169598195388090x5be0cd19137e2179ULLcshift64(uint64_t)64x64constant_51247946970867806162260x428a2f98d728ae22ULL81580646401687812610x7137449123ef65cdULL130967445868346888150xb5c0fbcfec4d3b2fULL168406078855112201560xe9b5dba58189dbbcULL41317034083384497200x3956c25bf348b538ULL64809810686014791930x59f111f1b605d019ULL105382852968941689870x923f82a4af194f9bULL123298341524192299760xab1c5ed5da6d8118ULL155665982095760430740xd807aa98a3030242ULL13340099756498902380x12835b0145706fbeULL26080127116381190520x243185be4ee4b28cULL61284114730068021460x550c7dc3d5ffb4e2ULL82681487227645812310x72be5d74f27b896fULL92860551871556870890x80deb1fe3b1696b1ULL112308588857182828050x9bdc06a725c71235ULL139510097547085185480xc19bf174cf692694ULL164728763423539391540xe49b69c19ef14ad2ULL172753238624357022430xefbe4786384f25e3ULL11353620571444238610x0fc19dc68b8cd5b5ULL25976289846391348210x240ca1cc77ac9c65ULL33082242580293228690x2de92c6f592b0275ULL53650589236408413470x4a7484aa6ea6e483ULL66790250129235629640x5cb0a9dcbd41fbd4ULL85730338377596486930x76f988da831153b5ULL109702951589499944110x983e5152ee66dfabULL121196862444512343200xa831c66d2db43210ULL126830247181189860470xb00327c898fb213fULL137881922300500415720xbf597fc7beef0ee4ULL143304671536323337620xc6e00bf33da88fc2ULL153954335877849843570xd5a79147930aa725ULL4893127128249473110x06ca6351e003826fULL14527378773307838560x142929670a0e6e70ULL28617676557523476440x27b70a8546d22ffcULL33222856760638036860x2e1b21385c26c926ULL55609405705177115970x4d2c6dfc5ac42aedULL59965572817431889590x53380d139d95b3dfULL72807585545558025900x650a73548baf63deULL85326442432964655760x766a0abb3c77b2a8ULL93502569769870087420x81c2c92e47edaee6ULL105525458269688435790x92722c851482353bULL117273477341743030760xa2bfe8a14cf10364ULL121131066232334049290xa81a664bbc423001ULL140004371832698694570xc24b8b70d0f89791ULL143699502716601462240xc76c51a30654be30ULL151013876982045291760xd192e819d6ef5218ULL154633975486746237600xd69906245565a910ULL175860524417423196580xf40e35855771202aULL11829342558861275440x106aa07032bbd1b8ULL18478140504630110160x19a4c116b8d2d0c8ULL21773277278357205310x1e376c085141ab53ULL28306435378542621690x2748774cdf8eeb99ULL37967419752334808720x34b0bcb5e19b48a8ULL41151781257667774430x391c0cb3c5c95a63ULL56814781685449059310x4ed8aa4ae3418acbULL66013735964725666430x5b9cca4f7763e373ULL75070607219429684830x682e6ff3d6b2b8a3ULL83990757903590817240x748f82ee5defb2fcULL86934639852267231680x78a5636f43172f60ULL95680294383602020980x84c87814a1f0ab72ULL101440789195011015480x8cc702081a6439ecULL104300552368372526480x90befffa23631e28ULL118400831806632586010xa4506cebde82bde9ULL137612104206588623570xbef9a3f7b2c67915ULL142993432764713746350xc67178f2e372532bULL145666805781657276440xca273eceea26619cULL150979579662104499270xd186b8c721c0c207ULL169229769113286029100xeada7dd6cde0eb1eULL176893823222608572080xf57d4f7fee6ed178ULL5000135403943648580x06f067aa72176fbaULL7485802508667188860x0a637dc5a2c898a6ULL12428791683288303820x113f9804bef90daeULL19773740339741509390x1b710b35131c471bULL29440786761549408040x28db77f523047d84ULL36599261930480692670x32caab7b40c72493ULL43681376391204533080x3c9ebe0a15c9bebcULL48361356689953293560x431d67c49c100d4cULL55320616332132522780x4cc5d4becb3e42b6ULL64489189456439864740x597f299cfc657e2aULL69027336350926753080x5fcb6fab3ad6faecULL78013885448448471270x6c44198c4a475817ULLm->counter[7]m->counter[6]m->counter[5]Em->counter[4]sigma1(x)(ROTR(x,19) ^ ROTR(x,61) ^ ((x)>>6))sigma0(x)(ROTR(x,1) ^ ROTR(x,8) ^ ((x)>>7))Sigma1(x)(ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41))Sigma0(x)(ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39))ROTR(x,n)(((x)>>(n)) | ((x) << (64 - (n))))(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))(((x) & (y)) ^ ((~(x)) & (z)))!defined(WORDS_BIGENDIAN) || defined(_CRAY)/*
 * Copyright (c) 2006, 2010 Kungliga Tekniska Hgskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/error_public.hFSE_ErrorCodeFSE_error_no_errorFSE_error_GENERICFSE_error_dstSize_tooSmallFSE_error_srcSize_wrongFSE_error_corruption_detectedFSE_error_tableLog_tooLargeFSE_error_maxSymbolValue_tooLargeFSE_error_maxSymbolValue_tooSmallFSE_error_maxCodeERROR_PUBLIC_H_MODULE/* ERROR_PUBLIC_H_MODULE *//* note : compare with size_t function results using FSE_getError() *//* ****************************************
*  error codes list
******************************************//* ******************************************************************
   Error codes list
   Copyright (C) 2016, Yann Collet

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
   - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/error_private.h"error_public.h"ERR_getErrorNameERR_getErrorStringtableLog_tooLargemaxSymbolValue_tooLargemaxSymbolValue_tooSmallSrc size incorrect"Src size incorrect"tableLog requires too much memory : unsupported"tableLog requires too much memory : unsupported"Unsupported max Symbol Value : too large"Unsupported max Symbol Value : too large"Specified maxSymbolValue is too small"Specified maxSymbolValue is too small"ERR_getErrorCode(ERR_enum)0ERR_isErrorERROR(maxCode)ERR_enumERROR(name)FSE_error_ ## nameERR_STATICERROR_H_MODULEERROR/* ERROR_H_MODULE *//*-****************************************
*  Error Strings
******************************************//* reported already defined on VS 2015 (Rich Geldreich) *//*-****************************************
*  Customization (error_public.h)
******************************************//* ****************************************
*  Compiler-specific
******************************************//* enum list *//* ****************************************
*  Dependencies
******************************************//* Note : this module is expected to remain private, do not expose it *//* ******************************************************************
   Error codes and messages
   Copyright (C) 2013-2016, Yann Collet

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Homepage : http://www.zstd.net
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/bitstream.h"error_private.h"BIT_endOfDStreamconst BIT_DStream_tconst BIT_DStream_t *sizeof(DStream->bitContainer)sizeof(DStream->bitContainer)*8BIT_reloadDStreamBIT_DStream_t *sizeof(bitD->bitContainer)sizeof(bitD->bitContainer)*8(sizeof(bitD->bitContainer)*8)BIT_DStream_overflowBIT_DStream_unfinishedBIT_DStream_endOfBufferBIT_DStream_completednbBytesBIT_readBitsFastBIT_readBitsBIT_skipBitsBIT_lookBitsFastbitMasksizeof(bitD->bitContainer)*8 - 1bitMask+1(bitMask+1)BIT_lookBitsBIT_getLowerBitsconst unsigned int[27]unsigned int[27]BIT_getMiddleBitsBIT_getUpperBitsBIT_initDStreamsizeof(*bitD)ERROR(srcSize_wrong)lastByteERROR(GENERIC)sizeof(bitD->bitContainer)*8 - 16(sizeof(bitD->bitContainer)*8 - 16)sizeof(bitD->bitContainer)*8 - 24(sizeof(bitD->bitContainer)*8 - 24)sizeof(bitD->bitContainer)*8 - 32(sizeof(bitD->bitContainer)*8 - 32)BIT_closeCStreamBIT_CStream_t *BIT_flushBitsBIT_flushBitsFastBIT_addBitsFastBIT_addBitsBIT_initCStreamsizeof(bitC->ptr)ERROR(dstSize_tooSmall)BIT_highbit32BIT_DStream_statusBIT_DStream_tBIT_CStream_tbitsConsumedbitContainerendPtrstartPtrbitPosconst unsigned int[]BIT_mask0x1FF0x1FFF0x3FFF0x7FFF0x1FFFF0x3FFFF0x7FFFF0x3FFFFF0x7FFFFF0x3FFFFFFBITSTREAM_H_MODULEdefined(__BMI__) && defined(__GNUC__)defined(__BMI__) && defined(__GNUC__) && __GNUC__*1000+__GNUC_MINOR__ >= 4008DStreambitDnbBitssrcBufferbitC/* BITSTREAM_H_MODULE *//*! BIT_endOfDStream() :
*   @return Tells if DStream has exactly reached its end (all bits consumed).
*//* reminder : srcSize > sizeof(bitD) *//* ptr > start *//* should not happen => corruption detected *//*! BIT_reloadDStream() :
*   Refill `bitD` from buffer previously set in BIT_initDStream() .
*   This function is safe, it guarantees it will not read beyond src buffer.
*   @return : status of `BIT_DStream_t` internal register.
              if status == BIT_DStream_unfinished, internal register is filled with >= (sizeof(bitD->bitContainer)*8 - 7) bits *//*! BIT_readBitsFast() :
*   unsafe version; only works only if nbBits >= 1 *//*! BIT_readBits() :
 *  Read (consume) next n bits from local register and update.
 *  Pay attention to not read more than nbBits contained into local register.
 *  @return : extracted value.
 *//*! BIT_lookBitsFast() :
*   unsafe version; only works only if nbBits >= 1 *//* experimental; fails if bitD->bitsConsumed + nbBits > sizeof(bitD->bitContainer)*8 *//*! BIT_lookBits() :
 *  Provides next n bits from local register.
 *  local register is not modified.
 *  On 32-bits, maxNbBits==24.
 *  On 64-bits, maxNbBits==56.
 *  @return : value extracted
 *//* experimental *//* endMark not present *//* ensures bitsConsumed is always set *//* normal case *//*! BIT_initDStream() :
*   Initialize a BIT_DStream_t.
*   `bitD` : a pointer to an already allocated BIT_DStream_t structure.
*   `srcSize` must be the *exact* size of the bitStream, in bytes.
*   @return : size of stream (== srcSize) or an errorCode if a problem is detected
*//*-********************************************************
* bitStream decoding
**********************************************************//* doesn't fit within authorized budget : cancel *//* endMark *//*! BIT_closeCStream() :
 *  @return : size of CStream, in bytes,
              or 0 if it could not fit into dstBuffer *//* if bitPos >= sizeof(bitContainer)*8 --> undefined behavior *//*! BIT_flushBits() :
 *  safe version; check for buffer overflow, and prevents it.
 *  note : does not signal buffer overflow. This will be revealed later on using BIT_closeCStream() *//*! BIT_flushBitsFast() :
 *  unsafe version; does not check buffer overflow *//*! BIT_addBitsFast() :
 *  works only if `value` is _clean_, meaning all high bits above nbBits are 0 *//*! BIT_addBits() :
    can add up to 26 bits into `bitC`.
    Does not check for register overflow ! *//*! BIT_initCStream() :
 *  `dstCapacity` must be > sizeof(void*)
 *  @return : 0 if success,
              otherwise an error code (can be tested using ERR_isError() ) *//*-**************************************************************
*  bitStream encoding
****************************************************************//* up to 26 bits *//*=====    Local Constants   =====*//* Use GCC Intrinsic *//*-**************************************************************
*  Internal functions
****************************************************************//* faster, but works only if nbBits >= 1 *//* unsafe version; does not check buffer overflow *//* faster, but works only if value is "clean", meaning all high bits above nbBits are 0 *//*-****************************************
*  unsafe API
******************************************//* Start by invoking BIT_initDStream().
*  A chunk of the bitStream is then stored into a local register.
*  Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).
*  You can then retrieve bitFields stored into the local register, **in reverse order**.
*  Local register is explicitly reloaded from memory by the BIT_reloadDStream() method.
*  A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BIT_DStream_unfinished.
*  Otherwise, it can be less than that, so proceed accordingly.
*  Checking if DStream has reached its end can be performed with BIT_endOfDStream().
*//* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( *//* result of BIT_reloadDStream() *//*-********************************************
*  bitStream decoding API (read backward)
**********************************************//* Start with initCStream, providing the size of buffer to write into.
*  bitStream will never write outside of this buffer.
*  `dstCapacity` must be >= sizeof(bitD->bitContainer), otherwise @return will be an error code.
*
*  bits are first added to a local register.
*  Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems.
*  Writing data into memory is an explicit operation, performed by the flushBits function.
*  Hence keep track how many bits are potentially stored into local register to avoid register overflow.
*  After a flushBits, a maximum of 7 bits might still be stored into local register.
*
*  Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers.
*
*  Last operation is to close the bitStream.
*  The function returns the final size of CStream in bytes.
*  If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable)
*//* bitStream can mix input from multiple sources.
*  A critical property of these streams is that they encode and decode in **reverse** direction.
*  So the first bit sequence you add will be the last to be read, like a LIFO stack.
*//*-******************************************
*  bitStream encoding API (write forward)
********************************************//* support for bextr (experimental) *//*=========================================
*  Target specific
=========================================*//* error codes and messages *//* unaligned access routines *//*
*  This API consists of small unitary functions, which must be inlined for best performance.
*  Since link-time-optimization is not available for all compilers,
*  these functions are defined into a .h to be included.
*//* ******************************************************************
   bitstream
   Part of FSE library
   header file (to include)
   Copyright (C) 2013-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
****************************************************************** */dstBuffer/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/fse.h"bitstream.h"FSE_endOfDStateconst FSE_DState_tconst FSE_DState_t *FSE_decodeSymbolFastFSE_DState_t *const FSE_decode_tDInfoconst FSE_decode_t *lowBitsFSE_decodeSymbolFSE_updateStateFSE_peekSymbolFSE_initDStateconst FSE_DTableconst FSE_DTable *const FSE_DTableHeaderconst FSE_DTableHeader *const FSE_DTableHeader *constDTableHFSE_flushCStateconst FSE_CState_tconst FSE_CState_t *FSE_encodeSymbolFSE_CState_t *const FSE_symbolCompressionTransformsymbolTTconst FSE_symbolCompressionTransform *const U16const U16 *const U16 *conststateTablenbBitsOutFSE_initCState2const FSE_CTableconst FSE_CTable *1<<15(1<<15)FSE_initCStateu16ptrtableLogFSE_decompress_wkspFSE_DTable *FSE_buildDTable_rleFSE_buildDTable_rawFSE_buildCTable_wkspFSE_CTable *FSE_buildCTable_rleFSE_buildCTable_rawFSE_compress_wkspFSE_optimalTableLog_internalFSE_count_simpleFSE_countFast_wkspFSE_countFastFSE_count_wkspFSE_decompress_usingDTableFSE_buildDTableFSE_freeDTableFSE_createDTableFSE_compress_usingCTableFSE_buildCTableFSE_freeCTableFSE_createCTableFSE_writeNCountFSE_NCountWriteBoundFSE_normalizeCountFSE_optimalTableLogFSE_countFSE_compress2FSE_compressBoundFSE_decompressFSE_compressFSE_decode_tFSE_DTableHeaderFSE_symbolCompressionTransformFSE_DState_tFSE_CState_tFSE_DTableFSE_CTablenewStatedeltaNbBitsdeltaFindStatestateLogFSE_TABLESTEP(tableSize)((tableSize>>1) + (tableSize>>3) + 3)FSE_TABLELOG_ABSOLUTE_MAXFSE_MIN_TABLELOGFSE_DEFAULT_TABLELOG(FSE_DEFAULT_MEMORY_USAGE-2)FSE_MAXTABLESIZE_MASK(FSE_MAX_TABLESIZE-1)FSE_MAX_TABLESIZE(1U<<FSE_MAX_TABLELOG)FSE_MAX_TABLELOG(FSE_MAX_MEMORY_USAGE-2)FSE_DECODE_TYPEFSE_FUNCTION_EXTENSIONFSE_FUNCTION_TYPEFSE_MAX_SYMBOL_VALUEFSE_DEFAULT_MEMORY_USAGEFSE_MAX_MEMORY_USAGEFSE_WKSP_SIZE_U32(maxTableLog,maxSymbolValue)( FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) + (1<<((maxTableLog>2)?(maxTableLog-2):0)) )FSE_DTABLE_SIZE_U32(maxTableLog)(1 + (1<<maxTableLog))FSE_CTABLE_SIZE_U32(maxTableLog,maxSymbolValue)(1 + (1<<(maxTableLog-1)) + ((maxSymbolValue+1)*2))FSE_COMPRESSBOUND(size)(FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))FSE_BLOCKBOUND(size)(size + (size>>7))FSE_NCOUNTBOUNDFSE_VERSION_NUMBER(FSE_VERSION_MAJOR *100*100 + FSE_VERSION_MINOR *100 + FSE_VERSION_RELEASE)FSE_VERSION_STRINGFSE_EXPAND_AND_QUOTE(FSE_LIB_VERSION)FSE_EXPAND_AND_QUOTE(str)FSE_QUOTE(str)FSE_LIB_VERSIONFSE_VERSION_MAJOR.FSE_VERSION_MINOR.FSE_VERSION_RELEASEFSE_VERSION_RELEASEFSE_VERSION_MINORFSE_VERSION_MAJORFSE_PUBLIC_APIFSE_Hdefined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1) && defined(__GNUC__) && (__GNUC__ >= 4)defined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1)defined(FSE_DLL_IMPORT) && (FSE_DLL_IMPORT==1)FSE_STATIC_LINKING_ONLYFSE_COMMONDEFS_ONLYFSE_MAX_TABLELOG > FSE_TABLELOG_ABSOLUTE_MAXFSE_readNCountFSE_getErrorNameFSE_isErrorFSE_versionNumber/* FSE_H *//* FSE_STATIC_LINKING_ONLY *//* ***************************************************************
*  Constants
*****************************************************************//* !FSE_COMMONDEFS_ONLY *//* **************************************************************
*  template functions type & suffix
****************************************************************//*!FSE_MAX_SYMBOL_VALUE :
*  Maximum symbol value authorized.
*  Required for proper stack allocation *//*!MEMORY_USAGE :
*  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
*  Increasing memory usage improves compression ratio
*  Reduced memory usage can improve speed, due to cache effect
*  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache *//* **************************************************************
*  Tuning parameters
****************************************************************//*! FSE_decodeSymbolFast() :
    unsafe, only works if no symbol has a probability > 50% *//* size == U32 *//* sizeof U32 *//* ======    Decompression    ====== *//*! FSE_initCState2() :
*   Same as FSE_initCState(), but the first symbol to include (which will be the last to be read)
*   uses the smallest state value possible, saving the cost of this symbol *//* total 8 bytes *//* *****************************************
*  Implementation of inlined functions
*******************************************//* faster, but works only if nbBits is always >= 1 (otherwise, result will be corrupted) *//* *****************************************
*  FSE unsafe API
*******************************************//**<
Let's now decompose FSE_decompress_usingDTable() into its unitary components.
You will decode FSE-encoded symbols from the bitStream,
and also any other bitFields you put in, **in reverse order**.

You will need a few variables to track your bitStream. They are :

BIT_DStream_t DStream;    // Stream context
FSE_DState_t  DState;     // State context. Multiple ones are possible
FSE_DTable*   DTablePtr;  // Decoding table, provided by FSE_buildDTable()

The first thing to do is to init the bitStream.
    errorCode = BIT_initDStream(&DStream, srcBuffer, srcSize);

You should then retrieve your initial state(s)
(in reverse flushing order if you have several ones) :
    errorCode = FSE_initDState(&DState, &DStream, DTablePtr);

You can then decode your data, symbol after symbol.
For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'.
Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).
    unsigned char symbol = FSE_decodeSymbol(&DState, &DStream);

You can retrieve any bitfield you eventually stored into the bitStream (in reverse order)
Note : maximum allowed nbBits is 25, for 32-bits compatibility
    size_t bitField = BIT_readBits(&DStream, nbBits);

All above operations only read from local register (which size depends on size_t).
Refueling the register from memory is manually performed by the reload method.
    endSignal = FSE_reloadDStream(&DStream);

BIT_reloadDStream() result tells if there is still some more data to read from DStream.
BIT_DStream_unfinished : there is still some data left into the DStream.
BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled.
BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed.
BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted.

When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop,
to properly detect the exact end of stream.
After each decoded symbol, check if DStream is fully consumed using this simple test :
    BIT_reloadDStream(&DStream) >= BIT_DStream_completed

When it's done, verify decompression is fully completed, by checking both DStream and the relevant states.
Checking if DStream has reached its end is performed by :
    BIT_endOfDStream(&DStream);
Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.
    FSE_endOfDState(&DState);
*//* precise table may vary, depending on U16 *//* *****************************************
*  FSE symbol decompression API
*******************************************//**<
These functions are inner components of FSE_compress_usingCTable().
They allow the creation of custom streams, mixing multiple tables and bit sources.

A key property to keep in mind is that encoding and decoding are done **in reverse direction**.
So the first symbol you will encode is the last you will decode, like a LIFO stack.

You will need a few variables to track your CStream. They are :

FSE_CTable    ct;         // Provided by FSE_buildCTable()
BIT_CStream_t bitStream;  // bitStream tracking structure
FSE_CState_t  state;      // State tracking structure (can have several)


The first thing to do is to init bitStream and state.
    size_t errorCode = BIT_initCStream(&bitStream, dstBuffer, maxDstSize);
    FSE_initCState(&state, ct);

Note that BIT_initCStream() can produce an error code, so its result should be tested, using FSE_isError();
You can then encode your input data, byte after byte.
FSE_encodeSymbol() outputs a maximum of 'tableLog' bits at a time.
Remember decoding will be done in reverse direction.
    FSE_encodeByte(&bitStream, &state, symbol);

At any time, you can also add any bit sequence.
Note : maximum allowed nbBits is 25, for compatibility with 32-bits decoders
    BIT_addBits(&bitStream, bitField, nbBits);

The above methods don't commit data to memory, they just store it into local register, for speed.
Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).
Writing data to memory is a manual operation, performed by the flushBits function.
    BIT_flushBits(&bitStream);

Your last FSE encoding operation shall be to flush your last state value(s).
    FSE_flushState(&bitStream, &state);

Finally, you must close the bitStream.
The function returns the size of CStream in bytes.
If data couldn't fit into dstBuffer, it will return a 0 ( == not compressible)
If there is an error, it returns an errorCode (which can be tested using FSE_isError()).
    size_t size = BIT_closeCStream(&bitStream);
*//*!
   This API consists of small unitary functions, which highly benefit from being inlined.
   Hence their body are included in next section.
*//* *****************************************
*  FSE symbol compression API
*******************************************//**< same as FSE_decompress(), using an externally allocated `workSpace` produced with `FSE_DTABLE_SIZE_U32(maxLog)` *//**< build a fake FSE_DTable, designed to always generate the same symbolValue *//**< build a fake FSE_DTable, designed to read a flat distribution where each symbol uses nbBits *//* FSE_buildCTable_wksp() :
 * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).
 * `wkspSize` must be >= `(1<<tableLog)`.
 *//**< build a fake FSE_CTable, designed to compress always the same symbolValue *//**< build a fake FSE_CTable, designed for a flat distribution, where each symbol uses nbBits *//* FSE_compress_wksp() :
 * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).
 * FSE_WKSP_SIZE_U32() provides the minimum size required for `workSpace` as a table of FSE_CTable.
 *//**< same as FSE_optimalTableLog(), which used `minus==2` *//*! FSE_count_simple
 * Same as FSE_countFast(), but does not use any additional memory (not even on stack).
 * This function is unsafe, and will segfault if any value within `src` is `> *maxSymbolValuePtr` (presuming it's also the size of `count`).
*//* FSE_countFast_wksp() :
 * Same as FSE_countFast(), but using an externally provided scratch buffer.
 * `workSpace` must be a table of minimum `1024` unsigned
 *//** FSE_countFast() :
 *  same as FSE_count(), but blindly trusts that all byte values within src are <= *maxSymbolValuePtr
 *//* FSE_count_wksp() :
 * Same as FSE_count(), but using an externally provided scratch buffer.
 * `workSpace` size must be table of >= `1024` unsigned
 *//* *****************************************
*  FSE advanced API
*******************************************//* It is possible to statically allocate FSE CTable/DTable as a table of FSE_CTable/FSE_DTable using below macros *//* Macro version, useful for static allocation *//* FSE buffer bounds *//* *****************************************
*  Static allocation
*******************************************//* *** Dependency *** *//*!
Tutorial :
----------
(Note : these functions only decompress FSE-compressed blocks.
 If block is uncompressed, use memcpy() instead
 If block is a single repeated byte, use memset() instead )

The first step is to obtain the normalized frequencies of symbols.
This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount().
'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short.
In practice, that means it's necessary to know 'maxSymbolValue' beforehand,
or size the table to handle worst case situations (typically 256).
FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'.
The result of FSE_readNCount() is the number of bytes read from 'rBuffer'.
Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that.
If there is an error, the function will return an error code, which can be tested using FSE_isError().

The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'.
This is performed by the function FSE_buildDTable().
The space required by 'FSE_DTable' must be already allocated using FSE_createDTable().
If there is an error, the function will return an error code, which can be tested using FSE_isError().

`FSE_DTable` can then be used to decompress `cSrc`, with FSE_decompress_usingDTable().
`cSrcSize` must be strictly correct, otherwise decompression will fail.
FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`).
If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small)
*//*! FSE_decompress_usingDTable():
    Decompress compressed source `cSrc` of size `cSrcSize` using `dt`
    into `dst` which must be already allocated.
    @return : size of regenerated data (necessarily <= `dstCapacity`),
              or an errorCode, which can be tested using FSE_isError() *//*! FSE_buildDTable():
    Builds 'dt', which must be already allocated, using FSE_createDTable().
    return : 0, or an errorCode, which can be tested using FSE_isError() *//* don't allocate that. It's just a way to be more restrictive than void* *//*! Constructor and Destructor of FSE_DTable.
    Note that its size depends on 'tableLog' *//*! FSE_readNCount():
    Read compactly saved 'normalizedCounter' from 'rBuffer'.
    @return : size read from 'rBuffer',
              or an errorCode, which can be tested using FSE_isError().
              maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values *//* *** DECOMPRESSION *** *//*!
Tutorial :
----------
The first step is to count all symbols. FSE_count() does this job very fast.
Result will be saved into 'count', a table of unsigned int, which must be already allocated, and have 'maxSymbolValuePtr[0]+1' cells.
'src' is a table of bytes of size 'srcSize'. All values within 'src' MUST be <= maxSymbolValuePtr[0]
maxSymbolValuePtr[0] will be updated, with its real value (necessarily <= original value)
FSE_count() will return the number of occurrence of the most frequent symbol.
This can be used to know if there is a single symbol within 'src', and to quickly evaluate its compressibility.
If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).

The next step is to normalize the frequencies.
FSE_normalizeCount() will ensure that sum of frequencies is == 2 ^'tableLog'.
It also guarantees a minimum of 1 to any Symbol with frequency >= 1.
You can use 'tableLog'==0 to mean "use default tableLog value".
If you are unsure of which tableLog value to use, you can ask FSE_optimalTableLog(),
which will provide the optimal valid tableLog given sourceSize, maxSymbolValue, and a user-defined maximum (0 means "default").

The result of FSE_normalizeCount() will be saved into a table,
called 'normalizedCounter', which is a table of signed short.
'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells.
The return value is tableLog if everything proceeded as expected.
It is 0 if there is a single symbol within distribution.
If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()).

'normalizedCounter' can be saved in a compact manner to a memory area using FSE_writeNCount().
'buffer' must be already allocated.
For guaranteed success, buffer size must be at least FSE_headerBound().
The result of the function is the number of bytes written into 'buffer'.
If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError(); ex : buffer size too small).

'normalizedCounter' can then be used to create the compression table 'CTable'.
The space required by 'CTable' must be already allocated, using FSE_createCTable().
You can then use FSE_buildCTable() to fill 'CTable'.
If there is an error, both functions will return an ErrorCode (which can be tested using FSE_isError()).

'CTable' can then be used to compress 'src', with FSE_compress_usingCTable().
Similar to FSE_count(), the convention is that 'src' is assumed to be a table of char of size 'srcSize'
The function returns the size of compressed data (without header), necessarily <= `dstCapacity`.
If it returns '0', compressed data could not fit into 'dst'.
If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).
*//*! FSE_compress_usingCTable():
    Compress `src` using `ct` into `dst` which must be already allocated.
    @return : size of compressed data (<= `dstCapacity`),
              or 0 if compressed data could not fit into `dst`,
              or an errorCode, which can be tested using FSE_isError() *//*! FSE_buildCTable():
    Builds `ct`, which must be already allocated, using FSE_createCTable().
    @return : 0, or an errorCode, which can be tested using FSE_isError() *//* don't allocate that. It's only meant to be more restrictive than void* *//*! Constructor and Destructor of FSE_CTable.
    Note that FSE_CTable size depends on 'tableLog' and 'maxSymbolValue' *//*! FSE_writeNCount():
    Compactly save 'normalizedCounter' into 'buffer'.
    @return : size of the compressed table,
              or an errorCode, which can be tested using FSE_isError(). *//*! FSE_NCountWriteBound():
    Provides the maximum possible size of an FSE normalized table, given 'maxSymbolValue' and 'tableLog'.
    Typically useful for allocation purpose. *//*! FSE_normalizeCount():
    normalize counts so that sum(count[]) == Power_of_2 (2^tableLog)
    'normalizedCounter' is a table of short, of minimum size (maxSymbolValue+1).
    @return : tableLog,
              or an errorCode, which can be tested using FSE_isError() *//*! FSE_optimalTableLog():
    dynamically downsize 'tableLog' when conditions are met.
    It saves CPU time, by using smaller tables, while preserving or even improving compression ratio.
    @return : recommended tableLog (necessarily <= 'maxTableLog') *//*! FSE_count():
    Provides the precise count of each byte within a table 'count'.
    'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1).
    *maxSymbolValuePtr will be updated if detected smaller than initial value.
    @return : the count of the most frequent symbol (which is not identified).
              if return == srcSize, there is only one symbol.
              Can also return an error code, which can be tested with FSE_isError(). *//* *** COMPRESSION *** *//*!
FSE_compress() does the following:
1. count symbol occurrence from source[] into table count[]
2. normalize counters so that sum(count[]) == Power_of_2 (2^tableLog)
3. save normalized counters to memory buffer using writeNCount()
4. build encoding table 'CTable' from normalized counters
5. encode the data stream using encoding table 'CTable'

FSE_decompress() does the following:
1. read normalized counters with readNCount()
2. build decoding table 'DTable' from normalized counters
3. decode the data stream using decoding table 'DTable'

The following API allows targeting specific sub-functions for advanced tasks.
For example, it's possible to compress several blocks using the same 'CTable',
or to save and provide normalized distribution using external method.
*//*-*****************************************
*  FSE detailed API
******************************************//*! FSE_compress2() :
    Same as FSE_compress(), but allows the selection of 'maxSymbolValue' and 'tableLog'
    Both parameters can be defined as '0' to mean : use default value
    @return : size of compressed data
    Special values : if return == 0, srcData is not compressible => Nothing is stored within cSrc !!!
                     if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression.
                     if FSE_isError(return), it's an error code.
*//*-*****************************************
*  FSE advanced functions
******************************************//* provides error code string (useful for debugging) *//* tells if a return value is an error code *//* Error Management *//* maximum compressed size *//*-*****************************************
*  Tool functions
******************************************//*! FSE_decompress():
    Decompress FSE data from buffer 'cSrc', of size 'cSrcSize',
    into already allocated destination buffer 'dst', of size 'dstCapacity'.
    @return : size of regenerated data (<= maxDstSize),
              or an error code, which can be tested using FSE_isError() .

    ** Important ** : FSE_decompress() does not decompress non-compressible nor RLE data !!!
    Why ? : making this distinction requires a header.
    Header management is intentionally delegated to the user layer, which can better manage special cases.
*//*! FSE_compress() :
    Compress content of buffer 'src', of size 'srcSize', into destination buffer 'dst'.
    'dst' buffer must be already allocated. Compression runs faster is dstCapacity >= FSE_compressBound(srcSize).
    @return : size of compressed data (<= dstCapacity).
    Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!
                     if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression instead.
                     if FSE_isError(return), compression failed (more details using FSE_getErrorName())
*//*-****************************************
*  FSE simple functions
******************************************//**< library version number; to be used when checking dll version *//* Visual expected *//*-*****************************************
*  FSE_PUBLIC_API : control library symbols visibility
******************************************//*-*****************************************
*  Dependencies
******************************************//* ******************************************************************
   FSE : Finite State Entropy codec
   Public Prototypes declaration
   Copyright (C) 2013-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
****************************************************************** */DStatePtrdtctCStatePtrcSrccSrcSizeworkSpacemaxLogsymbolValuenormalizedCountermaxSymbolValuewkspSizedstSizemaxTableLogminusmaxSymbolValuePtrsourcesourceSizetableLogPtrrBufferrBuffSizebufferSize/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/huf.hHUF_decompress1X4_usingDTableconst HUF_DTableconst HUF_DTable *HUF_decompress1X2_usingDTableHUF_decompress1X_usingDTableHUF_decompress1X4_DCtxHUF_DTable *HUF_decompress1X2_DCtxHUF_decompress1X_DCtxHUF_decompress1X4HUF_decompress1X2HUF_compress1X_usingCTableconst HUF_CEltconst HUF_CElt *HUF_CElt_s *HUF_compress1X_wkspHUF_compress1XHUF_decompress4X4_usingDTableHUF_decompress4X2_usingDTableHUF_decompress4X_usingDTableHUF_readDTableX4HUF_readDTableX2HUF_selectDecoderHUF_readCTableHUF_CElt *HUF_buildCTable_wkspHUF_compress4X_usingCTableHUF_writeCTableHUF_buildCTableHUF_optimalTableLogHUF_decompress4X4_DCtxHUF_decompress4X2_DCtxHUF_decompress4X_hufOnlyHUF_decompress4X_DCtxHUF_decompress4X4HUF_decompress4X2HUF_compress4X_wkspHUF_compress2HUF_compressBoundHUF_decompressHUF_compressHUF_CEltHUF_CElt_sHUF_DTableHUF_CREATE_STATIC_DTABLEX4(DTable,maxTableLog)HUF_DTable DTable[HUF_DTABLE_SIZE(maxTableLog)] = { ((U32)(maxTableLog) * 0x01000001) }HUF_CREATE_STATIC_DTABLEX2(DTable,maxTableLog)HUF_DTable DTable[HUF_DTABLE_SIZE((maxTableLog)-1)] = { ((U32)((maxTableLog)-1) * 0x01000001) }HUF_DTABLE_SIZE(maxTableLog)(1 + (1<<(maxTableLog)))HUF_CREATE_STATIC_CTABLE(name,maxSymbolValue)U32 name ## hb[maxSymbolValue+1]; void* name ## hv = &(name ## hb); HUF_CElt* name = (HUF_CElt*)(name ## hv)HUF_COMPRESSBOUND(size)(HUF_CTABLEBOUND + HUF_BLOCKBOUND(size))HUF_BLOCKBOUND(size)(size + (size>>8) + 8)HUF_CTABLEBOUNDHUF_SYMBOLVALUE_MAXHUF_TABLELOG_DEFAULTHUF_TABLELOG_MAXHUF_TABLELOG_ABSOLUTEMAXHUF_BLOCKSIZE_MAX(128 * 1024)HUF_PUBLIC_APIHUF_H_298734234HUF_STATIC_LINKING_ONLY(HUF_TABLELOG_MAX > HUF_TABLELOG_ABSOLUTEMAX)HUF_readStatsHUF_getErrorNameHUF_isError/* HUF_H_298734234 *//* HUF_STATIC_LINKING_ONLY *//**< automatic selection of sing or double symbol decoder, based on DTable *//**< double-symbols decoder *//**< single-symbol decoder *//* double-symbol decoder *//* single-symbol decoder *//**< `workSpace` must be a table of at least 1024 unsigned *//* single stream variants *//** HUF_selectDecoder() :
*   Tells which decoder is likely to decode faster,
*   based on a set of pre-determined metrics.
*   @return : 0==HUF_decompress4X2, 1==HUF_decompress4X4 .
*   Assumption : 0 < cSrcSize < dstSize <= 128 KB *//*
HUF_decompress() does the following:
1. select the decompression algorithm (X2, X4) based on pre-computed heuristics
2. build Huffman table from save, using HUF_readDTableXn()
3. decode 1 or 4 segments in parallel using HUF_decompressSXn_usingDTable
*//** HUF_readCTable() :
*   Loading a CTable saved with HUF_writeCTable() *//*! HUF_readStats() :
    Read compact Huffman tree, saved by HUF_writeCTable().
    `huffWeight` is destination buffer.
    @return : size read from `src` , or an error Code .
    Note : Needed by HUF_readCTable() and HUF_readDTableXn() . *//** HUF_buildCTable_wksp() :
 *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
 *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as a table of 1024 unsigned.
 *//* FSE_count() : find it within "fse.h" *//*!
HUF_compress() does the following:
1. count symbol occurrence from source[] into table count[] using FSE_count()
2. (optional) refine tableLog using HUF_optimalTableLog()
3. build Huffman table from count using HUF_buildCTable()
4. save Huffman table to memory buffer using HUF_writeCTable()
5. encode the data stream using HUF_compress4X_usingCTable()

The following API allows targeting specific sub-functions for advanced tasks.
For example, it's possible to compress several blocks using the same 'CTable',
or to save and regenerate 'CTable' using external methods.
*//* ****************************************
*  HUF detailed API
******************************************//**< considers RLE and uncompressed as errors *//**< decodes RLE and uncompressed *//* ****************************************
*  Advanced decompression functions
******************************************//* static allocation of HUF's DTable *//* no final ; *//* static allocation of HUF's Compression Table *//* only true if incompressible pre-filtered with fast heuristic *//* HUF buffer bounds *//* ****************************************
*  Static allocation
******************************************//* tableLog by default, when not specified *//* max configured tableLog (for static allocation); can be modified up to HUF_ABSOLUTEMAX_TABLELOG *//* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work *//* *** Constants *** *//* U32 *//* *** Dependencies *** *//** HUF_compress4X_wksp() :
*   Same as HUF_compress2(), but uses externally allocated `workSpace`, which must be a table of >= 1024 unsigned *//** HUF_compress2() :
 *   Same as HUF_compress(), but offers direct control over `maxSymbolValue` and `tableLog` .
 *   `tableLog` must be `<= HUF_TABLELOG_MAX` . *//* ***   Advanced function   *** *//**< provides error code string (useful for debugging) *//**< tells if a return value is an error code *//**< maximum compressed size (worst case) *//**< maximum input size for a single block compressed with HUF_compress *//* ***   Tool functions *** *//**
HUF_decompress() :
    Decompress HUF data from buffer 'cSrc', of size 'cSrcSize',
    into already allocated buffer 'dst', of minimum size 'dstSize'.
    `originalSize` : **must** be the ***exact*** size of original (uncompressed) data.
    Note : in contrast with FSE, HUF_decompress can regenerate
           RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data,
           because it knows size to regenerate.
    @return : size of regenerated data (== originalSize),
              or an error code, which can be tested using HUF_isError()
*//**
HUF_compress() :
    Compress content from buffer 'src', of size 'srcSize', into buffer 'dst'.
    'dst' buffer must be already allocated.
    Compression runs faster if `dstCapacity` >= HUF_compressBound(srcSize).
    `srcSize` must be <= `HUF_BLOCKSIZE_MAX` == 128 KB.
    @return : size of compressed data (<= `dstCapacity`).
    Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!
                     if return == 1, srcData is a single repeated byte symbol (RLE compression).
                     if HUF_isError(return), compression failed (more details using HUF_getErrorName())
*//* *** simple functions *** *//*-*** PUBLIC_API : control library symbols visibility *** *//* ******************************************************************
   Huffman coder, part of New Generation Entropy library
   header file
   Copyright (C) 2013-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
****************************************************************** */maxDstSizeDTableCTablehuffWeighthwSizerankStatsnbSymbolsPtrmaxNbBitshuffLogoriginalSize/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/mem.h/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/entropy_common.c"huf.h""fse.h"weightTotaliSizeoSizeERROR(corruption_detected)FSE_DTable[65]FSE_DTABLE_SIZE_U32(6)fseWorkspace(HUF_TABLELOG_MAX + 1)(HUF_TABLELOG_MAX + 1) * sizeof(U32)restveriflastWeightistartiendremainingbitStreamcharnumprevious0ERROR(tableLog_tooLarge)ERROR(maxSymbolValue_tooSmall)maxSVPtrheaderBufferhbSize900/* results *//* by construction : at least 2 elts of rank 1, must be even *//* check tree construction validity *//* last value must be a clean power of 2 *//* determine last weight *//* get last non-null symbol weight (implied, total must be 2^n) *//* collect weight stats *//* max (hwSize-1) values decoded, as last one is implied *//* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) *//* header compressed with FSE (normal case) *//* special header *//* is not necessary, even though some analyzer complain ... *//* memset(huffWeight, 0, hwSize);   *//*! HUF_readStats() :
    Read compact Huffman tree, saved by HUF_writeCTable().
    `huffWeight` is destination buffer.
    `rankStats` is assumed to be a table of at least HUF_TABLELOG_MAX U32.
    @return : size read from `src` , or an error Code .
    Note : Needed by HUF_readCTable() and HUF_readDTableX?() .
*//* while ((remaining>1) & (charnum<=*maxSVPtr)) *//* -1 means +1 *//* extra accuracy *//* extract tableLog *//*-**************************************************************
*  FSE NCount encoding-decoding
****************************************************************//* **************************************************************
*  HUF Error Management
****************************************************************//*-****************************************
*  FSE Error Management
******************************************//* HUF_TABLELOG_ABSOLUTEMAX *//* FSE_MIN_TABLELOG *//* ERR_*, ERROR *//* *************************************
*  Dependencies
***************************************//*
   Common functions of New Generation Entropy library
   Copyright (C) 2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
*************************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/fse_compress.cscratchBuffersizeof(scratchBuffer) >= FSE_WKSP_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)sizeof(scratchBuffer) >= ( (1 + (1<<((14-2)-1)) + ((255+1)*2)) + (1<<(((14-2)>2)?((14-2)-2):0)) )FSE_static_assert14340(14-2)204925613585fseWkspMax_t *sizeof(scratchBuffer)ostartoendS16[256]signed short[256]normCTableSizescratchBufferSizesizeof(FSE_CTable)FSE_count(count, &maxSymbolValue, src, srcSize)_var_err__FSE_normalizeCount(norm, tableLog, count, srcSize, maxSymbolValue)S16 *nc_errFSE_writeNCount(op, oend-op, norm, maxSymbolValue, tableLog)FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, scratchBufferSize)FSE_compress_usingCTable(op, oend - op, src, srcSize, CTable)fastFSE_compress_usingCTable_genericCState1CState2initError&bitCsizeof(bitC.bitContainer)sizeof(bitC.bitContainer)*8sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7(sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 )sizeof(bitC.bitContainer)*8 < FSE_MAX_TABLELOG*2+7U16 *tableU16FSCTptrFSE_symbolCompressionTransform *(U16) 0tableMaskU16 *constFSCTFSE_symbolCompressionTransform *constrtbTableconst U32[8]473195504333520860550000700000750000830000(U64)1(U64)1<<62((U64)1<<62)vStepstillToDistributelargestlargestPlowThresholdprobarestToBeaterrorCodeFSE_normalizeM2distributedToDistributelowOnemaxVmaxCvStepLogrSteptmpTotalsStartsEndweightmaxBitsSrcminBitsFSE_minTableLogminBitsSrcminBitsSymbolsFSE_sizeof_CTabletmpCounters1500FSE_count_parallel_wkspCounting1Counting2Counting3Counting44*256sizeof(unsigned)4*256*sizeof(unsigned)cachedsizeof(*count)FSE_writeNCount_genericcheckMaxheaderBufferSizewriteIsSafe0xFFFFUmaxHeaderSizeBYTE[4096]tableSymbolsizeof(tableSymbol)U32[257]unsigned int[257]cumulhighThresholdsizeof(FSE_FUNCTION_TYPE)nbOccurencesmaxBitsOutminStatePlusfseWkspMax_t1 << FSE_MAX_TABLELOGFSE_CTable[2561]unsigned int[2561]FSE_CTABLE_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)CTable_max{ CHECK_V_F(_var_err__, f); }CHECK_V_F(e,f)size_t const e = f; if (ERR_isError(e)) return fFSE_FLUSHBITS(s)(fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))FSE_TYPE_NAME(X,Y)FSE_CAT(X,Y)FSE_FUNCTION_NAME(X,Y)X ## YFSE_STATIC_ASSERT(c){ enum { FSE_static_assert = 1/(int)(!!(c)) }; }FORCE_INLINEdefined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L/* FSE_COMMONDEFS_ONLY *//* compilation failures here means scratchBuffer is not large enough *//* check compressibility *//* not enough space for compressed data *//* Compress *//* Write table description header *//* Heuristic : not compressible enough *//* each symbol present maximum once => not compressible *//* only a single symbol in src : rle *//* Scan input and build symbol stats *//* Not compressible *//* init conditions *//* FSE_compress_wksp() :
 * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).
 * `wkspSize` size must be `(1<<tableLog)`.
 *//* this test must be static *//* 2 or 4 encoding per loop *//* test bit 2 *//* join to mod 4 *//* not enough space available to write a bitstream *//* init *//* Build Symbol Transformation Table *//* Build table *//* header *//* fake FSE_CTable, for rle input (always same symbol) *//* min size *//* Sanity checks *//* assumption : tableLog >= 1 *//* fake FSE_CTable, for raw (uncompressed) input *//* Print Table (debug) *//* corner case, need another normalization method *//* rle special case *//* <== here, one division ! *//* Too small tableLog, compression potentially impossible *//* Unsupported size *//* scale on remaining *//* all values are pretty poor;
           probably incompressible data (should have already been detected);
           find max, then give all remaining points to max *//* risk of rounding to zero *//* Init *//* Secondary normalization method.
   To be used when primary method fails. *//* Need a minimum to safely represent all symbol values *//* Accuracy can be reduced *//* provides the minimum logSize to safely represent a distribution *//*! FSE_sizeof_CTable() :
    FSE_CTable is a variable size structure which contains :
    `U16 tableLog;`
    `U16 maxSymbolValue;`
    `U16 nextStateNumber[1 << tableLog];`                         // This size is variable
    `FSE_symbolCompressionTransform symbolTT[maxSymbolValue+1];`  // This size is variable
Allocation is manual (C standard does not support variable-size structures).
*//*-**************************************************************
*  FSE Compression Code
****************************************************************//* FSE_count_wksp() :
 * Same as FSE_count(), but using an externally provided scratch buffer.
 * `workSpace` size must be table of >= `1024` unsigned *//* fast variant (unsafe : won't check if src contains values beyond count[] limit) *//* FSE_countFast_wksp() :
 * Same as FSE_countFast(), but using an externally provided scratch buffer.
 * `workSpace` size must be table of >= `1024` unsigned *//* verify stats will fit into destination table *//* finish last symbols *//* by stripes of 16 bytes *//* 0 == default *//* safety checks *//* FSE_count_parallel_wksp() :
 * Same as FSE_count_parallel(), but using an externally provided scratch buffer.
 * `workSpace` size must be a minimum of `1024 * sizeof(unsigned)`` *//*! FSE_count_simple
    This function counts byte values within `src`, and store the histogram into table `count`.
    It doesn't use any additional memory.
    But this function is unsafe : it doesn't check that all values within `src` can fit into `count`.
    For this reason, prefer using a table `count` with 256 elements.
    @return : count of most numerous element
*//*-**************************************************************
*  Counting histogram
****************************************************************//* Unsupported *//* Buffer overflow *//* flush remaining bitStream *//* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ *//* +1 for extra accuracy *//* stops at 1 *//* Table Size *//* maxSymbolValue==0 ? use default *//* memset() is not necessary, even if static analyzer complain about it *//* TableU16 : sorted by symbol order; gives next state value *//* note : static analyzer may not understand tableSymbol is properly initialized *//* Must have gone through all positions *//* Low proba area *//* Spread symbols *//* Low proba symbol *//* symbol start positions *//* For explanations on how to distribute symbol values over the table :
    *  http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html *//* CTable header *//* FSE_buildCTable_wksp() :
 * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).
 * wkspSize should be sized to handle worst case situation, which is `1<<max_tableLog * sizeof(FSE_FUNCTION_TYPE)`
 * workSpace must also be properly aligned with FSE_FUNCTION_TYPE requirements
 *//* Function templates *//* Function names *//*
  designed to be included
  for type-specific functions (template emulation in C)
  Objective is to write these functions only once, for improved maintenance
*//* **************************************************************
*  Templates
****************************************************************//* **************************************************************
*  Error Management
****************************************************************//* printf (debug) *//* malloc, free, qsort *//* **************************************************************
*  Includes
****************************************************************//* __STDC_VERSION__ *//* **************************************************************
*  Compiler specifics
****************************************************************//* ******************************************************************
   FSE : Finite State Entropy encoder
   Copyright (C) 2013-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/fse_decompress.cshort[256]countingNCountLengthFSE_buildDTable (workSpace, counting, maxSymbolValue, tableLog)FSE_decompress_usingDTable_genericomaxolimitBIT_initDStream(&bitD, cSrc, cSrcSize)&state1&state2sizeof(bitD.bitContainer)sizeof(bitD.bitContainer)*8FSE_DTableHeader *FSE_DTableHeader *constdPtrFSE_decode_t *FSE_decode_t *constdinfomaxSV1celltdPtrtableDecodeU16[256]symbolNextERROR(maxSymbolValue_tooLarge)const S16largeLimitsizeof(DTableH)nextStatesizeof (U32)FSE_DTable[4097]unsigned int[4097]4097FSE_DTABLE_SIZE_U32(FSE_MAX_TABLELOG)DTable_max_tFSE_GETSYMBOL(statePtr)fast ? FSE_decodeSymbolFast(statePtr, &bitD) : FSE_decodeSymbol(statePtr, &bitD){ size_t const e = f; if (FSE_isError(e)) return e; }/* Static analyzer seems unable to understand this table will be properly initialized later *//* always return, even if it is an error code *///if (NCountLength >= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size; supposed to be already checked in NCountLength, only remaining case : NCountLength==cSrcSize *//* normal FSE decoding mode *//* select fast mode (static) *//* note : BIT_reloadDStream(&bitD) >= FSE_DStream_partiallyFilled; Ends at exactly BIT_DStream_completed *//* tail *//* This test must be static *//* 4 symbols per loop *//* Build Decoding Table *//*-*******************************************************
*  Decompression (Byte symbols)
*********************************************************//* Build Decoding table *//* position must reach all cells once, otherwise normalizedCounter is incorrect *//* lowprob area *//* Init, lay down lowprob symbols *//* Sanity Checks *//* because *dt is unsigned, 32-bits aligned on 32-bits *//* check and forward error code *//* ******************************************************************
   FSE : Finite State Entropy decoder
   Copyright (C) 2013-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/huf_compress.csizeof(workSpace)HUF_compress_internalsizeof(huffNodeTable)FSE_count_wksp (table.count, &maxSymbolValue, (const BYTE*)src, srcSize, (U32*)workSpace)maxBitsHUF_buildCTable_wksp (table.CTable, table.count, maxSymbolValue, huffLog, workSpace, wkspSize)HUF_CElt[256]HUF_CElt_s[256]hSizeHUF_writeCTable (op, dstSize, table.CTable, maxSymbolValue, huffLog)segmentSize6 + 16 + 1 + 16 + 1 + 1 + 16 + 1 + 1 + 1 + 8HUF_compress1X_usingCTable(op, oend-op, ip, segmentSize, CTable)HUF_compress1X_usingCTable(op, oend-op, ip, iend-ip, CTable)singleStreaminitErr~3HUF_encodeSymbolnodeTablenodeElt *nodeElt_s *sizeof(nodeTable)nodeElt *consthuffNode0huffNodenonNullRanklowSlowNnodeNbSTARTNODEnodeRoot1U<<30(U32)(1U<<30)1U<<31(U32)(1U<<31)n2U16[13]unsigned short[13]nbPerRankvalPerRankHUF_sortrankPos[32]rankrankPos *sizeof(rank)bitCPtrHUF_setMaxHeightlargestBitstotalCostbaseCostnoSymbol4042322160 0xF0F0F0F0U32[14]unsigned int[14]rankLastsizeof(rankLast)currentNbBitsnBitsToDecreasehighPoslowPoshighTotallowTotalBYTE[256]U32[16]rankValnbSymbolsreadSizeHUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize)HUF_readStats(huffWeight, 255+1, rankVal, &nbSymbols, &tableLog, src, srcSize)nextRankStartU16[14]unsigned short[14]BYTE[13]unsigned char[13]bitsToWeightBYTE[255]unsigned char[255]HUF_compressWeights(op+1, maxDstSize-1, huffWeight, maxSymbolValue)256-128(256-128)HUF_compressWeightsMAX_FSE_TABLELOG_FOR_HUFF_HEADERFSE_CTable[59]unsigned int[59]FSE_CTABLE_SIZE_U32(MAX_FSE_TABLELOG_FOR_HUFF_HEADER, HUF_TABLELOG_MAX)BYTE[64]1<<MAX_FSE_TABLELOG_FOR_HUFF_HEADERU32[13]unsigned int[13]S16[13]signed short[13]FSE_count_simple(count, &maxSymbolValue, weightTable, wtSize)lastNonNullweightTablewtSizeFSE_normalizeCount(norm, tableLog, count, wtSize, maxSymbolValue)FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, sizeof(scratchBuffer))FSE_compress_usingCTable(op, oend - op, weightTable, wtSize, CTable)nodeElt[512]nodeElt_s[512]5102*HUF_SYMBOLVALUE_MAX2*HUF_SYMBOLVALUE_MAX+12*HUF_SYMBOLVALUE_MAX+1 +1huffNodeTablerankPosnodeEltnodeElt_sparentHUF_FLUSHBITS_2(stream)if (sizeof((stream)->bitContainer)*8 < HUF_TABLELOG_MAX*4+7) HUF_FLUSHBITS(stream)HUF_FLUSHBITS_1(stream)if (sizeof((stream)->bitContainer)*8 < HUF_TABLELOG_MAX*2+7) HUF_FLUSHBITS(stream)HUF_FLUSHBITS(s)(HUF_SYMBOLVALUE_MAX+1)HUF_STATIC_ASSERT(c){ enum { HUF_static_assert = 1/(int)(!!(c)) }; }/* 4 streams *//* single stream *//* uncompressible *//* single segment *//* not useful to try compression *//* Build Huffman Tree *//* Fast heuristic : not compressible enough *//* single symbol, rle *//* current block size limit *//* cannot fit within dst budget *//* Uncompressed (note : 1 means rle, so first byte must be correct) *//* checks & inits *//* `count` can overlap with `CTable`; saves 1 KB *//* `workSpace` must a table of at least 1024 unsigned *//* jumpTable *//* no saving possible : too small input *//* minimum space to compress successfully *//* first 3 segments *//* note : n&3==0 at this stage *//* not enough space to compress *//** HUF_buildCTable() :
 *  Note : count is used before tree is written, so they can safely overlap
 *//* assign value within rank, symbol order *//* push nbBits per symbol, symbol order *//* get starting value within each rank *//* determine stating value per rank *//* check fit into table *//* fill result into tree (val, nbBits) *//* enforce maxTableLog *//* distribute weights (unlimited tree height) *//* create parents *//* fake entry, strong barrier *//* init for parents *//* sort, decreasing order *//* workSpace is not large enough *//* there are several too large elements (at least >= 2) *//* special case : no rank 1 symbol (using maxNbBits-1); let's create one from largest rank 0 (using maxNbBits) *//* Sometimes, cost correction overshoot *//* while (totalCost > 0) *//* this rank is now empty *//* special case, reached largest symbol *//* this rank is no longer empty *//* HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary *//* only triggered when no more rank 1 symbol left => find closest one (note : there is necessarily at least one !) *//* < maxNbBits *//* Get pos of last (smallest) symbol per rank *//* repay normalized cost *//* note : totalCost is necessarily a multiple of baseCost *//* renorm totalCost *//* n end at index of smallest symbol using < maxNbBits *//* n stops at huffNode[n].nbBits <= maxNbBits *//* early exit : no elt > maxNbBits *//* start at n=tablelog <-> w=1 *//* for w==0 *//* support w=0=>n=tableLog+1 *//* fill val *//* fill nbBits *//* Prepare base value per rank *//* check result *//* get symbol weights *//* large enough for values from 0 to 16 *//* init not required, even though some static analyzer may complain *//* to be sure it doesn't cause msan issue in final combination *//*special case*//* not enough space within dst buffer *//* should not happen : likely means source cannot be compressed *//* write raw values as 4-bits (max : 15) *//* FSE compressed *//* attempt weights compression by FSE *//* convert to weight *//* check conditions *//* precomputed conversion table *//*! HUF_writeCTable() :
    `CTable` : huffman tree to save, using huf representation.
    @return : size of saved CTable *//* typedef'd to HUF_CElt within "huf.h" *//* HUF_compressWeights() :
 * Same as FSE_compress(), but dedicated to huff0's weights compression.
 * The use case needs much less stack memory.
 * Note : all elements within weightTable are supposed to be <= HUF_TABLELOG_MAX.
 *//* *******************************************************
*  HUF : Huffman block compression
*********************************************************//* **************************************************************
*  Utils
****************************************************************//* header compression *//* FSE_optimalTableLog_internal *//* ******************************************************************
   Huffman encoder, part of New Generation Entropy library
   Copyright (C) 2013-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/entropy/huf_decompress.calgoNbconst decompressionAlgoconst decompressionAlgo[2]..(*[2])(..)const decompressionAlgo *..(**)(..)QD256DTime0const algo_time_tconst algo_time_t[3]struct <unnamed>[3]const algo_time_t[16][3]struct <unnamed>[16][3]const algo_time_t(*)[3]struct <unnamed>(*)[3]const algo_time_t *DTime1const DTableDescdtdHUF_DTable[4097]16777217201326604HUF_decompress4X4_usingDTable_internaldtPtrconst HUF_DEltX4const HUF_DEltX4 *const HUF_DEltX4 *constbitD1bitD2bitD3bitD4length1length2length3length4istart1istart2istart3istart4opStart2opStart3opStart4op1op2op3op4endSignaldtLog&bitD1&bitD2&bitD3&bitD4sizeof(bitD4.bitContainer)sizeof(bitD4.bitContainer)-1(sizeof(bitD4.bitContainer)-1)endCheckHUF_decompress1X4_usingDTable_internalHUF_decodeStreamX4bitDPtrsizeof(bitDPtr->bitContainer)sizeof(bitDPtr->bitContainer)-1(sizeof(bitDPtr->bitContainer)-1)HUF_decodeLastSymbolX4(sizeof(DStream->bitContainer)*8)HUF_decodeSymbolX4weightListsortedSymbol_t[256]sortedSymbolrankStart0rankStartmaxWsizeOfSortHUF_DEltX4 *HUF_DEltX4 *constsizeof(HUF_DEltX4) == sizeof(HUF_DTable)HUF_static_assertDCtxsortedSymbol_t *rankVal0U32(*)[13]unsigned int(*)[13]rescalenextRankValconsumedrankValPtrconst sortedSymbol_tconst sortedSymbol_t *DTableDesc *sizeof(dtd)HUF_fillDTableX4scaleLogsizeof(rankVal)sortedRankminWeightDEltHUF_fillDTableX4Level2skipSize(12)-1HUF_DTable[2049]unsigned int[2049]184549387HUF_decompress4X2_usingDTable_internalconst HUF_DEltX2const HUF_DEltX2 *const HUF_DEltX2 *consttargetLogsortedListsortedListSizerankValOriginmaxWeightnbBitsBaselinesizeLogsortedSymbolsbaseSeqBIT_DStream_t *constHUF_decompress1X2_usingDTable_internalHUF_decodeStreamX2HUF_decodeSymbolX2HUF_DEltX2 *HUF_DEltX2 *constsizeof(DTableDesc) == sizeof(HUF_DTable)HUF_getDTableDescdecompressionAlgoalgo_time_tU32[12][13]unsigned int[12][13]rankVal_tsortedSymbol_tHUF_DEltX4HUF_DEltX2DTableDescdecode256TimetableTimesequencetableTypealgoTime131321511353223855671414182436883143724648971515262292616132730947172933592083400611772379478512422415515513492644526014552422417472218911936HUF_DECODE_SYMBOLX4_2(ptr,DStreamPtr)if (MEM_64bits()) ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)HUF_DECODE_SYMBOLX4_1(ptr,DStreamPtr)if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)HUF_DECODE_SYMBOLX4_0(ptr,DStreamPtr)ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)HUF_DECODE_SYMBOLX2_2(ptr,DStreamPtr)if (MEM_64bits()) HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)HUF_DECODE_SYMBOLX2_1(ptr,DStreamPtr)if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)HUF_DECODE_SYMBOLX2_0(ptr,DStreamPtr)*ptr++ = HUF_decodeSymbolX2(DStreamPtr, dt, dtLog)defined(_MSC_VER) || defined(__GNUC__)/* RLE *//* not compressed *//* invalid *//* validation checks *//* advantage to algorithm using less memory, for cache eviction *//* Q < 16 since dstSize > cSrcSize *//* decoder timing evaluation *//* Q ==15 : 93-99% *//* Q ==14 : 87-93% *//* Q ==13 : 81-87% *//* Q ==12 : 75-81% *//* Q ==11 : 69-75% *//* Q ==10 : 62-69% *//* Q == 9 : 56-62% *//* Q == 8 : 50-56% *//* Q == 7 : 44-50% *//* Q == 6 : 38-44% *//* Q == 5 : 32-38% *//* Q == 4 : 25-32% *//* Q == 3 : 18-25% *//* Q == 2 : 12-18% *//* Q==1 : impossible *//* Q==0 : impossible *//* single, double, quad *//* Quantization *//* ********************************//* Generic decompression selector *//* decoded size *//* check *//* finish bitStreams one by one *//* note : op4 already verified within main loop *//* check corruption *//* 16-32 symbols per loop (4-8 symbols per stream) *//* overflow *//* strict minimum : jump table + 1 byte per stream *//* force compiler to not use strict-aliasing *//* decode *//* no need to reload : reached the end of DStream *//* closer to end : up to 2 symbols at a time *//* up to 8 symbols at a time *//* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol *//* note : dtLog >= 1 *//* tableLog <= maxTableLog *//* Build rankVal *//* forget 0w symbols; this is beginning of weight(1) *//* sort symbols by weight *//* put all 0w symbols at the end of sorted list*//* Get start index of each weight *//* necessarily finds a solution before 0 *//* find maxWeight *//* DTable can't fit code depth *//* memset(weightList, 0, sizeof(weightList)); *//* if compilation fails here, assertion is false *//* force compiler to avoid strict-aliasing *//* enough room for a second symbol *//* fill DTable *//* note : targetLog >= srcLog, hence scaleLog <= 1 *//* since length >= 1 *//* note : sortedSymbols already skipped *//* fill skipped values *//* get pre-calculated rankVal *//* HUF_fillDTableX4Level2() :
 * `rankValOrigin` must be a table of at least (HUF_TABLELOG_MAX + 1) U32 *//* double-symbols decoding *//* *************************//* note : op4 supposed already verified within main loop *//* Check *//* no more data to retrieve from bitstream, hence no need to reload *//* closer to the end *//* up to 4 symbols at a time *//* Prepare ranks *//* DTable too small, huffman tree cannot fit in *//* Table header *//* memset(huffWeight, 0, sizeof(huffWeight)); *//* single-symbol decoding *//*-***************************//*  single-symbol decoding   *//*  generic DTableDesc       *//* BIT_* *//* **************************************************************
*  Dependencies
****************************************************************//* disable inline *//* inline is defined *//* ******************************************************************
   Huffman decoder, part of New Generation Entropy library
   Copyright (C) 2013-2016, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** */Dstream/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_compress.hLizard_versionStringLizard_stream_tLIZARD_COMPRESSBOUND(isize)((unsigned)(isize) > (unsigned)LIZARD_MAX_INPUT_SIZE ? 0 : (isize) + 1 + 1 + ((isize/LIZARD_BLOCK_SIZE)+1)*4)LIZARD_BLOCK64K_SIZE(1<<16)LIZARD_BLOCK_SIZE(1<<17)LIZARD_MAX_INPUT_SIZE0x7E000000LIZARD_DEFAULT_CLEVELLIZARD_MAX_CLEVELLIZARD_MIN_CLEVELLIZARD_VERSION_STRINGLIZARD_EXPAND_AND_QUOTE(LIZARD_LIB_VERSION)LIZARD_EXPAND_AND_QUOTE(str)LIZARD_QUOTE(str)LIZARD_LIB_VERSIONLIZARD_VERSION_MAJOR.LIZARD_VERSION_MINOR.LIZARD_VERSION_RELEASELIZARD_VERSION_NUMBER(LIZARD_VERSION_MAJOR *100*100 + LIZARD_VERSION_MINOR *100 + LIZARD_VERSION_RELEASE)LIZARD_VERSION_RELEASELIZARD_VERSION_MINORLIZARD_VERSION_MAJORLIZARDLIB_APILIZARD_H_2983defined(LIZARD_DLL_EXPORT) && (LIZARD_DLL_EXPORT==1)defined(LIZARD_DLL_IMPORT) && (LIZARD_DLL_IMPORT==1)LIZARD_NO_HUFFMANLizard_saveDictLizard_stream_t *Lizard_stream_s *Lizard_compress_continueLizard_loadDictLizard_resetStreamLizard_freeStreamLizard_createStreamLizard_compress_extStateLizard_sizeofStateLizard_compressBoundLizard_compressLizard_stream_sLizard_versionNumber/* LIZARD_H_2983827168210 *//*! Lizard_saveDict() :
 *  If previously compressed data block is not guaranteed to remain available at its memory location,
 *  save it into a safer place (char* safeBuffer).
 *  Note : you don't need to call Lizard_loadDict() afterwards,
 *         dictionary is immediately usable, you can therefore call Lizard_compress_continue().
 *  Return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.
 *//*! Lizard_compress_continue() :
 *  Compress buffer content 'src', using data from previously compressed blocks as dictionary to improve compression ratio.
 *  Important : Previous data blocks are assumed to still be present and unmodified !
 *  'dst' buffer must be already allocated.
 *  If maxDstSize >= Lizard_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
 *  If not, and if compressed data cannot fit into 'dst' buffer size, compression stops, and function returns a zero.
 *//*! Lizard_loadDict() :
 *  Use this function to load a static dictionary into Lizard_stream.
 *  Any previous data will be forgotten, only 'dictionary' will remain in memory.
 *  Loading a size of 0 is allowed.
 *  Return : dictionary size, in bytes (necessarily <= LIZARD_DICT_SIZE)
 *//*! Lizard_resetStream() :
 *  Use this function to reset/reuse an allocated `Lizard_stream_t` structure
 *//*! Lizard_createStream() will allocate and initialize an `Lizard_stream_t` structure.
 *  Lizard_freeStream() releases its memory.
 *  In the context of a DLL (liblizard), please use these methods rather than the static struct.
 *  They are more future proof, in case of a change of `Lizard_stream_t` size.
 *//*-*********************************************
*  Streaming Compression Functions
***********************************************//*!
Lizard_compress_extState() :
    Same compression function, just using an externally allocated memory space to store compression state.
    Use Lizard_sizeofState() to know how much memory must be allocated,
    and allocate it on 8-bytes boundaries (using malloc() typically).
    Then, provide it as 'void* state' to compression function.
*//*!
Lizard_compressBound() :
    Provides the maximum size that Lizard compression may output in a "worst case" scenario (input data not compressible)
    This function is primarily useful for memory allocation purposes (destination buffer size).
    Macro LIZARD_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
    Note that Lizard_compress() compress faster when dest buffer size is >= Lizard_compressBound(srcSize)
        inputSize  : max supported value is LIZARD_MAX_INPUT_SIZE
        return : maximum output size in a "worst case" scenario
              or 0, if input size is too large ( > LIZARD_MAX_INPUT_SIZE)
*//* 2 113 929 216 bytes *//*-************************************
*  Advanced Functions
**************************************//*
Lizard_compress() :
    Compresses 'sourceSize' bytes from buffer 'source'
    into already allocated 'dest' buffer of size 'maxDestSize'.
    Compression is guaranteed to succeed if 'maxDestSize' >= Lizard_compressBound(sourceSize).
    It also runs faster, so it's a recommended setting.
    If the function cannot compress 'source' into a more limited 'dest' budget,
    compression stops *immediately*, and the function result is zero.
    As a consequence, 'dest' content is not valid.
    This function never writes outside 'dest' buffer, nor read outside 'source' buffer.
        sourceSize  : Max supported value is LIZARD_MAX_INPUT_VALUE
        maxDestSize : full or partial size of buffer 'dest' (which must be already allocated)
        return : the number of bytes written into buffer 'dest' (necessarily <= maxOutputSize)
              or 0 if compression fails
*//*-************************************
*  Simple Functions
**************************************//* maximum compression level *//* minimum compression level *//* for tweaks, bug-fixes, or development *//* for new (non-breaking) interface capabilities *//* for breaking interface changes  *//*-************************************
*  Version
**************************************//*
*  LIZARD_DLL_EXPORT :
*  Enable exporting of functions when building a Windows DLL
*//*^***************************************************************
*  Export parameters
*****************************************************************//*
 * lizard_compress.h provides block compression functions. It gives full buffer control to user.
 * Block compression functions are not-enough to send information,
 * since it's still necessary to provide metadata (such as compressed size),
 * and each application can do it in whichever way it wants.
 * For interoperability, there is Lizard frame specification (lizard_Frame_format.md).
 * A library is provided to take care of it, see lizard_frame.h.
*//*
   Lizard - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2016, Yann Collet
   Copyright (C) 2016-2017, Przemyslaw Skibinski <inikep@gmail.com>

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - Lizard source repository : https://github.com/inikep/lizard
*/streamPtrsafeBufferinputSize__idx__comparison__GNUC_PREREQ(4, 6)GCC diagnostic pushGCC diagnostic ignored "-Wcast-qual"GCC diagnostic pop/* Perform binary search - inline version.
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */atof (const char *__nptr)/* Floating-point inline functions for stdlib.h.
   Copyright (C) 2012-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */MEM_readMINMATCHsizeof(value)iPtrDiffdefined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)/* function safe only for comparisons *//*|| defined(_MSC_VER)*//* MEM_FORCE_MEMORY_ACCESS :
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets depending on alignment.
 *            In some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//**
 * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_common.h"lizard_compress.h""entropy/mem.h"Lizard_countpIn<pInLimit-(STEPSIZE-1)pIn<pInLimit-(sizeof(size_t)-1)(pIn<pInLimit-(sizeof(size_t)-1)) != 0STEPSIZELizard_NbCommonBytesLizard_highbit32Lizard_wildCopy16Lizard_wildCopyLizard_copy8Lizard_dstream_tLizard_dstream_sLizard_parametersLizard_decompress_typeLizard_coderwords_LZ4Lizard_coderwords_LIZv1Lizard_parser_typeLizard_parser_fastSmallLizard_parser_fastLizard_parser_fastBigLizard_parser_noChainLizard_parser_hashChainLizard_parser_priceFastLizard_parser_lowestPriceLizard_parser_optimalPriceLizard_parser_optimalPriceBTlast_offdiffBaseflagsEndliteralsEndlenEndoffset24Endoffset16EndflagsPtrliteralsPtrlenPtroffset24Ptroffset16PtrdestBasesrcBasecachedLiteralscachedLitLengthcachedPricelog2FlagSumlog2LitSumlitPriceSumflagSumlitSumlitFreqflagFreqflagsBaseliteralsBaselenBaseoffset24Baseoffset16BasehuffEndhuffBasecomprStreamLenhuffTypeoff24poshashTablechainTablechainTableSizehashTableSizedecompressTypeparserTypefullSearchsufficientLengthminMatchLongOffsearchLengthsearchNumhashLog3hashLogcontentLogwindowLogallocatedMemorynextToUpdatelowLimitdictLimitdictBaseconst Lizard_parametersconst Lizard_parameters[40]struct <unnamed>[40]Lizard_defaultParametersMEM_readMINMATCH(ptr)(U32)(MEM_read32(ptr))((a)<(b)?(a):(b))((a)>(b))?(a):(b)MEM_INITFREEMEMALLOCATOR(n,s)calloc(n,s)GB*(1U<<30)*(1 <<20)KB*(1 <<10)unlikely(expr)expect((expr) != 0, 0)likely(expr)expect((expr) != 0, 1)expect(expr,value)(__builtin_expect ((expr),(value)) )LIZARD_GCC_VERSIONLIZARD_HASHLOG_LIZv1LIZARD_CHAINLOG_LIZv1LIZARD_WINDOWLOG_LIZv1LIZARD_HASHLOG_LZ4SMLIZARD_HASHLOG_LZ4LIZARD_CHAINLOG_LZ4LIZARD_WINDOWLOG_LZ4LIZARD_STREAM_UNCOMPRESSEDLIZARD_STREAM_LENLIZARD_STREAM_OFFSET24LIZARD_STREAM_OFFSET16LIZARD_STREAM_FLAGSLIZARD_STREAM_LITERALSLIZARD_FLAG_UNCOMPRESSEDLIZARD_FLAG_LENLIZARD_FLAG_OFFSET24LIZARD_FLAG_OFFSET16LIZARD_FLAG_FLAGSLIZARD_FLAG_LITERALSLIZARD_LAST_LONG_OFFMAX_SHORT_MATCHLENMAX_SHORT_LITLENML_RUN_BITS(ML_BITS_LIZv1 + RUN_BITS_LIZv1)RUN_BITS_LIZv1ML_BITS_LIZv1RUN_MASK_LZ4((1U<<RUN_BITS_LZ4)-1)RUN_BITS_LZ4(8-ML_BITS_LZ4)ML_MASK_LZ4((1U<<ML_BITS_LZ4)-1)ML_BITS_LZ4LIZARD_HUF_BLOCK_SIZELIZARD_COMPRESS_ADD_HUFHUF_compressBound(LIZARD_BLOCK_SIZE_PAD)LIZARD_COMPRESS_ADD_BUF(5*LIZARD_BLOCK_SIZE_PAD)LIZARD_BLOCK_SIZE_PAD(LIZARD_BLOCK_SIZE+32)MM_LONGOFFLIZARD_MAX_16BIT_OFFSETLIZARD_INIT_LAST_OFFSETLIZARD_MAX_PRICE(1<<28)MFLIMIT(WILDCOPYLENGTH+MINMATCH)LASTLITERALSWILDCOPYLENGTHLIZARD_DICT_SIZE(1<<24)MINMATCHDECOMPLOG_CODEWORDS_LIZv1(__VA_ARGS__...)LIZARD_LOG_DECOMPRESS_LIZv1(__VA_ARGS__...)COMPLOG_CODEWORDS_LIZv1(__VA_ARGS__...)LIZARD_LOG_COMPRESS_LIZv1(__VA_ARGS__...)DECOMPLOG_CODEWORDS_LZ4(__VA_ARGS__...)LIZARD_LOG_DECOMPRESS_LZ4(__VA_ARGS__...)COMPLOG_CODEWORDS_LZ4(__VA_ARGS__...)LIZARD_LOG_COMPRESS_LZ4(__VA_ARGS__...)LIZARD_LOG_DECOMPRESS(__VA_ARGS__...)LIZARD_LOG_COMPRESS(__VA_ARGS__...)LIZARD_COMMON_H_2983defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)(LIZARD_GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)MINMATCH == 3defined(_MSC_VER) && defined(_WIN32_WCE)defined(_MSC_VER) && defined(_WIN64) && !defined(LIZARD_FORCE_SW_BITCOUNT)(defined(__clang__) || (LIZARD_GCC_VERSION >= 304)) && !defined(LIZARD_FORCE_SW_BITCOUNT)defined(_MSC_VER) && !defined(LIZARD_FORCE_SW_BITCOUNT)Lizard_createStream_MinLevelLizard_resetStream_MinLevelLizard_compress_extState_MinLevelLizard_compress_MinLevelLizard_sizeofState_MinLevel/* LIZARD_COMMON_H_2983827168210 *//* alias to functions with compressionLevel=1 *//*-************************************
*  Common functions
**************************************//* **************************************
*  Function body to include for inlining
****************************************//* Visual Studio for Windows CE does not support Hardware bit count *//*
 * LIZARD_FORCE_SW_BITCOUNT
 * Define this parameter if your target system or compiler does not support hardware bit count
 *//* join to align *//* customized variant of memcpy, which can overwrite up to 7 bytes beyond dstEnd *//*-************************************
*  Reading and writing into memory
**************************************//* _MSC_VER *//* disable: C4293: too large shift (32-bits) *//*-************************************
*  Compiler Options
**************************************///  {                     24,                       24,                   28,  24, 1<<24,  7,           0, 1<<24,  2, Lizard_optimal_price }, // max values//  {                     10,                       10,                   10,   0,     0,  4,           0,     0,  0, Lizard_fast          }, // min values// level 49// level 48// level 47// level 46// level 45// level 44// level 43// level 42// level 41// level 40/*               windLog,               contentLog,              HashLog,  H3,  Snum, SL,   MMLongOff, SuffL, FS, Parser function,           Decompressor type  */// level 39// level 38// level 37// level 36// level 35// level 34// level 33// level 32// level 31// level 30// level 29// level 28// level 27// level 26// level 25// level 24// level 23// level 22// level 21// level 20/*              windLog,                contentLog,              HashLog,  H3,  Snum, SL,   MMLongOff, SuffL, FS, Parser function,           Decompressor type  */// level 19// level 18// level 17// level 16// level 15// level 14// level 13// level 12// level 11// level 10/*               windLog,              contentLog,               HashLog,  H3,  Snum, SL,   MMLongOff, SuffL, FS, Parser function,           Decompressor type  *//* *************************************
*  HC Pre-defined compression levels
***************************************//* index from which to continue dictionary update *//* below that point, no more dict *//* below that point, need extDict *//* alternate base for extDict *//* All index relative to this position *//* next block here to continue on current prefix *//* used only by optimal parser: perform full search of matches: 1 == more compression, slower *//* used only by optimal parser: size of matches which is acceptable: larger == more compression, slower *//* min match size with offsets >= 1<<16 *//* size of matches : larger == faster decompression *//* nb of searches : larger == more compression, slower*//* dispatch table : larger == more memory, faster*//* full search segment : larger == more compression, slower, more memory (useless for fast) *//* largest match distance : impact decompression buffer size *//* from faster to stronger *//* stream numbers *//* header byte *//* LIZv1 codewords *//* LZ4 codewords *///#define LIZARD_USE_TEST//#define USE_LZ4_ONLY/*-************************************
*  Common Constants
**************************************///printf(__VA_ARGS__)//#define LIZARD_USE_LOGS/* LIZARD_GCC_VERSION *//* intptr_t *//* memset, memcpy *//* malloc, calloc, free *//*-************************************
*  Memory routines
**************************************//*
    Lizard - Fast LZ compression algorithm 
    Copyright (C) 2011-2015, Yann Collet
    Copyright (C) 2016-2017, Przemyslaw Skibinski <inikep@gmail.com>

    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
       - Lizard source repository : https://github.com/inikep/lizard
*/dstPtrsrcPtrdstEndmaxDestSizeferror_unlocked (FILE *__stream)feof_unlocked (FILE *__stream)fwrite_unlocked(ptr,size,n,stream)(__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n) && (size_t) (size) * (size_t) (n) <= 8 && (size_t) (size) != 0) ? ({ const char *__ptr = (const char *) (ptr); FILE *__stream = (stream); size_t __cnt; for (__cnt = (size_t) (size) * (size_t) (n); __cnt > 0; --__cnt) if (putc_unlocked (*__ptr++, __stream) == EOF) break; ((size_t) (size) * (size_t) (n) - __cnt) / (size_t) (size); }) : (((__builtin_constant_p (size) && (size_t) (size) == 0) || (__builtin_constant_p (n) && (size_t) (n) == 0)) ? ((void) (ptr), (void) (stream), (void) (size), (void) (n), (size_t) 0) : fwrite_unlocked (ptr, size, n, stream))))fread_unlocked(ptr,size,n,stream)(__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n) && (size_t) (size) * (size_t) (n) <= 8 && (size_t) (size) != 0) ? ({ char *__ptr = (char *) (ptr); FILE *__stream = (stream); size_t __cnt; for (__cnt = (size_t) (size) * (size_t) (n); __cnt > 0; --__cnt) { int __c = getc_unlocked (__stream); if (__c == EOF) break; *__ptr++ = __c; } ((size_t) (size) * (size_t) (n) - __cnt) / (size_t) (size); }) : (((__builtin_constant_p (size) && (size_t) (size) == 0) || (__builtin_constant_p (n) && (size_t) (n) == 0)) ? ((void) (ptr), (void) (stream), (void) (size), (void) (n), (size_t) 0) : fread_unlocked (ptr, size, n, stream))))/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_compress_liz.hLizard_get_price_LIZv1Lizard_stream_t *consttokenadditionalliterals2LIZARD_PRICE_MULT1<<161<<ML_RUN_BITS(1<<ML_RUN_BITS)(BYTE)(MAX_SHORT_MATCHLEN<<RUN_BITS_LIZv1)offset_loadLizard_encodeLastLiterals_LIZv1const BYTE **Lizard_encodeSequence_LIZv1"T32+ literal=%u match=%u offset=%d\n", (U32)length, 0, 0litLengthmatchLengthanchor"T31 literal=%u match=%u offset=%d\n", 0, (U32)matchLength, offset"T0-30 literal=%u match=%u offset=%d\n", 0, (U32)matchLength, offset"T32+ literal=%u match=%u offset=%d\n", (U32)length, (U32)matchLength, offsetERROR matchLength=%d/%d
"ERROR matchLength=%d/%d\n"ERROR offset=%d
"ERROR offset=%d\n"ERROR matchLength[%d] < MINMATCH  offset=%d
"ERROR matchLength[%d] < MINMATCH  offset=%d\n"char[45]Lizard_rescaleFreqs2 * 256LIZARD_FREQ_DIVLizard_setLog2PricesLIZARD_GET_TOKEN_PRICE_LIZv1(token)(LIZARD_PRICE_MULT * (ctx->log2FlagSum - Lizard_highbit32(ctx->flagFreq[token]+1)))// 1=better ratio/* Encode MatchLength */// error// 24-bit offset/* Encode Offset *//* Encode Literal length *//* Copy Literals *//* Prepare next loop */// if ((limitedOutputBuffer) && (ctx->literalsPtr > oend - 5 /*LIZARD_LENGTH_SIZE_LIZv1(length)*/)) { LIZARD_LOG_COMPRESS_LIZv1("encodeSequence overflow2\n"); return 1; }   /* Check output limit */// it should never happen//  if ((limitedOutputBuffer) && (ctx->literalsPtr > oend - 8 /*LIZARD_LENGTH_SIZE_LIZv1(length)*/)) { LIZARD_LOG_COMPRESS_LIZv1("encodeSequence overflow2\n"); return 1; }   /* Check output limit *///  if ((limitedOutputBuffer) && (ctx->literalsPtr > oend - length - LIZARD_LENGTH_SIZE_LIZv1(length) - WILDCOPYLENGTH)) { LIZARD_LOG_COMPRESS_LIZv1("encodeSequence overflow1\n"); return 1; }   /* Check output limit *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_compress_lz4.hLizard_get_price_LZ4(BYTE)(ML_MASK_LZ4<<RUN_BITS_LZ4)Lizard_encodeLastLiterals_LZ4Lizard_encodeSequence_LZ4"literal : %u  --  match : %u  --  offset : %u\n", (U32)(*ip - *anchor), (U32)matchLength, (U32)(*ip-match)LIZARD_GET_TOKEN_PRICE_LZ4(token)(ctx->log2FlagSum - Lizard_highbit32(ctx->flagFreq[token]+1))LIZARD_LENGTH_SIZE_LZ4(len)((len >= (1<<16)+RUN_MASK_LZ4) ? 5 : ((len >= 254+RUN_MASK_LZ4) ? 3 : ((len >= RUN_MASK_LZ4) ? 1 : 0)))// token//def LIZARD_USE_HUFFMAN//  if (ctx->literalsPtr > ctx->literalsEnd - 5 /*LIZARD_LENGTH_SIZE_LZ4(length)*/) { LIZARD_LOG_COMPRESS_LZ4("encodeSequence overflow2\n"); return 1; }   /* Check output limit *///   if (ctx->literalsPtr > ctx->literalsEnd - length - LIZARD_LENGTH_SIZE_LZ4(length) - 2 - WILDCOPYLENGTH) { LIZARD_LOG_COMPRESS_LZ4("encodeSequence overflow1\n"); return 1; }   /* Check output limit *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_hashchain.hLizard_compress_hashChainmflimitmatchlimitmlml2ml3ml0refstart2ref2start3ref3start0ref0(U32)(start2 - ref2)(U32)(ip - ref)_Search2_Search3OPTIMAL_MLcorrectionnew_mlGET_MINMATCH((U32)(start2 - ref2))GET_MINMATCH((U32)(ip - ref))(int)ML_MASK_LZ4_output_errorLizard_InsertAndGetWiderMatchHashTablelowPrefixPtrdictEndmatchIndexnbAttemptsLLdeltacontentMaskmaxDistanceLIZARD_HC_MIN_OFFSETmltLizard_InsertAndFindBestMatchLizard_InsertLIZARD_HC_HASH_FUNCTION(ip,hashLog)Lizard_hashPtr(ip, hashLog, ctx->params.searchLength)GET_MINMATCH(offset)(MINMATCH)(int)((ML_MASK_LZ4-1)+MINMATCH)LIZARD_HC_LONGOFF_MMLIZARD_HC_MIN_OFFSET > 0LIZARD_HC_LONGOFF_MM > 0/* End *//* Encode Last Literals */// match2 doesn't fit, remove it/*
        * OK, now we have 3 ascending matches; let's write at least the first one
        * ip & ref are known; Now for ml
        *//* can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1 *//* Not enough space for match 2 : remove it *//* Now, encode 2 sequences *//* ip & ref are known; Now for ml *//* No better match : 2 sequences to encode *//* Now, we have start2 = ip+new_ml, with new_ml = min(ml, OPTIMAL_ML=18) */// match2 doesn't fit/*
        * Currently we have :
        * ml2 > ml1, and
        * ip1+3 <= ip2 (usually < ip1+ml1)
        *//* First Match too small : removed *//* Here, start0==ip *//* empirical *//* No better match *//* saved, in case we would skip too much *//* Main Loop *//* intentional overflow *//* First Match *//* virtual matchpos *//* HC4 match finder *//* Index table will be updated *//* Update chains up to ip (excluded) *//* not used with offsets > 1<<16 */iLowLimitiHighLimitmatchposstartposiLimit/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_nochain.hLizard_compress_noChainLizard_InsertAndGetWiderMatchNoChainLIZARD_NOCHAIN_MIN_OFFSETLizard_InsertAndFindBestMatchNoChainLizard_InsertNoChainbase+idxLIZARD_NOCHAIN_HASH_FUNCTION(ip,hashLog)Lizard_hash5Ptr(ip, hashLog)LIZARD_NOCHAIN_MIN_OFFSET > 0//#define LIZARD_NOCHAIN_HASH_FUNCTION(ip, hashLog) Lizard_hashPtr(ip, hashLog, ctx->params.searchLength)/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_fast.hLizard_compress_fastaccelerationforwardH2113929216(U32)LIZARD_MAX_INPUT_SIZELizard_minLengthforwardIp > mflimit(forwardIp > mflimit) != 0forwardIpsearchMatchNbLizard_skipTriggeracceleration << Lizard_skipTriggerLIZARD_FAST_MIN_OFFSETnewLowLimit_next_match_last_literalsLizard_getPositionLizard_getPositionOnHashLizard_putPositionLizard_putPositionOnHashLizard_hashPosition(MFLIMIT+1)LIZARD_FAST_LONGOFF_MMLIZARD_FAST_MIN_OFFSET > 0LIZARD_FAST_LONGOFF_MM > 0/* Test next position *//* Fill table *//* Test end of chunk */// while (1)/* Find a match *//* First Byte *//* Input too small, no compression (all literals) *//* Unsupported inputSize, too large (or negative) *//* Init conditions *//* Increase this value ==> compression run slower on incompressible data *//**************************************
*  Hash Functions
**************************************//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_fastsmall.hLizard_compress_fastSmallLizard_getPositionSmallLizard_getPositionOnHashSmallLizard_putPositionSmallLizard_putPositionOnHashSmallLizard_hashPositionSmall/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_fastbig.hLizard_compress_fastBigLizard_getPositionHLogLizard_getPositionOnHashHLogLizard_putPositionHLogLizard_putPositionOnHashHLogLizard_hashPositionHLogLIZARD_FASTBIG_LONGOFF_MM/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_optimal.hLizard_compress_optimalPriceLizard_optimal_t[4100]struct <unnamed>[4100]LIZARD_OPT_NUM4100Lizard_match_t[4097]struct <unnamed>[4097]inrcur2skip_numllenlitlenmlenbest_mlenbest_offmatch_numlast_posconst intptr_tsufficient_lenfaster_get_matcheslizardOptimalMinOffset1<<30(1<<30)LIZARD_OPTIMAL_MIN_OFFSETrepMinMatchREPMINMATCH"%d: SET price[%d/%d]=%d litlen=%d len=%d off=%d\n"(int)(inr-source), mlen, last_pos, opt[mlen].price, opt[mlen].litlen, opt[mlen].mlen, opt[mlen].off"%d: match_num=%d last_pos=%d\n"(int)(ip-source), match_num, last_pos"%d: start Found mlen=%d off=%d best_mlen=%d last_pos=%d\n"(int)(ip-source), matches[i].len, matches[i].off, best_mlen, last_posmatches[i].off"%d: TRY1 opt[%d].price=%d price=%d cur=%d litlen=%d\n"(int)(inr-source), cur - litlen, opt[cur - litlen].price, price, cur, litlen"%d: TRY2 price=%d cur=%d litlen=%d llen=%d\n"(int)(inr-source), price, cur, litlen, llen"%d: TRY3 price=%d cur=%d litlen=%d litonly=%d\n"(int)(inr-source), price, cur, litlen, Lizard_get_price(ctx, rep, inr, ctx->off24pos, litlen, 0, 0)"%d: TRY price=%d opt[%d].price=%d\n"(int)(inr-source), price, cur, opt[cur].price(int)(inr-source), cur, last_pos, opt[cur].price, opt[cur].litlen, opt[cur].mlen, opt[cur].off"%d: COPYREP1 cur=%d mlen=%d rep=%d\n"(int)(inr-source), cur, mlen, opt[cur-mlen].rep"%d: COPYREP2 cur=%d offset=%d rep=%d\n"(int)(inr-source), cur, offset, opt[cur].rep"%d: CURRENT price[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d\n"(int)(inr-source), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep"%d: try REP rep=%d mlen=%d\n"(int)(inr-source), opt[cur].rep, mlen"%d: Found REP mlen=%d off=%d rep=%d opt[%d].off=%d\n"(int)(inr-source), mlen, 0, opt[cur].rep, cur, opt[cur].off"%d: REP sufficient_len=%d best_mlen=%d best_off=%d last_pos=%d\n"(int)(inr-source), sufficient_len, best_mlen, best_off, last_pos"%d: TRY3 price=%d cur=%d litlen=%d getprice=%d\n"(int)(inr-source), price, cur, litlen, Lizard_get_price(ctx, rep, inr, opt[cur].off24pos, litlen, 0, mlen - MINMATCH)"%d: Found REP mlen=%d off=%d price=%d litlen=%d price[%d]=%d\n"(int)(inr-source), mlen, 0, price, litlen, cur - litlen, opt[cur - litlen].pricecur + mlen(int)(inr-source), cur + mlen, last_pos, opt[cur + mlen].price, opt[cur + mlen].litlen, opt[cur + mlen].mlen, opt[cur + mlen].off"%d: Lizard_GetAllMatches match_num=%d\n"(int)(inr-source), match_num"%d: Lizard_BinTree_GetAllMatches match_num=%d\n""%d: Found1 cur=%d cur2=%d mlen=%d off=%d best_mlen=%d last_pos=%d\n"(int)(inr-source), cur, cur2, matches[i].len, matches[i].off, best_mlen, last_pos"%d: Found2 pred=%d mlen=%d best_mlen=%d off=%d price=%d litlen=%d price[%d]=%d\n"(int)(inr-source), matches[i].back, mlen, best_mlen, matches[i].off, price, litlen, cur - litlen, opt[cur - litlen].pricecur2 + mlen(int)(inr-source), cur2 + mlen, last_pos, opt[cur2 + mlen].price, opt[cur2 + mlen].litlen, opt[cur2 + mlen].mlen, opt[cur2 + mlen].off"%d: price[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d\n"(int)(ip-source+i), i, last_pos, opt[i].price, opt[i].off, opt[i].mlen, opt[i].litlen, opt[i].rep"%d: cur=%d/%d best_mlen=%d best_off=%d rep=%d\n"(int)(ip-source+cur), cur, last_pos, best_mlen, best_off, opt[cur].rep"%d: price2[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d\n""%d: price3[%d/%d]=%d off=%d mlen=%d litlen=%d rep=%d\n"(int)(ip-source+cur), cur, last_pos, opt[cur].price, opt[cur].off, opt[cur].mlen, opt[cur].litlen, opt[cur].rep"%d: ENCODE literals=%d off=%d mlen=%d "(int)(ip-source), (int)(ip-anchor), (int)(offset), mlen"%d: offset=%d rep=%d\n"(int)(ip-source), offset, ctx->last_offLizard_optimal_t *sizeof(Lizard_optimal_t)matchIndexLOLizard_match_t *encodeLizard_BinTree_GetAllMatchesmnumdelta0delta1HashPosnewMatchIndexnewmlnewoffLizard_GetAllMatchesmatchDictLizard_BinTree_InsertLizard_get_priceLizard_optimal_tLizard_match_tSET_PRICE(pos,mlen,offset,litlen,price){ while (last_pos < pos) { opt[last_pos+1].price = LIZARD_MAX_PRICE; last_pos++; } opt[pos].mlen = (int)mlen; opt[pos].off = (int)offset; opt[pos].litlen = (int)litlen; opt[pos].price = (int)price; LIZARD_LOG_PARSER("%d: SET price[%d/%d]=%d litlen=%d len=%d off=%d\n", (int)(inr-source), pos, last_pos, opt[pos].price, opt[pos].litlen, opt[pos].mlen, opt[pos].off); }(1<<12)LIZARD_LOG_ENCODE(fmt,__VA_ARGS__...)LIZARD_LOG_PRICE(fmt,__VA_ARGS__...)LIZARD_LOG_PARSER(fmt,__VA_ARGS__...)//            if (mlen == 1) { ip++; cur++; continue; }// cur, last_pos, best_mlen, best_off have to be set//  for (skip_num = 0, cur = 1; cur <= last_pos; cur++)//                if (cur2 + mlen > last_pos || ((matches[i].off != opt[cur2 + mlen].off) && (price < opt[cur2 + mlen].price)))//  if (opt[cur2].mlen == 1)// set prices using matches at position = cur// || ((price == opt[cur + mlen].price) && (opt[cur].mlen == 1) && (cur != litlen))) // at equal price prefer REP instead of MATCH//if (opt[cur].mlen == 1)/* && mlen > best_mlen*//* check rep code */// copy rep/* set rep code */// || ((price == opt[cur].price) && (opt[cur-1].mlen == 1) && (cur != litlen)))// -1 = literals, 0 = rep// check further positions// set prices using matches at position = 0//    printf("%d: newoff=%d newml=%d\n", (U32)current, (int)newoff, (int)newml);//    printf("%d: off=%d mlt=%d\n", (U32)current, (U32)(current - matchIndex), (int)mlt);/* to prepare for next usage of match[mlt] */// if (ip[mlt] == match[mlt])// check rest of matches//            fprintf(stderr, "dictBase[%p]+matchIndex[%d]=match[%p] dictLimit=%d base=%p ip=%p iLimit=%p off=%d\n", dictBase, matchIndex, match, dictLimit, base, ip, iLimit, (U32)(ip-match));/*fullSearch ||*///   bool fullSearch = (ctx->params.fullSearch >= 2);//printf(fmt, __VA_ARGS__) //printf(fmt, __VA_ARGS__)/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_lowestprice.hLizard_compress_lowestPrice_Searchbest_priceoff0off1best_poscommon0common1_EncodeLizard_GetWiderMatchLIZARD_LOWESTPRICE_MIN_OFFSETLizard_FindMatchLowestPriceLizard_better_priceLizard_more_profitablecommon + literalsbest_commonbest_common - literals//	find the lowest price for encoding ml bytes//    goto _Encode;//Lizard_count(ip+MINMATCH, match+MINMATCH, iLimit) + MINMATCH;//   if ((mlt >= minMatchLongOff) || (ctx->last_off < LIZARD_MAX_16BIT_OFFSET)) //      if ((mlt >= minMatchLongOff) || (ctx->last_off < LIZARD_MAX_16BIT_OFFSET))// + MINMATCH;// rep codebest_ip/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_parser_pricefast.hLizard_compress_priceFastLIZARD_PRICEFAST_MIN_OFFSETLizard_FindMatchFasterLizard_FindMatchFastmatchIndex3// && Lizard_better_price((ip - *matchpos), ml, (U32)(ip - match), mlt, ctx->last_off)))// && Lizard_better_price((ip - *matchpos), ml, (ip - match), mlt, ctx->last_off)))/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_compress.c"lizard_parser_pricefast.h""lizard_parser_lowestprice.h""lizard_parser_optimal.h""lizard_parser_fastbig.h""lizard_parser_fastsmall.h""lizard_parser_fast.h""lizard_parser_nochain.h""lizard_parser_hashchain.h""entropy/huf.h""lizard_compress_lz4.h""lizard_compress_liz.h""lizard_common.h"sizeof(void*)sizeof(void*)-1(sizeof(void*)-1)2 GBsourceEnddictBeginLizard_compress_generic"Lizard_compress_generic res=%d inputPart=%d \n", res, inputPart"Lizard_compress_generic in=%d out=%d\n", (int)(ip-(const BYTE*)source), (int)(op-(BYTE*)dest)inputPart"Lizard_compress_generic source=%p inputSize=%d dest=%p maxOutputSize=%d cLevel=%d dictBase=%p dictSize=%d\n", source, inputSize, dest, maxOutputSize, ctx->compressionLevel, ctx->dictBase, (int)dictSize"Lizard_compress_generic total=%d\n", (int)(op-(BYTE*)dest)"Lizard_compress_generic ERROR\n"prefixSizeendIndexLizard_setExternalDictHASH_UPDATE_LIMIT(HASH_UPDATE_LIMIT-1)ctxPtrwantedLizard_streammaxOutputSizectxvoidLizard_streamPtrnewBlockLizard_initStreamtempPtrconst Lizard_parameters *"Allocated %d MB (compressionLevel=%d)\n", (int)(sizeof(Lizard_stream_t) + hashTableSize + chainTableSize)>>20, compressionLevel2384sizeof(Lizard_stream_t)131104655520ERROR: Cannot allocate %d MB (compressionLevel=%d)
"ERROR: Cannot allocate %d MB (compressionLevel=%d)\n"596sizeof(Lizard_stream_t)/4Lizard_initLizard_verifyCompressionLevelLizard_encodeLastLiterals"Lizard_encodeLastLiterals Lizard_coderwords_LZ4=%d\n", ctx->params.decompressType == Lizard_coderwords_LZ4Lizard_encodeSequenceLizard_writeBlockflagsLenliteralsLenlenLenoffset16Lenoffset24Len5*3(uint32_t)(*op-start)_write_uncompressed"%d: total=%d block=%d flagsLen[%.2f%%]=%d comprFlagsLen[%.2f%%]=%d literalsLen[%.2f%%]=%d comprLiteralsLen[%.2f%%]=%d lenLen=%d offset16Len[%.2f%%]=%d offset24Len[%.2f%%]=%d\n", (int)(ip - ctx->srcBase), (int)(*op - ctx->destBase), sum, (flagsLen*100.0)/sum, flagsLen, (comprFlagsLen*100.0)/sum, comprFlagsLen, (literalsLen*100.0)/sum, literalsLen, (comprLiteralsLen*100.0)/sum, comprLiteralsLen, lenLen, (offset16Len*100.0)/sum, offset16Len, (offset24Len*100.0)/sum, offset24Len"%d: total=%d block=%d UNCOMPRESSED inputSize=%u outSize=%d\n", (int)(ip - ctx->srcBase), (int)(*op - ctx->destBase), (int)(*op-start), inputSize, (int)(oend-start)"Lizard_writeBlock ERROR size=%d/%d flagsLen=%d literalsLen=%d lenLen=%d offset16Len=%d offset24Len=%d\n", (int)(*op-start), (int)(oend-start), flagsLen, literalsLen, lenLen, offset16Len, offset24LenLizard_writeStream"*op[%p] + 6 > oend[%p]\n", *op, oend"streamLen[%d] > LIZARD_BLOCK_SIZE\n", streamLenctx->comprStreamLen"*op[%p] oend[%p] comprStreamLen[%d]\n", *op, oend, (int)ctx->comprStreamLen"HUF_compress streamLen=%d comprStreamLen=%d\n", (int)streamLen, (int)ctx->comprStreamLen"HUF_compress ERROR comprStreamLen=%d streamLen=%d\n", (int)ctx->comprStreamLen, (int)streamLen"HUF_compress ERROR %d: %s\n", (int)ctx->comprStreamLen, HUF_getErrorName(ctx->comprStreamLen)useHuffBuf"*op[%p] + 3 + streamLen[%d] > oend[%p]\n", *op, streamLen, oend"Uncompressed streamLen=%d\n", (int)streamLenLizard_initBlockLizard_count_2segmentsip + (mEnd - match)iEndvEndLizard_hashPtrLizard_hash7PtrLizard_hash758295818150454627prime7bytes64-56(64-56)Lizard_hash6PtrLizard_hash6227718039650203prime6bytes64-48(64-48)Lizard_hash5PtrLizard_hash5889523592379prime5bytes64-40(64-40)Lizard_hash4PtrLizard_hash4prime4bytesisize58295818150454627ULL227718039650203ULL889523592379ULLLIZARD_MINIMAL_BLOCK_GAIN(comprSize)(comprSize + (comprSize/32) + 512)LIZARD_MINIMAL_HUFF_GAIN(comprSize)(comprSize + (comprSize/8) + 512)DELTANEXT(p)chainTable[(p) & contentMask]USE_LZ4_ONLYLIZARD_USE_TESTLIZARD_USE_LOGSLIZARD_RESET_MEM/**************************************
*  Level1 functions
**************************************//* initialize stream *//* Error : state is not aligned for pointers (32 or 64 bits) *//* Check overlapping input/dictionary space *//* Check if blocks follow each other *//* Check overflow *//* auto-init if forgotten */// can be lower than 0/* dictionary saving *//* match referencing will resume from there *//* Only one memory segment for extDict, so any previous extDict is lost at this stage *//* Referencing remaining dictionary content *//* initialization */// + LIZARD_FLAG_OFFSET16 + LIZARD_FLAG_OFFSET24;//  printf("malloc from=%p to=%p hashTable=%p hashEnd=%p chainTable=%p chainEnd=%p\n", ctx, ((BYTE*)ctx)+sizeof(Lizard_stream_t) + hashTableSize + chainTableSize, ctx->hashTable, ((BYTE*)ctx->hashTable) + hashTableSize, ctx->chainTable, ((BYTE*)ctx->chainTable)+chainTableSize);//    hashTableSize = (U32)(sizeof(U32)*(((size_t)1 << params.hashLog3)+((size_t)1 << params.hashLog)));/* if ctx==NULL memory is allocated and returned as value *///   printf("memset hashTable=%p hashEnd=%p chainTable=%p chainEnd=%p\n", ctx->hashTable, ((BYTE*)ctx->hashTable) + ctx->hashTableSize, ctx->chainTable, ((BYTE*)ctx->chainTable)+ctx->chainTableSize);// No need to use memset() on tables as values are always bound checked/**************************************
*  Include parsers
**************************************//* compressible *//* reset last offset *//** Lizard_count_2segments() :
*   can count match length with `ip` & `match` in 2 different segments.
*   convention : on reaching mEnd, match count continue starting from iStart
*//**************************************
*  Internal functions
**************************************//* equal to MEM_read64 *//* *************************************
*  Hash functions
***************************************//*-************************************
*  Local Utils
**************************************//* *************************************
*  Local Macros
***************************************/// intptr_t/* *************************************
*  Includes
***************************************//*
    Lizard - Fast LZ compression algorithm 
    Copyright (C) 2011-2015, Yann Collet
    Copyright (C) 2016-2017, Przemyslaw Skibinski <inikep@gmail.com>

    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOTLizard_hash4Ptr
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
       - Lizard source repository : https://github.com/inikep/lizard
*/useHuffstreamLenmEndiStarthBitsmls/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_decompress.hLizard_streamDecode_tprefixEndextDictSizeexternalDictLIZARDDLIB_APILIZARD_DECOMPRESS_H_2983Lizard_decompress_safe_usingDictLizard_decompress_safe_continueLizard_streamDecode_t *Lizard_setStreamDecodeLizard_freeStreamDecodeLizard_createStreamDecodeLizard_decompress_safe_partialLizard_decompress_safe/* LIZARD_DECOMPRESS_H_2983827168210 *//*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as
    a combination of Lizard_setStreamDecode() followed by Lizard_decompress_x_continue()
    They are stand-alone. They don't need nor update an Lizard_streamDecode_t structure.
*//*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks *must* remain available at the memory position where they were decoded (up to LIZARD_DICT_SIZE)
    In the case of a ring buffers, decoding buffer must be either :
    - Exactly same size as encoding buffer, with same update rule (block boundaries at same positions)
      In which case, the decoding & encoding ring buffer can have any size, including small ones ( < LIZARD_DICT_SIZE).
    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.
      maxBlockSize is implementation dependent. It's the maximum size you intend to compress into a single block.
      In which case, encoding and decoding buffers do not need to be synchronized,
      and encoding ring buffer can have any size, including small ones ( < LIZARD_DICT_SIZE).
    - _At least_ LIZARD_DICT_SIZE + 8 bytes + maxBlockSize.
      In which case, encoding and decoding buffers do not need to be synchronized,
      and encoding ring buffer can have any size, including larger than decoding buffer.
    Whenever these conditions are not possible, save the last LIZARD_DICT_SIZE of decoded data into a safe buffer,
    and indicate where it is saved using Lizard_setStreamDecode()
*//*! Lizard_setStreamDecode() :
 *  Use this function to instruct where to find the dictionary.
 *  Setting a size of 0 is allowed (same effect as reset).
 *  @return : 1 if OK, 0 if error
 *//*
 * Lizard_streamDecode_t
 * information structure to track an Lizard stream.
 * init this structure content using Lizard_setStreamDecode or memset() before first use !
 *
 * In the context of a DLL (liblizard) please prefer usage of construction methods below.
 * They are more future proof, in case of a change of Lizard_streamDecode_t size in the future.
 * Lizard_createStreamDecode will allocate and initialize an Lizard_streamDecode_t structure
 * Lizard_freeStreamDecode releases its memory.
 *//*-**********************************************
*  Streaming Decompression Functions
************************************************//*!
Lizard_decompress_safe_partial() :
    This function decompress a compressed block of size 'compressedSize' at position 'source'
    into destination buffer 'dest' of size 'maxDecompressedSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxDecompressedSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*//*
Lizard_decompress_safe() :
    compressedSize : is the precise full size of the compressed block.
    maxDecompressedSize : is the size of destination buffer, which must be already allocated.
    return : the number of bytes decompressed into destination buffer (necessarily <= maxDecompressedSize)
             If destination buffer is not large enough, decoding will stop and output an error code (<0).
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits, including malicious data packets.
             It never writes outside output buffer, nor reads outside input buffer.
*/maxDecompressedSizedictStartLizard_streamDecodetargetOutputSize/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_decompress_lz4.hLizard_decompress_LZ4Lizard_dstream_t *Lizard_dstream_s *blockBasecpyoexitcheckOffset(int)(LIZARD_DICT_SIZE)outputSize==0(outputSize==0) != 0ctx->literalsPtr > iend - 5(ctx->literalsPtr > iend - 5) != 0"0"length >= 254(length >= 254) != 0(size_t)(op+length)<(size_t)(op)((size_t)(op+length)<(size_t)(op)) != 0"1"(size_t)(ctx->literalsPtr+length)<(size_t)(ctx->literalsPtr)((size_t)(ctx->literalsPtr+length)<(size_t)(ctx->literalsPtr)) != 0"2"cpy > oend - WILDCOPYLENGTH || ctx->literalsPtr + length > iend - (2 + WILDCOPYLENGTH)cpy > oend - 16 || ctx->literalsPtr + length > iend - (2 + 16)(cpy > oend - 16 || ctx->literalsPtr + length > iend - (2 + 16)) != 0"offset outside buffers\n"match < lowLimit(match < lowLimit) != 0"lowPrefix[%p]-dictSize[%d]=lowLimit[%p] match[%p]=op[%p]-offset[%d]\n", lowPrefix, (int)dictSize, lowLimit, match, op, (int)offset"4""5"op + length > oend - WILDCOPYLENGTHop + length > oend - 16(op + length > oend - 16) != 0"6"cpy > oend - WILDCOPYLENGTHcpy > oend - 16(cpy > oend - 16) != 0"1match=%p lowLimit=%p\n", match, lowLimitusingExtDictcopySizerestSizeendOfMatchcopyFrompartialDecodinglowPrefix"9""_output_error=%d ctx->flagsPtr=%p blockBase=%p\n", (int) (-(ctx->flagsPtr-blockBase))-1, ctx->flagsPtr, blockBase"cpy=%p oend=%p ctx->literalsPtr+length[%d]=%p iend=%p\n", cpy, oend, (int)length, ctx->literalsPtr+length, iend/* Overflow error detected *//* Nb of output bytes decoded *//* end of decoding *//* Error : input must be consumed *//* last literals *//* Error : offset outside buffers *//* copy match within block *//* overlap copy *//* match encompass external dictionary and current block *//* match can be copied as a single segment from external dictionary *//* doesn't respect parsing restriction *//* check external dictionary *//* overflow detection *//* get matchlength *//* get offset *//* copy literals *//* get literal length *//* Main Loop : decode sequences *//* Empty output buffer *//* Special cases *//* Local Variables *//* note : = 0 if noDict *//* only if dict==usingExtDict *//* == dest if dict == noDict *//* noDict, withPrefix64k, usingExtDict *//* only used if partialDecoding==partial *//* full, partial *//* this value is the max size of Output Buffer. *//*! Lizard_decompress_LZ4() :
 *  This generic decompression function cover all use cases.
 *  It shall be instantiated several times, using different sets of directives
 *  Note that it is important this generic function is really inlined,
 *  in order to remove useless branches during compilation optimization.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_decompress_liz.hLizard_decompress_LIZv1ctx->literalsPtr > iend - 1(ctx->literalsPtr > iend - 1) != 0"3"cpy > oend - WILDCOPYLENGTH || ctx->literalsPtr > iend - WILDCOPYLENGTHcpy > oend - 16 || ctx->literalsPtr > iend - 16(cpy > oend - 16 || ctx->literalsPtr > iend - 16) != 0ctx->offset16Ptr > ctx->offset16End(ctx->offset16Ptr > ctx->offset16End) != 0"(ctx->offset16Ptr > ctx->offset16End\n""7""T32+ literal=%u match=%u offset=%d ipos=%d opos=%d\n", (U32)litLength, (U32)length, (int)-last_off, (U32)(ctx->flagsPtr-blockBase), (U32)(op-dest)ctx->offset24Ptr > ctx->offset24End - 3(ctx->offset24Ptr > ctx->offset24End - 3) != 0"8""T0-30 literal=%u match=%u offset=%d\n", 0, (U32)length, (int)-last_off"10"(uintptr_t)(-last_off) > (uintptr_t)op((uintptr_t)(-last_off) > (uintptr_t)op) != 0"lowPrefix[%p]-dictSize[%d]=lowLimit[%p] match[%p]=op[%p]-last_off[%d]\n", lowPrefix, (int)dictSize, lowLimit, match, op, (int)last_off"12""13match=%p lowLimit=%p\n", match, lowLimitnew_offnot_repCode"14"/* branchless *///    intptr_t litLength;/*! Lizard_decompress_LIZv1() :
 *  This generic decompression function cover all use cases.
 *  It shall be instantiated several times, using different sets of directives
 *  Note that it is important this generic function is really inlined,
 *  in order to remove useless branches during compilation optimization.
 *//*
  [0_MMMM_LLL] - 16-bit offset, 4-bit match length (4-15+), 3-bit literal length (0-7+)
  [1_MMMM_LLL] -   last offset, 4-bit match length (0-15+), 3-bit literal length (0-7+)
  flag 31      - 24-bit offset,        match length (47+),    no literal length
  flag 0-30    - 24-bit offset,  31 match lengths (16-46),    no literal length
*//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_decompress.c"lizard_decompress_liz.h""lizard_decompress_lz4.h""lizard_decompress.h"Lizard_decompress_safe_forceExtDictfullnoDict(int)(LIZARD_DICT_SIZE - 1)withPrefix64klizardsdsizeof(Lizard_streamDecode_t)lizardspartialLizard_decompress_genericdecompFlagsBasedecompOff24BasedecompOff16BasedecompLiteralsBase"inputSize=%d outputSize=%d targetOutputSize=%d partialDecoding=%d\n", inputSize, outputSize, targetOutputSize, partialDecoding"ERROR Lizard_decompress_generic inputSize=%d compressionLevel=%d\n", inputSize, compressionLevel4*LIZARD_HUF_BLOCK_SIZE"UNCOMPRESSED  ip[%p] > iend[%p] - 3\n", ip, iend"UNCOMPRESSED  ip[%p]+length[%d] > iend[%p]\n", ip, length, iend"res=%d\n", res"%d: total=%d block=%d flagsLen=%d(HUF=%d) literalsLen=%d(HUF=%d) offset16Len=%d offset24Len=%d lengthsLen=%d \n", (int)(op-(BYTE*)dest) ,(int)(ip-istart), (int)total, (int)(ctx.flagsEnd-ctx.flagsPtr), (int)comprFlagsLen, (int)(ctx.literalsEnd-ctx.literalsPtr), (int)comprLiteralsLen, (int)(ctx.offset16End-ctx.offset16Ptr), (int)(ctx.offset24End-ctx.offset24Ptr), (int)(ctx.lenEnd-ctx.lenPtr)"Lizard_decompress_generic res=%d inputSize=%d\n", res, (int)(ctx.literalsEnd-ctx.lenEnd)-LIZARD_INIT_LAST_OFFSET"Lizard_decompress_generic ip=%p inputSize=%d targetOutputSize=%d dest=%p outputSize=%d cLevel=%d dict=%d dictSize=%d dictStart=%p partialDecoding=%d\n", ip, inputSize, targetOutputSize, dest, outputSize, compressionLevel, dict, (int)dictSize, dictStart, partialDecoding"Lizard_decompress_generic total=%d\n", (int)(op-(BYTE*)dest)"Lizard_decompress_generic ERROR ip=%p iend=%p\n", ip, iendLizard_readStreamearlyEnd_directivedict_directiveLIZARD_STATS/* debug function *//*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as "_continue" ones,
    the dictionary must be explicitly provided within parameters
*//*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using Lizard_setStreamDecode()
*//*!
 * Lizard_setStreamDecode() :
 * Use this function to instruct where to find the dictionary.
 * This function is not necessary if previous data is still available where it was decoded.
 * Loading a size of 0 is allowed (same effect as no dictionary).
 * Return : 1 if OK, 0 if error
 *//*
 * If you prefer dynamic allocation methods,
 * Lizard_createStreamDecode()
 * provides a pointer (void*) towards an initialized Lizard_streamDecode_t structure.
 *//*===== streaming decompression functions =====*///   printf("%d: total=%d block=%d UNCOMPRESSED op=%p oexit=%p oend=%p\n", (int)(op-(BYTE*)dest) ,(int)(ip-istart), length, op, oexit, oend);/* uncompressed *//*-*****************************
*  Decompression functions
*******************************//*-************************************
*  Local Structures and types
**************************************/// printf//#define LIZARD_STATS 1 // 0=simple stats, 1=more, 2=full/**************************************
*  Includes
**************************************//*
   Lizard - Fast LZ compression algorithm
   Copyright (C) 2011-2016, Yann Collet
   Copyright (C) 2016-2017, Przemyslaw Skibinski <inikep@gmail.com>

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - Lizard source repository : https://github.com/inikep/lizard
*/streamEndstreamFlag/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_frame.hLizardF_decompressOptions_tLizardF_dctx_s *LizardF_decompressionContext_tLizardF_compressOptions_tLizardF_cctx_s *LizardF_compressionContext_tLizardF_preferences_tLizardF_frameInfo_tcontentChecksum_tframeType_tblockMode_tblockSizeID_tLizardF_frameType_tLizardF_frameLizardF_skippableFrameskippableFrameskippableFrame = LizardF_skippableFrameLizardF_contentChecksum_tLizardF_noContentChecksumLizardF_contentChecksumEnablednoContentChecksumnoContentChecksum = LizardF_noContentChecksumcontentChecksumEnabledcontentChecksumEnabled = LizardF_contentChecksumEnabledLizardF_blockMode_tLizardF_blockLinkedLizardF_blockIndependentblockLinkedblockLinked = LizardF_blockLinkedblockIndependentblockIndependent = LizardF_blockIndependentLizardF_blockSizeID_tLizardF_defaultLizardF_max128KBLizardF_max256KBLizardF_max1MBLizardF_max4MBLizardF_max16MBLizardF_max64MBLizardF_max256MBLizardF_errorCode_tstableDststableSrcautoFlushframeInfocontentSizeframeTypecontentChecksumFlagblockModeblockSizeIDLIZARDF_VERSIONLIZARDF_OBSOLETE_ENUM(x),xonceLIZARDF_DISABLE_OBSOLETE_ENUMSLizardF_decompressconst LizardF_decompressOptions_tconst LizardF_decompressOptions_t *LizardF_getFrameInfoLizardF_frameInfo_t *LizardF_freeDecompressionContextLizardF_createDecompressionContextLizardF_decompressionContext_t *LizardF_dctx_s **LizardF_dctx_sLizardF_compressEndconst LizardF_compressOptions_tconst LizardF_compressOptions_t *LizardF_flushLizardF_compressUpdateLizardF_compressBoundconst LizardF_preferences_tconst LizardF_preferences_t *LizardF_compressBeginLizardF_freeCompressionContextLizardF_createCompressionContextLizardF_compressionContext_t *LizardF_cctx_s **LizardF_cctx_sLizardF_compressFrameLizardF_compressFrameBoundLizardF_getErrorNameLizardF_isError/*!LizardF_decompress() :
 * Call this function repetitively to regenerate data compressed within srcBuffer.
 * The function will attempt to decode *srcSizePtr bytes from srcBuffer, into dstBuffer of maximum size *dstSizePtr.
 *
 * The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).
 *
 * The number of bytes read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
 * If number of bytes read is < number of bytes provided, then decompression operation is not completed.
 * It typically happens when dstBuffer is not large enough to contain all decoded data.
 * LizardF_decompress() must be called again, starting from where it stopped (srcBuffer + *srcSizePtr)
 * The function will check this condition, and refuse to continue if it is not respected.
 *
 * `dstBuffer` is expected to be flushed between each call to the function, its content will be overwritten.
 * `dst` arguments can be changed at will at each consecutive call to the function.
 *
 * The function result is an hint of how many `srcSize` bytes LizardF_decompress() expects for next call.
 * Schematically, it's the size of the current (or remaining) compressed block + header of next block.
 * Respecting the hint provides some boost to performance, since it does skip intermediate buffers.
 * This is just a hint though, it's always possible to provide any srcSize.
 * When a frame is fully decoded, the function result will be 0 (no more data expected).
 * If decompression failed, function result is an error code, which can be tested using LizardF_isError().
 *
 * After a frame is fully decoded, dctx can be used again to decompress another frame.
 *//*!LizardF_getFrameInfo() :
 * This function decodes frame header information (such as max blockSize, frame checksum, etc.).
 * Its usage is optional. The objective is to extract frame header information, typically for allocation purposes.
 * A header size is variable and can be from 7 to 15 bytes. It's also possible to input more bytes than that.
 * The number of bytes read from srcBuffer will be updated within *srcSizePtr (necessarily <= original value).
 * (note that LizardF_getFrameInfo() can also be used anytime *after* starting decompression, in this case 0 input byte is enough)
 * Frame header info is *copied into* an already allocated LizardF_frameInfo_t structure.
 * The function result is an hint about how many srcSize bytes LizardF_decompress() expects for next call,
 *                        or an error code which can be tested using LizardF_isError()
 *                        (typically, when there is not enough src bytes to fully decode the frame header)
 * Decompression is expected to resume from where it stopped (srcBuffer + *srcSizePtr)
 *//*======   Decompression   ======*//*!LizardF_createDecompressionContext() :
 * Create an LizardF_decompressionContext_t object, which will be used to track all decompression operations.
 * The version provided MUST be LIZARDF_VERSION. It is intended to track potential breaking differences between different versions.
 * The function will provide a pointer to a fully allocated and initialized LizardF_decompressionContext_t object.
 * The result is an errorCode, which can be tested using LizardF_isError().
 * dctx memory can be released using LizardF_freeDecompressionContext();
 * The result of LizardF_freeDecompressionContext() is indicative of the current state of decompressionContext when being released.
 * That is, it should be == 0 if decompression has been completed fully and correctly.
 *//* Resource management *//* guarantee that decompressed data will still be there on next function calls (avoid storage into tmp buffers) *//* must be aligned on 8-bytes *//*-*********************************
*  Decompression functions
***********************************//* LizardF_compressEnd()
 * When you want to properly finish the compressed frame, just call LizardF_compressEnd().
 * It will flush whatever data remained within compressionContext (like Lizard_flush())
 * but also properly finalize the frame, with an endMark and a checksum.
 * The result of the function is the number of bytes written into dstBuffer (necessarily >= 4 (endMark), or 8 if optional frame checksum is enabled)
 * The function outputs an error code if it fails (can be tested using LizardF_isError())
 * The LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
 * A successful call to LizardF_compressEnd() makes cctx available again for next compression task.
 *//* LizardF_flush()
 * Should you need to generate compressed data immediately, without waiting for the current block to be filled,
 * you can call Lizard_flush(), which will immediately compress any remaining data buffered within cctx.
 * Note that dstMaxSize must be large enough to ensure the operation will be successful.
 * LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
 * The result of the function is the number of bytes written into dstBuffer
 * (it can be zero, this means there was no data left within cctx)
 * The function outputs an error code if it fails (can be tested using LizardF_isError())
 *//* LizardF_compressUpdate()
 * LizardF_compressUpdate() can be called repetitively to compress as much data as necessary.
 * The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
 * You can get the minimum value of dstMaxSize by using LizardF_compressBound().
 * If this condition is not respected, LizardF_compress() will fail (result is an errorCode).
 * LizardF_compressUpdate() doesn't guarantee error recovery, so you have to reset compression context when an error occurs.
 * The LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
 * The result of the function is the number of bytes written into dstBuffer : it can be zero, meaning input data was just buffered.
 * The function outputs an error code if it fails (can be tested using LizardF_isError())
 *//* LizardF_compressBound() :
 * Provides the minimum size of Dst buffer given srcSize to handle worst case situations.
 * Different preferences can produce different results.
 * prefsPtr is optional : you can provide NULL as argument, all preferences will then be set to cover worst case.
 * This function includes frame termination cost (4 bytes, or 8 if frame checksum is enabled)
 *//* LizardF_compressBegin() :
 * will write the frame header into dstBuffer.
 * dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header size is 15 bytes.
 * The LizardF_preferences_t structure is optional : you can provide NULL as argument, all preferences will then be set to default.
 * The result of the function is the number of bytes written into dstBuffer for the header
 * or an error code (can be tested using LizardF_isError())
 *//* Compression *//* LizardF_createCompressionContext() :
 * The first thing to do is to create a compressionContext object, which will be used in all compression operations.
 * This is achieved using LizardF_createCompressionContext(), which takes as argument a version and an LizardF_preferences_t structure.
 * The version provided MUST be LIZARDF_VERSION. It is intended to track potential version differences between different binaries.
 * The function will provide a pointer to a fully allocated LizardF_compressionContext_t object.
 * If the result LizardF_errorCode_t is not zero, there was an error during context creation.
 * Object can release its memory using LizardF_freeCompressionContext();
 *//* Resource Management *//* 1 == src content will remain available on future calls to LizardF_compress(); avoid saving src content within tmp buffer as future dictionary *//*-***********************************
*  Advanced compression functions
*************************************//*!LizardF_compressFrame() :
 * Compress an entire srcBuffer into a valid Lizard frame, as defined by specification v1.5.1
 * The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
 * You can get the minimum value of dstMaxSize by using LizardF_compressFrameBound()
 * If this condition is not respected, LizardF_compressFrame() will fail (result is an errorCode)
 * The LizardF_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default.
 * The result of the function is the number of bytes written into dstBuffer.
 * The function outputs an error code if it fails (can be tested using LizardF_isError())
 *//*-*********************************
*  Simple compression function
***********************************//* must be zero for forward compatibility *//* 1 == always flush (reduce need for tmp buffer) *//* 0 == default (fast mode); values above 16 count as 16; values below 0 count as 0 *//* Size of uncompressed (original) content ; 0 == unknown *//* LizardF_frame, skippableFrame ; 0 == default *//* noContentChecksum, contentChecksumEnabled ; 0 == default  *//* blockLinked, blockIndependent ; 0 == default *//* max64KB, max256KB, max1MB, max4MB ; 0 == default *///#define LIZARDF_DISABLE_OBSOLETE_ENUMS/*-************************************
*  Frame compression types
**************************************//* return error code string; useful for debugging *//*-************************************
*  Error management
**************************************//*-************************************
*  Includes
**************************************//* LizardF is a stand-alone API to create Lizard-compressed frames
 * conformant with specification v1.5.1.
 * All related operations, including memory management, are handled internally by the library.
 * You don't need lizard_compress.h when using lizard_frame.h.
 * *//*
   Lizard auto-framing library
   Header File
   Copyright (C) 2011-2015, Yann Collet
   Copyright (C) 2016-2017, Przemyslaw Skibinski

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Lizard source repository : https://github.com/inikep/lizard
*/dstSizePtrsrcSizePtrdOptPtrframeInfoPtrdctxPtrdstMaxSizecOptPtrprefsPtrcctxPtrpreferencesPtr/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_frame_static.h"lizard_frame.h"LizardF_errorCodesLizardF_OK_NoErrorOK_NoErrorLIZARDF_GENERATE_ENUMLizardF_ERROR_GENERICERROR_GENERICLizardF_ERROR_maxBlockSize_invalidERROR_maxBlockSize_invalidLizardF_ERROR_blockMode_invalidERROR_blockMode_invalidLizardF_ERROR_contentChecksumFlag_invalidERROR_contentChecksumFlag_invalidLizardF_ERROR_compressionLevel_invalidERROR_compressionLevel_invalidLizardF_ERROR_headerVersion_wrongERROR_headerVersion_wrongLizardF_ERROR_blockChecksum_unsupportedERROR_blockChecksum_unsupportedLizardF_ERROR_reservedFlag_setERROR_reservedFlag_setLizardF_ERROR_allocation_failedERROR_allocation_failedLizardF_ERROR_srcSize_tooLargeERROR_srcSize_tooLargeLizardF_ERROR_dstMaxSize_tooSmallERROR_dstMaxSize_tooSmallLizardF_ERROR_frameHeader_incompleteERROR_frameHeader_incompleteLizardF_ERROR_frameType_unknownERROR_frameType_unknownLizardF_ERROR_frameSize_wrongERROR_frameSize_wrongLizardF_ERROR_srcPtr_wrongERROR_srcPtr_wrongLizardF_ERROR_decompressionFailedERROR_decompressionFailedLizardF_ERROR_headerChecksum_invalidERROR_headerChecksum_invalidLizardF_ERROR_contentChecksum_invalidERROR_contentChecksum_invalidLizardF_ERROR_maxCodeERROR_maxCodeLIZARDF_GENERATE_ENUM(ENUM)LizardF_ ## ENUM, ENUM = LizardF_ ## ENUM,LIZARDF_LIST_ERRORS(ITEM)ITEM(OK_NoError) ITEM(ERROR_GENERIC) ITEM(ERROR_maxBlockSize_invalid) ITEM(ERROR_blockMode_invalid) ITEM(ERROR_contentChecksumFlag_invalid) ITEM(ERROR_compressionLevel_invalid) ITEM(ERROR_headerVersion_wrong) ITEM(ERROR_blockChecksum_unsupported) ITEM(ERROR_reservedFlag_set) ITEM(ERROR_allocation_failed) ITEM(ERROR_srcSize_tooLarge) ITEM(ERROR_dstMaxSize_tooSmall) ITEM(ERROR_frameHeader_incomplete) ITEM(ERROR_frameType_unknown) ITEM(ERROR_frameSize_wrong) ITEM(ERROR_srcPtr_wrong) ITEM(ERROR_decompressionFailed) ITEM(ERROR_headerChecksum_invalid) ITEM(ERROR_contentChecksum_invalid) ITEM(ERROR_maxCode)LIZARDF_DISABLE_OLD_ENUMS/* enum is exposed, to handle specific errors; compare function result to -enum value *///#define LIZARDF_DISABLE_OLD_ENUMS/**************************************
 * Error management
 * ************************************//* lizard_frame_static.h should be used solely in the context of static linking.
 * It contains definitions which may still change overtime.
 * Never use it in the context of DLL linking.
 * *//*
   Lizard auto-framing library
   Header File for static linking only
   Copyright (C) 2011-2015, Yann Collet.
   Copyright (C) 2016-2017, Przemyslaw Skibinski

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - Lizard source repository : https://github.com/inikep/lizard
*//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/xxhash/xxhash.hLizard_XXH64_hashFromCanonicalLizard_XXH64_canonicalFromHashLizard_XXH64_digestLizard_XXH64_updateLizard_XXH64_resetLizard_XXH64_copyStateLizard_XXH64_freeStateLizard_XXH64_createStateLizard_XXH64Lizard_XXH32_hashFromCanonicalLizard_XXH32_canonicalFromHashLizard_XXH32_digestLizard_XXH32_updateLizard_XXH32_resetLizard_XXH32_copyStateLizard_XXH32_freeStateLizard_XXH32_createStateLizard_XXH32Lizard_XXH_versionNumberXXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)XXH_NAME2(XXH_NAMESPACE, XXH64_digest)XXH_NAME2(XXH_NAMESPACE, XXH64_update)XXH_NAME2(XXH_NAMESPACE, XXH64_reset)XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)XXH_NAME2(XXH_NAMESPACE, XXH64_createState)XXH_NAME2(XXH_NAMESPACE, XXH64)XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)XXH_NAME2(XXH_NAMESPACE, XXH32_digest)XXH_NAME2(XXH_NAMESPACE, XXH32_update)XXH_NAME2(XXH_NAMESPACE, XXH32_reset)XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)XXH_NAME2(XXH_NAMESPACE, XXH32_createState)XXH_NAME2(XXH_NAMESPACE, XXH32)XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)XXH_NAME2(A,B)XXH_CAT(A,B)A ## BXXH_NO_LONG_LONGLizard_/* XXH_STATIC_LINKING_ONLY *//* include xxhash function bodies as `static`, for inlining *//* remove 64-bits support *//* These definitions are only meant to make possible
   static allocation of XXH state, on stack or in a struct for example.
   Never use members directly. *//* XXH_NO_LONG_LONG *//*======   Canonical representation   ======*//*======   Streaming   ======*//*! XXH64() :
    Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".
    "seed" can be used to alter the result predictably.
    This function runs faster on 64-bits systems, but slower on 32-bits systems (see benchmark).
*//*-**********************************************************************
*  64-bits hash
************************************************************************//*! XXH32() :
    Calculate the 32-bits hash of sequence "length" bytes stored at memory address "input".
    The memory between input & input+length must be valid (allocated and read-accessible).
    "seed" can be used to alter the result predictably.
    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s *//*-**********************************************************************
*  32-bits hash
************************************************************************//*!XXH_NAMESPACE, aka Namespace Emulation :

If you want to include _and expose_ xxHash functions from within your own library,
but also want to avoid symbol collisions with other libraries which may also include xxHash,

you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
with the value of XXH_NAMESPACE (therefore, avoid NULL and numeric values).

Note that no change is required within the calling program as long as it includes `xxhash.h` :
regular symbol name will be automatically translated by this header.
*//** XXH_PRIVATE_API
*   This is useful to include xxhash functions in `static` mode
*   in order to inline them, and remove their symbol from the public list.
*   Methodology :
*     #define XXH_PRIVATE_API
*     #include "xxhash.h"
*   `xxhash.c` is automatically included.
*   It's not useful to compile and link it as a separate module.
*//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/xxhash/home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/lizard_frame.c"xxhash/xxhash.h""lizard_frame_static.h"LizardF_dctx_t *optionsNullsrcStartsrcEnddstStartselectedIndoAnotherStagenextSrcSizeHintLizardF_decompressOptions_t *sizeof(optionsNull)(size_t)-LizardF_ERROR_srcPtr_wrongdstage_getHeadermaxFHSizeconst LizardF_errorCode_tminFHSizedstage_storeHeadersizeToCopyBYTE[16]BHSizedstage_getCBlockSizedstage_storeCBlockSizenextCBlockSize0x7FFFFFFFUdstage_getSuffix(size_t)-LizardF_ERROR_GENERICLIZARDF_BLOCKUNCOMPRESSED_FLAGdstage_copyDirectdstage_getCBlockdstage_storeCBlockdstage_decodeCBlockdstage_decodeCBlock_intoTmpdstage_decodeCBlock_intoDstdecodedSize2 * LIZARD_DICT_SIZEreservedDictSpacedecompressionContextdecompressOptionsPtr(size_t)-LizardF_ERROR_decompressionFaileddstage_flushOutsuffixSize(size_t)-LizardF_ERROR_frameSize_wrongdstage_storeSuffixreadCRCresultCRC18446744073709551598(size_t)-LizardF_ERROR_contentChecksum_invaliddstage_getSFrameSizedstage_storeSFrameSizeSFrameSizedstage_skipSkippabledstage_getSuffix-1(unsigned)(dstage_getSuffix-1)preserveSizeoldDictEndnewDictSizeLizardF_updateDictLizardF_decompress_safeonextSrcSize(size_t)-LizardF_ERROR_frameHeader_incompletedstPtr0withinTmpdCtxLizardF_decodeHeaderFLGBDHCblockChecksumFlagcontentSizeFlagbufferNeededcurrentBlockSizeframeHeaderSizesizeof(dctxPtr->frameInfo)0xFFFFFFF0U407710288LIZARDF_MAGIC_SKIPPABLE_START407708166LIZARDF_MAGICNUMBER(size_t)-LizardF_ERROR_frameType_unknown_2BITS_1BIT_3BITS(size_t)-LizardF_ERROR_headerVersion_wrong(size_t)-LizardF_ERROR_blockChecksum_unsupported(size_t)-LizardF_ERROR_reservedFlag_set(size_t)-LizardF_ERROR_maxBlockSize_invalid_4BITS18446744073709551599(size_t)-LizardF_ERROR_headerChecksum_invaliddctxPtr->maxBlockSizeLizardF_headerSizeLizardF_dctx_t *constsizeof(LizardF_dctx_t)(LizardF_errorCode_t)-LizardF_ERROR_GENERICLizardF_cctx_t *compress(size_t)-LizardF_ERROR_dstMaxSize_tooSmallrealDictSizecOptionsNulllastBlockCompressednotDoneLizardF_preferences_t *LizardF_compressOptions_t *sizeof(cOptionsNull)fromTmpBufferfromSrcBufferLizardF_localSaveDictLizardF_selectCompressionsrcVoidPtrLizardF_decompressionContextLizardF_decompressionContextPtrversionNumbercompressionContextcompressOptionsPtrLizardF_localLizard_compress_continueLizardF_compressBlockcSizePtrprefsNullsizeof(prefsNull)bidnbBlockslastBlockSizeblockInfoframeEndprefNullheaderStartrequiredBuffSizesizeof(prefNull)LIZARDF_BLOCKSIZEID_DEFAULTERROR in LizardF_compressBegin: Cannot allocate %d MB
"ERROR in LizardF_compressBegin: Cannot allocate %d MB\n"(size_t)-LizardF_ERROR_allocation_failed1 & _2BITS(1 & _2BITS)(1 & _2BITS) << 6((1 & _2BITS) << 6)sizeof(LizardF_cctx_t)-LizardF_ERROR_allocation_failed(LizardF_errorCode_t)(-LizardF_ERROR_allocation_failed)cctxIprefssizeof(cctxI)sizeof(options)5 MBsizeof(prefs)const LizardF_blockSizeID_tstreamSizeLizardF_headerChecksumLizardF_optimalBSIDproposedBSIDmaxBlockSizeLizardF_getBlockSizeconst size_t[7]unsigned long[7]128 KB256 KBcodeErrorconst char *[20]char *[20]-LizardF_ERROR_maxCode18446744073709551597(LizardF_errorCode_t)(-LizardF_ERROR_maxCode)LizardF_writeLE64LizardF_readLE64value64LizardF_writeLE32LizardF_readLE32value32dStage_tLizardF_lastBlockStatuscompressFunc_tLizardF_dctx_tLizardF_cctx_ttmpOutStarttmpOutSizetmpOuttmpOutBuffertmpInTargettmpInSizetmpInsrcExpectmaxBufferSizeframeRemainingSizedStagelizardCtxLevellizardCtxPtrtmpBuffcStageconst char *[]LizardF_errorStringsLIZARDF_GENERATE_STRINGlizardctxLizardF_compressionContextLizardF_compressionContextPtrrequestedBSIDLIZARDF_GENERATE_STRING(STRING)#STRING,0x80000000U0x184D2206U0x184D2A50U_8BITS/* require function to be called again from position where it stopped *//* preserve dictionary within tmp if necessary *//* no direct access *//* case dstage_decodeSFrameSize: *//* not enough input to get full sBlockSize; wait for more *//* not enough input to read cBlockSize field *//* no direct call, to avoid scan-build warning *//* case dstage_checkSuffix: *//* not enough input to read complete suffix *//* can be skipped *//* not enough size for entire CRC *//* frame completed *//* incorrect frame size decoded *//* still some data to flush *//* end of flush ? *//* dictionary management *//* flush decoded data from tmpOut to dstBuffer *//* decompression failed *//* Decode *//* dict not within tmp *//* ensure enough place for tmpOut *//* not enough place into dst : decode into tmpOut *//* pass-through *//* need more input *//* entry from dstage_decodeCBlockSize *//* still need to copy more *//* all copied *//* not enough input to read full block *//* uncompressed block *//* invalid cBlockSize *//* frameEnd signal, no more CBlock *//* no more direct access, to prevent scan-build warning *//* case dstage_decodeCBlockSize: *//* not enough input to get full cBlockSize; wait for more *//* not enough src data, ask for some more *//* rest of header + nextBlockHeader *//* minimum to attempt decode *//* enough to decode - shortcut *//* programmed as a state machine *//* expect to continue decoding src buffer where it left previously *//*! LizardF_decompress() :
* Call this function repetitively to regenerate data compressed within srcBuffer.
* The function will attempt to decode *srcSizePtr from srcBuffer, into dstBuffer of maximum size *dstSizePtr.
*
* The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).
*
* The number of bytes effectively read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
* If the number of bytes read is < number of bytes provided, then the decompression operation is not complete.
* You will have to call it again, continuing from where it stopped.
*
* The function result is an hint of the better srcSize to use for next call to LizardF_decompress.
* Basically, it's the size of the current (or remaining) compressed block + header of next block.
* Respecting the hint provides some boost to performance, since it allows less buffer shuffling.
* Note that this is just a hint, you can always provide any srcSize you want.
* When a frame is fully decoded, the function result will be 0.
* If decompression failed, function result is an error code which can be tested using LizardF_isError().
*//* note : dstSize < LIZARD_DICT_SIZE *//* join dict & dest into tmp *//* tmp buffer not large enough *//* copy dst into tmp to complete dict *//* copy relevant dict portion in front of tmpOut within tmpOutBuffer *//* assumption : dctxPtr->dict + dctxPtr->dictSize == dctxPtr->tmpOut + dctxPtr->tmpOutStart *//* dstBuffer large enough to become dictionary *//* dictionary continuity *//* priority to dictionary continuity *//* trivial redirector, for common prototype *//* should not happen, already checked *//* returns : recommended nb of bytes for LizardF_decompress() *//* frameInfo already decoded *//* note : requires dstage_* header related to be at beginning of enum *//*! LizardF_getFrameInfo() :
*   Decodes frame header information, such as blockSize.
*   It is optional : you could start by calling directly LizardF_decompress() instead.
*   The objective is to extract header information without starting decompression, typically for allocation purposes.
*   LizardF_getFrameInfo() can also be used *after* starting decompression, on a valid LizardF_decompressionContext_t.
*   The number of bytes read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
*   You are expected to resume decompression from where it stopped (srcBuffer + *srcSizePtr)
*   @return : hint of the better `srcSize` to use for next call to LizardF_decompress,
*             or an error code which can be tested using LizardF_isError().
*//* tmp buffers too small *//* alloc *//* save *//* Bad header checksum error *//* Reserved bits *//* 1-7 only supported values for the time being *//* Reserved bit *//* Not supported for the time being *//* Version Number, only supported value *//* validate *//* not enough input to fully decode frame header *//* Frame Header Size *//* Flags *//* control magic number *//* special case : skippable frames *//* minimal frame header size *//* need to decode header to get frameInfo *//*! LizardF_decodeHeader() :
   input   : `srcVoidPtr` points at the **beginning of the frame**
   output  : set internal values of dctx, such as
             dctxPtr->frameInfo and dctxPtr->dStage.
             Also allocates internal buffers.
   @return : nb Bytes read from srcVoidPtr (necessarily <= srcSize)
             or an error code (testable with LizardF_isError())
*//* minimal srcSize to determine header size *//*! LizardF_headerSize() :
*   @return : size of frame header
*             or an error code, which can be tested using LizardF_isError()
*//* ******************************************************************** *//* ********************* Decompression ******************************** *//* can accept NULL input, like free() *//*! LizardF_createDecompressionContext() :
*   Create a decompressionContext object, which will track all decompression operations.
*   Provides a pointer to a fully allocated and initialized LizardF_decompressionContext object.
*   Object can later be released using LizardF_freeDecompressionContext().
*   @return : if != 0, there was an error during context creation.
*//*-***************************************************
*   Frame Decompression
*****************************************************//* reuse HC context *//* state is now re-usable (with identical preferences) *//* content Checksum *//*! LizardF_compressEnd() :
* When you want to properly finish the compressed frame, just call LizardF_compressEnd().
* It will flush whatever data remained within compressionContext (like Lizard_flush())
* but also properly finalize the frame, with an endMark and a checksum.
* The result of the function is the number of bytes written into dstBuffer (necessarily >= 4 (endMark size))
* The function outputs an error code if it fails (can be tested using LizardF_isError())
* The LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
* compressionContext can then be used again, starting with LizardF_compressBegin(). The preferences will remain the same.
*//* necessarily LizardF_blockLinked *//* keep tmpIn within limits *//* compress tmp buffer *//* select compression function *//* not yet useful *//* +8 : block header(4) + block checksum(4) *//* nothing to flush *//*! LizardF_flush() :
* Should you need to create compressed data immediately, without waiting for a block to be filled,
* you can call Lizard_flush(), which will immediately compress any remaining data stored within compressionContext.
* The result of the function is the number of bytes written into dstBuffer
* (it can be zero, this means there was no data left within compressionContext)
* The function outputs an error code if it fails (can be tested using LizardF_isError())
* The LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
*//* fill tmp buffer *//* some input data left, necessarily < blockSize *//* necessarily LizardF_blockLinked && lastBlockCompressed==fromTmpBuffer *//* preserve dictionary if necessary *//* compress remaining input < blockSize *//* compress full block *//* complete tmpIn block and then compress it *//* still needs some CRC *//* add src to tmpIn buffer *//* some data already within tmp buffer *//* complete tmp buffer *//*! LizardF_compressUpdate() :
* LizardF_compressUpdate() can be called repetitively to compress as much data as necessary.
* The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
* If this condition is not respected, LizardF_compress() will fail (result is an errorCode)
* You can get the minimum value of dstMaxSize by using LizardF_compressBound()
* The LizardF_compressOptions_t structure is optional : you can provide NULL as argument.
* The result of the function is the number of bytes written into dstBuffer : it can be zero, meaning input data was just buffered.
* The function outputs an error code if it fails (can be tested using LizardF_isError())
*//* compression failed *//* compress one block *//* default, without block CRC option *//* worst case *//* LizardF_compressBound() : gives the size of Dst buffer given a srcSize to handle worst case situations.
*                        The LizardF_frameInfo_t structure is optional :
*                        you can provide NULL as argument, preferences will then be set to cover worst case situations.
* *//* header written, now request input data block *//* CRC Byte *//* Optional Frame content size field *//* BD Byte *//* Frame content size *//* Frame checksum *//* Block mode *//* Version('01') *//* FLG Byte *//* Magic Number *//* just needs dict *//* Buffer Management *//* ctx Management *//*! LizardF_compressBegin() :
* will write the frame header into dstBuffer.
* dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header size is LizardF_MAXHEADERFRAME_SIZE bytes.
* The result of the function is the number of bytes written into dstBuffer for the header
* or an error code (can be tested using LizardF_isError())
*//* null pointers can be safely provided to this function, like free() *//* Next stage : write header *//* LizardF_createCompressionContext() :
* The first thing to do is to create a compressionContext object, which will be used in all compression operations.
* This is achieved using LizardF_createCompressionContext(), which takes as argument a version and an LizardF_preferences_t structure.
* The version provided MUST be LIZARDF_VERSION. It is intended to track potential version differences between different binaries.
* The function will provide a pointer to an allocated LizardF_compressionContext_t object.
* If the result LizardF_errorCode_t is not OK_NoError, there was an error during context creation.
* Object can release its memory using LizardF_freeCompressionContext();
*//*-*********************************
*  Advanced compression functions
***********************************//* flush last block, and generate suffix *//* header size *//* write header *//* no need for linked blocks *//* auto-correct content size if selected (!=0) *//* mess with real buffer size to prevent allocation; works because autoflush==1 & stableSrc==1 *//* works because no allocation *//*! LizardF_compressFrame() :
* Compress an entire srcBuffer into a valid Lizard frame, as defined by specification v1.5.0, in a single step.
* The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
* You can get the minimum value of dstMaxSize by using LizardF_compressFrameBound()
* If this condition is not respected, LizardF_compressFrame() will fail (result is an errorCode)
* The LizardF_preferences_t structure is optional : you can provide NULL as argument. All preferences will then be set to default.
* The result of the function is the number of bytes written into dstBuffer.
* The function outputs an error code if it fails (can be tested using LizardF_isError())
*//* header size, including magic number and frame content size*//*-************************************
*  Simple compression functions
**************************************//*-************************************
*  Private functions
**************************************//* 0: unallocated;  1: Lizard_stream_t;  *//*-************************************
*  Structures and local types
**************************************//*-************************************
*  Constants
**************************************//* unoptimized version; solves endianess & alignment issues *//* LIZARD_DICT_SIZE *//* LizardF is a stand-alone API to create Lizard-compressed Frames
*  in full conformance with specification v1.5.0
*  All related operations, including memory management, are handled by the library.
* *//*
Lizard auto-framing library
Copyright (C) 2011-2016, Yann Collet
Copyright (C) 2016-2017, Przemyslaw Skibinski

BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You can contact the author at :
- Lizard source repository : https://github.com/inikep/lizard
*//home/atharvakale/390r-debugging-setup/p7zip/C/lizard/lib/xxhash/xxhash.cXXH_GCC_VERSIONdefined(__INTEL_COMPILER) || \XXH_GCC_VERSION >= 403/*====== Canonical representation   ======*//*======   Hash Streaming   ======*//*======   xxh64   ======*//*======   Memory access   ======*//* *******************************************************************
*  64-bits hash functions
*********************************************************************//*======   Hash streaming   ======*//* *******************************************************************
*  32-bits hash functions
*********************************************************************//*! and for memcpy() *//*! Modify the local functions below should you wish to use some other memory routines
*   for malloc(), free() *//*!XXH_FORCE_ALIGN_CHECK :
 * This is a minor performance trick, only useful with lots of very small keys.
 * It means : check for aligned/unaligned input.
 * The check costs one initial branch per hash;
 * set it to 0 when the input is guaranteed to be aligned,
 * or when alignment doesn't matter for performance.
 *//*!XXH_FORCE_NATIVE_FORMAT :
 * By default, xxHash library provides endian-independent Hash values, based on little-endian convention.
 * Results are therefore identical for little-endian and big-endian CPU.
 * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
 * Should endian-independence be of no importance for your application, you may set the #define below to 1,
 * to improve speed for Big-endian CPU.
 * This option has no impact on Little_Endian CPU.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4.hLZ4_u16LZ4_i8LZ4_streamDecode_tLZ4_streamDecode_uLZ4_streamDecode_t_internalLZ4_stream_tLZ4_stream_uLZ4_stream_t_internalLZ4_byteLZ4_u32internal_donotuseconst LZ4_byteconst LZ4_byte *LZ4_STREAMDECODE_MINSIZEminStateSizecurrentOffsetconst LZ4_stream_t_internalconst LZ4_stream_t_internal *LZ4_stream_t_internal *dictCtxLZ4_u32[4096]unsigned int[4096]LZ4_HASH_SIZE_U32char[16416]16416LZ4_STREAM_MINSIZELZ4_DEPRECATED(message)((1UL << LZ4_MEMORY_USAGE) + 32)(1 << LZ4_HASHLOG)LZ4_HASHTABLESIZE(1 << LZ4_MEMORY_USAGE)LZ4_HASHLOG(LZ4_MEMORY_USAGE-2)LZ4_H_98237428734687LZ4_COMPRESS_INPLACE_BUFFER_SIZE(maxCompressedSize)((maxCompressedSize) + LZ4_COMPRESS_INPLACE_MARGIN)LZ4_COMPRESS_INPLACE_MARGIN(LZ4_DISTANCE_MAX + 32)LZ4_DISTANCE_MAXLZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize)((decompressedSize) + LZ4_DECOMPRESS_INPLACE_MARGIN(decompressedSize))LZ4_DECOMPRESS_INPLACE_MARGIN(compressedSize)(((compressedSize) >> 8) + 32)LZ4LIB_STATIC_APILZ4_STATIC_3504398509LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize)(65536 + 14 + (maxBlockSize))LZ4_COMPRESSBOUND(isize)((unsigned)(isize) > (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)LZ4_MAX_INPUT_SIZELZ4_MEMORY_USAGELZ4_MEMORY_USAGE_DEFAULTLZ4_MEMORY_USAGE_MAXLZ4_MEMORY_USAGE_MINLZ4_VERSION_STRINGLZ4_EXPAND_AND_QUOTE(LZ4_LIB_VERSION)LZ4_EXPAND_AND_QUOTE(str)LZ4_QUOTE(str)LZ4_LIB_VERSIONLZ4_VERSION_MAJOR.LZ4_VERSION_MINOR.LZ4_VERSION_RELEASELZ4_VERSION_NUMBER(LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)LZ4_VERSION_RELEASELZ4_VERSION_MINORLZ4_VERSION_MAJORLZ4_FREESTANDINGLZ4LIB_APILZ4LIB_VISIBILITYLZ4_H_2983827168210defined(LZ4_DLL_EXPORT) && (LZ4_DLL_EXPORT==1)defined(LZ4_DLL_IMPORT) && (LZ4_DLL_IMPORT==1)defined(LZ4_FREESTANDING) && (LZ4_FREESTANDING == 1)!defined(LZ4_memcpy)!defined(LZ4_memset)!defined(LZ4_memmove)! defined(LZ4_FREESTANDING)(LZ4_MEMORY_USAGE < LZ4_MEMORY_USAGE_MIN)(LZ4_MEMORY_USAGE > LZ4_MEMORY_USAGE_MAX)!defined(RC_INVOKED)!defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)LZ4_STATIC_LINKING_ONLYLZ4_PUBLISH_STATIC_FUNCTIONSdefined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)LZ4_DISABLE_DEPRECATE_WARNINGSdefined (__cplusplus) && (__cplusplus >= 201402)defined(__clang__) || (defined(__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 45))defined(__GNUC__) && (__GNUC__ * 10 + __GNUC_MINOR__ >= 31)LZ4_resetStreamLZ4_stream_t *LZ4_stream_u *LZ4_decompress_fast_usingDictLZ4_decompress_fast_continueLZ4_streamDecode_t *LZ4_streamDecode_u *LZ4_decompress_fastLZ4_decompress_fast_withPrefix64kLZ4_decompress_safe_withPrefix64kLZ4_slideInputBufferLZ4_resetStreamStateLZ4_sizeofStreamStateLZ4_createLZ4_uncompress_unknownOutputSizeLZ4_uncompressLZ4_compress_limitedOutput_continueLZ4_compress_continueLZ4_compress_limitedOutput_withStateLZ4_compress_withStateLZ4_compress_limitedOutputLZ4_compressLZ4_initStreamLZ4_attach_dictionaryconst LZ4_stream_tconst LZ4_stream_t *LZ4_compress_fast_extState_fastResetLZ4_decompress_safe_partial_usingDictLZ4_decompress_safe_usingDictLZ4_decompress_safe_continueLZ4_decoderRingBufferSizeLZ4_setStreamDecodeLZ4_freeStreamDecodeLZ4_createStreamDecodeLZ4_saveDictLZ4_compress_fast_continueLZ4_loadDictLZ4_resetStream_fastLZ4_freeStreamLZ4_createStreamLZ4_decompress_safe_partialLZ4_compress_destSizeLZ4_compress_fast_extStateLZ4_sizeofStateLZ4_compress_fastLZ4_compressBoundLZ4_decompress_safeLZ4_compress_defaultLZ4_versionStringLZ4_versionNumber"This function is deprecated and unsafe. Consider using LZ4_decompress_safe_usingDict() instead""This function is deprecated and unsafe. Consider using LZ4_decompress_safe_continue() instead""This function is deprecated and unsafe. Consider using LZ4_decompress_safe() instead""use LZ4_decompress_fast_usingDict() instead""use LZ4_decompress_safe_usingDict() instead""Use LZ4_saveDict() instead""Use LZ4_resetStream() instead""Use LZ4_createStream() instead""use LZ4_decompress_safe() instead""use LZ4_decompress_fast() instead""use LZ4_compress_fast_continue() instead""use LZ4_compress_fast_extState() instead""use LZ4_compress_default() instead"/* LZ4_H_98237428734687 *//*! LZ4_resetStream() :
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is done with LZ4_initStream(), or LZ4_resetStream().
 *  Consider switching to LZ4_initStream(),
 *  invoking LZ4_resetStream() will trigger deprecation warnings in the future.
 *//*! Obsolete LZ4_decompress_fast variants (since v1.9.0) :
 *  These functions used to be faster than LZ4_decompress_safe(),
 *  but this is no longer the case. They are now slower.
 *  This is because LZ4_decompress_fast() doesn't know the input size,
 *  and therefore must progress more cautiously into the input buffer to not read beyond the end of block.
 *  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.
 *  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.
 *
 *  The last remaining LZ4_decompress_fast() specificity is that
 *  it can decompress a block without knowing its compressed size.
 *  Such functionality can be achieved in a more secure manner
 *  by employing LZ4_decompress_safe_partial().
 *
 *  Parameters:
 *  originalSize : is the uncompressed size to regenerate.
 *                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.
 * @return : number of bytes read from source buffer (== compressed size).
 *           The function expects to finish at block's end exactly.
 *           If the source stream is detected malformed, the function stops decoding and returns a negative result.
 *  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.
 *         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.
 *         Also, since match offsets are not validated, match reads from 'src' may underflow too.
 *         These issues never happen if input (compressed) data is correct.
 *         But they may happen if input data is invalid (error or intentional tampering).
 *         As a consequence, use these functions in trusted environments with trusted data **only**.
 *//*! Obsolete streaming decoding functions (since v1.7.0) *//* Obsolete streaming functions (since v1.7.0)
 * degraded functionality; do not use!
 *
 * In order to perform streaming compression, these functions depended on data
 * that is no longer tracked in the state. They have been preserved as well as
 * possible: using them will still produce a correct output. However, they don't
 * actually retain any history between compression calls. The compression ratio
 * achieved will therefore be no better than compressing each chunk
 * independently.
 *//*! Obsolete decompression functions (since v1.8.0) *//*! Obsolete compression functions (since v1.7.3) *//* LZ4_DISABLE_DEPRECATE_WARNINGS *//* C++14 or greater *//* disable deprecation warnings *//*! Deprecation warnings
 *
 *  Deprecated functions make the compiler generate a warning when invoked.
 *  This is meant to invite users to update their source code.
 *  Should deprecation warnings be a problem, it is generally possible to disable them,
 *  typically with -Wno-deprecated-declarations for gcc
 *  or _CRT_SECURE_NO_WARNINGS in Visual.
 *
 *  Another method is to define LZ4_DISABLE_DEPRECATE_WARNINGS
 *  before including the header file.
 *//*-************************************
*  Obsolete Functions
**************************************//* previously typedef'd to LZ4_streamDecode_t *//*! LZ4_streamDecode_t :
 *  Never ever use below internal definitions directly !
 *  These definitions are not API/ABI safe, and may change in future versions.
 *  If you need static allocation, declare or allocate an LZ4_streamDecode_t object.
**//*! LZ4_initStream() : v1.9.0+
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is automatically done when invoking LZ4_createStream(),
 *  but it's not when the structure is simply declared on stack (for example).
 *
 *  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.
 *  It can also initialize any arbitrary buffer of sufficient size,
 *  and will @return a pointer of proper type upon initialization.
 *
 *  Note : initialization fails if size and alignment conditions are not respected.
 *         In which case, the function will @return NULL.
 *  Note2: An LZ4_stream_t structure guarantees correct alignment and size.
 *  Note3: Before v1.9.0, use LZ4_resetStream() instead
**//* previously typedef'd to LZ4_stream_t *//* static size, for inter-version compatibility *//* Implicit padding to ensure structure is aligned *//*! LZ4_stream_t :
 *  Never ever use below internal definitions directly !
 *  These definitions are not API/ABI safe, and may change in future versions.
 *  If you need static allocation, declare or allocate an LZ4_stream_t object.
**//* required as macro for static allocation *//*-************************************************************
 *  Private Definitions
 **************************************************************
 * Do not use these definitions directly.
 * They are only exposed to allow static allocation of `LZ4_stream_t` and `LZ4_streamDecode_t`.
 * Accessing members will expose user code to API and/or ABI break in future versions of the library.
 **************************************************************//* LZ4_STATIC_LINKING_ONLY *//* LZ4_STATIC_3504398509 *//**< maxCompressedSize is generally LZ4_COMPRESSBOUND(inputSize), but can be set to any lower value, with the risk that compression can fail (return code 0(zero)) *//* LZ4_DISTANCE_MAX can be safely replaced by srcSize when it's smaller *//* set to maximum value by default *//* history window size; can be user-defined at compile time *//**< note: presumes that compressedSize < decompressedSize. note2: margin is overestimated a bit, since it could use compressedSize instead *//*! In-place compression and decompression
 *
 * It's possible to have input and output sharing the same buffer,
 * for highly constrained memory environments.
 * In both cases, it requires input to lay at the end of the buffer,
 * and decompression to start at beginning of the buffer.
 * Buffer size must feature some margin, hence be larger than final size.
 *
 * |<------------------------buffer--------------------------------->|
 *                             |<-----------compressed data--------->|
 * |<-----------decompressed size------------------>|
 *                                                  |<----margin---->|
 *
 * This technique is more useful for decompression,
 * since decompressed size is typically larger,
 * and margin is short.
 *
 * In-place decompression will work inside any buffer
 * which size is >= LZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize).
 * This presumes that decompressedSize > compressedSize.
 * Otherwise, it means compression actually expanded data,
 * and it would be more efficient to store such data with a flag indicating it's not compressed.
 * This can happen when data is not compressible (already compressed, or encrypted).
 *
 * For in-place compression, margin is larger, as it must be able to cope with both
 * history preservation, requiring input data to remain unmodified up to LZ4_DISTANCE_MAX,
 * and data expansion, which can happen when input is not compressible.
 * As a consequence, buffer size requirements are much higher,
 * and memory savings offered by in-place compression are more limited.
 *
 * There are ways to limit this cost for compression :
 * - Reduce history size, by modifying LZ4_DISTANCE_MAX.
 *   Note that it is a compile-time constant, so all compressions will apply this limit.
 *   Lower values will reduce compression ratio, except when input_size < LZ4_DISTANCE_MAX,
 *   so it's a reasonable trick when inputs are known to be small.
 * - Require the compressor to deliver a "maximum compressed size".
 *   This is the `dstCapacity` parameter in `LZ4_compress*()`.
 *   When this size is < LZ4_COMPRESSBOUND(inputSize), then compression can fail,
 *   in which case, the return code will be 0 (zero).
 *   The caller must be ready for these cases to happen,
 *   and typically design a backup scheme to send data uncompressed.
 * The combination of both techniques can significantly reduce
 * the amount of margin required for in-place compression.
 *
 * In-place compression can work in any buffer
 * which size is >= (maxCompressedSize)
 * with maxCompressedSize == LZ4_COMPRESSBOUND(srcSize) for guaranteed compression success.
 * LZ4_COMPRESS_INPLACE_BUFFER_SIZE() depends on both maxCompressedSize and LZ4_DISTANCE_MAX,
 * so it's possible to reduce memory requirements by playing with them.
 *//*! LZ4_attach_dictionary() :
 *  This is an experimental API that allows
 *  efficient use of a static dictionary many times.
 *
 *  Rather than re-loading the dictionary buffer into a working context before
 *  each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a
 *  working LZ4_stream_t, this function introduces a no-copy setup mechanism,
 *  in which the working stream references the dictionary stream in-place.
 *
 *  Several assumptions are made about the state of the dictionary stream.
 *  Currently, only streams which have been prepared by LZ4_loadDict() should
 *  be expected to work.
 *
 *  Alternatively, the provided dictionaryStream may be NULL,
 *  in which case any existing dictionary stream is unset.
 *
 *  If a dictionary is provided, it replaces any pre-existing stream history.
 *  The dictionary contents are the only history that can be referenced and
 *  logically immediately precede the data compressed in the first subsequent
 *  compression call.
 *
 *  The dictionary will only remain attached to the working stream through the
 *  first compression call, at the end of which it is cleared. The dictionary
 *  stream (and source buffer) must remain in-place / accessible / unchanged
 *  through the completion of the first compression call on the stream.
 *//*! LZ4_compress_fast_extState_fastReset() :
 *  A variant of LZ4_compress_fast_extState().
 *
 *  Using this variant avoids an expensive initialization step.
 *  It is only safe to call if the state buffer is known to be correctly initialized already
 *  (see above comment on LZ4_resetStream_fast() for a definition of "correctly initialized").
 *  From a high level, the difference is that
 *  this function initializes the provided state with a call to something like LZ4_resetStream_fast()
 *  while LZ4_compress_fast_extState() starts with a call to LZ4_resetStream().
 *//*-****************************************************************************
 * Experimental section
 *
 * Symbols declared in this section must be considered unstable. Their
 * signatures or semantics may change, or they may be removed altogether in the
 * future. They are therefore only safe to depend on when the caller is
 * statically linked against the library.
 *
 * To protect against unsafe usage, not only are the declarations guarded,
 * the definitions are hidden by default
 * when building LZ4 as a shared/dynamic library.
 *
 * In order to access these declarations,
 * define LZ4_STATIC_LINKING_ONLY in your application
 * before including LZ4's headers.
 *
 * In order to make their implementations accessible dynamically, you must
 * define LZ4_PUBLISH_STATIC_FUNCTIONS when building the LZ4 library.
 ******************************************************************************//*^*************************************
 * !!!!!!   STATIC LINKING ONLY   !!!!!!
 ***************************************//* LZ4_H_2983827168210 *//*! LZ4_decompress_safe_partial_usingDict() :
 *  Behaves the same as LZ4_decompress_safe_partial()
 *  with the added ability to specify a memory segment for past data.
 *  Performance tip : Decompression speed can be substantially increased
 *                    when dst == dictStart + dictSize.
 *//*! LZ4_decompress_safe_usingDict() :
 *  Works the same as
 *  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_safe_continue()
 *  However, it's stateless: it doesn't need any LZ4_streamDecode_t state.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.
 *  Performance tip : Decompression speed can be substantially increased
 *                    when dst == dictStart + dictSize.
 *//*! LZ4_decompress_safe_continue() :
 *  This decoding function allows decompression of consecutive blocks in "streaming" mode.
 *  The difference with the usual independent blocks is that
 *  new blocks are allowed to find references into former blocks.
 *  A block is an unsplittable entity, and must be presented entirely to the decompression function.
 *  LZ4_decompress_safe_continue() only accepts one block at a time.
 *  It's modeled after `LZ4_decompress_safe()` and behaves similarly.
 *
 * @LZ4_streamDecode : decompression state, tracking the position in memory of past data
 * @compressedSize : exact complete size of one compressed block.
 * @dstCapacity : size of destination buffer (which must be already allocated),
 *                must be an upper bound of decompressed size.
 * @return : number of bytes decompressed into destination buffer (necessarily <= dstCapacity)
 *           If destination buffer is not large enough, decoding will stop and output an error code (negative value).
 *           If the source stream is detected malformed, the function will stop decoding and return a negative result.
 *
 *  The last 64KB of previously decoded data *must* remain available and unmodified
 *  at the memory position where they were previously decoded.
 *  If less than 64KB of data has been decoded, all the data must be present.
 *
 *  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :
 *  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).
 *    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized.
 *    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.
 *  - Synchronized mode :
 *    Decompression buffer size is _exactly_ the same as compression buffer size,
 *    and follows exactly same update rule (block boundaries at same positions),
 *    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),
 *    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).
 *  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized,
 *    and encoding ring buffer can have any size, including small ones ( < 64 KB).
 *
 *  Whenever these conditions are not possible,
 *  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,
 *  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block.
*//* for static allocation; maxBlockSize presumed valid *//*! LZ4_decoderRingBufferSize() : v1.8.2+
 *  Note : in a ring buffer scenario (optional),
 *  blocks are presumed decompressed next to each other
 *  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),
 *  at which stage it resumes from beginning of ring buffer.
 *  When setting such a ring buffer for streaming decompression,
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 *//*! LZ4_setStreamDecode() :
 *  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.
 *  Use this function to start decompression of a new stream of blocks.
 *  A dictionary can optionally be set. Use NULL or size 0 for a reset order.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.
 * @return : 1 if OK, 0 if error
 *//* !defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION) *//* https://docs.microsoft.com/en-us/windows/win32/menurc/predefined-macros *//*! LZ4_createStreamDecode() and LZ4_freeStreamDecode() :
 *  creation / destruction of streaming decompression tracking context.
 *  A tracking context can be re-used multiple times.
 *//* tracking context *//*-**********************************************
*  Streaming Decompression Functions
*  Bufferless synchronous API
************************************************//*! LZ4_saveDict() :
 *  If last 64KB data cannot be guaranteed to remain available at its current memory location,
 *  save it into a safer place (char* safeBuffer).
 *  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),
 *  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.
 * @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error.
 *//*! LZ4_compress_fast_continue() :
 *  Compress 'src' content using data from previously compressed blocks, for better compression ratio.
 * 'dst' buffer must be already allocated.
 *  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
 *
 * @return : size of compressed block
 *           or 0 if there is an error (typically, cannot fit into 'dst').
 *
 *  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.
 *           Each block has precise boundaries.
 *           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.
 *           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.
 *
 *  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !
 *
 *  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.
 *           Make sure that buffers are separated, by at least one byte.
 *           This construction ensures that each block only depends on previous block.
 *
 *  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.
 *
 *  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed.
 *//*! LZ4_loadDict() :
 *  Use this function to reference a static dictionary into LZ4_stream_t.
 *  The dictionary must remain available during compression.
 *  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.
 *  The same dictionary will have to be loaded on decompression side for successful decoding.
 *  Dictionary are useful for better compression of small data (KB range).
 *  While LZ4 accept any input as dictionary,
 *  results are generally better when using Zstandard's Dictionary Builder.
 *  Loading a size of 0 is allowed, and is the same as reset.
 * @return : loaded dictionary size, in bytes (necessarily <= 64 KB)
 *//*! LZ4_resetStream_fast() : v1.9.0+
 *  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks
 *  (e.g., LZ4_compress_fast_continue()).
 *
 *  An LZ4_stream_t must be initialized once before usage.
 *  This is automatically done when created by LZ4_createStream().
 *  However, should the LZ4_stream_t be simply declared on stack (for example),
 *  it's necessary to initialize it first, using LZ4_initStream().
 *
 *  After init, start any new stream with LZ4_resetStream_fast().
 *  A same LZ4_stream_t can be re-used multiple times consecutively
 *  and compress multiple streams,
 *  provided that it starts each new stream with LZ4_resetStream_fast().
 *
 *  LZ4_resetStream_fast() is much faster than LZ4_initStream(),
 *  but is not compatible with memory regions containing garbage data.
 *
 *  Note: it's only useful to call LZ4_resetStream_fast()
 *        in the context of streaming compression.
 *        The *extState* functions perform their own resets.
 *        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.
 *//**
 Note about RC_INVOKED

 - RC_INVOKED is predefined symbol of rc.exe (the resource compiler which is part of MSVC/Visual Studio).
   https://docs.microsoft.com/en-us/windows/win32/menurc/predefined-macros

 - Since rc.exe is a legacy compiler, it truncates long symbol (> 30 chars)
   and reports warning "RC4011: identifier truncated".

 - To eliminate the warning, we surround long preprocessor symbol with
   "#if !defined(RC_INVOKED) ... #endif" block that means
   "skip this block when rc.exe is trying to read it".
*//* incomplete type (defined later) *//*! LZ4_decompress_safe_partial() :
 *  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',
 *  into destination buffer 'dst' of size 'dstCapacity'.
 *  Up to 'targetOutputSize' bytes will be decoded.
 *  The function stops decoding on reaching this objective.
 *  This can be useful to boost performance
 *  whenever only the beginning of a block is required.
 *
 * @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)
 *           If source stream is detected malformed, function returns a negative result.
 *
 *  Note 1 : @return can be < targetOutputSize, if compressed block contains less data.
 *
 *  Note 2 : targetOutputSize must be <= dstCapacity
 *
 *  Note 3 : this function effectively stops decoding on reaching targetOutputSize,
 *           so dstCapacity is kind of redundant.
 *           This is because in older versions of this function,
 *           decoding operation would still write complete sequences.
 *           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,
 *           it could write more bytes, though only up to dstCapacity.
 *           Some "margin" used to be required for this operation to work properly.
 *           Thankfully, this is no longer necessary.
 *           The function nonetheless keeps the same signature, in an effort to preserve API compatibility.
 *
 *  Note 4 : If srcSize is the exact size of the block,
 *           then targetOutputSize can be any value,
 *           including larger than the block's decompressed size.
 *           The function will, at most, generate block's decompressed size.
 *
 *  Note 5 : If srcSize is _larger_ than block's compressed size,
 *           then targetOutputSize **MUST** be <= block's decompressed size.
 *           Otherwise, *silent corruption will occur*.
 *//*! LZ4_compress_destSize() :
 *  Reverse the logic : compresses as much data as possible from 'src' buffer
 *  into already allocated buffer 'dst', of size >= 'targetDestSize'.
 *  This function either compresses the entire 'src' content into 'dst' if it's large enough,
 *  or fill 'dst' buffer completely with as much data as possible from 'src'.
 *  note: acceleration parameter is fixed to "default".
 *
 * *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.
 *               New value is necessarily <= input value.
 * @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)
 *           or 0 if compression fails.
 *
 * Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):
 *        the produced compressed content could, in specific circumstances,
 *        require to be decompressed into a destination buffer larger
 *        by at least 1 byte than the content to decompress.
 *        If an application uses `LZ4_compress_destSize()`,
 *        it's highly recommended to update liblz4 to v1.9.2 or better.
 *        If this can't be done or ensured,
 *        the receiving decompression function should provide
 *        a dstCapacity which is > decompressedSize, by at least 1 byte.
 *        See https://github.com/lz4/lz4/issues/859 for details
 *//*! LZ4_compress_fast_extState() :
 *  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.
 *  Use LZ4_sizeofState() to know how much memory must be allocated,
 *  and allocate it on 8-bytes boundaries (using `malloc()` typically).
 *  Then, provide this buffer as `void* state` to compression function.
 *//*! LZ4_compress_fast() :
    Same as LZ4_compress_default(), but allows selection of "acceleration" factor.
    The larger the acceleration value, the faster the algorithm, but also the lesser the compression.
    It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
    An acceleration value of "1" is the same as regular LZ4_compress_default()
    Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).
    Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c).
*//*! LZ4_compressBound() :
    Provides the maximum size that LZ4 compression may output in a "worst case" scenario (input data not compressible)
    This function is primarily useful for memory allocation purposes (destination buffer size).
    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
    Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)
        inputSize  : max supported value is LZ4_MAX_INPUT_SIZE
        return : maximum output size in a "worst case" scenario
              or 0, if input size is incorrect (too large or negative)
*//*! LZ4_decompress_safe() :
 * @compressedSize : is the exact complete size of the compressed block.
 * @dstCapacity : is the size of destination buffer (which must be already allocated),
 *                is an upper bound of decompressed size.
 * @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)
 *           If destination buffer is not large enough, decoding will stop and output an error code (negative value).
 *           If the source stream is detected malformed, the function will stop decoding and return a negative result.
 * Note 1 : This function is protected against malicious data packets :
 *          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,
 *          even if the compressed block is maliciously modified to order the decoder to do these actions.
 *          In such case, the decoder stops immediately, and considers the compressed block malformed.
 * Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.
 *          The implementation is free to send / store / derive this information in whichever way is most beneficial.
 *          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead.
 *//*! LZ4_compress_default() :
 *  Compresses 'srcSize' bytes from buffer 'src'
 *  into already allocated 'dst' buffer of size 'dstCapacity'.
 *  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).
 *  It also runs faster, so it's a recommended setting.
 *  If the function cannot compress 'src' into a more limited 'dst' budget,
 *  compression stops *immediately*, and the function result is zero.
 *  In which case, 'dst' content is undefined (invalid).
 *      srcSize : max supported value is LZ4_MAX_INPUT_SIZE.
 *      dstCapacity : size of buffer 'dst' (which must be already allocated)
 *     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)
 *                or 0 if compression fails
 * Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer).
 *//*!
 * LZ4_MEMORY_USAGE :
 * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; )
 * Increasing memory usage improves compression ratio, at the cost of speed.
 * Reduced memory usage may improve speed at the cost of ratio, thanks to better cache locality.
 * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache
 *//*-************************************
*  Tuning parameter
**************************************//**< library version string; useful to check dll version; requires v1.7.5+ *//**< library version number; useful to check dll version; requires v1.3.0+ *//* requires v1.7.3+ *//*! LZ4_FREESTANDING :
 *  When this macro is set to 1, it enables "freestanding mode" that is
 *  suitable for typical freestanding environment which doesn't support
 *  standard C library.
 *
 *  - LZ4_FREESTANDING is a compile-time switch.
 *  - It requires the following macros to be defined:
 *    LZ4_memcpy, LZ4_memmove, LZ4_memset.
 *  - It only enables LZ4/HC functions which don't use heap.
 *    All LZ4F_* functions are not supported.
 *  - See tests/freestanding.c to check its basic setup.
 *//*
*  LZ4_DLL_EXPORT :
*  Enable exporting of functions when building a Windows DLL
*  LZ4LIB_VISIBILITY :
*  Control library symbols visibility.
*//**
  Introduction

  LZ4 is lossless compression algorithm, providing compression speed >500 MB/s per core,
  scalable with multi-cores CPU. It features an extremely fast decoder, with speed in
  multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.

  The LZ4 compression library provides in-memory compression and decompression functions.
  It gives full buffer control to user.
  Compression can be done in:
    - a single step (described as Simple Functions)
    - a single step, reusing a context (described in Advanced Functions)
    - unbounded multiple steps (described as Streaming compression)

  lz4.h generates and decodes LZ4-compressed blocks (doc/lz4_Block_format.md).
  Decompressing such a compressed block requires additional metadata.
  Exact metadata depends on exact decompression function.
  For the typical case of LZ4_decompress_safe(),
  metadata includes block's compressed size, and maximum bound of decompressed size.
  Each application is free to encode and pass such metadata in whichever way it wants.

  lz4.h only handle blocks, it can not generate Frames.

  Blocks are different from Frames (doc/lz4_Frame_format.md).
  Frames bundle both blocks and metadata in a specified manner.
  Embedding metadata is required for compressed data to be self-contained and portable.
  Frame format is delivered through a companion API, declared in lz4frame.h.
  The `lz4` CLI can only manage frames.
*//* --- Dependency --- *//*
 *  LZ4 - Fast LZ compression algorithm
 *  Header File
 *  Copyright (C) 2011-2020, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/home/atharvakale/390r-debugging-setup/p7zip/C/lz4LZ4_streamDecodeinputBufferLZ4_streamPtrworkingStreamdictionaryStreamLZ4_streammaxDictSizetargetDstSize/usr/lib/gcc/x86_64-redhat-linux/12/include/limits.h/usr/lib/gcc/x86_64-redhat-linux/12/include/syslimits.h/usr/include/limits.h/usr/include/bits/posix2_lim.h/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4.c<limits.h>"lz4.h"t_asizeof(LZ4_stream_t)dictSize >= 064 KB64 KB - 1LZ4_streamDecode!=NULLLZ4_streamDecode_t_internal *LZ4_streamDecode_t_internal *constlz4sd"LZ4_decompress_fast_continue (toDecodeSize=%i)", originalSizeoriginalSize >= 0"first invocation : no prefix nor extDict"lz4sd->extDictSize == 0"continue using existing prefix""prefix becomes extDict"65550dictionary != NULLsizeof(LZ4_streamDecode_t) >= sizeof(LZ4_streamDecode_t_internal)LZ4_static_assertsizeof(LZ4_streamDecode_t)LZ4_decompress_safe_doubleDictdecode_full_blockLZ4_decompress_fast_extDictLZ4_decompress_safe_partial_forceExtDictpartial_decodeLZ4_decompress_safe_forceExtDict"LZ4_decompress_safe_forceExtDict"LZ4_decompress_safe_partial_withSmallPrefixLZ4_decompress_safe_withSmallPrefixLZ4_decompress_safe_partial_withPrefix64k"LZ4_decompress_fast"LZ4_decompress_generic(int)(64 KB)shortiendshortoend"LZ4_decompress_generic (srcSize:%i, dstSize:%i)", srcSize, outputSizelowPrefix <= opsrcSize==0(srcSize==0) != 0"skip fast decode loop"FASTLOOP_SAFE_DISTANCE"using fast decode loop"oend - op >= FASTLOOP_SAFE_DISTANCEip < iend"error reading long literal length"(uptrval)(op)+length<(uptrval)(op)((uptrval)(op)+length<(uptrval)(op)) != 0(uptrval)(ip)+length<(uptrval)(ip)((uptrval)(ip)+length<(uptrval)(ip)) != 0MFLIMIT >= WILDCOPYLENGTH12 >= 8"copy %u bytes in a 16-bytes stripe", (unsigned)length" offset = %zu", offsetmatch <= op"error reading long match length"(uptrval)(op)+length<(uptrval)op((uptrval)(op)+length<(uptrval)op) != 0match + dictSize < lowPrefix(match + dictSize < lowPrefix) != 0"Error : offset outside buffers"match >= lowPrefixop + 18 <= oendop+8match+8op+16match+16"Error : pos=%zi, offset=%zi => outside buffers", op-lowPrefix, op-matchdictEnd != NULLop+length > oend-LASTLITERALSop+length > oend-5(op+length > oend-5) != 0"partialDecoding: dictionary match, close to dstEnd"(size_t)(oend-op)"end-of-block condition violated"dictEnd - copySize(op <= oend) && (oend-op >= 32)offset<16(offset<16) != 0ML_BITSRUN_MASKaddlconst Rvl_trvl_error16 + 1(16 + 1/*max lit + offset + nextToken*/)__builtin_memcpyML_MASK__builtin_memmovesafe_decode"using safe decode loop"(ip < shortiend) & (op <= shortoend)((ip < shortiend) & (op <= shortoend)) != 0op + 0match + 0op + 8match + 8op +16match +16"partialDecoding: copying literals, close to input or output end""partialDecoding: literal length = %u", (unsigned)length"partialDecoding: remaining space in dstBuffer : %i", (int)(oend - op)"partialDecoding: remaining space in srcBuffer : %i", (int)(iend - ip)op<=oend"should have been last run of literals""ip(%p) + length(%i) = %p != iend (%p)", ip, (int)length, ip+length, iend"or cpy(%p) > oend(%p)", cpy, oendoffset<8(offset<8) != 0op+4cpy > oend-MATCH_SAFEGUARD_DISTANCEcpy > oend-((2*8) - 4)(cpy > oend-((2*8) - 4)) != 0safe_literal_copy2+12+1+LASTLITERALS(2+1+LASTLITERALS)_copy_matchsafe_match_copyMATCH_SAFEGUARD_DISTANCEmatchEndcopyEndconst unsigned int[8]const int[8]int[8]oCopyLimit(WILDCOPYLENGTH-1)"decoded %i bytes", (int) (((char*)op)-dst)read_variable_lengthip != NULL*ip != NULLilimit != NULL(*ip) >= ilimit((*ip) >= ilimit) != 0(*ip) > ilimit((*ip) > ilimit) != 0length > ((Rvl_t)(-1)/2)(length > ((Rvl_t)(-1)/2)) != 0sizeof(length)sizeof(length)<8(sizeof(length)<8)LZ4_decompress_unsafe_genericprefixStart"LZ4_decompress_unsafe_generic"dictSize == 0"invalid: literals end at distance %zi from end of block", oend-op"offset out of range""invalid: match ends at distance %zi from end of block", oend-opllextMatchextmlread_long_length_no_check"read_long_length_no_check: +length=%zu using %zu input bytes", l, l/255 + 1LZ4_stream_t_internal *const"LZ4_saveDict : dictSize=%i, safeBuffer=%p", dictSize, safeBufferdict->dictionarypreviousDictEndLZ4_compress_forceExtDictconst limitedOutput_directiveconst tableType_tconst dict_directiveconst dictIssue_directivenotLimitedbyU32dictSmallnoDictIssue"LZ4_compress_fast_continue (inputSize=%i, dictSize=%u)", inputSize, streamPtr->dictSizeLZ4_ACCELERATION_DEFAULT65537LZ4_ACCELERATION_MAX"LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small", streamPtr->dictSize, streamPtr->dictionaryilimitinitial_checkdecompressedSizeLZ4_dictlimitedOutputstreamPtr->dictCtxsizeof(*streamPtr)4 KBusingDictCtxLZ4_renormDictTnextSize >= 0"LZ4_renormDictT"LZ4_u32 *"LZ4_attach_dictionary (%p, %p, size %u)", workingStream, dictionaryStream, dictCtx != NULL ? dictCtx->dictSize : 0idx32"LZ4_loadDict (%i bytes from %p into %p)", dictSize, dictionary, LZ4_dict(int)HASH_UNIT(U32)tableTypeHASH_UNIT"LZ4_freeStream %p", LZ4_stream"LZ4_resetStream (ctx:%p)", LZ4_streamsizeof(LZ4_stream_t_internal)(LZ4_stream)(sizeof(LZ4_stream_t_internal))"LZ4_initStream"(buffer)LZ4_stream_t_alignment16424sizeof(t_a)sizeof(t_a) - sizeof(LZ4_stream_t)LZ4_stream_t *constlz4ssizeof(LZ4_stream_t) >= sizeof(LZ4_stream_t_internal)"LZ4_createStream %p", lz4ssizeof(*lz4s)ctxBodyLZ4_compress_destSize_extStatesizeof (*state)s != NULL65547LZ4_64KlimitfillOutputbyU16addrModesizeof(void*)==4(sizeof(void*)==4)(sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX))byPtr((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32ctx != NULL(sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX))((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)) ? byPtr : byU32LZ4_compress_generic"LZ4_compress_generic: srcSize=%i, dstCapacity=%i", srcSize, dstCapacity(U32)LZ4_MAX_INPUT_SIZE"Generating an empty block"outputDirective == notLimited || dstCapacity >= 1dst != NULLinputConsumed != NULLsrc != NULLLZ4_compress_generic_validatednextSizeinputConsumedoutputDirectivedictDirectivedictIssuestartIndexdictDeltamaybe_extMemprefixIdxLimitmflimitPlusOne"LZ4_compress_generic_validated: srcSize=%i, tableType=%u", inputSize, tableTypeinputSize<LZ4_64KlimitdictDirective==noDictacceleration >= 1LZ4_minLengthforwardIp > mflimitPlusOne(forwardIp > mflimitPlusOne) != 0ip < mflimitPlusOnematchIndex <= currentforwardIp - base < (ptrdiff_t)(2 GB - 1)tableType == byU32"extDict candidate: matchIndex=%5u  <  startIndex=%5u", matchIndex, startIndexstartIndex - matchIndex >= MINMATCH"candidate at pos=%u  (offset=%u \n", matchIndex, current - matchIndexmatchIndex < current(current - matchIndex) <= LZ4_DISTANCE_MAXip[-1]==match[-1](ip[-1]==match[-1]) != 0op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimitop + litLength + (2 + 1 + 5) + (litLength/255) > olimit(op + litLength + (2 + 1 + 5) + (litLength/255) > olimit) != 0op + (litLength+240)/255 + litLength + 2 + 1 + MFLIMIT - MINMATCH > olimitop + (litLength+240)/255 + litLength + 2 + 1 + 12 - 4 > olimit(op + (litLength+240)/255 + litLength + 2 + 1 + 12 - 4 > olimit) != 0"seq.start:%i, literals=%u, match.start:%i", (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source)"             with offset=%u  (ext if > %i)", offset, (int)(ip - (const BYTE*)source)offset <= LZ4_DISTANCE_MAX && offset > 0"             with offset=%u  (same segment)", (U32)(ip - match)ip-match <= LZ4_DISTANCE_MAXdictEnd > match"             with matchLength=%u starting in extDict", matchCode+MINMATCH"             with matchLength=%u", matchCode+MINMATCHop + (1 + LASTLITERALS) + (matchCode+240)/255 > olimitop + (1 + 5) + (matchCode+240)/255 > olimit(op + (1 + 5) + (matchCode+240)/255 > olimit) != 0newMatchCode < matchCodeip <= filledIp(ip <= filledIp) != 0"Clearing %u positions", (U32)(filledIp - ip)outputDirective == limitedOutput!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit)"seq.start:%i, literals=%u, match.start:%i", (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source)filledIpLZ4_skipTriggerconst LZ4_u32const LZ4_u32 *LZ4_DISTANCE_ABSOLUTE_MAX(LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX)(RUN_MASK<<ML_BITS)matchCodemorenewMatchCode15 /* in token */ - 110204*255(LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)lastRunolimit >= op"Final literal run : %i literals", (int)lastRunaccumulatorresult > 0"LZ4_compress_generic: compressed %i bytes into %i bytes", inputSize, resultLZ4_prepareTableinputSize >= 0"LZ4_prepareTable: Resetting table in %p", cctxcctx->hashTable(cctx->hashTable)((1 << 14))"LZ4_prepareTable: Re-use hash table (no reset)"clearedTable1 GB(U32)clearedTable"LZ4_prepareTable: adding 64KB to currentOffset"LZ4_getPositionLZ4_getPositionOnHashtableType == byPtrconst BYTE *const *LZ4_getIndexOnHashLZ4_MEMORY_USAGE > 214 > 2h < (1U << (LZ4_MEMORY_USAGE-2))h < (1U << (LZ4_MEMORY_USAGE-1))LZ4_putPositionLZ4_putPositionOnHashconst BYTE **constLZ4_putIndexOnHashidx < 65536LZ4_clearHashLZ4_hashPositionsizeof(reg_t)sizeof(reg_t)==8(sizeof(reg_t)==8)LZ4_hash5prime8bytesLZ4_hash4(MINMATCH*8)(LZ4_HASHLOG+1)(MINMATCH*8)-(LZ4_HASHLOG+1)((MINMATCH*8)-(LZ4_HASHLOG+1))(MINMATCH*8)-LZ4_HASHLOG((MINMATCH*8)-LZ4_HASHLOG)1.9.41090010904LZ4_countpIn < pInLimit-(STEPSIZE-1)pIn < pInLimit-(sizeof(reg_t)-1)(pIn < pInLimit-(sizeof(reg_t)-1)) != 0const reg_t(STEPSIZE==8)LZ4_NbCommonBytessizeof(val) == 8sizeof(val)==8LZ4_memcpy_using_offsetBYTE[8]dstEnd >= dstPtr + MINMATCH*srcPtr(v)(*srcPtr)(8)&v[2]&v[4]LZ4_wildCopy32d+16s+16LZ4_memcpy_using_offset_basesrcPtr + offset == dstPtrdstPtr+4LZ4_wildCopy8LZ4_writeLE16LZ4_readLE16LZ4_write32LZ4_unalign32 *LZ4_write16LZ4_unalign16 *LZ4_read_ARCHconst LZ4_unalignSTconst LZ4_unalignST *LZ4_read32const LZ4_unalign32const LZ4_unalign32 *LZ4_read16const LZ4_unalign16const LZ4_unalign16 *LZ4_isLittleEndianLZ4_isAlignedRvl_tdictIssue_directivetableType_tLZ4_unalignSTLZ4_unalign32LZ4_unalign16limitedOutput_directivereg_tuptrvaluArchu16(Rvl_t)(-1)(64 KB)(MFLIMIT-1)(64 KB) + (MFLIMIT-1)((64 KB) + (MFLIMIT-1))dec64tableinc32table( (a) < (b) ? (a) : (b) )LZ4_FAST_DEC_LOOPLZ4_memmoveLZ4_memcpy(dst,src,size)__builtin_memcpy(dst, src, size)LZ4_STATIC_ASSERT(c){ enum { LZ4_static_assert = 1/(int)(!!(c)) }; }((1U<<RUN_BITS)-1)RUN_BITS(8-ML_BITS)((1U<<ML_BITS)-1)((2*WILDCOPYLENGTH) - MINMATCH)MEM_INIT(p,v,s)LZ4_memset((p),(v),(s))LZ4_memset(p,v,s)memset((p),(v),(s))FREEMEM(p)free(p)ALLOC_AND_ZERO(s)calloc(1,s)ALLOC(s)malloc(s)LZ4_ALIGN_TESTLZ4_FORCE_O2LZ4_FORCE_INLINELZ4_SRC_INCLUDEDLZ4_FORCE_MEMORY_ACCESSLZ4_HEAPMODEdefined(__GNUC__) && \(defined(__INTEL_COMPILER) && !defined(_WIN32)) || defined(__GNUC__)defined(__PPC64__) && defined(__LITTLE_ENDIAN__) && defined(__GNUC__) && !defined(__clang__)(defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)likelyunlikelydefined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)defined(LZ4_USER_MEMORY_FUNCTIONS)! LZ4_FREESTANDING(LZ4_DISTANCE_MAX > LZ4_DISTANCE_ABSOLUTE_MAX)defined(LZ4_DEBUG) && (LZ4_DEBUG>=1)defined(LZ4_DEBUG) && (LZ4_DEBUG>=2)UINT_MAX != 4294967295ULdefined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==2)defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)defined __i386__ || defined _M_IX86 || defined __x86_64__ || defined _M_X64defined(__aarch64__) && defined(__APPLE__)defined(__aarch64__) && !defined(__clang__)defined(_MSC_VER) && (_MSC_VER <= 1933)defined(_MSC_VER) && (_MSC_VER >= 1800) && (defined(_M_AMD64) && !defined(_M_ARM64EC)) && !defined(LZ4_FORCE_SW_BITCOUNT)defined(__clang__) && (__clang_major__ < 10)defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)(defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \defined(_MSC_VER) && (_MSC_VER >= 1400) && !defined(LZ4_FORCE_SW_BITCOUNT)LZ4_COMMONDEFS_ONLY(LZ4_HEAPMODE)/* LZ4_COMMONDEFS_ONLY *//* avoid const char * -> char * conversion warning *//* Obsolete Streaming functions *//*
These decompression functions are deprecated and should no longer be used.
They are only provided here for compatibility with older user programs.
- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
*//* obsolete compression functions *//*=*************************************************
*  Obsolete Functions
***************************************************//* The buffer wraps around, or they're switching to another buffer. *//* They're rolling the current segment. *//* The first call, no dictionary yet. *//*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*//*! LZ4_decoderRingBufferSize() :
 *  when setting a ring buffer for streaming decompression (optional scenario),
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 *  Note : in a ring buffer scenario,
 *  blocks are presumed decompressed next to each other.
 *  When not enough space remains for next block (remainingSize < maxBlockSize),
 *  decoding resumes from beginning of ring buffer.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 *//*! LZ4_setStreamDecode() :
 *  Use this function to instruct where to find the dictionary.
 *  This function is not necessary if previous data is still available where it was decoded.
 *  Loading a size of 0 is allowed (same effect as no dictionary).
 * @return : 1 if OK, 0 if error
 *//* support free on NULL *//* The "double dictionary" mode, for use with e.g. ring buffers: the first part
 * of the dictionary is passed as prefix, and the second via dictStart + dictSize.
 * These routines are used only once, in LZ4_decompress_*_continue().
 *//* Another obsolete API function, paired with the previous one. *//* Exported, an obsolete API function. *//*===== Instantiate a few more decoding cases, used more than once. =====*//*===== Instantiate the API decoding functions. =====*//* wildcopy correction *//* Error : last LASTLITERALS bytes must be literals (uncompressed) *//* silence msan warning when offset==0 *//* partialDecoding : may end anywhere within the block *//* match stretches into both external dictionary and current block *//* match fits entirely within external dictionary : just copy *//* match starting within external dictionary *//* can overwrite up to 8 bytes beyond cpy *//* Necessarily EOF when !partialDecoding.
                 * When partialDecoding, it is EOF if we've either
                 * filled the output buffer or
                 * can't proceed with reading an offset for following match.
                 *//* supports overlapping memory regions, for in-place decompression scenarios *//* We must be on the last sequence (or invalid) because of the parsing limitations
                      * so check that we exactly consume the input and don't overrun the output buffer.
                      *//* Finishing in the middle of a literals segment,
                     * due to lack of output space.
                     *//* Finishing in the middle of a literals segment,
                     * due to lack of input.
                     *//* Since we are partial decoding we may be in this block because of the output parsing
                     * restriction, which is not valid since the output buffer is allowed to be undersized.
                     *//* We've either hit the input parsing restriction or the output parsing restriction.
                 * In the normal scenario, decoding a full block, it must be the last sequence,
                 * otherwise it's an error (invalid input or dimensions).
                 * In partialDecoding scenario, it's necessary to ensure there is no buffer overflow.
                 *//* decode literal length *//* The second stage didn't work out, but the info is ready.
                 * Propel it right to the point of match copying. *//* Both stages worked, load the next token. *//* Copy the match. *//* Do not deal with overlapping matches. *//* check overflow *//* match length *//* The second stage: prepare for match copying, decode full info.
                 * If it doesn't work out, the info won't be wasted. *//* Copy the literals *//* strictly "less than" on input, to re-enter the loop with at least one byte *//* A two-stage shortcut for the most common case:
             * 1) If the literal length is 0..14, and there is enough space,
             * enter the shortcut and copy 16 bytes on behalf of the literals
             * (in the fast mode, only 8 bytes can be safely copied this way).
             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
             * manner; but we ensure that there's enough space in the output for
             * those 18 bytes earlier, upon entering the shortcut (in other words,
             * there is a combined check for both stages).
             *//* literal length *//* Main Loop : decode remaining sequences where output < FASTLOOP_SAFE_DISTANCE *//* Fastpath check: skip LZ4_wildCopy32 when true *//* overflow check *//* Literals can only be <= 14, but hope compilers optimize better when copy by a register size *//*max lit + offset + nextToken*//* We don't need to check oend, since we check it once for each loop below *//* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE *//* Fast loop : decode sequences as long as output < oend-FASTLOOP_SAFE_DISTANCE *//* LZ4_FAST_DEC_LOOP:
     * designed for modern OoO performance cpus,
     * where copying reliably 32-bytes is preferable to an unpredictable branch.
     * note : fast loop may show a regression for some client arm chips. *//*maxML*//*maxLL*//*offset*//* Set up the "end" pointers for the shortcut. *//* always <= dst, == dst when no prefix *//* If endOnInput==endOnInputSize, this value is `dstCapacity` *//*! LZ4_decompress_generic() :
 *  This generic decompression function covers all use cases.
 *  It shall be instantiated several times, using different sets of directives.
 *  Note that it is important for performance that this function really get inlined,
 *  in order to remove useless branches during compilation optimization.
 *//* accumulator overflow detection (32-bit mode only) *//* read limit reached *//* Read the variable-length literal or match length.
 *
 * @ip : input pointer
 * @ilimit : position after which if length is not decoded, the input is necessarily corrupted.
 * @initial_check - check ip >= ipmax before start of loop.  Returns initial_error if so.
 * @error (output) - error code.  Must be set to 0 before call.
**//* main loop *//* match *//* incorrect end of block :
                 * last match must stop at least LASTLITERALS==5 bytes before end of output block *//* match copy - slow variant, supporting overlap copy *//* match split between extDict & prefix *//* match entirely within extDict *//* extDict scenario *//* check special case : extDict *//* out of range *//* output buffer overflow *//* long literal length *//* incorrect end of block :
                 * last match must start at least MFLIMIT==12 bytes before end of output block *//* end of block *//* support in-place decompression *//* literals *//* start new sequence *//* note: =0 if dictStart==NULL *//* core decoder variant for LZ4_decompress_fast*()
 * for legacy support only : these entry points are deprecated.
 * - Presumes input is correctly formed (no defense vs malformed inputs)
 * - Does not know input size (presume input buffer is "large enough")
 * - Decompress a full block (only)
 * @return : nb of bytes read from input.
 * Note : this variant is not optimized for speed, just for maintenance.
 *        the goal is to remove support of decompress_fast*() variants by v2.0
**//* variant for decompress_unsafe()
 * does not know end of input
 * presumes input is well formed
 * note : will consume at least one byte *//*-*******************************
 *  Decompression functions
 ********************************//* useless to define a dictionary > 64 KB *//*! LZ4_saveDict() :
 *  If previously compressed data block is not guaranteed to remain available at its memory location,
 *  save it into a safer place (char* safeBuffer).
 *  Note : no need to call LZ4_loadDict() afterwards, dictionary is immediately usable,
 *         one can therefore call LZ4_compress_fast_continue() right after.
 * @return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.
 *//* Hidden debug function, to force-test external dictionary mode *//* small data <= 4 KB *//* For compressing large blobs, it is faster to pay the setup
                 * cost to copy the dictionary's tables into the active context,
                 * so that the compression loop is only looking into one table.
                 *//* We depend here on the fact that dictCtx'es (produced by
             * LZ4_loadDict) guarantee that their tables contain no references
             * to offsets between dictCtx->currentOffset - 64 KB and
             * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe
             * to use noDictIssue even when the dict isn't a full 64 KB.
             *//* external dictionary mode *//* prefix mode : source data follows dictionary *//* remove dictionary existence from history, to employ faster prefix mode *//* usingDictCtx *//* tolerance : don't lose history, in case next invocation would use prefix mode *//* prefix mode *//* tiny dictionary : not enough for a hash *//* invalidate tiny dictionaries *//* fix index overflow *//* rescale hash table *//* potential ptrdiff_t overflow (32-bits mode) *//* Don't actually attach an empty dictionary.
         *//* If the current offset is zero, we will never look in the
         * external dictionary context, since there is no value a table
         * entry can take that indicate a miss. In that case, we need
         * to bump the offset to something non-zero.
         *//* We always increment the offset by 64 KB, since, if the dict is longer,
     * we truncate it to the last 64k, and if it's shorter, we still want to
     * advance by a whole window length so we can provide the guarantee that
     * there are only valid offsets in the window, which allows an optimization
     * in LZ4_compress_fast_continue() where it uses noDictIssue even when the
     * dictionary isn't a full 64k. *//* It's necessary to reset the context,
     * and not just continue it with prepareTable()
     * to avoid any risk of generating overflowing matchIndex
     * when compressing using this dictionary *//* resetStream is now deprecated,
 * prefer initStream() which is more general *//* effectively disabled *//*-******************************
*  Streaming functions
********************************//* malloc-calloc always properly aligned *//* compression success is guaranteed *//* Note!: This function leaves the stream in an unclean/broken state!
 * It is not safe to subsequently use the same state with a _fastReset() or
 * _continue() call without resetting it. *//**
 * LZ4_compress_fast_extState_fastReset() :
 * A variant of LZ4_compress_fast_extState().
 *
 * Using this variant avoids an expensive initialization step. It is only safe
 * to call if the state buffer is known to be correctly initialized already
 * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of
 * "correctly initialized").
 *//* only written into if outputDirective == fillOutput *//* no output, can't write anything *//* src == NULL supported if srcSize == 0 *//* Unsupported srcSize, too large (or negative) *//* only written when outputDirective == fillOutput *//** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time;
 *  takes care of src == (NULL, 0)
 *  and forward the rest to LZ4_compress_generic_validated *//* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine *//*additional length tokens*//*token*//* adapt lastRun to fill 'dst' *//* Check output buffer overflow *//* single memory segment *//* required for match length counter *//* there was no match, try the dictionary *//* byU32, byU16 *//* Ensure we have enough space for the last literals. *//* We have already filled up to filledIp so if ip ends up less than filledIp
                         * we have positions in the hash table beyond the current position. This is
                         * a problem if we reuse the hash table. So we have to remove these positions
                         * from the hash table.
                         *//* to avoid needing a zero byte *//* in token *//* Match description too long : reduce it *//* match within extDict *//* static test *//* the match was too close to the end, rewind and go to last literals *//* min last literals so last match is <= end - MFLIMIT *//* token *//* offset *//* at this stage, the following variables must be correctly set :
         * - ip : at start of LZ operation
         * - match : at start of previous pattern occurrence; can be within current prefix, or within extDict
         * - offset : if maybe_ext_memSegment==1 (constant)
         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
         *//* litlen *//* Encode Literals *//* Catch up *//* match found *//* match now expected within distance *//* too far *//* match outside of valid area *//* single continuous memory segment *//* make dictCtx index comparable with current context *//* Instead, they use the block we just compressed. *//* Subsequent linked blocks can't use the dictionary. *//* Update context state *//* Impossible to store anything *//* If init conditions are not met, we don't have to mark stream
     * as having dirty context, since no action was taken yet *//* only supported use case with byPtr *//* Size too large (not within 64K limit) *//* the dictCtx currentOffset is indexed on the start of the dictionary,
     * while a dictionary in the current context precedes the currentOffset *//* used when dictDirective == dictSmall *//* make indexes in dictCtx comparable with indexes in current context *//** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time.
 *  The following conditions are presumed already validated:
 *  - source != NULL
 *  - inputSize > 0
 *//* Finally, clear history *//* Adding a gap, so all previous entries are > LZ4_DISTANCE_MAX back,
     * is faster than compressing without a gap.
     * However, compressing with currentOffset == 0 is faster still,
     * so we preserve that case.
     *//* If the table hasn't been used, it's guaranteed to be zeroed out, and is
     * therefore safe to use no matter what mode we're in. Otherwise, we figure
     * out if it's safe to leave as is or whether it needs to be reset.
     *//* forbidden case *//* LZ4_getIndexOnHash() :
 * Index of match position registered in hash table.
 * hash position must be calculated by using base+index, or dictBase+index.
 * Assumption 1 : only valid if tableType == byU32 or byU16.
 * Assumption 2 : h is presumed valid (within limits of hash table)
 *//* LZ4_putPosition*() : only used in byPtr mode *//* illegal! *//* fallthrough *//*-******************************
*  Compression functions
********************************//*-****************************************
*  Internal Definitions, used only in Tests
*******************************************//**
 * This enum distinguishes several different modes of accessing previous
 * content in the stream.
 *
 * - noDict        : There is no preceding content.
 * - withPrefix64k : Table entries up to ctx->dictSize before the current blob
 *                   blob being compressed are valid and refer to the preceding
 *                   content (of length ctx->dictSize), which is available
 *                   contiguously preceding in memory the content currently
 *                   being compressed.
 * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
 *                   else in memory, starting at ctx->dictionary with length
 *                   ctx->dictSize.
 * - usingDictCtx  : Everything concerning the preceding content is
 *                   in a separate context, pointed to by ctx->dictCtx.
 *                   ctx->dictionary, ctx->dictSize, and table entries
 *                   in the current context that refer to positions
 *                   preceding the beginning of the current compression are
 *                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx
 *                   ->dictSize describe the location and size of the preceding
 *                   content, and matches are found by looking in the ctx
 *                   ->dictCtx->hashTable.
 *//*-************************************
*  Local Constants
**************************************//* 32 on 64 bits (goal), 16 on 32 bits.
            Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
            Note that this code path is never triggered in 32-bits mode. *//* this method doesn't consume memory space like the previous one,
             * but it contains several branches,
             * that may end up slowing execution *//* this method is probably faster,
             * but adds a 128 bytes lookup table *//* x64 CPUS without BMI support interpret `TZCNT` as `REP BSF` *//* Avoid undefined clang-cl intrinsics issue.
             * See https://github.com/lz4/lz4/pull/1017 for details. *//*-*************************************************************************************************
* ARM64EC is a Microsoft-designed ARM64 ABI compatible with AMD64 applications on ARM64 Windows 11.
* The ARM64EC ABI does not support AVX/AVX2/AVX512 instructions, nor their relevant intrinsics
* including _tzcnt_u64. Therefore, we need to neuter the _tzcnt_u64 code path for ARM64EC.
****************************************************************************************************//* MSVC 2022 ver 17.3 or earlier *//* warning C6385: Reading invalid data from 'v'. *//* LZ4_memcpy_using_offset()  presumes :
 * - dstEnd >= dstPtr + MINMATCH
 * - there is at least 8 bytes available to write after dstEnd *//* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
 * this version copies two times 16 bytes (instead of one time 32 bytes)
 * because it must be compatible with offsets >= 16. *//* silence an msan warning when offset==0 *//* On non-Apple aarch64, we disable this optimization for clang because
      * on certain mobile chipsets, performance is reduced with clang. For
      * more information refer to https://github.com/lz4/lz4/pull/707 *//* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd *//* LZ4_FORCE_MEMORY_ACCESS *//* safe and portable access using memcpy() *//* lie to the compiler about data alignment; use with caution *//* don't use static : performance detrimental *//**
 * LZ4 relies on memcpy with a constant size being inlined. In freestanding
 * environments, the compiler can't assume the implementation of memcpy() is
 * standard compliant, so it can't apply its specialized memcpy() inlining
 * logic. When possible, use __builtin_memcpy() to tell the compiler to analyze
 * memcpy() as if it were standard compliant, so it can inline it in freestanding
 * environments. This is needed when decompressing the Linux Kernel, for example.
 *//* 32-bits in x32 mode *//* 64-bits in x32 mode *//* generally true, except OpenVMS-64 *//*-************************************
*  Types
**************************************//* use after variable declarations *//*-************************************
*  Error detection
**************************************//* max supported by LZ4 format *//* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer *//* see ../doc/lz4_Block_format.md#parsing-restrictions *//* memory management functions can be customized by user project.
 * Below functions must exist somewhere in the Project
 * and be available at link time *//*! LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION :
 *  Disable relatively high-level LZ4/HC functions that use dynamic memory
 *  allocation functions (malloc(), calloc(), free()).
 *
 *  Note that this is a compile-time switch. And since it disables
 *  public/stable LZ4 v1 API functions, we don't recommend using this
 *  symbol to generate a library for distribution.
 *
 *  The following public functions are removed when this symbol is defined.
 *  - lz4   : LZ4_createStream, LZ4_freeStream,
 *            LZ4_createStreamDecode, LZ4_freeStreamDecode, LZ4_create (deprecated)
 *  - lz4hc : LZ4_createStreamHC, LZ4_freeStreamHC,
 *            LZ4_createHC (deprecated), LZ4_freeHC  (deprecated)
 *  - lz4frame, lz4file : All LZ4F_* functions
 *//* can be externally provided *//* Should the alignment test prove unreliable, for some reason,
 * it can be disabled by setting LZ4_ALIGN_TEST to 0 *//* LZ4_FORCE_O2 and LZ4_FORCE_INLINE
 * gcc on ppc64le generates an unrolled SIMDized loop for LZ4_wildCopy8,
 * together with a simple 8-byte copy loop as a fall-back path.
 * However, this optimization hurts the decompression speed by >30%,
 * because the execution does not go to the optimized loop
 * for typical compressible data, and all of the preamble checks
 * before going to the fall-back path become useless overhead.
 * This optimization happens only with the -O3 flag, and -O2 generates
 * a simple 8-byte copy loop.
 * With gcc on ppc64le, all of the LZ4_decompress_* and LZ4_wildCopy8
 * functions are annotated with __attribute__((optimize("O2"))),
 * and also LZ4_wildCopy8 is forcibly inlined, so that the O2 attribute
 * of LZ4_wildCopy8 does not affect the compression speed.
 *//* LZ4_FORCE_INLINE *//* disable: C6237: conditional expression is always 0 *//* only present in VS2005+ *//* Visual Studio 2005+ *//* see also "memory routines" below *//* LZ4_DISTANCE_MAX *//* due to LZ4_decompress_safe_withPrefix64k *//*
 * LZ4_SRC_INCLUDED:
 * Amalgamation flag, whether lz4.c is included
 *//*-************************************
*  Dependency
**************************************//* avoid double def *//* Visual Studio for WinCE doesn't support Hardware bit count *//*
 * LZ4_FORCE_SW_BITCOUNT
 * Define this parameter if your target system or compiler does not support hardware bit count
 *//* LZ4_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets which assembly generation depends on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//*-************************************
*  CPU Feature Detection
**************************************//*
 * LZ4_ACCELERATION_MAX :
 * Any "acceleration" value higher than this threshold
 * get treated as LZ4_ACCELERATION_MAX instead (fix #876)
 *//*
 * LZ4_ACCELERATION_DEFAULT :
 * Select "acceleration" for LZ4_compress_fast() when parameter value <= 0
 *//*
 * LZ4_HEAPMODE :
 * Select how stateless compression functions like `LZ4_compress_default()`
 * allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).
 *//*-************************************
*  Tuning parameters
**************************************//*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-2020, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/tableBasealignment/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4frame.hLZ4F_errorCodesLZ4F_OK_NoErrorLZ4F_ERROR_GENERICLZ4F_ERROR_maxBlockSize_invalidLZ4F_ERROR_blockMode_invalidLZ4F_ERROR_contentChecksumFlag_invalidLZ4F_ERROR_compressionLevel_invalidLZ4F_ERROR_headerVersion_wrongLZ4F_ERROR_blockChecksum_invalidLZ4F_ERROR_reservedFlag_setLZ4F_ERROR_allocation_failedLZ4F_ERROR_srcSize_tooLargeLZ4F_ERROR_dstMaxSize_tooSmallLZ4F_ERROR_frameHeader_incompleteLZ4F_ERROR_frameType_unknownLZ4F_ERROR_frameSize_wrongLZ4F_ERROR_srcPtr_wrongLZ4F_ERROR_decompressionFailedLZ4F_ERROR_headerChecksum_invalidLZ4F_ERROR_contentChecksum_invalidLZ4F_ERROR_frameDecoding_alreadyStartedLZ4F_ERROR_compressionState_uninitializedLZ4F_ERROR_parameter_nullLZ4F_ERROR_maxCode_LZ4F_dummy_error_enum_for_c89_never_usedLZ4F_decompressOptions_tLZ4F_dctx *LZ4F_dctx_s *LZ4F_decompressionContext_tLZ4F_dctxLZ4F_compressOptions_tLZ4F_cctx *LZ4F_cctx_s *LZ4F_compressionContext_tLZ4F_cctxLZ4F_CDictLZ4F_CustomMemLZ4F_FreeFunctionLZ4F_CallocFunctionLZ4F_AllocFunctionLZ4F_preferences_tLZ4F_frameInfo_tLZ4F_frameType_tLZ4F_frameLZ4F_skippableFrameLZ4F_blockChecksum_tLZ4F_noBlockChecksumLZ4F_blockChecksumEnabledLZ4F_contentChecksum_tLZ4F_noContentChecksumLZ4F_contentChecksumEnabledLZ4F_blockMode_tLZ4F_blockLinkedLZ4F_blockIndependentLZ4F_blockSizeID_tLZ4F_defaultLZ4F_max64KBLZ4F_max256KBLZ4F_max1MBLZ4F_max4MBLZ4F_errorCode_treserved0reserved1skipChecksumsopaqueStatecustomFreecustomCalloccustomAllocfavorDecSpeeddictIDconst LZ4F_CustomMemLZ4F_defaultCMemLZ4F_GENERATE_ENUM(ENUM)LZ4F_ ## ENUM,LZ4F_LIST_ERRORS(ITEM)ITEM(OK_NoError) ITEM(ERROR_GENERIC) ITEM(ERROR_maxBlockSize_invalid) ITEM(ERROR_blockMode_invalid) ITEM(ERROR_contentChecksumFlag_invalid) ITEM(ERROR_compressionLevel_invalid) ITEM(ERROR_headerVersion_wrong) ITEM(ERROR_blockChecksum_invalid) ITEM(ERROR_reservedFlag_set) ITEM(ERROR_allocation_failed) ITEM(ERROR_srcSize_tooLarge) ITEM(ERROR_dstMaxSize_tooSmall) ITEM(ERROR_frameHeader_incomplete) ITEM(ERROR_frameType_unknown) ITEM(ERROR_frameSize_wrong) ITEM(ERROR_srcPtr_wrong) ITEM(ERROR_decompressionFailed) ITEM(ERROR_headerChecksum_invalid) ITEM(ERROR_contentChecksum_invalid) ITEM(ERROR_frameDecoding_alreadyStarted) ITEM(ERROR_compressionState_uninitialized) ITEM(ERROR_parameter_null) ITEM(ERROR_maxCode)LZ4FLIB_STATIC_APILZ4F_H_STATIC_09782039843LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTHLZ4F_MAGIC_SKIPPABLE_STARTLZ4F_MAGICNUMBER0x184D2204ULZ4F_CONTENT_CHECKSUM_SIZELZ4F_BLOCK_CHECKSUM_SIZELZ4F_BLOCK_HEADER_SIZELZ4F_HEADER_SIZE_MAXLZ4F_HEADER_SIZE_MINLZ4F_VERSIONLZ4F_INIT_PREFERENCES{ LZ4F_INIT_FRAMEINFO, 0, 0u, 0u, { 0u, 0u, 0u } }LZ4F_INIT_FRAMEINFO{ LZ4F_default, LZ4F_blockLinked, LZ4F_noContentChecksum, LZ4F_frame, 0ULL, 0U, LZ4F_noBlockChecksum }LZ4F_OBSOLETE_ENUM(x)LZ4F_DEPRECATE(x)x __attribute__((deprecated))LZ4FLIB_APILZ4FLIB_VISIBILITYLZ4F_H_09782039843LZ4F_DISABLE_DEPRECATE_WARNINGSdefined(__clang__) || (defined(__GNUC__) && (__GNUC__ >= 6))LZ4F_ENABLE_OBSOLETE_ENUMSdefined(LZ4F_STATIC_LINKING_ONLY) && !defined(LZ4F_H_STATIC_09782039843)LZ4F_PUBLISH_STATIC_FUNCTIONSLZ4F_CDict *LZ4F_CDict_s *LZ4F_createCDict_advancedLZ4F_createDecompressionContext_advancedLZ4F_createCompressionContext_advancedLZ4F_decompress_usingDictconst LZ4F_decompressOptions_tconst LZ4F_decompressOptions_t *LZ4F_compressBegin_usingCDictconst LZ4F_CDictconst LZ4F_CDict *const LZ4F_preferences_tconst LZ4F_preferences_t *LZ4F_compressFrame_usingCDictLZ4F_freeCDictLZ4F_createCDictLZ4F_CDict_sLZ4F_uncompressedUpdateconst LZ4F_compressOptions_tconst LZ4F_compressOptions_t *LZ4F_getBlockSizeLZ4F_getErrorCodeLZ4F_resetDecompressionContextLZ4F_decompressLZ4F_getFrameInfoLZ4F_frameInfo_t *LZ4F_headerSizeLZ4F_freeDecompressionContextLZ4F_createDecompressionContextLZ4F_dctx **LZ4F_dctx_s **LZ4F_dctx_sLZ4F_compressEndLZ4F_flushLZ4F_compressUpdateLZ4F_compressBoundLZ4F_compressBeginLZ4F_freeCompressionContextLZ4F_createCompressionContextLZ4F_cctx **LZ4F_cctx_s **LZ4F_getVersionLZ4F_cctx_sLZ4F_compressFrameLZ4F_compressFrameBoundLZ4F_compressionLevel_maxLZ4F_getErrorNameLZ4F_isErrorLZ4F_GENERATE_ENUMERROR_parameter_nullERROR_compressionState_uninitializedERROR_frameDecoding_alreadyStartedERROR_blockChecksum_invalidmax4MBmax1MBmax256KBmax64KB/* defined(LZ4F_STATIC_LINKING_ONLY) && !defined(LZ4F_H_STATIC_09782039843) *//**< this constant defers to stdlib's functions *//* optional; when not defined, uses customAlloc + memset *//*! Custom memory allocation : v1.9.4+
 *  These prototypes make it possible to pass custom allocation/free functions.
 *  LZ4F_customMem is provided at state creation time, using LZ4F_create*_advanced() listed below.
 *  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones.
 *//*! LZ4F_decompress_usingDict() :
 *  Same as LZ4F_decompress(), using a predefined dictionary.
 *  Dictionary is used "in place", without any preprocessing.
**  It must remain accessible throughout the entire frame decoding. *//*! LZ4F_compressBegin_usingCDict() :
 *  Inits streaming dictionary compression, and writes the frame header into dstBuffer.
 *  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
 * `prefsPtr` is optional : you may provide NULL as argument,
 *  however, it's the only way to provide dictID in the frame header.
 * @return : number of bytes written into dstBuffer for the header,
 *           or an error code (which can be tested using LZ4F_isError()) *//*! LZ4_compressFrame_usingCDict() :
 *  Compress an entire srcBuffer into a valid LZ4 frame using a digested Dictionary.
 *  cctx must point to a context created by LZ4F_createCompressionContext().
 *  If cdict==NULL, compress without a dictionary.
 *  dstBuffer MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
 *  If this condition is not respected, function will fail (@return an errorCode).
 *  The LZ4F_preferences_t structure is optional : you may provide NULL as argument,
 *  but it's not recommended, as it's the only way to provide dictID in the frame header.
 * @return : number of bytes written into dstBuffer.
 *           or an error code if it fails (can be tested using LZ4F_isError()) *//*! LZ4_createCDict() :
 *  When compressing multiple messages / blocks using the same dictionary, it's recommended to load it just once.
 *  LZ4_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.
 *  LZ4_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
 * `dictBuffer` can be released after LZ4_CDict creation, since its content is copied within CDict *//* A Dictionary is useful for the compression of small messages (KB range).
 * It dramatically improves compression efficiency.
 *
 * LZ4 can ingest any input as dictionary, though only the last 64 KB are useful.
 * Best results are generally achieved by using Zstandard's Dictionary Builder
 * to generate a high-quality dictionary from a set of samples.
 *
 * Loading a dictionary has a cost, since it involves construction of tables.
 * The Bulk processing dictionary API makes it possible to share this cost
 * over an arbitrary number of compression jobs, even concurrently,
 * markedly improving compression latency for these cases.
 *
 * The same dictionary will have to be used on the decompression side
 * for decoding to be successful.
 * To help identify the correct dictionary at decoding stage,
 * the frame header allows optional embedding of a dictID field.
 *//**********************************
 *  Bulk processing dictionary API
 *********************************//*! LZ4F_uncompressedUpdate() :
 *  LZ4F_uncompressedUpdate() can be called repetitively to add as much data uncompressed data as necessary.
 *  Important rule: dstCapacity MUST be large enough to store the entire source buffer as
 *  no compression is done for this operation
 *  If this condition is not respected, LZ4F_uncompressedUpdate() will fail (result is an errorCode).
 *  After an error, the state is left in a UB state, and must be re-initialized or freed.
 *  If previously a compressed block was written, buffered data is flushed
 *  before appending uncompressed data is continued.
 *  This is only supported when LZ4F_blockIndependent is used
 * `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.
 * @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *//*! LZ4F_getBlockSize() :
 *  Return, in scalar format (size_t),
 *  the maximum block size associated with blockSizeID.
**//* enum list is exposed, to handle specific errors *//* ---   Error List   --- *//* These declarations are not stable and may change in the future.
 * They are therefore only safe to depend on
 * when the caller is statically linked against the library.
 * To access their declarations, define LZ4F_STATIC_LINKING_ONLY.
 *
 * By default, these symbols aren't published into shared/dynamic libraries.
 * You can override this behavior and force them to be published
 * by defining LZ4F_PUBLISH_STATIC_FUNCTIONS.
 * Use at your own risk.
 *//* LZ4F_H_09782039843 *//* always successful *//*! LZ4F_resetDecompressionContext() : added in v1.8.0
 *  In case of an error, the context is left in "undefined" state.
 *  In which case, it's necessary to reset it, before re-using it.
 *  This method can also be used to abruptly stop any unfinished decompression,
 *  and start a new one using same context resources. *//*! LZ4F_decompress() :
 *  Call this function repetitively to regenerate data compressed in `srcBuffer`.
 *
 *  The function requires a valid dctx state.
 *  It will read up to *srcSizePtr bytes from srcBuffer,
 *  and decompress data into dstBuffer, of capacity *dstSizePtr.
 *
 *  The nb of bytes consumed from srcBuffer will be written into *srcSizePtr (necessarily <= original value).
 *  The nb of bytes decompressed into dstBuffer will be written into *dstSizePtr (necessarily <= original value).
 *
 *  The function does not necessarily read all input bytes, so always check value in *srcSizePtr.
 *  Unconsumed source data must be presented again in subsequent invocations.
 *
 * `dstBuffer` can freely change between each consecutive function invocation.
 * `dstBuffer` content will be overwritten.
 *
 * @return : an hint of how many `srcSize` bytes LZ4F_decompress() expects for next call.
 *  Schematically, it's the size of the current (or remaining) compressed block + header of next block.
 *  Respecting the hint provides some small speed benefit, because it skips intermediate buffers.
 *  This is just a hint though, it's always possible to provide any srcSize.
 *
 *  When a frame is fully decoded, @return will be 0 (no more data expected).
 *  When provided with more bytes than necessary to decode a frame,
 *  LZ4F_decompress() will stop reading exactly at end of current frame, and @return 0.
 *
 *  If decompression failed, @return is an error code, which can be tested using LZ4F_isError().
 *  After a decompression error, the `dctx` context is not resumable.
 *  Use LZ4F_resetDecompressionContext() to return to clean state.
 *
 *  After a frame is fully decoded, dctx can be used again to decompress another frame.
 *//*! LZ4F_getFrameInfo() :
 *  This function extracts frame parameters (max blockSize, dictID, etc.).
 *  Its usage is optional: user can also invoke LZ4F_decompress() directly.
 *
 *  Extracted information will fill an existing LZ4F_frameInfo_t structure.
 *  This can be useful for allocation and dictionary identification purposes.
 *
 *  LZ4F_getFrameInfo() can work in the following situations :
 *
 *  1) At the beginning of a new frame, before any invocation of LZ4F_decompress().
 *     It will decode header from `srcBuffer`,
 *     consuming the header and starting the decoding process.
 *
 *     Input size must be large enough to contain the full frame header.
 *     Frame header size can be known beforehand by LZ4F_headerSize().
 *     Frame header size is variable, but is guaranteed to be >= LZ4F_HEADER_SIZE_MIN bytes,
 *     and not more than <= LZ4F_HEADER_SIZE_MAX bytes.
 *     Hence, blindly providing LZ4F_HEADER_SIZE_MAX bytes or more will always work.
 *     It's allowed to provide more input data than the header size,
 *     LZ4F_getFrameInfo() will only consume the header.
 *
 *     If input size is not large enough,
 *     aka if it's smaller than header size,
 *     function will fail and return an error code.
 *
 *  2) After decoding has been started,
 *     it's possible to invoke LZ4F_getFrameInfo() anytime
 *     to extract already decoded frame parameters stored within dctx.
 *
 *     Note that, if decoding has barely started,
 *     and not yet read enough information to decode the header,
 *     LZ4F_getFrameInfo() will fail.
 *
 *  The number of bytes consumed from srcBuffer will be updated in *srcSizePtr (necessarily <= original value).
 *  LZ4F_getFrameInfo() only consumes bytes when decoding has not yet started,
 *  and when decoding the header has been successful.
 *  Decompression must then resume from (srcBuffer + *srcSizePtr).
 *
 * @return : a hint about how many srcSize bytes LZ4F_decompress() expects for next call,
 *           or an error code which can be tested using LZ4F_isError().
 *  note 1 : in case of error, dctx is not modified. Decoding operation can resume from beginning safely.
 *  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure.
 *//*! LZ4F_headerSize() : v1.9.0+
 *  Provide the header size of a frame starting at `src`.
 * `srcSize` must be >= LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH,
 *  which is enough to decode the header length.
 * @return : size of frame header
 *           or an error code, which can be tested using LZ4F_isError()
 *  note : Frame header size is variable, but is guaranteed to be
 *         >= LZ4F_HEADER_SIZE_MIN bytes, and <= LZ4F_HEADER_SIZE_MAX bytes.
 *//*-***********************************
*  Streaming decompression functions
*************************************//*! LZ4F_createDecompressionContext() :
 *  Create an LZ4F_dctx object, to track all decompression operations.
 *  @version provided MUST be LZ4F_VERSION.
 *  @dctxPtr MUST be valid.
 *  The function fills @dctxPtr with the value of a pointer to an allocated and initialized LZ4F_dctx object.
 *  The @return is an errorCode, which can be tested using LZ4F_isError().
 *  dctx memory can be released using LZ4F_freeDecompressionContext();
 *  Result of LZ4F_freeDecompressionContext() indicates current state of decompressionContext when being released.
 *  That is, it should be == 0 if decompression has been completed fully and correctly.
 *//* idem *//* must be set to zero for forward compatibility *//* disable checksum calculation and verification, even when one is present in frame, to save CPU time.
                           * Setting this option to 1 once disables all checksums for the rest of the frame. *//* pledges that last 64KB decompressed data will remain available unmodified between invocations.
                           * This optimization skips storage operations in tmp buffers. *//* compatibility with previous API versions *//*! LZ4F_compressEnd() :
 *  To properly finish an LZ4 frame, invoke LZ4F_compressEnd().
 *  It will flush whatever data remained within `cctx` (like LZ4_flush())
 *  and properly finalize the frame, with an endMark and a checksum.
 * `cOptPtr` is optional : NULL can be provided, in which case all options will be set to default.
 * @return : nb of bytes written into dstBuffer, necessarily >= 4 (endMark),
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *  Note : LZ4F_compressEnd() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).
 *  A successful call to LZ4F_compressEnd() makes `cctx` available again for another compression task.
 *//*! LZ4F_flush() :
 *  When data must be generated and sent immediately, without waiting for a block to be completely filled,
 *  it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx.
 * `dstCapacity` must be large enough to ensure the operation will be successful.
 * `cOptPtr` is optional : it's possible to provide NULL, all options will be set to default.
 * @return : nb of bytes written into dstBuffer (can be zero, when there is no data stored within cctx)
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *  Note : LZ4F_flush() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).
 *//*! LZ4F_compressUpdate() :
 *  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
 *  Important rule: dstCapacity MUST be large enough to ensure operation success even in worst case situations.
 *  This value is provided by LZ4F_compressBound().
 *  If this condition is not respected, LZ4F_compress() will fail (result is an errorCode).
 *  After an error, the state is left in a UB state, and must be re-initialized or freed.
 *  If previously an uncompressed block was written, buffered data is flushed
 *  before appending compressed data is continued.
 * `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.
 * @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *//*! LZ4F_compressBound() :
 *  Provides minimum dstCapacity required to guarantee success of
 *  LZ4F_compressUpdate(), given a srcSize and preferences, for a worst case scenario.
 *  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() instead.
 *  Note that the result is only valid for a single invocation of LZ4F_compressUpdate().
 *  When invoking LZ4F_compressUpdate() multiple times,
 *  if the output buffer is gradually filled up instead of emptied and re-used from its start,
 *  one must check if there is enough remaining capacity before each invocation, using LZ4F_compressBound().
 * @return is always the same for a srcSize and prefsPtr.
 *  prefsPtr is optional : when NULL is provided, preferences will be set to cover worst case scenario.
 *  tech details :
 * @return if automatic flushing is not enabled, includes the possibility that internal buffer might already be filled by up to (blockSize-1) bytes.
 *  It also includes frame footer (ending + checksum), since it might be generated by LZ4F_compressEnd().
 * @return doesn't include frame header, as it was already generated by LZ4F_compressBegin().
 *//*! LZ4F_compressBegin() :
 *  will write the frame header into dstBuffer.
 *  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
 * `prefsPtr` is optional : NULL can be provided to set all preferences to default.
 * @return : number of bytes written into dstBuffer for the header
 *           or an error code (which can be tested using LZ4F_isError())
 *//* Size in bytes of the content checksum. *//* Size in bytes of a block checksum footer in little-endian format. *//* Size in bytes of a block header in little-endian format. Highest bit indicates if block data is uncompressed *//* LZ4 Frame header size can vary, depending on selected parameters *//*----    Compression    ----*//*! LZ4F_createCompressionContext() :
 *  The first thing to do is to create a compressionContext object,
 *  which will keep track of operation state during streaming compression.
 *  This is achieved using LZ4F_createCompressionContext(), which takes as argument a version,
 *  and a pointer to LZ4F_cctx*, to write the resulting pointer into.
 *  @version provided MUST be LZ4F_VERSION. It is intended to track potential version mismatch, notably when using DLL.
 *  The function provides a pointer to a fully allocated LZ4F_cctx object.
 *  @cctxPtr MUST be != NULL.
 *  If @return != zero, context creation failed.
 *  A created compression context can be employed multiple times for consecutive streaming operations.
 *  Once all streaming compression jobs are completed,
 *  the state object can be released using LZ4F_freeCompressionContext().
 *  Note1 : LZ4F_freeCompressionContext() is always successful. Its return value can be ignored.
 *  Note2 : LZ4F_freeCompressionContext() works fine with NULL input pointers (do nothing).
**//* This number can be used to check for an incompatible API breaking change *//*---   Resource Management   ---*//* 1 == src content will remain present on future calls to LZ4F_compress(); skip copying src content within tmp buffer *//* for compatibility with older APIs, prefer using LZ4F_cctx *//*! LZ4F_compressFrame() :
 *  Compress srcBuffer content into an LZ4-compressed frame.
 *  It's a one shot operation, all input content is consumed, and all output is generated.
 *
 *  Note : it's a stateless operation (no LZ4F_cctx state needed).
 *  In order to reduce load on the allocator, LZ4F_compressFrame(), by default,
 *  uses the stack to allocate space for the compression state and some table.
 *  If this usage of the stack is too much for your application,
 *  consider compiling `lz4frame.c` with compile-time macro LZ4F_HEAPMODE set to 1 instead.
 *  All state allocations will use the Heap.
 *  It also means each invocation of LZ4F_compressFrame() will trigger several internal alloc/free invocations.
 *
 * @dstCapacity MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
 * @preferencesPtr is optional : one can provide NULL, in which case all preferences are set to default.
 * @return : number of bytes written into dstBuffer.
 *           or an error code if it fails (can be tested using LZ4F_isError())
 *//*! LZ4F_compressFrameBound() :
 *  Returns the maximum possible compressed size with LZ4F_compressFrame() given srcSize and preferences.
 * `preferencesPtr` is optional. It can be replaced by NULL, in which case, the function will assume default preferences.
 *  Note : this result is only usable with LZ4F_compressFrame().
 *         It may also be relevant to LZ4F_compressUpdate() _only if_ no flush() operation is ever performed.
 *//* v1.8.0+ *//* v1.8.3+ *//* v1.8.2+ *//* 1: parser favors decompression speed vs compression ratio. Only works for high compression modes (>= LZ4HC_CLEVEL_OPT_MIN) *//* 1: always flush; reduces usage of internal buffers *//* 0: default (fast mode); values > LZ4HC_CLEVEL_MAX count as LZ4HC_CLEVEL_MAX; values < 0 trigger "fast acceleration" *//*! LZ4F_preferences_t :
 *  makes it possible to supply advanced compression instructions to streaming interface.
 *  Structure must be first init to 0, using memset() or LZ4F_INIT_PREFERENCES,
 *  setting all parameters to default.
 *  All reserved fields must be set to zero. *//* 1: each block followed by a checksum of block's compressed data; 0: disabled (default) *//* Dictionary ID, sent by compressor to help decoder select correct dictionary; 0 == no dictID provided *//* Size of uncompressed content ; 0 == unknown *//* read-only field : LZ4F_frame or LZ4F_skippableFrame *//* 1: frame terminated with 32-bit checksum of decompressed data; 0: disabled (default) *//* LZ4F_blockLinked, LZ4F_blockIndependent; 0 == default *//* max64KB, max256KB, max1MB, max4MB; 0 == default *//*! LZ4F_frameInfo_t :
 *  makes it possible to set or read frame parameters.
 *  Structure must be first init to 0, using memset() or LZ4F_INIT_FRAMEINFO,
 *  setting all parameters to default.
 *  It's then possible to update selectively some parameters *//* Linked blocks sharply reduce inefficiencies when using small blocks,
 * they compress better.
 * However, some LZ4 decoders are only compatible with independent blocks *//* The larger the block size, the (slightly) better the compression ratio,
 * though there are diminishing returns.
 * Larger blocks also increase memory usage on both compression and decompression sides.
 *//* #define LZ4F_ENABLE_OBSOLETE_ENUMS   // uncomment to enable obsolete enums *//*-************************************
 *  Frame compression types
 ************************************* *//**< return error code string; for debugging *//**< tells when a function result is an error code *//*-************************************
 *  Error management
 **************************************//* no deprecation warning for this compiler *//* __declspec(deprecated) x - only works with C++ *//*  LZ4_DLL_EXPORT :
 *  Enable exporting of functions when building a Windows DLL
 *  LZ4FLIB_VISIBILITY :
 *  Control library symbols visibility.
 *//*-***************************************************************
 *  Compiler specifics
 *****************************************************************//**
 * Introduction
 *
 * lz4frame.h implements LZ4 frame specification: see doc/lz4_Frame_format.md .
 * LZ4 Frames are compatible with `lz4` CLI,
 * and designed to be interoperable with any system.
**//* ---   Dependency   --- *//* LZ4F is a stand-alone API able to create and decode LZ4 frames
 * conformant with specification v1.6.1 in doc/lz4_Frame_format.md .
 * Generated frames are compatible with `lz4` CLI.
 *
 * LZ4F also offers streaming capabilities.
 *
 * lz4.h is not required when using lz4frame.h,
 * except to extract common constants such as LZ4_VERSION_NUMBER.
 * *//*
   LZ4F - LZ4-Frame library
   Header File
   Copyright (C) 2011-2020, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 source repository : https://github.com/lz4/lz4
   - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
*/customMemdictBuffercdictCDict__WCHAR_MIN____WCHAR_MAX___BITS_WCHAR_HL'\0' - 1 > 0(-__WCHAR_MAX__ - 1)/* bits/wchar.h *//* The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
   are not defined, give the right value and type as long as both int
   and wchar_t are 32-bit types.  Adding L'\0' to a constant value
   ensures that the type is correct; it is necessary to use (L'\0' +
   0) rather than just L'\0' so that the type in C++ is the promoted
   version of wchar_t rather than the distinct wchar_t type itself.
   Because wchar_t in preprocessor #if expressions is treated as
   intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
   wrong value for WCHAR_MAX in such expressions and so cannot be used
   to define __WCHAR_MAX in the unsigned case.  *//* wchar_t type related definitions.
   Copyright (C) 2000-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */_BITS_STDINT_UINTN_H/* bits/stdint-uintn.h *//* Define uintN_t types.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */_GCC_WRAP_STDINT_H__STDC_HOSTED__defined __cplusplus && __cplusplus >= 201103L__attribute__((deprecated(message)))This function is deprecated and unsafe. Consider using LZ4_decompress_safe_usingDict() insteadchar[95]This function is deprecated and unsafe. Consider using LZ4_decompress_safe_continue() insteadchar[94]This function is deprecated and unsafe. Consider using LZ4_decompress_safe() insteadchar[85]use LZ4_decompress_fast_usingDict() insteaduse LZ4_decompress_safe_usingDict() insteadUse LZ4_saveDict() insteadUse LZ4_resetStream() insteadUse LZ4_createStream() insteaduse LZ4_decompress_safe() insteaduse LZ4_decompress_fast() insteaduse LZ4_compress_fast_continue() insteaduse LZ4_compress_fast_extState() insteaduse LZ4_compress_default() instead/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4hc.hLZ4_attach_HC_dictionaryLZ4_streamHC_t *LZ4_streamHC_u *const LZ4_streamHC_tconst LZ4_streamHC_t *LZ4_compress_HC_extStateHC_fastResetLZ4_favorDecompressionSpeedLZ4_setCompressionLevelLZ4_resetStreamHCLZ4_resetStreamStateHCLZ4_sizeofStreamStateHCLZ4_compressHC2_limitedOutput_continueLZ4_compressHC2_continueLZ4_slideInputBufferHCLZ4_freeHCLZ4_createHCLZ4_compressHC_limitedOutput_continueLZ4_compressHC_continueLZ4_compressHC2_limitedOutput_withStateHCLZ4_compressHC2_withStateHCLZ4_compressHC_limitedOutput_withStateHCLZ4_compressHC_withStateHCLZ4_compressHC2_limitedOutputLZ4_compressHC2LZ4_compressHC_limitedOutputLZ4_compressHCLZ4_initStreamHCLZ4_saveDictHCLZ4_compress_HC_continue_destSizeLZ4_compress_HC_continueLZ4_loadDictHCLZ4_resetStreamHC_fastLZ4_freeStreamHCLZ4_createStreamHCLZ4_compress_HC_destSizeLZ4_compress_HC_extStateHCLZ4_sizeofStateHCLZ4_compress_HCLZ4_streamHC_tLZ4_streamHC_uLZ4HC_CCtx_internalconst LZ4HC_CCtx_internalconst LZ4HC_CCtx_internal *LZ4HC_CCtx_internal *dirtyLZ4_u16[65536]unsigned short[65536]LZ4HC_MAXDLZ4_u32[32768]unsigned int[32768]LZ4HC_HASHTABLESIZEchar[262200]262200LZ4_STREAMHC_MINSIZELZ4_HC_SLO_098092834LZ4HC_HASH_MASK(LZ4HC_HASHTABLESIZE - 1)(1 << LZ4HC_HASH_LOG)LZ4HC_HASH_LOGLZ4HC_MAXD_MASK(LZ4HC_MAXD - 1)(1<<LZ4HC_DICTIONARY_LOGSIZE)LZ4HC_DICTIONARY_LOGSIZELZ4HC_CLEVEL_MAXLZ4HC_CLEVEL_OPT_MINLZ4HC_CLEVEL_DEFAULTLZ4HC_CLEVEL_MINLZ4_HC_H_19834876238432LZ4_HC_STATIC_LINKING_ONLY"use LZ4_initStreamHC() instead"use LZ4_initStreamHC() instead"use LZ4_createStreamHC() instead"use LZ4_createStreamHC() instead"use LZ4_compress_HC_continue() instead"use LZ4_compress_HC_continue() instead"use LZ4_saveDictHC() instead"use LZ4_saveDictHC() instead"use LZ4_freeStreamHC() instead"use LZ4_freeStreamHC() instead"use LZ4_compress_HC_extStateHC() instead"use LZ4_compress_HC_extStateHC() instead"use LZ4_compress_HC() instead"use LZ4_compress_HC() instead/* LZ4_HC_STATIC_LINKING_ONLY *//* LZ4_HC_SLO_098092834 *//*! LZ4_attach_HC_dictionary() :
 *  This is an experimental API that allows for the efficient use of a
 *  static dictionary many times.
 *
 *  Rather than re-loading the dictionary buffer into a working context before
 *  each compression, or copying a pre-loaded dictionary's LZ4_streamHC_t into a
 *  working LZ4_streamHC_t, this function introduces a no-copy setup mechanism,
 *  in which the working stream references the dictionary stream in-place.
 *
 *  Several assumptions are made about the state of the dictionary stream.
 *  Currently, only streams which have been prepared by LZ4_loadDictHC() should
 *  be expected to work.
 *
 *  Alternatively, the provided dictionary stream pointer may be NULL, in which
 *  case any existing dictionary stream is unset.
 *
 *  A dictionary should only be attached to a stream without any history (i.e.,
 *  a stream that has just been reset).
 *
 *  The dictionary will remain attached to the working stream only for the
 *  current stream session. Calls to LZ4_resetStreamHC(_fast) will remove the
 *  dictionary context association from the working stream. The dictionary
 *  stream (and source buffer) must remain in-place / accessible / unchanged
 *  through the lifetime of the stream session.
 *//*! LZ4_compress_HC_extStateHC_fastReset() :
 *  A variant of LZ4_compress_HC_extStateHC().
 *
 *  Using this variant avoids an expensive initialization step. It is only safe
 *  to call if the state buffer is known to be correctly initialized already
 *  (see above comment on LZ4_resetStreamHC_fast() for a definition of
 *  "correctly initialized"). From a high level, the difference is that this
 *  function initializes the provided state with a call to
 *  LZ4_resetStreamHC_fast() while LZ4_compress_HC_extStateHC() starts with a
 *  call to LZ4_resetStreamHC().
 *//*! LZ4_resetStreamHC_fast() : v1.9.0+
 *  When an LZ4_streamHC_t is known to be in a internally coherent state,
 *  it can often be prepared for a new compression with almost no work, only
 *  sometimes falling back to the full, expensive reset that is always required
 *  when the stream is in an indeterminate state (i.e., the reset performed by
 *  LZ4_resetStreamHC()).
 *
 *  LZ4_streamHCs are guaranteed to be in a valid state when:
 *  - returned from LZ4_createStreamHC()
 *  - reset by LZ4_resetStreamHC()
 *  - memset(stream, 0, sizeof(LZ4_streamHC_t))
 *  - the stream was in a valid state and was reset by LZ4_resetStreamHC_fast()
 *  - the stream was in a valid state and was then used in any compression call
 *    that returned success
 *  - the stream was in an indeterminate state and was used in a compression
 *    call that fully reset the state (LZ4_compress_HC_extStateHC()) and that
 *    returned success
 *
 *  Note:
 *  A stream that was last used in a compression call that returned an error
 *  may be passed to this function. However, it will be fully reset, which will
 *  clear any existing history and settings from the context.
 *//*! LZ4_favorDecompressionSpeed() : v1.8.2+ (experimental)
 *  Opt. Parser will favor decompression speed over compression ratio.
 *  Only applicable to levels >= LZ4HC_CLEVEL_OPT_MIN.
 *//*! LZ4_setCompressionLevel() : v1.8.0+ (experimental)
 *  It's possible to change compression level
 *  between successive invocations of LZ4_compress_HC_continue*()
 *  for dynamic adaptation.
 *//* LZ4LIB_STATIC_API *//* protection macro *//*-**************************************************
 * !!!!!     STATIC LINKING ONLY     !!!!!
 * Following definitions are considered experimental.
 * They should not be linked from DLL,
 * as there is no guarantee of API stability yet.
 * Prototypes will be promoted to "stable" status
 * after successful usage in real-life scenarios.
 ***************************************************//* LZ4_HC_H_19834876238432 *//* LZ4_resetStreamHC() is now replaced by LZ4_initStreamHC().
 * The intention is to emphasize the difference with LZ4_resetStreamHC_fast(),
 * which is now the recommended function to start a new stream of blocks,
 * but cannot be used to initialize a memory segment containing arbitrary garbage data.
 *
 * It is recommended to switch to LZ4_initStreamHC().
 * LZ4_resetStreamHC() will generate deprecation warnings in a future version.
 *//* Obsolete streaming functions; degraded functionality; do not use!
 *
 * In order to perform streaming compression, these functions depended on data
 * that is no longer tracked in the state. They have been preserved as well as
 * possible: using them will still produce a correct output. However, use of
 * LZ4_slideInputBufferHC() will truncate the history of the stream, rather
 * than preserve a window-sized chunk of history.
 *//* deprecated compression functions *//* see lz4.h LZ4_DISABLE_DEPRECATE_WARNINGS to turn off deprecation warnings *//*-************************************
*  Deprecated Functions
**************************************//* LZ4_initStreamHC() : v1.9.0+
 * Required before first use of a statically allocated LZ4_streamHC_t.
 * Before v1.9.0 : use LZ4_resetStreamHC() instead
 *//* LZ4_streamHC_t :
 * This structure allows static allocation of LZ4 HC streaming state.
 * This can be used to allocate statically on stack, or as part of a larger structure.
 *
 * Such state **must** be initialized using LZ4_initStreamHC() before first use.
 *
 * Note that invoking LZ4_initStreamHC() is not required when
 * the state was created using LZ4_createStreamHC() (which is recommended).
 * Using the normal builder, a newly created state is automatically initialized.
 *
 * Static allocation shall only be used in combination with static linking.
 *//* previously typedef'd to LZ4_streamHC_t *//* stream has to be fully reset if this flag is set *//* favor decompression speed if this flag set,
                                  otherwise, favor compression ratio *//* alternate reference for extDict *//* Indexes relative to this position *//* Never ever use these definitions directly !
 * Declare or allocate an LZ4_streamHC_t instead.
**//*-******************************************************************
 * PRIVATE DEFINITIONS :
 * Do not use these definitions directly.
 * They are merely exposed to allow static allocation of `LZ4_streamHC_t`.
 * Declare an `LZ4_streamHC_t` directly, rather than any type below.
 * Even then, only do so in the context of static linking, as definitions may change between versions.
 ********************************************************************//*^**********************************************
 * !!!!!!   STATIC LINKING ONLY   !!!!!!
 ***********************************************//*! LZ4_compress_HC_continue_destSize() : v1.9.0+
 *  Similar to LZ4_compress_HC_continue(),
 *  but will read as much data as possible from `src`
 *  to fit into `targetDstSize` budget.
 *  Result is provided into 2 parts :
 * @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)
 *           or 0 if compression fails.
 * `srcSizePtr` : on success, *srcSizePtr will be updated to indicate how much bytes were read from `src`.
 *           Note that this function may not consume the entire input.
 *//* v1.9.0+ *//*
  These functions compress data in successive blocks of any size,
  using previous blocks as dictionary, to improve compression ratio.
  One key assumption is that previous blocks (up to 64 KB) remain read-accessible while compressing next blocks.
  There is an exception for ring buffers, which can be smaller than 64 KB.
  Ring-buffer scenario is automatically detected and handled within LZ4_compress_HC_continue().

  Before starting compression, state must be allocated and properly initialized.
  LZ4_createStreamHC() does both, though compression level is set to LZ4HC_CLEVEL_DEFAULT.

  Selecting the compression level can be done with LZ4_resetStreamHC_fast() (starts a new stream)
  or LZ4_setCompressionLevel() (anytime, between blocks in the same stream) (experimental).
  LZ4_resetStreamHC_fast() only works on states which have been properly initialized at least once,
  which is automatically the case when state is created using LZ4_createStreamHC().

  After reset, a first "fictional block" can be designated as initial dictionary,
  using LZ4_loadDictHC() (Optional).

  Invoke LZ4_compress_HC_continue() to compress each successive block.
  The number of blocks is unlimited.
  Previous input blocks, including initial dictionary when present,
  must remain accessible and unmodified during compression.

  It's allowed to update compression level anytime between blocks,
  using LZ4_setCompressionLevel() (experimental).

  'dst' buffer should be sized to handle worst case scenarios
  (see LZ4_compressBound(), it ensures compression success).
  In case of failure, the API does not guarantee recovery,
  so the state _must_ be reset.
  To ensure compression success
  whenever `dst` buffer size cannot be made >= LZ4_compressBound(),
  consider using LZ4_compress_HC_continue_destSize().

  Whenever previous input blocks can't be preserved unmodified in-place during compression of next blocks,
  it's possible to copy the last blocks into a more stable memory space, using LZ4_saveDictHC().
  Return value of LZ4_saveDictHC() is the size of dictionary effectively saved into 'safeBuffer' (<= 64 KB)

  After completing a streaming compression,
  it's possible to start a new stream of blocks, using the same LZ4_streamHC_t state,
  just by resetting it, using LZ4_resetStreamHC_fast().
*//*! LZ4_createStreamHC() and LZ4_freeStreamHC() :
 *  These functions create and release memory for LZ4 HC streaming state.
 *  Newly created states are automatically initialized.
 *  A same state can be used multiple times consecutively,
 *  starting with LZ4_resetStreamHC_fast() to start a new stream of blocks.
 *//*-************************************
 *  Streaming Compression
 *  Bufferless synchronous API
 **************************************//*! LZ4_compress_HC_destSize() : v1.9.0+
 *  Will compress as much data as possible from `src`
 *  to fit into `targetDstSize` budget.
 *  Result is provided in 2 parts :
 * @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)
 *           or 0 if compression fails.
 * `srcSizePtr` : on success, *srcSizePtr is updated to indicate how much bytes were read from `src`
 *//*! LZ4_compress_HC_extStateHC() :
 *  Same as LZ4_compress_HC(), but using an externally allocated memory segment for `state`.
 * `state` size is provided by LZ4_sizeofStateHC().
 *  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly).
 *//* Note :
 *   Decompression functions are provided within "lz4.h" (BSD license)
 *//*! LZ4_compress_HC() :
 *  Compress data from `src` into `dst`, using the powerful but slower "HC" algorithm.
 * `dst` must be already allocated.
 *  Compression is guaranteed to succeed if `dstCapacity >= LZ4_compressBound(srcSize)` (see "lz4.h")
 *  Max supported `srcSize` value is LZ4_MAX_INPUT_SIZE (see "lz4.h")
 * `compressionLevel` : any value between 1 and LZ4HC_CLEVEL_MAX will work.
 *                      Values > LZ4HC_CLEVEL_MAX behave the same as LZ4HC_CLEVEL_MAX.
 * @return : the number of bytes written into 'dst'
 *           or 0 if compression fails.
 *//*-************************************
 *  Block Compression
 **************************************//* --- Useful constants --- *//* stddef, LZ4LIB_API, LZ4_DEPRECATED *//* note : lz4hc requires lz4.h/lz4.c for compilation *//*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2020, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 source repository : https://github.com/lz4/lz4
   - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
*/working_streamdictionary_streamLZ4_streamHCPtrfavorstreamHCPtrLZ4HC_DatastateHC/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/xxhash.huint32_t[2]uint64_t[4]defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)!defined (__VMS) \/* never read nor write, might be removed in a future version *//* remove 64-bit support *//* These definitions are only present to allow
 * static allocation of XXH state, on stack or in a struct for example.
 * Never **ever** use members directly. *//* ================================================================================================
   This section contains declarations which are not guaranteed to remain stable.
   They may change in future versions, becoming incompatible with a different version of the library.
   These declarations should only be used with static linking.
   Never use them in association with dynamic linking !
=================================================================================================== *//*! XXH64() :
    Calculate the 64-bit hash of sequence of length "len" stored at memory address "input".
    "seed" can be used to alter the result predictably.
    This function runs faster on 64-bit systems, but slower on 32-bit systems (see benchmark).
*//*-**********************************************************************
*  64-bit hash
************************************************************************//* Default result type for XXH functions are primitive unsigned 32 and 64 bits.
 * The canonical representation uses human-readable write convention, aka big-endian (large digits first).
 * These functions allow transformation of hash result into and from its canonical format.
 * This way, hash values can be written into a file / memory, and remain comparable on different systems and programs.
 *//*
 * Streaming functions generate the xxHash of an input provided in multiple segments.
 * Note that, for small input, they are slower than single-call functions, due to state management.
 * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
 *
 * XXH state must first be allocated, using XXH*_createState() .
 *
 * Start a new hash by initializing state with a seed, using XXH*_reset().
 *
 * Then, feed the hash state by calling XXH*_update() as many times as necessary.
 * The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.
 *
 * Finally, a hash value can be produced anytime, by using XXH*_digest().
 * This function returns the nn-bits hash as an int or long long.
 *
 * It's still possible to continue inserting input into the hash state after a digest,
 * and generate some new hashes later on, by calling again XXH*_digest().
 *
 * When done, free XXH state space if it was allocated dynamically.
 *//*! XXH32() :
    Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
    The memory between input & input+length must be valid (allocated and read-accessible).
    "seed" can be used to alter the result predictably.
    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s *//*-**********************************************************************
*  32-bit hash
************************************************************************//*! XXH_NAMESPACE, aka Namespace Emulation :
 *
 * If you want to include _and expose_ xxHash functions from within your own library,
 * but also want to avoid symbol collisions with other libraries which may also include xxHash,
 *
 * you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
 * with the value of XXH_NAMESPACE (therefore, avoid NULL and numeric values).
 *
 * Note that no change is required within the calling program as long as it includes `xxhash.h` :
 * regular symbol name will be automatically translated by this header.
 *//* XXH_INLINE_ALL || XXH_PRIVATE_API *//* this version may generate warnings for unused static functions *//** XXH_INLINE_ALL (and XXH_PRIVATE_API)
 *  This is useful to include xxhash functions in `static` mode
 *  in order to inline them, and remove their symbol from the public list.
 *  Inlining can offer dramatic performance improvement on small keys.
 *  Methodology :
 *     #define XXH_INLINE_ALL
 *     #include "xxhash.h"
 * `xxhash.c` is automatically included.
 *  It's not useful to compile and link it as a separate module.
 *//* ****************************
 *  API modifier
 ******************************//* Notice extracted from xxHash homepage :

xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
It also successfully passes all tests from the SMHasher suite.

Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)

Name            Speed       Q.Score   Author
xxHash          5.4 GB/s     10
CrapWow         3.2 GB/s      2       Andrew
MumurHash 3a    2.7 GB/s     10       Austin Appleby
SpookyHash      2.0 GB/s     10       Bob Jenkins
SBox            1.4 GB/s      9       Bret Mulvey
Lookup3         1.2 GB/s      9       Bob Jenkins
SuperFastHash   1.2 GB/s      1       Paul Hsieh
CityHash64      1.05 GB/s    10       Pike & Alakuijala
FNV             0.55 GB/s     5       Fowler, Noll, Vo
CRC32           0.43 GB/s     9
MD5-32          0.33 GB/s    10       Ronald L. Rivest
SHA1-32         0.28 GB/s    10

Q.Score is a measure of quality of the hash function.
It depends on successfully passing SMHasher test set.
10 is a perfect score.

A 64-bit version, named XXH64, is available since r35.
It offers much better speed, but for 64-bit applications only.
Name     Speed on 64 bits    Speed on 32 bits
XXH64       13.8 GB/s            1.9 GB/s
XXH32        6.8 GB/s            6.0 GB/s
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4frame.c"lz4hc.h""lz4frame.h"dstage_init"LZ4F_decompress : %p,%u => %p,%u", srcBuffer, (unsigned)*srcSizePtr, dstBuffer, (unsigned)*dstSizePtr*dstSizePtr == 0&optionsNullLZ4F_decompressOptions_t *dctx != NULL"dstage_getFrameHeader""dstage_storeFrameHeader"dctx->tmpInTarget - dctx->tmpInSize(size_t)(srcEnd - srcPtr)LZ4F_decodeHeader(dctx, dctx->header, dctx->tmpInTarget)"dstage_init"dctx->tmpIn == NULLdctx->tmpIn == ((void *)0)allocation_faileddctx->tmpOutBuffer== NULLdctx->tmpOutBuffer== ((void *)0)wantedDataremainingInput"end of frame"maxBlockSize_invalid"next block is uncompressed (size %u)", (U32)nextCBlockSize"dstage_copyDirect"(size_t)(srcEnd-srcPtr)(size_t)(dstEnd-dstPtr)dctx->tmpInTargetminBuffSize"dstage_getBlockChecksum"stillToCopy"compare block checksum""incorrect block checksum: %08X != %08X", readCRC, calcCRCblockChecksum_invalid"dstage_getCBlock"inputLeftdctx->tmpInTarget >= 4selectedIn != NULLreadBlockCrc != calcBlockCrcdstPtr != NULLdecodedSize < 0decompressionFaileddctx->dictSize64 *(1<<10)"dstage_flushOut"dctx->tmpOutSize - dctx->tmpOutStartdctx->frameRemainingSizeframeSize_wrongreadCRC != resultCRCcontentChecksum_invaliddstage_getFrameHeaderdstage_storeFrameHeaderBYTE[19]unsigned char[19]BFSizedstage_getBlockHeaderdstage_storeBlockHeaderblockHeadercrcSizeLZ4F_BLOCKUNCOMPRESSED_FLAGdstage_getBlockChecksumcrcSrccalcCRCreadBlockCrccalcBlockCrc(unsigned)dstage_init == 2LZ4F_static_assertdctx->tmpOutBuffer != NULL(dstage_getSuffix)(unsigned)(dstage_getSuffix)(unsigned)(dstage_getSuffix)-2LZ4F_updateDictdctx->dict != NULLdstPtr >= dstBufferStartdstSize < 64 KBdctx->dict + dctx->dictSize == dctx->tmpOut + dctx->tmpOutStartdstage_getFrameHeader < dstage_storeFrameHeaderframeDecoding_alreadyStartedframeHeader_incompletedecodeResultsrc == NULLsrc == ((void *)0)srcPtr_wrongframeType_unknown407708164dictIDFlagLZ4F_decodeHeader"LZ4F_decodeHeader"srcSize < minFHSize&(dctx->frameInfo)sizeof(dctx->frameInfo)"frame header error : unknown magic number"reservedFlag_setheaderVersion_wrongframeHeaderSize > 5HC != srcPtr[frameHeaderSize-1]headerChecksum_invaliddstBufferStartLZ4F_decompressionContextPtr != NULLLZ4F_decompressionContextPtr == NULLLZ4F_decompressionContextPtr == ((void *)0)parameter_nullLZ4F_dctx *const288sizeof(LZ4F_dctx)flushSize"LZ4F_compressEnd: dstCapacity=%u", (unsigned)dstCapacityflushSize <= dstCapacitydstCapacity < 4dstMaxSize_tooSmalldstCapacity < 8"Writing 32-bit content checksum"cctxPtr->cStage != 1compressionState_uninitializeddstCapacity < (cctxPtr->tmpInSize + BHSize + BFSize)((void)"flush overflows dstBuffer!", (size_t)(dstPtr - dstStart) <= dstCapacity)LZ4F_cctx_t *LZ4B_UNCOMPRESSEDLZ4B_COMPRESSEDLZ4F_compressUpdateImplconst compressFunc_tbytesWritten"LZ4F_compressUpdate (srcSize=%zu)", srcSizeLZ4F_preferences_t *blockSize > cctxPtr->tmpInSizeblockCompression == LZ4B_COMPRESSED0 <= realDictSize && realDictSize <= 64 KB(cctxPtr->tmpIn + blockSize) <= (cctxPtr->tmpBuff + cctxPtr->maxBufferSize)LZ4F_localSaveDictLZ4F_selectCompressionLZ4F_doNotCompressBlockLZ4F_compressBlockHC_continueLZ4F_compressBlockHCLZ4F_compressBlock_continue"LZ4F_compressBlock_continue (srcSize=%i)", srcSizeLZ4F_compressBlock"LZ4F_compressBlock (srcSize=%i)", srcSizeLZ4F_makeBlockcompress != NULLcrc32dstCapacity < maxFHSizectxTypeIDrequiredSizeallocatedSizecctxPtr->lz4CtxPtr == NULLcctxPtr->lz4CtxPtr == ((void *)0)sizeof(LZ4_streamHC_t)LZ4F_BLOCKSIZEID_DEFAULTLZ4F_decompressionContextPtrblockCompressioncompressModelz4ctxcrcFlagcctxPtr->tmpBuff == NULLcctxPtr->tmpBuff == ((void *)0)ctxTypeID_to_sizeLZ4F_initStreamLZ4F_compressionContextPtr != NULLLZ4F_compressionContextPtr == NULLLZ4F_compressionContextPtr == ((void *)0)*LZ4F_compressionContextPtr==NULL*LZ4F_compressionContextPtr==((void *)0)LZ4F_cctx *constsizeof(LZ4F_cctx)"LZ4F_createCDict"LZ4F_CDict *constsizeof(*cdict)"LZ4F_createCDict_advanced"LZ4F_cctx_t *const&cctxsizeof(cctx)sizeof(lz4ctx)"LZ4F_compressFrame"&prefsconst LZ4F_blockSizeID_t&optionsLZ4F_compressOptions_t *dstCapacity < LZ4F_compressFrameBound(srcSize, &prefs)dstEnd >= dstPtrtailSizedstEnd >= dstStartLZ4F_compressBound_internalconst LZ4F_preferences_t *constflushblockIDmaxBufferedbufferedSizealreadyBufferedmaxSrcSizenbFullBlockspartialBlockSizeblockCRCSizeLZ4F_optimalBSIDLZ4F_headerChecksumconst size_t[4]blockSizeIdx(int)LZ4F_max64KBLZ4F_returnErrorCodesizeof(ptrdiff_t) >= sizeof(size_t)const char *[23]char *[23]-LZ4F_ERROR_maxCode18446744073709551594(LZ4F_errorCode_t)(-LZ4F_ERROR_maxCode)LZ4F_writeLE64LZ4F_readLE64LZ4F_writeLE32LZ4F_readLE32LZ4F_freeLZ4F_mallocLZ4F_callocLZ4F_compressionContextPtrcmemLZ4F_lastBlockStatusLZ4F_cctx_tLZ4F_blockCompression_tskipChecksumblockChecksumlz4CtxStatelz4CtxAlloclz4CtxPtrHCCtxfastCtxdictContentk_cOptionsNullLZ4F_errorStringsLZ4F_GENERATE_STRINGchar[28]FORWARD_IF_ERROR(r)if (LZ4F_isError(r)) return (r)RETURN_ERROR_IF(c,e)if (c) RETURN_ERROR(e)RETURN_ERROR(e)return LZ4F_returnErrorCode(LZ4F_ERROR_ ## e)LZ4F_GENERATE_STRING(STRING)*(1<<30)*(1<<20)*(1<<10)LZ4F_STATIC_ASSERT(c){ enum { LZ4F_static_assert = 1/(int)(!!(c)) }; }calloc(1,(s))LZ4F_STATIC_LINKING_ONLYLZ4F_HEAPMODEdefined(LZ4_DEBUG) && (LZ4_DEBUG>=2) && !defined(DEBUGLOG)(LZ4F_HEAPMODE)FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION/*! LZ4F_decompress_usingDict() :
 *  Same as LZ4F_decompress(), using a predefined dictionary.
 *  Dictionary is used "in place", without any preprocessing.
 *  It must remain accessible throughout the entire frame decoding.
 *//* valid stages : [init ... getSuffix[ *//* cannot rely on dst data to remain there for next call *//* dictionary exists *//* dictionary is not already within tmp *//* next block will use up to 64KB from previous ones *//* preserve history within tmpOut whenever necessary *//* while (doAnotherStage) *//* switch (dctx->dStage) *//* frame fully skipped : prepare context for a new frame *//* still more to skip *//* no direct entry *//* if (dctx->dStage == dstage_storeSFrameSize) *//* no direct entry, avoid initialization risks *//* if (dctx->dStage == dstage_storeSuffix) *//* no checksum, frame is completed *//* could not flush everything : stop there, just request a block header *//* get next block *//* all flushed *//*withinTmp*//* fall-through *//* the dictSize param is an int, avoid truncation / sign issues *//* Decode block into tmpOut *//* dict not within tmpOut *//* truncate dictionary to 64 KB if too big *//* manage dictionary *//* end of block, let's get another one *//* overflow control : dctx->dictSize is an int, avoid truncation / sign issues *//* unless the dictionary is stored in tmpOut:
                  * in which case it's faster to decode within tmpOut
                  * to benefit from prefix speedup *//* decode directly into destination buffer if there is enough room *//* selectedIn is defined at this stage (either srcPtr, or dctx->tmpIn) *//* First, decode and control block checksum if it exists *//* At this stage, input is large enough to decode a block *//* next header size *//* always jump over next block *//* input large enough to read full block directly *//* new block *//* all input consumed *//* check block checksum for recently transferred uncompressed block *//* need to copy more *//* all done *//* history management (linked blocks only)*//* next block is a compressed block *//* next block is uncompressed *//* frameEnd signal, no more block *//* decode block header *//* if (dctx->dStage == dstage_storeBlockHeader) *//* not enough input for cBlockSize *//* block checksum *//* ensure allocation will be re-attempted on next entry*//* internal buffers allocation *//* will update dStage appropriately *//* minimum size to decode header *//* 0-size input *//* behaves as a state machine *//* once set, disable for the remainder of the frame *//*! LZ4F_decompress() :
 *  Call this function repetitively to regenerate compressed data in srcBuffer.
 *  The function will attempt to decode up to *srcSizePtr bytes from srcBuffer
 *  into dstBuffer of capacity *dstSizePtr.
 *
 *  The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).
 *
 *  The number of bytes effectively read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
 *  If number of bytes read is < number of bytes provided, then decompression operation is not complete.
 *  Remaining data will have to be presented again in a subsequent invocation.
 *
 *  The function result is an hint of the better srcSize to use for next call to LZ4F_decompress.
 *  Schematically, it's the size of the current (or remaining) compressed block + header of next block.
 *  Respecting the hint provides a small boost to performance, since it allows less buffer shuffling.
 *  Note that this is just a hint, and it's always possible to any srcSize value.
 *  When a frame is fully decoded, @return will be 0.
 *  If decompression failed, @return is an error code which can be tested using LZ4F_isError().
 *//* withinTmp expectation : content of [dstPtr,dstSize] is same as [dict+dictSize,dstSize], so we just extend it *//* continue history within tmpOutBuffer *//* dstBuffer does not contain whole useful history (64 KB), so it must be saved within tmpOutBuffer *//* if dstSize >= 64 KB, dictionary would be set into dstBuffer directly *//* history in dstBuffer becomes large enough to become dictionary *//* prefix mode, everything within dstBuffer *//* will lead to prefix mode *//* LZ4F_updateDict() :
 * only used for LZ4F_blockLinked mode
 * Condition : @dstPtr != NULL
 *//* block header size *//* frame decoding already started, in the middle of header => automatic fail *//* returns : recommended nb of bytes for LZ4F_decompress() *//*! LZ4F_getFrameInfo() :
 *  This function extracts frame parameters (max blockSize, frame checksum, etc.).
 *  Usage is optional. Objective is to provide relevant information for allocation purposes.
 *  This function works in 2 situations :
 *   - At the beginning of a new frame, in which case it will decode this information from `srcBuffer`, and start the decoding process.
 *     Amount of input data provided must be large enough to successfully decode the frame header.
 *     A header size is variable, but is guaranteed to be <= LZ4F_HEADER_SIZE_MAX bytes. It's possible to provide more input data than this minimum.
 *   - After decoding has been started. In which case, no input is read, frame parameters are extracted from dctx.
 *  The number of bytes consumed from srcBuffer will be updated within *srcSizePtr (necessarily <= original value).
 *  Decompression must resume from (srcBuffer + *srcSizePtr).
 * @return : an hint about how many srcSize bytes LZ4F_decompress() expects for next call,
 *           or an error code which can be tested using LZ4F_isError()
 *  note 1 : in case of error, dctx is not modified. Decoding operations can resume from where they stopped.
 *  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure.
 *//*! LZ4F_headerSize() :
 * @return : size of frame header
 *           or an error code, which can be tested using LZ4F_isError()
 *//* check header *//* 4-7 only supported values for the time being *//*! LZ4F_decodeHeader() :
 *  input   : `src` points at the **beginning of the frame**
 *  output  : set internal values of dctx, such as
 *            dctx->frameInfo and dctx->dStage.
 *            Also allocates internal buffers.
 *  @return : nb Bytes read from src (necessarily <= srcSize)
 *            or an error code (testable with LZ4F_isError())
 *//*==---   Streaming Decompression operations   ---==*//* failed allocation *//* in case it nonetheless happen in production *//* violation of narrow contract *//*! LZ4F_createDecompressionContext() :
 *  Create a decompressionContext object, which will track all decompression operations.
 *  Provides a pointer to a fully allocated and initialized LZ4F_decompressionContext object.
 *  Object can later be released using LZ4F_freeDecompressionContext().
 * @return : if != 0, there was an error during context creation.
 *//* typedef'd to LZ4F_dctx in lz4frame.h *//*! LZ4F_compressEnd() :
 *  When you want to properly finish the compressed frame, just call LZ4F_compressEnd().
 *  It will flush whatever data remained within compressionContext (like LZ4_flush())
 *  but also properly finalize the frame, with an endMark and an (optional) checksum.
 *  LZ4F_compressOptions_t structure is optional : you can provide NULL as argument.
 * @return: the number of bytes written into dstBuffer (necessarily >= 4 (endMark size))
 *       or an error code if it fails (can be tested using LZ4F_isError())
 *  The context can then be used again to compress a new frame, starting with LZ4F_compressBegin().
 *//* necessarily LZ4F_blockLinked *//* not useful (yet) *//*! LZ4F_flush() :
 *  When compressed data must be sent immediately, without waiting for a block to be filled,
 *  invoke LZ4_flush(), which will immediately compress any remaining data stored within LZ4F_cctx.
 *  The result of the function is the number of bytes written into dstBuffer.
 *  It can be zero, this means there was no data left within LZ4F_cctx.
 *  The function outputs an error code if it fails (can be tested using LZ4F_isError())
 *  LZ4F_compressOptions_t* is optional. NULL is a valid argument.
 *//*! LZ4F_compressUpdate() :
 *  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
 *  When successful, the function always entirely consumes @srcBuffer.
 *  src data is either buffered or compressed into @dstBuffer.
 *  If previously an uncompressed block was written, buffered data is flushed
 *  before appending compressed data is continued.
 *  This is only supported when LZ4F_blockIndependent is used
 * @dstCapacity MUST be >= LZ4F_compressBound(srcSize, preferencesPtr).
 * @compressOptionsPtr is optional : provide NULL to mean "default".
 * @return : the number of bytes written into dstBuffer. It can be zero, meaning input data was just buffered.
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *  After an error, the state is left in a UB state, and must be re-initialized.
 *//*! LZ4F_compressUpdate() :
 *  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
 *  When successful, the function always entirely consumes @srcBuffer.
 *  src data is either buffered or compressed into @dstBuffer.
 *  If previously an uncompressed block was written, buffered data is flushed
 *  before appending compressed data is continued.
 * @dstCapacity MUST be >= LZ4F_compressBound(srcSize, preferencesPtr).
 * @compressOptionsPtr is optional : provide NULL to mean "default".
 * @return : the number of bytes written into dstBuffer. It can be zero, meaning input data was just buffered.
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *  After an error, the state is left in a UB state, and must be re-initialized.
 *//* only preserve 64KB within internal buffer. Ensures there is enough room for next block.
         * note: this situation necessarily implies lastBlockCompressed==fromTmpBuffer *//* not enough room to store next block *//* no autoflush : there may be some data left within internal buffer *//* src is stable : dictionary remains in src across invocations *//* linked blocks are only supported in compressed mode, see LZ4F_uncompressedUpdate *//* preserve dictionary within @tmpBuff whenever necessary *//* autoFlush : remaining input (< blockSize) is compressed *//* compress full blocks *//* flush currently written block, to continue with new block compression *//* state must be initialized and waiting for next block *//*! LZ4F_compressUpdateImpl() :
 *  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
 *  When successful, the function always entirely consumes @srcBuffer.
 *  src data is either buffered or compressed into @dstBuffer.
 *  If the block compression does not match the compression of the previous block, the old data is flushed
 *  and operations continue with the new compression mode.
 * @dstCapacity MUST be >= LZ4F_compressBound(srcSize, preferencesPtr) when block compression is turned on.
 * @compressOptionsPtr is optional : provide NULL to mean "default".
 * @return : the number of bytes written into dstBuffer. It can be zero, meaning input data was just buffered.
 *           or an error code if it fails (which can be tested using LZ4F_isError())
 *  After an error, the state is left in a UB state, and must be re-initialized.
 *//* Save history (up to 64KB) into @tmpBuff *//* init once at beginning of frame *//* checksum of compressed data *//*! LZ4F_makeBlock():
 *  compress a single block, add header and optional checksum.
 *  assumption : dst buffer capacity is >= BHSize + srcSize + crcSize
 *//*  LZ4F_compressBound() :
 * @return minimum capacity of dstBuffer for a given srcSize to handle worst case scenario.
 *  LZ4F_preferences_t structure is optional : if NULL, preferences will be set to cover worst case scenario.
 *  This function cannot fail.
 *//*! LZ4F_compressBegin() :
 *  init streaming compression AND writes frame header into @dstBuffer.
 * @dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
 * @preferencesPtr can be NULL, in which case default parameters are selected.
 * @return : number of bytes written into dstBuffer for the header
 *        or an error code (can be tested using LZ4F_isError())
 *//* Header CRC Byte *//* Optional dictionary ID field *//* frame init only for blockLinked : blockIndependent will be init at each block *//* context init *//* only needs past data up to window size *//* otherwise, a sufficient buffer is already allocated,
             * but we need to reset it to the correct context type *//* must take ownership of memory allocation,
                 * in order to respect custom allocator contract *//* not enough space allocated *//* cctx Management *//*! LZ4F_compressBegin_usingCDict() :
 *  init streaming compression AND writes frame header into @dstBuffer.
 * @dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
 * @return : number of bytes written into @dstBuffer for the header
 *           or an error code (can be tested using LZ4F_isError())
 *//* In these cases, we will call LZ4_compress_fast_continue(),
             * which needs an already reset context. Otherwise, we'll call a
             * one-shot API. The non-continued APIs internally perform their own
             * resets at the beginning of their calls, where they know what
             * tableType they need the context to be in. So in that case this
             * would be misguided / wasted work. *//**
 * This function prepares the internal LZ4(HC) stream for a new compression,
 * resetting the context and attaching the dictionary, if there is one.
 *
 * It needs to be called at the beginning of each independent compression
 * stream (i.e., at the beginning of a frame in blockLinked mode, or at the
 * beginning of each block in blockIndependent mode).
 *//* note: LZ4_streamHC_t and LZ4_stream_t are simple POD types *//* considered a violation of narrow contract *//*! LZ4F_createCompressionContext() :
 *  The first thing to do is to create a compressionContext object, which will be used in all compression operations.
 *  This is achieved using LZ4F_createCompressionContext(), which takes as argument a version and an LZ4F_preferences_t structure.
 *  The version provided MUST be LZ4F_VERSION. It is intended to track potential incompatible differences between different binaries.
 *  The function will provide a pointer to an allocated LZ4F_compressionContext_t object.
 *  If the result LZ4F_errorCode_t is not OK_NoError, there was an error during context creation.
 *  Object can release its memory using LZ4F_freeCompressionContext();
**//* Uninitialized. Next stage : init cctx *//*! LZ4F_createCDict() :
 *  When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once.
 *  LZ4F_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.
 *  LZ4F_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
 * @dictBuffer can be released after LZ4F_CDict creation, since its content is copied within CDict
 * @return : digested dictionary for compression, or NULL if failed *//* typedef'd to LZ4F_CDict within lz4frame_static.h *//*-***************************************************
*   Dictionary compression
*****************************************************//* mess with real buffer size to prevent dynamic allocation; works only because autoflush==1 & stableSrc==1 *//*! LZ4F_compressFrame() :
 *  Compress an entire srcBuffer into a valid LZ4 frame, in a single step.
 *  dstBuffer MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
 *  The LZ4F_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default.
 * @return : number of bytes written into dstBuffer.
 *           or an error code if it fails (can be tested using LZ4F_isError())
 *//* only one block => no need for inter-block link *//*! LZ4F_compressFrame_usingCDict() :
 *  Compress srcBuffer using a dictionary, in a single step.
 *  cdict can be NULL, in which case, no dictionary is used.
 *  dstBuffer MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
 *  The LZ4F_preferences_t structure is optional : you may provide NULL as argument,
 *  however, it's the only way to provide a dictID, so it's not recommended.
 * @return : number of bytes written into dstBuffer,
 *           or an error code if it fails (can be tested using LZ4F_isError())
 *//* max header size, including optional fields *//*! LZ4F_compressBound_internal() :
 *  Provides dstCapacity given a srcSize to guarantee operation success in worst case situations.
 *  prefsPtr is optional : if NULL is provided, preferences will be set to cover worst case scenario.
 * @return is always the same for a srcSize and prefsPtr, so it can be relied upon to size reusable buffers.
 *  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() operations.
 *//*-************************************
*  Simple-pass compression functions
**************************************//* A compilation error here means sizeof(ptrdiff_t) is not large enough *//* in use as: 0 = none, 1 = lz4 ctx, 2 = lz4hc ctx *//* sized for: 0 = none, 1 = lz4 ctx, 2 = lz4hc ctx *//* amount of data to compress after tmpIn *//* starting position of data compress within internal buffer (>= tmpBuff) *//* internal buffer, for streaming *//* 0 : compression uninitialized ; 1 : initialized, can compress *//* block footer : checksum (optional) *//* block header : size, and compress flag *//* 19 *//*  7 *//* avoid double definition *//* unoptimized version; solves endianness & alignment issues *//*-************************************
*  Basic Types
**************************************//*-************************************
*  Debug
**************************************//* nothing defined : use default <stdlib.h>'s free() *//* custom malloc defined : use it *//* nothing defined : use default <stdlib.h>'s malloc() *//* only custom alloc defined : use it, and combine it with memset() *//* nothing defined : use default <stdlib.h>'s calloc() *//* custom calloc defined : use it *//* avoid redefinition when sources are coalesced *//* memset, memcpy, memmove *//*
 * User may redirect invocations of
 * malloc(), calloc() and free()
 * towards another library or solution of their choice
 * by modifying below section.
**//*-************************************
*  Library declarations
**************************************//*
 * LZ4F_HEAPMODE :
 * Control how LZ4F_compressFrame allocates the Compression State,
 * either on stack (0:default, fastest), or in memory heap (1:requires malloc()).
 *//* LZ4F is a stand-alone API to create LZ4-compressed Frames
 * in full conformance with specification v1.6.1 .
 * This library rely upon memory management capabilities (malloc, free)
 * provided either by <stdlib.h>,
 * or redirected towards another library of user's choice
 * (see Memory Routines below).
 *//*
 * LZ4 auto-framing library
 * Copyright (C) 2011-2016, Yann Collet.
 *
 * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following disclaimer
 *   in the documentation and/or other materials provided with the
 *   distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You can contact the author at :
 * - LZ4 homepage : http://www.lz4.org
 * - LZ4 source repository : https://github.com/lz4/lz4
 */RTSIG_MAXXATTR_LIST_MAXXATTR_SIZE_MAXXATTR_NAME_MAXPIPE_BUFPATH_MAXMAX_INPUTMAX_CANONLINK_MAXARG_MAXNGROUPS_MAXNR_OPEN_LINUX_LIMITS_H/* size of extended attribute namelist (64k) *//* size of an extended attribute value (64k) *//* # chars in an extended attribute name *//* # bytes in atomic write to a pipe *//* # chars in a path name including nul *//* # chars in a file name *//* size of the type-ahead buffer *//* size of the canonical input queue *//* # links a file may have *//* # bytes of args + environ for exec() *//* supplemental group IDs are available *//* Minimum size for a thread.  We are free to choose a reasonable value.  *//* Definition of PTHREAD_STACK_MIN.  Linux version.
   Copyright (C) 2021-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/pthread_stack_min.h><linux/limits.h>SEM_VALUE_MAXMQ_PRIO_MAXHOST_NAME_MAXLOGIN_NAME_MAXTTY_NAME_MAXDELAYTIMER_MAXAIO_PRIO_DELTA_MAXPTHREAD_THREADS_MAX_POSIX_THREAD_THREADS_MAXPTHREAD_DESTRUCTOR_ITERATIONS_POSIX_THREAD_DESTRUCTOR_ITERATIONSPTHREAD_KEYS_MAX_POSIX_THREAD_KEYS_MAX__undef_ARG_MAX__undef_OPEN_MAXOPEN_MAX__undef_LINK_MAX__undef_NR_OPEN/* Maximum value the semaphore can have.  *//* Maximum message queue priority level.  *//* Maximum host name length.  *//* Maximum login name length.  This is arbitrary.  *//* Maximum tty name length.  *//* Maximum number of timer expiration overruns.  *//* Arrange for the definition of PTHREAD_STACK_MIN.  *//* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  *//* We have no predefined limit on the number of threads.  *//* The number of threads per process.  *//* Number of iterations this implementation does.  *//* Controlling the iterations of destructors for thread-specific data.  *//* This is the value this implementation supports.  *//* The number of data keys per process.  *//* Have to remove ARG_MAX?  *//* Have to remove OPEN_MAX?  *//* Have to remove LINK_MAX?  *//* Have to remove NR_OPEN?  *//* The kernel sources contain a file with all the needed information.  *//* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  *//* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <https://www.gnu.org/licenses/>.  */<bits/local_lim.h>SSIZE_MAXLONG_MAX_POSIX_CLOCKRES_MIN20000000_POSIX_TZNAME_MAX_POSIX_TTY_NAME_MAX_POSIX_TIMER_MAX_POSIX_SYMLOOP_MAX_POSIX_SYMLINK_MAX_POSIX_STREAM_MAX_POSIX_SSIZE_MAX_POSIX_SIGQUEUE_MAX_POSIX_SEM_VALUE_MAX_POSIX_SEM_NSEMS_MAX_POSIX_RTSIG_MAX_POSIX_RE_DUP_MAX_POSIX_PIPE_BUF_POSIX_PATH_MAX_POSIX_OPEN_MAX_POSIX_NGROUPS_MAX_POSIX_NAME_MAX_POSIX_MQ_PRIO_MAX_POSIX_MQ_OPEN_MAX_POSIX_MAX_INPUT_POSIX_MAX_CANON_POSIX_LOGIN_NAME_MAX_POSIX_LINK_MAX_POSIX_HOST_NAME_MAX_POSIX_DELAYTIMER_MAX_POSIX_CHILD_MAX_POSIX_ARG_MAX_POSIX_AIO_MAX_POSIX_AIO_LISTIO_MAX_BITS_POSIX1_LIM_H__WORDSIZE == 64 || __WORDSIZE32_SIZE_ULONG/* bits/posix1_lim.h  *//* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  *//* ssize_t is not formally required to be the signed type
   corresponding to size_t, but it is for all configurations supported
   by glibc.  *//* Get the implementation-specific values for the above.  *//* Maximum clock resolution in nanoseconds.  *//* Maximum number of elements in an `iovec' array.  *//* Maximum number of bytes that can be buffered on a socket for send
   or receive.  *//* Maximum number of connections that can be queued on a socket.  *//* Maximum length of a timezone name (element of `tzname').  *//* Maximum number of characters in a tty name.  *//* Number of timer for a process.  *//* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  *//* The number of bytes in a symbolic link.  *//* Number of streams a process can have open at once.  *//* Largest value of a `ssize_t'.  *//* Number of pending realtime signals.  *//* Maximal value of a semaphore.  *//* Number of semaphores a process can have.  *//* Minimal number of realtime signals reserved for the application.  *//* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  *//* Number of bytes than can be written atomically to a pipe.  *//* Number of bytes in a pathname.  *//* Number of descriptors that a process may examine with `pselect' or
   `select'.  *//* Number of files one process can have open at once.  *//* Number of simultaneous supplementary group IDs per process.  *//* Number of bytes in a filename.  *//* Maximum number of supported message priorities.  *//* Maximum number of message queues open for a process.  *//* Number of bytes for which space will be
   available in a terminal input queue.  *//* Number of bytes in a terminal canonical input queue.  *//* Maximum length of login name.  *//* Maximum link count of a file.  *//* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  *//* Minimal number of timer expiration overruns.  *//* Maximum simultaneous processes per real user ID.  *//* Maximum length of arguments to `execve', including environment.  *//* Minimal number of outstanding asynchronous I/O operations.  *//* Minimum number of operations in one list I/O call.  *//* These are the standard-mandated minimum values.  *//*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */RE_DUP_MAX(0x7fff)CHARCLASS_NAME_MAXLINE_MAX_POSIX2_LINE_MAXEXPR_NEST_MAX_POSIX2_EXPR_NEST_MAXCOLL_WEIGHTS_MAXBC_STRING_MAX_POSIX2_BC_STRING_MAXBC_SCALE_MAX_POSIX2_BC_SCALE_MAXBC_DIM_MAX_POSIX2_BC_DIM_MAXBC_BASE_MAX_POSIX2_BC_BASE_MAX_POSIX2_CHARCLASS_NAME_MAX_POSIX2_RE_DUP_MAX_POSIX2_COLL_WEIGHTS_MAX_BITS_POSIX2_LIM_H/* bits/posix2_lim.h *//* This value is defined like this in regex.h.  *//* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  *//* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  *//* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  *//* The maximum length, in bytes, of an input line.  *//* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  *//* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  *//* The maximum length of a string constant accepted by the `bc' utility.  *//* The maximum `scale' value allowed by the `bc' utility.  *//* The maximum number of elements allowed in an array by the `bc' utility.  *//* The maximum `ibase' and `obase' values allowed by the `bc' utility.  *//*
 * Never include this file directly; include <limits.h> instead.
 */<bits/posix2_lim.h>ULLONG_MAX(LLONG_MAX * 2ULL + 1)LLONG_MAXLLONG_MIN(-LLONG_MAX-1)MB_LEN_MAX_LIBC_LIMITS_H_!defined __GNUC__ || __GNUC__ < 2_LIMITS_H__CHAR_UNSIGNED__defined __GNUC__ && !defined _GCC_LIMITS_H_defined __USE_ISOC99 && defined __GNUC__CHAR_WIDTHSCHAR_WIDTHUCHAR_WIDTHSHRT_WIDTHUSHRT_WIDTHINT_WIDTHUINT_WIDTHLONG_WIDTHULONG_WIDTHLLONG_WIDTHULLONG_WIDTHBOOL_MAXBOOL_WIDTH/* POSIX adds things to <limits.h>.  *//* The macros for _Bool are not defined by GCC's <limits.h> before GCC
   11, or if _GNU_SOURCE is defined rather than enabling C2x support
   with -std.  *//* The integer width macros are not defined by GCC's <limits.h> before
   GCC 7, or if _GNU_SOURCE rather than
   __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.  *//* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  *//* `_GCC_LIMITS_H_' is what GCC's file defines.  *//* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  *//* !_LIBC_LIMITS_H_ *//* GCC 2.  *//* limits.h  *//* ISO C99 *//* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed long long int' can hold.  *//* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed long int' can hold.  *//* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed int' can hold.  *//* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed short int' can hold.  *//* Minimum and maximum values a `char' can hold.  *//* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  *//* Minimum and maximum values a `signed char' can hold.  *//* Number of bits in a `char'.	*//* These assume 8-bit `char's, 16-bit `short int's,
   and 32-bit `int's and `long int's.  *//* We don't have #include_next.
   Define ANSI <limits.h> for standard 32-bit words.  *//* We only protect from multiple inclusion here, because all the other
   #include's protect themselves, and in GCC 2 we may #include_next through
   multiple copies of this file before we get to GCC's.  *//* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  *//* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  *//*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */_GCC_LIMITS_H__LIMITS_H_____SCHAR_MAX__ == __INT_MAX____SHRT_MAX__ == __INT_MAX__defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901Ldefined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)(defined __STDC_WANT_IEC_60559_BFP_EXT__ \defined (__STDC_VERSION__) && __STDC_VERSION__ > 201710L_GCC_NEXT_LIMITS_H/* not _GCC_LIMITS_H_ *//* recurse down to the real one *//* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  *//* _LIMITS_H___ *//* C2X width and limit of _Bool.  *//* TS 18661-1 / C2X widths of integer types.  *//* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  *//* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  *//* Maximum value an `unsigned int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  *//* Maximum value an `unsigned char' can hold.  (Minimum is 0).  *//* Maximum length of a multibyte character.  *//* Number of bits in a `char'.  *//* Copyright (C) 1991-2022 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//* Use "..." so that we find syslimits.h only in this same directory.  *//* Terminated in limity.h.  *//* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  *//* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  *//* Copyright (C) 1992-2022 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//* tell gcc's limits.h to recurse *//* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */"syslimits.h"(LLONG_MAX * 2ULL + 1ULL)(-LLONG_MAX - 1LL)ULONG_MAX(LONG_MAX * 2UL + 1UL)__LONG_MAX__LONG_MIN(-LONG_MAX - 1L)UINT_MAX(INT_MAX * 2U + 1U)INT_MAXINT_MIN(-INT_MAX - 1)USHRT_MAX(SHRT_MAX * 2 + 1)SHRT_MAX__SHRT_MAX__SHRT_MIN(-SHRT_MAX - 1)CHAR_MAXSCHAR_MAXCHAR_MINSCHAR_MINUCHAR_MAX(SCHAR_MAX * 2 + 1)__SCHAR_MAX__(-SCHAR_MAX - 1)CHAR_BIT__CHAR_BIT__0x7fff0x7f/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/lz4hc.c"lz4.c"cParams_tlz4hclz4optlz4hc_strat_eLZ4HC_compress_optimalconst dictCtx_directiveconst HCfavor_esizeof(LZ4HC_optimal_t) * (LZ4_OPT_NUM + TRAILING_LITERALS)sizeof(LZ4HC_optimal_t) * ((1<<12) + 3)LZ4HC_optimal_t *LZ4HC_optimal_t *const409965584opSavedovml MINMATCHovoff"LZ4HC_compress_optimal(dst=%p, dstCapa=%u)", dst, (unsigned)dstCapacityLZ4_OPT_NUM"rPos:%3i => price:%3i (litlen=%i) -- initial setup", rPos, cost, opt[rPos].litlenmatchML < LZ4_OPT_NUM"rPos:%3i => price:%3i (matchlen=%i) -- initial setup", mlen, cost, mlen"rPos:%3i => price:%3i (litlen=%i) -- initial setup", last_match_pos+addLit, opt[last_match_pos+addLit].price, addLit"rPos:%u[%u] vs [%u]%u", cur, opt[cur].price, opt[cur+1].price, cur+1"search at rPos:%u", cur"rPos:%3i => price:%3i (litlen=%i)", pos, price, opt[pos].litlencur + newMatch.len < LZ4_OPT_NUM"testing price rPos %i (last_match_pos=%i)", pos, last_match_pos(U32)favorDecSpeed <= 1"rPos:%3i => price:%3i (matchlen=%i)", pos, price, mlpos < LZ4_OPT_NUM"rPos:%3i => price:%3i (litlen=%i)", last_match_pos+addLit, opt[last_match_pos+addLit].price, addLitlast_match_pos < LZ4_OPT_NUM + TRAILING_LITERALScur < LZ4_OPT_NUMlast_match_pos >= 1"reverse traversal, looking for shortest path (last_match_pos=%i)", last_match_pos"pos %i: sequence length %i", candidate_pos, selected_matchLengthnext_matchLength > 0ml >= MINMATCH(offset >= 1) && (offset <= LZ4_DISTANCE_MAX)last_match_posconst LZ4HC_match_tfirstMatchLZ4HC_CCtx_internal *constfirstMLrPosmatchMLaddLitTRAILING_LITERALScurPtrnewMatchbaseLitlencandidate_posselected_matchLengthselected_offsetnext_matchLengthnext_offsetnbSearchesfullUpdatelastRunSizellAdd"Final literal run : %i literals", (int)lastRunSize(RUN_MASK << ML_BITS)_dest_overflow"Last sequence overflowing (only %i bytes remaining)", (int)(oend-1-opSaved)maxMlSize < INT_MAXovml >= 0"Space to end : %i + ml (%i)", (int)((oend + LASTLITERALS) - (op + ll_totalCost + 2) - 1), ovml"Before : ip = %p, anchor = %p", ip, anchor"After : ip = %p, anchor = %p", ip, anchorll_addbytesll_totalCostmaxLitPosbytesLeftForMlmaxMlSize(ML_MASK-1)_return_labelLZ4HC_FindLongerMatchmatch0mdLZ4HC_sequencePrice1 + 2litlen >= 0mlen >= MINMATCH(int)(ML_MASK+MINMATCH)LZ4HC_literalsPrice(int)RUN_MASKbufferStartLZ4_streamHC_t *consthc4sizeof(*hc4)minLencLevel"LZ4_saveDictHC(%p, %p, %d)", LZ4_streamHCPtr, safeBuffer, dictSizeprefixSize >= 0"LZ4_compress_HC_continue"LZ4_compressHC_continue_generic"LZ4_compressHC_continue_generic(ctx=%p, src=%p, srcSize=%d, limit=%d)", LZ4_streamHCPtr, src, *srcSizePtr, limitctxPtr != NULLLZ4HC_HASHSIZELZ4HC_setExternalDict"LZ4HC_setExternalDict(%p, %p)", ctxPtr, newBlock"LZ4_loadDictHC(ctx:%p, dict:%p, dictSize:%d)", LZ4_streamHCPtr, dictionary, dictSizeLZ4_streamHCPtr != NULLsizeof(*LZ4_streamHCPtr)"LZ4_setCompressionLevel(%p, %d)", LZ4_streamHCPtr, compressionLevel"LZ4_resetStreamHC_fast(%p, %d)", LZ4_streamHCPtr, compressionLevels->end >= s->prefixStart"LZ4_initStreamHC(%p, %u)", buffer, (unsigned)sizehcstatesizeof(*hcstate)(hcstate)(sizeof(*hcstate))262192"LZ4_freeStreamHC(%p)", LZ4_streamHCPtr"LZ4_compress_HC"LZ4_streamHC_t_alignment262208sizeof(t_a) - sizeof(LZ4_streamHC_t)(int)sizeof(LZ4_streamHC_t)LZ4HC_compress_genericLZ4HC_compress_generic_dictCtxctx->dictCtx != NULLctx->dictCtxsizeof(LZ4HC_CCtx_internal)usingDictCtxHcLZ4HC_compress_generic_noDictCtxctx->dictCtx == NULLtargetDestSizesourceSizePtrnoDictCtxLZ4HC_compress_generic_internalconst cParams_tconst cParams_t[13]struct <unnamed>[13]clTable"LZ4HC_compress_generic_internal(src=%p, srcSize=%d)", src, *srcSizePtrcParamconst cParams_t *favorDecompressionSpeedfavorCompressionRatiocParam.strat == lz4optLZ4HC_compress_hashChainpatternAnalysisoptrnomatch"LZ4HC_compress_hashChain (dict?=>%i)", dict"_Search2 (currently found match of size %i)", m1.lenmaxNbAttempts"Last sequence overflowing"m1.len >= 0LZ4HC_encodeSequencenotLimited == 0"Not enough room to write %i literals (%i bytes remaining)", (int)length, (int)(oend - op)2 + 1 + LASTLITERALS(2 + 1 + LASTLITERALS)offset <= LZ4_DISTANCE_MAXoffset > 0matchLength >= MINMATCH"Not enough room to write match length"1 + LASTLITERALS(1 + LASTLITERALS)LZ4HC_InsertAndFindBestMatchuselessPtr"LZ4HC_InsertAndFindBestMatch"LZ4HC_InsertAndGetWiderMatchLZ4_u16 *const LZ4HC_CCtx_internal *constprefixPtrprefixIdxipIndexwithinStartDistance(LZ4_DISTANCE_MAX + 1)lowestMatchIndexdictIdxlookBackLengthmatchChainPosrep_untestedsrcPatternLength"LZ4HC_InsertAndGetWiderMatch"startpos != NULL"First candidate match for pos %u found at index %u / %u (lowestMatchIndex)", ipIndex, matchIndex, lowestMatchIndexmatchIndex < ipIndexmatchPtr < iplongest >= 1"Found match of len=%i within prefix, offset=%i, back=%i", longest, offset, -backmatchIndex >= dictIdxmatchIndex <= prefixIdx - 4(matchIndex <= prefixIdx - 4) != 0"Found match of len=%i within dict, offset=%i, back=%i", longest, offset, -backlookBackLength==0matchIndex + (U32)pos"Repeat pattern detected, char %02X", pattern >> 24matchCandidateIdx - (U32)backLengthmatchCandidateIdx - backLength >= lowestMatchIndexnewMatchIndex >= prefixIdx - 3 && newMatchIndex < prefixIdx && !extDictcurrentSegmentLengthprefixPtr - prefixIdx + matchIndex != ipmaxML < 2 GB"Found repeat pattern match of len=%i, offset=%i", longest, offsetmatchIndex + matchChainPosmatchPtrvLimitkTrigger 4distanceToNextMatchaccel1 << kTriggercandidateDistdistNextMatchmatchCandidateIdxrep_confirmedsizeof(pattern)rep_notextDictforwardPatternLengthrotatedPatternlowestMatchPtrbackLength_ip_op_anchorchainSwapmaxMLdistToNextPatterndictEndOffset <= 1 GB"dictEndOffset = %zu, dictMatchIndex = %u => relative matchIndex = %i", dictEndOffset, dictMatchIndex, (int)dictMatchIndex - (int)dictEndOffset"found match of length %i within extDictCtx", longestdictCtx->chainTabledictMatchIndexdictEndOffsetnextOffsetconst LZ4_u16const LZ4_u16 *longest >= 0LZ4HC_protectDictEndLZ4HC_reverseCountPatternip >= iLow+4(ip >= iLow+4) != 0bytePtrip>iLow(ip>iLow) != 0LZ4HC_countPatternsizeof(pattern)==8(sizeof(pattern)==8)sizeof(pattern)*4(sizeof(pattern)*4)ip < iEnd-(sizeof(pattern)-1)(ip < iEnd-(sizeof(pattern)-1)) != 0patternBytebitOffsetsizeof(pattern)*8(sizeof(pattern)*8)(sizeof(pattern)*8) - 8LZ4HC_rotatePatternbitsToRotatesizeof(pattern) - 1(sizeof(pattern) - 1)(int)bitsToRotateLZ4HC_countBackiMin - ipmMin - matchmin <= 0ip >= iMin(size_t)(ip-iMin) < (1U<<31)match >= mMin(size_t)(match - mMin) < (1U<<31)LZ4HC_Insertip >= prefixPtrtarget >= prefixIdxLZ4HC_init_internalnewStartingOffset"LZ4HC_init_internal"newStartingOffset >= bufferSizeLZ4HC_clearTableshc4->hashTablesizeof(hc4->hashTable)(hc4->hashTable)(sizeof(hc4->hashTable))hc4->chainTablesizeof(hc4->chainTable)(hc4->chainTable)(0xFF)(sizeof(hc4->chainTable))LZ4HC_hashPtrLZ4_read32(ptr)LZ4HC_optimal_tLZ4HC_match_tHCfavor_erepeat_state_edictCtx_directivetargetLengthstrat(*_anchor)(*_op)(*_ip)LZ4HC_rotl32(x,r)UPDATABLE(ip,op,anchor)&ip, &op, &anchorDELTANEXTU16(table,pos)table[(U16)(pos)]DELTANEXTMAXD(p)chainTable[(p) & LZ4HC_MAXD_MASK]HASH_FUNCTION(i)(((i) * 2654435761U) >> ((MINMATCH*8)-LZ4HC_HASH_LOG))( (a) > (b) ? (a) : (b) )(int)((ML_MASK-1)+MINMATCH)LZ4HC_HEAPMODEGCC diagnostic ignored "-Wunused-function"defined (__clang__)defined(LZ4_DEBUG) && (LZ4_DEBUG >= 6)defined(LZ4HC_HEAPMODE) && LZ4HC_HEAPMODE==1/* ll validated; now adjust match length *//* restore correct out pointer *//* 2 for offset, 1 for token *//* Assumption : ip, anchor, ovml and ovref must be set correctly *//* can be != iend if limit==fillOutput *//* adapt lastRunSize to fill 'dst' *//* Check output limit *//* restore correct value *//* while (ip <= mflimit) *//* updates ip, op and anchor *//* literal; note: can end up with several literals, in which case, skip them *//* relative position (to ip) *//* encode all recorded sequences in order *//* can be 1, means literal *//* last match elected, first match to encode *//* from end to beginning *//* == 1 when only one candidate *//* cur, last_match_pos, best_mlen, best_off must be set *//* for (cur = 1; cur <= last_match_pos; cur++) *//* literal *//* complete following positions with literals *//* last pos of last match *//* set prices using match at position = cur *//* before match : set price with literals at beginning *//* immediate encoding *//* only test matches of minimum length; slightly faster, but misses a few bytes *//* not useful to search here if next position has same (or lower) cost *//*min seq price*//* in some cases, next position has same cost, but cost rises sharply after, so a small match would still be beneficial *//* check further positions *//* necessarily < sufficient_len < LZ4_OPT_NUM *//* set prices using initial match *//* set prices for first positions (literals) *//* good enough solution : immediate encoding *//* Hack for support LZ4 format restriction *//* overflow - last sequence *//* ~64 KB, which is a bit large for stack... *//* favor shortcut *//*chainSwap*//*patternAnalysis*//* note : LZ4HC_InsertAndGetWiderMatch() is able to modify the starting position of a match (*startpos),
     * but this won't be the case here, as we define iLowLimit==ip,
    ** so LZ4HC_InsertAndGetWiderMatch() won't be allowed to search past ip *//* token + 16-bit offset *//* requires mlen >= MINMATCH *//* price in bytes *//* ================================================
 *  LZ4 Optimal parser (levels [LZ4HC_CLEVEL_OPT_MIN - LZ4HC_CLEVEL_MAX])
 * ===============================================*//* ugly conversion trick, required to evade (const char*) -> (char*) cast-qual warning :( *//* not enough memory *//* init failed *//* state is presumed correctly sized, aka >= sizeof(LZ4_streamHC_t)
 * @return : 0 on success, !=0 if error *//* Deprecated streaming functions *//* Wrappers for deprecated compression functions *//* These functions currently generate deprecation warnings *//***************************************************
*  Deprecated Functions
***************************************************//* LZ4_saveDictHC :
 * save history content
 * into a user-provided buffer
 * which is then used to continue compression
 *//* invalidate dictionary is it's too small *//* cannot reference an extDict and a dictCtx at the same time *//* compression *//* need a full initialization, there are bad side-effects when using resetFast() *//* LZ4_loadDictHC() :
 * LZ4_streamHCPtr is presumed properly initialized *//* just a stub *//* allocation *//**************************************
*  Streaming Functions
**************************************//* init failure *//* state is presumed sized correctly (>= sizeof(LZ4_streamHC_t)) *//* state is presumed correctly initialized,
 * in which case its size and alignment have already been validate *//* ultra mode *//* note : convention is different from lz4frame, maybe something to review *//* Unsupported input size (too large or negative) *//* 12==LZ4HC_CLEVEL_MAX *//*11 *//*10==LZ4HC_CLEVEL_OPT_MIN*//* 2, unused *//* 1, unused *//* 0, unused *//* Assumption : ip, anchor, ml and ref must be set correctly *//* adapt lastRunSize to fill 'dest' *//* let's find a new ML3 *//* ML3 becomes ML2 *//* ML2 becomes ML1 *//*
        * OK, now we have 3 ascending matches;
        * let's write the first one ML1.
        * ip & ref are known; Now decide ml.
        *//* No better match => encode ML1 and ML2 *//* do not search further *//* restore initial Match1 *//* squeezing ML1 between ML0(original ML1) and ML2 *//* first match was skipped at least once *//* No better match => encode ML1 immediately *//* levels 9+ *//* g_debuglog_enable = (pos >= 2228) & (pos <= 2262); *//* only works for single segment *//* LZ4HC_encodeSequence() :
 * @return : 0 if ok,
 *           1 if buffer issue detected *//* note : LZ4HC_InsertAndGetWiderMatch() is able to modify the starting position of a match (*startpos),
     * but this won't be the case here, as we define iLowLimit==ip,
     * so LZ4HC_InsertAndGetWiderMatch() won't be allowed to search past ip *//* while ((matchIndex>=lowestMatchIndex) && (nbAttempts)) *//* follow current chain *//* PA optimization *//* avoid overflow *//* no back possible *//* farthest position in current segment, will find a match of length currentSegmentLength + maybe some back *//* Can only happen if started in the prefix *//* best position, full pattern, might be followed by more match *//* haven't reached this position yet *//* current pattern segment large enough to contain full srcPatternLength *//* Adjust to end of pattern if the source pattern fits, otherwise the beginning of the pattern *//* Limit backLength not go further than lowestMatchIndex *//* good candidate *//* may be a repeated pattern *//* search forward only *//* better match => select a better chain *//* lowestMatchIndex <= matchIndex < dictLimit : within Ext Dict *//* within current Prefix *//* do nothing:
             * favorDecSpeed intentionally skips matches with offset < 8 *//* insert all prior positions up to ip (excluded) *//* in case there is no solution *//* LZ4HC_protectDictEnd() :
 * Checks if the match is in the last 3 bytes of the dictionary, so reading the
 * 4 byte MINMATCH would overflow.
 * @returns true if the match index is okay.
 *//* works for any endianness *//* LZ4HC_reverseCountPattern() :
 * pattern must be a sample of repetitive pattern of length 1, 2 or 4 (but not 3!)
 * read using natural platform endianness *//* big endian *//* LZ4HC_countPattern() :
 * pattern32 must be a sample of repetitive pattern of length 1, 2 or 4 (but not 3!) *//** LZ4HC_countBack() :
 * @return : negative value, nb of common bytes before ip/match *//**************************************
*  HC Compression
**************************************//* Make fields passed to, and updated by LZ4HC_encodeSequence explicit *//* faster *//* flexible, LZ4HC_MAXD dependent *//*===   Macros   ===*//*===   Constants   ===*//*===   Enums   ===*//* LZ4_count, constants, mem *//*===   Common definitions   ===*//*===    Dependency    ===*//*! HEAPMODE :
 *  Select how stateless HC compression functions like `LZ4_compress_HC()`
 *  allocate memory for their workspace:
 *  in stack (0:fastest), or in heap (1:default, requires malloc()).
 *  Since workspace is rather large, heap mode is recommended.
**//* *************************************
*  Tuning Parameter
***************************************//* note : lz4hc is not an independent module, it requires lz4.h/lz4.c for proper compilation *//*
    LZ4 HC - High Compression Mode of LZ4
    Copyright (C) 2011-2020, Yann Collet.

    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
       - LZ4 source repository : https://github.com/lz4/lz4
       - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
*/iLowpattern32rotateiMinmMin__SYSCALL_WORDSIZE__WORDSIZE_TIME64_COMPAT32__WORDSIZEdefined __x86_64__ && !defined __ILP32__/* Both x86-64 and x32 use the 64-bit system call interface.  *//* Determine the wordsize from the preprocessor defines.  */__TIMESIZE/* For others, time size is word size.  *//* For x32, time is 64-bit even though word size is 32-bit.  *//* Bit size of the time_t type at glibc build time, x86-64 and x32 case.
   Copyright (C) 2018-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/timesize.h>defined _TIME_BITS_TIME_BITS == 64! defined (_FILE_OFFSET_BITS) || _FILE_OFFSET_BITS != 64__TIMESIZE == 32_TIME_BITS == 32__TIMESIZE > 32/* We need to know the word size in order to check the time size.  *//* Features part to handle 64-bit time_t support.
   Copyright (C) 2021-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */_STDC_PREDEF_H__GCC_IEC_559__GCC_IEC_559 > 0__GCC_IEC_559_COMPLEX__GCC_IEC_559_COMPLEX > 0/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters *//* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  *//* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI/* long double is distinct from double, so there is nothing to
   define here.  *//* Properties of long double type.  ldbl-96 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License  published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/long-double.h>__attribute_returns_twice____attribute__ ((__returns_twice__))__attr_dealloc_free__attr_dealloc (__builtin_free, 1)__attr_dealloc(dealloc,argno)__attribute__ ((__malloc__ (dealloc, argno)))__attr_access_none(argno)__attribute__ ((__access__ (__none__, argno)))__fortified_attr_access(a,o,s)__attr_access ((a, o, s))__attr_access(x)__attribute__ ((__access__ x))__glibc_macro_warning(message)__glibc_macro_warning1 (GCC warning message)__glibc_macro_warning1(message)_Pragma (#message)__REDIRECT_NTH_LDBL(name,proto,alias)__REDIRECT_NTH (name, proto, alias)__REDIRECT_LDBL(name,proto,alias)__REDIRECT (name, proto, alias)__LDBL_REDIR_DECL(name)__LDBL_REDIR2_DECL(name)__LDBL_REDIR_NTH(name,proto)name proto __THROW__LDBL_REDIR1_NTH(name,proto,alias)__LDBL_REDIR(name,proto)name proto__LDBL_REDIR1(name,proto,alias)__attribute_copy__(arg)__attribute__ ((__copy__ (arg)))__attribute_copy____attribute_nonstring____attribute__ ((__nonstring__))__glibc_likely(cond)__builtin_expect ((cond), 1)__glibc_unlikely(cond)__builtin_expect ((cond), 0)__restrict_arr__restrict__va_arg_pack_len()__builtin_va_arg_pack_len ()__va_arg_pack()__builtin_va_arg_pack ()__fortify_function__extern_always_inline __attribute_artificial____extern_always_inlineextern __always_inline __attribute__ ((__gnu_inline__))extern __inline __attribute__ ((__gnu_inline__))__attribute_artificial____attribute__ ((__artificial__))__always_inline__inline __attribute__ ((__always_inline__))__wur__attribute_warn_unused_result____attribute__ ((__warn_unused_result__))__returns_nonnull__attribute__ ((__returns_nonnull__))__nonnull(params)__attribute_nonnull__ (params)__attribute_nonnull__(params)__attribute__ ((__nonnull__ params))__attribute_format_strfmon__(a,b)__attribute__ ((__format__ (__strfmon__, a, b)))__attribute_format_arg__(x)__attribute__ ((__format_arg__ (x)))__attribute_deprecated_msg__(msg)__attribute__ ((__deprecated__ (msg)))__attribute_deprecated____attribute__ ((__deprecated__))__attribute_noinline____attribute__ ((__noinline__))__attribute_used____attribute__ ((__used__))__attribute_maybe_unused____attribute__ ((__unused__))__attribute_const____attribute__ ((__const__))__attribute_pure____attribute__ ((__pure__))__attribute_alloc_align__(param)__attribute__ ((__alloc_align__ param))__attribute_alloc_size__(params)__attribute__ ((__alloc_size__ params))__attribute_malloc____attribute__ ((__malloc__))__ASMNAME2(prefix,cname)__STRING (prefix) cname__ASMNAME(cname)__ASMNAME2 (__USER_LABEL_PREFIX__, cname)__REDIRECT_NTHNL(name,proto,alias)name proto __asm__ (__ASMNAME (#alias)) __THROWNL__REDIRECT_NTH(name,proto,alias)name proto __asm__ (__ASMNAME (#alias)) __THROW__REDIRECT(name,proto,alias)name proto __asm__ (__ASMNAME (#alias))__glibc_c99_flexarr_available__flexarr[]__errordecl(name,msg)extern void name (void) __attribute__((__error__ (msg)))__warnattr(msg)__attribute__((__warning__ (msg)))__glibc_fortify_n(f,__l,__s,__osz,__VA_ARGS__...)(__glibc_safe_or_unknown_len (__l, __s, __osz) ? __ ## f ## _alias (__VA_ARGS__) : (__glibc_unsafe_len (__l, __s, __osz) ? __ ## f ## _chk_warn (__VA_ARGS__, (__osz) / (__s)) : __ ## f ## _chk (__VA_ARGS__, (__osz) / (__s))))__glibc_fortify(f,__l,__s,__osz,__VA_ARGS__...)(__glibc_safe_or_unknown_len (__l, __s, __osz) ? __ ## f ## _alias (__VA_ARGS__) : (__glibc_unsafe_len (__l, __s, __osz) ? __ ## f ## _chk_warn (__VA_ARGS__, __osz) : __ ## f ## _chk (__VA_ARGS__, __osz)))__glibc_unsafe_len(__l,__s,__osz)(__glibc_unsigned_or_positive (__l) && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz)) && !__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz))__glibc_safe_or_unknown_len(__l,__s,__osz)((__builtin_constant_p (__osz) && (__osz) == (__SIZE_TYPE__) -1) || (__glibc_unsigned_or_positive (__l) && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), (__s), (__osz))) && __glibc_safe_len_cond ((__SIZE_TYPE__) (__l), (__s), (__osz))))__glibc_unsigned_or_positive(__l)((__typeof (__l)) 0 < (__typeof (__l)) -1 || (__builtin_constant_p (__l) && (__l) > 0))__glibc_safe_len_cond(__l,__s,__osz)((__l) <= (__osz) / (__s))__glibc_objsize(__o)__bos (__o)__glibc_objsize0(__o)__bos0 (__o)__bos0(ptr)__builtin_object_size (ptr, 0)__bos(ptr)__builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)__END_DECLS__BEGIN_DECLS__ptr_t__STRING(x)#x__CONCAT(x,y)x ## y__PMT(args)args__P(args)__NTHNL(fct)__attribute__ ((__nothrow__)) fct__NTH(fct)__attribute__ ((__nothrow__ __LEAF)) fct__THROWNL__attribute__ ((__nothrow__))__THROW__attribute__ ((__nothrow__ __LEAF))__LEAF_ATTR__attribute__ ((__leaf__))__LEAF, __leaf____glibc_has_extension(ext)__has_extension (ext)__glibc_has_builtin(name)__has_builtin (name)__glibc_has_attribute(attr)__has_attribute (attr)__PMTdefined __GNUC__ && !defined __STDC__ && !defined __cplusplus(defined __has_attribute \__has_extensiondefined __GNUC__ || defined __clang____GNUC_PREREQ (4, 6) && !defined _LIBC!defined __cplusplus \defined __cplusplus && (__GNUC_PREREQ (2,8) || __clang_major >= 4)(defined __cplusplus						\__USE_FORTIFY_LEVEL == 3 && (__glibc_clang_prereq (9, 0)		      \__GNUC_PREREQ (4,3)defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L && !defined __HP_cc__GNUC_PREREQ (2,97) || defined __clang__defined __GNUC__(defined __GNUC__ && __GNUC__ >= 2) || (__clang_major__ >= 4)!(defined __GNUC__ || defined __clang__)__GNUC_PREREQ (2,96) || __glibc_has_attribute (__malloc__)__GNUC_PREREQ (4, 3)__GNUC_PREREQ (4, 9) || __glibc_has_attribute (__alloc_align__)__GNUC_PREREQ (2,96) || __glibc_has_attribute (__pure__)__GNUC_PREREQ (2,5) || __glibc_has_attribute (__const__)__GNUC_PREREQ (2,7) || __glibc_has_attribute (__unused__)__GNUC_PREREQ (3,1) || __glibc_has_attribute (__used__)__GNUC_PREREQ (3,2) || __glibc_has_attribute (__deprecated__)__GNUC_PREREQ (4,5) \__GNUC_PREREQ (2,8) || __glibc_has_attribute (__format_arg__)__GNUC_PREREQ (2,97) || __glibc_has_attribute (__format__)__attribute_nonnull____GNUC_PREREQ (3,3) || __glibc_has_attribute (__nonnull__)__nonnull__GNUC_PREREQ (4, 9) || __glibc_has_attribute (__returns_nonnull__)__GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)defined __USE_FORTIFY_LEVEL && __USE_FORTIFY_LEVEL > 0__GNUC_PREREQ (3,2) || __glibc_has_attribute (__always_inline__)__GNUC_PREREQ (4,3) || __glibc_has_attribute (__artificial__)(!defined __cplusplus || __GNUC_PREREQ (4,3) \defined __GNUC_STDC_INLINE__ || defined __cplusplus!(__GNUC_PREREQ (2,8) || defined __clang__)!(__GNUC_PREREQ (2,92) || __clang_major__ >= 3)(__GNUC_PREREQ (3,1) || __clang_major__ >= 3) && !defined __cplusplus(__GNUC__ >= 3) || __glibc_has_builtin (__builtin_expect)(!defined _Noreturn \__GNUC_PREREQ (2,8)__GNUC_PREREQ (8, 0)__GNUC_PREREQ (9, 0)(!defined _Static_assert && !defined __cplusplus \__GNULIB_CDEFSdefined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH(!defined __LDBL_COMPAT && __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 0) \__GNUC_PREREQ (4,8) || __glibc_clang_prereq (3,5)__GNUC_PREREQ (10, 0)__USE_FORTIFY_LEVEL == 3__GNUC_PREREQ (4, 1)c_generic_selections__GNUC_STDC_INLINE____artificial____always_inline____warn_unused_result____returns_nonnull____nonnull____format____format_arg____attribute_deprecated_with_message____deprecated____used____unused____const____pure____alloc_align____malloc____nothrow____STDC__/* sys/cdefs.h *//* Ignore.  *//* Specify that a function such as setjmp or vfork may return
   twice.  *//* Designates dealloc as a function to call to deallocate objects
   allocated by the declared function.  *//* For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
   use the access attribute to get object sizes from function definition
   arguments, so we can't use them on functions we fortify.  Drop the object
   size hints for such functions.  *//* Designates a 1-based positional argument ref-index of pointer type
   that can be used to access size-index elements of the pointed-to
   array according to access mode, or at least one element when
   size-index is not provided:
     access (access-mode, <ref-index> [, <size-index>])  *//* Generic selection (ISO C11) is a C-only feature, available in GCC
   since version 4.9.  Previous versions do not provide generic
   selection, even though they might set __STDC_VERSION__ to 201112L,
   when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
   when testing __STDC_VERSION__ for generic selection support.
   On the other hand, Clang also defines __GNUC__, so a clang-specific
   check is required to enable the use of generic selection.  *//* __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
   intended for use in preprocessor macros.

   Note: MESSAGE must be a _single_ string; concatenation of string
   literals is not supported.  *//* Unused.  *//* Alias name defined manually.  *//* Alias name defined automatically, with leading underscores.  *//* Alias name defined automatically.  *//* Gnulib avoids including these, as they don't work on non-glibc or
   older glibc platforms.  *//* Copies attributes from the declaration or type referenced by
   the argument.  *//* Undefine (also defined in libc-symbols.h).  *//* Describes a char array whose address can safely be passed as the first
   argument to strncpy and strncat, as the char array is not necessarily
   a NUL-terminated string.  *//* Not supported.  *//* Some other non-C99 compiler.  *//* Not supported in old GCC.  *//* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 and clang support this.
   This syntax is not usable in C++ mode.  *//* Ignore *//* __restrict is known in EGCS 1.2 and above, and in clang.
   It works also in C++ mode (outside of arrays), but only when spelled
   as '__restrict', not 'restrict'.  *//* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  *//* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  *//* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
   or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
   older than 4.3 may define these macros and still not guarantee GNU inlining
   semantics.

   clang++ identifies itself as gcc-4.2, but has support for GNU inlining
   semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
   __GNUC_GNU_INLINE__ macro definitions.  *//* Associate error messages with the source location of the call site rather
   than with the source location inside the function.  *//* The Linux kernel defines __always_inline in stddef.h (283d7573), and
   it conflicts with this definition.  Therefore undefine it first to
   allow either header to be included first.  *//* Forces a function to be always inlined.  *//* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  *//* The returns_nonnull function attribute marks the return type of the function
   as always being non-null.  *//* The nonnull function attribute marks pointer parameters that
   must not be NULL.  This has the name __nonnull in glibc,
   and __attribute_nonnull__ in files shared with Gnulib to avoid
   collision with a different __nonnull in DragonFlyBSD 5.9.  *//* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  *//* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  *//* Since version 4.5, gcc also allows one to specify the message printed
   when a deprecated function is used.  clang claims to be gcc 4.2, but
   may also support this feature.  *//* Since version 3.2, gcc allows marking deprecated functions.  *//* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  *//* This declaration tells the compiler that the value is constant.  *//* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  *//* Tell the compiler which argument to an allocation function
   indicates the alignment of the allocation.  *//* Tell the compiler which arguments to an allocation function
   indicate the size of the allocation.  *//* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  *//* GCC and clang have various useful declarations that can be made with
   the '__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it.  *//*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; \
	_Pragma("let " #name " = " #alias)
*//* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); *//* Some other non-C99 compiler.  Approximate with [1].  *//* Pre-2.97 GCC did not support C99 flexible arrays but did have
   an equivalent extension with slightly different notation.  *//* GCC 2.97 and clang support C99 flexible array members as an extension,
   even when in C89 mode or compiling C++ (any version).  *//* Support for flexible arrays.
   Headers that should use flexible arrays only if they're "real"
   (e.g. only if they won't affect sizeof()) should test
   #if __glibc_c99_flexarr_available.  *//* Fortify function f, where object size argument passed to f is the number of
   elements and not total size.  *//* Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
   declared.  *//* Conversely, we know at compile time that the length is unsafe if the
   __L * __S <= __OBJSZ condition can be folded to a constant and if it is
   false.  *//* Length is known to be safe at compile time if the __L * __S <= __OBJSZ
   condition can be folded to a constant and if it is true, or unknown (-1) *//* Compile time conditions to choose between the regular, _chk and _chk_warn
   variants.  These conditions should get evaluated to constant and optimized
   away.  *//* Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.  *//* Fortify support.  *//* C++ needs to know that types and declarations are C, not C++.  *//* This is not a typedef so `const __ptr_t' does the right thing.  *//* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  *//* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  *//* GCC || clang.  *//* No inline functions.  *//* Not GCC or clang.  *//* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this only works with
   gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  *//* All functions, except those with callbacks or those that
   synchronize memory, are leaf functions.  *//* Compilers that lack __has_attribute may object to
       #if defined __has_attribute && __has_attribute (...)
   even though they do not need to evaluate the right-hand side of the &&.
   Similarly for __has_builtin, etc.  *//* Some user header file might have defined this before.  *//* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   supported anymore.  *//* We are almost always included from features.h. *//* Copyright (C) 1992-2022 Free Software Foundation, Inc.
   Copyright The GNU Toolchain Authors.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__stub_stty__stub_sigreturn__stub_setlogin__stub_revoke__stub_gtty__stub_fchflags__stub_chflags__stub___compat_bdflush_LIBC/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  *//usr/include/gnu<gnu/stubs-64.h>!defined __x86_64__defined __x86_64__ && defined __LP64__/* This file is automatically generated.
   This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */__NO_INLINE____WCOREFLAG__W_CONTINUED0xffff__W_STOPCODE(sig)((sig) << 8 | 0x7f)__W_EXITCODE(ret,sig)((ret) << 8 | (sig))__WCOREDUMP(status)((status) & __WCOREFLAG)__WIFCONTINUED(status)((status) == __W_CONTINUED)__WIFSTOPPED(status)(((status) & 0xff) == 0x7f)__WIFSIGNALED(status)(((signed char) (((status) & 0x7f) + 1) >> 1) > 0)__WIFEXITED(status)(__WTERMSIG(status) == 0)__WSTOPSIG(status)__WEXITSTATUS(status)__WTERMSIG(status)((status) & 0x7f)(((status) & 0xff00) >> 8)/* Macros for constructing status values.  *//* Nonzero if STATUS indicates the child dumped core.  *//* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  *//* Nonzero if STATUS indicates the child is stopped.  *//* Nonzero if STATUS indicates termination by a signal.  *//* Nonzero if STATUS indicates normal termination.  *//* If WIFSTOPPED(STATUS), the signal that stopped the child.  *//* If WIFSIGNALED(STATUS), the terminating signal.  *//* If WIFEXITED(STATUS), the low-order 8 bits of the status.  *//* Everything extant so far uses these same bits.  *//* Definitions of status bits for `wait' et al.
   Copyright (C) 1992-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__CFLOAT64X_Complex _Float64x__CFLOAT32X_Complex _Float32x__CFLOAT64_Complex _Float64__CFLOAT32_Complex _Float32__f64x(x)x ## f64x__f32x(x)x ## f32x__f64(x)x ## f64__f32(x)x ## f32(__HAVE_DISTINCT_FLOAT128 && __LDBL_MANT_DIG__ != 113)_BITS_FLOATN_COMMON_H__GNUC_PREREQ (7, 0) && !defined __cplusplus!__GNUC_PREREQ (7, 0) || defined __cplusplus!__GNUC_PREREQ (7, 0)/* _BITS_FLOATN_COMMON_H *//* !__ASSEMBLER__.  *//* If double, long double and _Float64 all have the same set of
   values, TS 18661-3 requires the usual arithmetic conversions on
   long double and _Float64 to produce _Float64.  For this to be the
   case when building with a compiler without a distinct _Float64
   type, _Float64 must be a typedef for long double, not for
   double.  *//* The remaining of this file provides support for older compilers.  *//* Defined to a complex type if __HAVE_<type> is 1.  *//* No corresponding suffix available for this type.  *//* Defined to concatenate the literal suffix to be used with _FloatN
   or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
   literal suffixes exist since GCC 7, for C only.  *//* Defined to 1 if any _FloatN or _FloatNx types that are not
   ABI-distinct are however distinct types at the C language level (so
   for the purposes of __builtin_types_compatible_p and _Generic).  *//* Defined to 1 if the corresponding _FloatN type is not binary compatible
   with the corresponding ISO C type in the current compilation unit as
   opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
   in glibc.  *//* Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
   type is the first with its format in the sequence of (the default
   choices for) float, double, long double, _Float16, _Float32,
   _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
   glibc; that is, if functions present once per floating-point format
   rather than once per type are present for this type.

   All configurations supported by glibc have _Float32 the same format
   as float, _Float64 and _Float32x the same format as double, the
   _Float64x the same format as either long double or _Float128.  No
   configurations support _Float128x or, as of GCC 7, have compiler
   support for a type meeting the requirements for _Float128x.  *//* Defined to 1 if the current compiler invocation provides a
   floating-point type with the right format for this type, and this
   glibc includes corresponding *fN or *fNx interfaces for it.  *//* This header should be included at the bottom of each bits/floatn.h.
   It defines the following macros for each _FloatN and _FloatNx type,
   where the same definitions, or definitions based only on the macros
   in bits/floatn.h, are appropriate for all glibc configurations.  *//* Macros to control TS 18661-3 glibc features where the same
   definitions are appropriate for all platforms.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/floatn-common.h>__CFLOAT128_Complex _Float128__f128(x)x ## f128_BITS_FLOATN_H(defined __x86_64__							\!__GNUC_PREREQ (6, 0)/* _BITS_FLOATN_H *//* In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
   e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
   been a __builtin_signbitf128 in GCC and the type-generic builtin is
   only available since GCC 6.  *//* Older GCC has only a subset of built-in functions for _Float128 on
   x86, and __builtin_infq is not usable in static initializers.
   Converting a narrower sNaN to _Float128 produces a quiet NaN, so
   attempts to use _Float128 sNaNs will not work properly with older
   compilers.  *//* __builtin_huge_valf128 doesn't exist before GCC 7.0.  *//* The type _Float128 exists only since GCC 7.0.  *//* Add a typedef for older GCC compilers which don't natively support
   _Complex _Float128.  *//* Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.  *//* The literal suffix f128 exists only since GCC 7.0.  *//* Defined to concatenate the literal suffix to be used with _Float128
   types, if __HAVE_FLOAT128 is 1. *//* Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
   of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
   the format of _Float128, which must be different from that of long
   double.  *//* Defined to 1 if the current compiler invocation provides a
   floating-point type with the right format for _Float64x, and this
   glibc includes corresponding *f64x interfaces for it.  *//* Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
   from the default float, double and long double types in this glibc.  *//* Defined to 1 if the current compiler invocation provides a
   floating-point type with the IEEE 754 binary128 format, and this
   glibc includes corresponding *f128 interfaces for it.  The required
   libgcc support was added some time after the basic compiler
   support, for x86_64 and x86.  *//* Macros to control TS 18661-3 glibc features on x86.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64__STATFS_MATCHES_STATFS64__RLIM_T_MATCHES_RLIM64_T__INO_T_MATCHES_INO64_T__OFF_T_MATCHES_OFF64_T__CPU_MASK_TYPE__SYSCALL_ULONG_TYPE__SSIZE_T_TYPE__SWORD_TYPE__FSID_T_TYPEstruct { int __val[2]; }__BLKSIZE_T_TYPE__SYSCALL_SLONG_TYPE__TIMER_T_TYPE__CLOCKID_T_TYPE__S32_TYPE__KEY_T_TYPE__DADDR_T_TYPE__SUSECONDS64_T_TYPE__SQUAD_TYPE__SUSECONDS_T_TYPE__USECONDS_T_TYPE__U32_TYPE__TIME_T_TYPE__CLOCK_T_TYPE__ID_T_TYPE__FSFILCNT64_T_TYPE__UQUAD_TYPE__FSFILCNT_T_TYPE__FSBLKCNT64_T_TYPE__FSBLKCNT_T_TYPE__BLKCNT64_T_TYPE__BLKCNT_T_TYPE__RLIM64_T_TYPE__RLIM_T_TYPE__PID_T_TYPE__OFF64_T_TYPE__OFF_T_TYPE__FSWORD_T_TYPE__NLINK_T_TYPE__MODE_T_TYPE__INO64_T_TYPE__INO_T_TYPE__GID_T_TYPE__UID_T_TYPE__DEV_T_TYPE__ULONGWORD_TYPE__SLONGWORD_TYPE_BITS_TYPESIZES_H_BITS_TYPES_H/* bits/typesizes.h *//* Number of descriptors that can fit in an `fd_set'.  *//* And for getitimer, setitimer and rusage  *//* And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.  *//* And for __rlim_t and __rlim64_t.  *//* Same for ino_t and ino64_t.  *//* Tell the libc code that off_t and off64_t are actually the same type
   for all ABI purposes, even if possibly expressed as different base types
   for C type-checking purposes.  *//* X32 kernel interface is 64-bit.  *//* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  *//* bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
   Copyright (C) 2012-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__TIME64_T_TYPE_BITS_TIME64_H__TIMESIZE == 64/* bits/time64.h *//* Define a 64-bit time type alongsize the 32-bit one.  *//* If we already have 64-bit time type then use it.  *//* Define __TIME64_T_TYPE so that it is always a 64-bit type.  *//* bits/time64.h -- underlying types for __time64_t.  Generic version.
   Copyright (C) 2018-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/time64.h><bits/typesizes.h>__sig_atomic_t__socklen_t__intptr_t__caddr_t__loff_t__syscall_ulong_t__syscall_slong_t__ssize_t__fsword_t__fsfilcnt64_t__fsfilcnt_t__fsblkcnt64_t__fsblkcnt_t__blkcnt64_t__blkcnt_t__blksize_t__timer_t__clockid_t__key_t__daddr_t__suseconds64_t__suseconds_t__useconds_t__time_t__id_t__rlim64_t__rlim_t__clock_t__fsid_t__pid_t__off64_t__off_t__nlink_t__mode_t__ino64_t__ino_t__gid_t__uid_t__dev_t__uintmax_t__intmax_t__u_quad_t__quad_t__uint_least64_t__int_least64_t__uint_least32_t__int_least32_t__uint_least16_t__int_least16_t__uint_least8_t__int_least8_t__uint64_t__int64_t__uint32_t__int32_t__uint16_t__int16_t__uint8_t__int8_t__u_long__u_int__u_short__u_char__val__STD_TYPEtypedef__U64_TYPEunsigned long int__S64_TYPE__ULONG32_TYPE__SLONG32_TYPE__UWORD_TYPE__U16_TYPEunsigned short int__S16_TYPEshort int__TIMESIZE == 64 && defined __LIBC__TIMESIZE != 64/* bits/types.h *//* Seconds since the Epoch, visible to user code when time_t is too
   narrow only for consistency with the old way of widening too-narrow
   types.  User code should never use __time64_t.  *//* C99: An integer type that can be accessed as an atomic entity,
   even in the presence of asynchronous interrupts.
   It is not currently necessary for this to be machine-specific.  *//* Duplicate info from sys/socket.h.  *//* Duplicates info from stdint.h but this is used in unistd.h.  *//* Type of file sizes and offsets (LFS).  *//* These few don't really vary by system, they always correspond
   to one of the other defined types.  *//* Unsigned long type used in system calls.  *//* Signed long type used in system calls.  *//* Type of a byte count, or error.  *//* Type of miscellaneous file system fields.  *//* Type to count file system nodes.  *//* Type to represent block size.  *//* Timer ID returned by `timer_create'.  *//* Clock ID used in clock and timer functions.  *//* Type of an IPC key.  *//* The type of a disk address.  *//* Signed count of microseconds.  *//* Count of microseconds.  *//* Seconds since the Epoch.  *//* General type for IDs.  *//* Type for resource measurement (LFS).  *//* Type for resource measurement.  *//* Type of CPU usage counts.  *//* Type of file system IDs.  *//* Type of process identifications.  *//* Type of file sizes and offsets.  *//* Type of file link counts.  *//* Type of file attribute bitmasks.  *//* Type of file serial numbers (LFS).*//* Type of file serial numbers.  *//* Type of group identifications.  *//* Type of user identifications.  *//* Type of device numbers.  *//* Defines __TIME*_T_TYPE macros.  *//* Defines __*_T_TYPE macros.  *//* No need to mark the typedef with __extension__.   *//* We want __extension__ before typedef's that use nonstandard base types
   such as `long long' in C89 mode.  *//* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, traditionally long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  *//* quad_t is also 64 bits.  *//* Smallest types with at least a given width.  *//* Fixed-size types, underlying types depend on word size and compiler.  *//* Convenience types.  *//*
 * Never include this file directly; use <sys/types.h> instead.
 *//* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */clock_t__clock_t_defined/* Returned by `clock'.  */clockid_t__clockid_t_definedtime_t__time_t_defined/* Returned by `time'.  */timer_t__timer_t_definedint64_tint32_tint16_tint8_t_BITS_STDINT_INTN_H/* bits/stdint-intn.h *//* Define intN_t types.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__BYTE_ORDER__LITTLE_ENDIAN_BITS_ENDIANNESS_H_BITS_ENDIAN_H/* bits/endianness.h *//* i386/x86_64 are little-endian.  */<bits/endianness.h>__LONG_LONG_PAIR(HI,LO)LO, HI__FLOAT_WORD_ORDER__PDP_ENDIAN3412__BIG_ENDIAN__BYTE_ORDER == __LITTLE_ENDIAN__BYTE_ORDER == __BIG_ENDIAN/* bits/endian.h *//* Some machines may need to use a different endianness for floating point
   values.  *//* This file defines `__BYTE_ORDER' for the particular machine.  *//* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  *//* Endian macros for string.h functions
   Copyright (C) 1992-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */__bswap_64__bswap_32__bswap_16__bswap_constant_64(x)((((x) & 0xff00000000000000ull) >> 56) | (((x) & 0x00ff000000000000ull) >> 40) | (((x) & 0x0000ff0000000000ull) >> 24) | (((x) & 0x000000ff00000000ull) >> 8) | (((x) & 0x00000000ff000000ull) << 8) | (((x) & 0x0000000000ff0000ull) << 24) | (((x) & 0x000000000000ff00ull) << 40) | (((x) & 0x00000000000000ffull) << 56))__bswap_constant_32(x)((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >> 8) | (((x) & 0x0000ff00u) << 8) | (((x) & 0x000000ffu) << 24))__bswap_constant_16(x)((__uint16_t) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))_BITS_BYTESWAP_H!defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H__GNUC_PREREQ (4, 8)/* _BITS_BYTESWAP_H *//* Swap bytes in 64-bit value.  *//* Swap bytes in 32-bit value.  *//* Swap bytes in 16-bit value.  *//* Macros and inline functions to swap the order of bytes in integer values.
   Copyright (C) 1997-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__bsx__uint64_identity__uint32_identity__uint16_identity_BITS_UINTN_IDENTITY_H!defined _NETINET_IN_H && !defined _ENDIAN_H/* _BITS_UINTN_IDENTITY_H.  *//* These inline functions are to ensure the appropriate type
   conversions and associated diagnostics from macros that convert to
   a given endianness.  *//* Inline functions to return unsigned integer values unchanged.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/uintn-identity.h><bits/byteswap.h>le64toh(x)__uint64_identity (x)be64toh(x)__bswap_64 (x)htole64(x)htobe64(x)le32toh(x)__uint32_identity (x)be32toh(x)__bswap_32 (x)htole32(x)htobe32(x)le16toh(x)__uint16_identity (x)be16toh(x)__bswap_16 (x)htole16(x)htobe16(x)BYTE_ORDERPDP_ENDIANBIG_ENDIANLITTLE_ENDIAN_ENDIAN_Hdefined __USE_MISC && !defined __ASSEMBLER__/* endian.h *//* Conversion interfaces.  *//* Get the definitions of __*_ENDIAN, __BYTE_ORDER, and __FLOAT_WORD_ORDER.  */__FD_ISSET(d,s)((__FDS_BITS (s)[__FD_ELT (d)] & __FD_MASK (d)) != 0)__FD_CLR(d,s)((void) (__FDS_BITS (s)[__FD_ELT(d)] &= ~__FD_MASK(d)))__FD_SET(d,s)((void) (__FDS_BITS (s)[__FD_ELT(d)] |= __FD_MASK(d)))__FD_ZERO(s)do { unsigned int __i; fd_set *__arr = (s); for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i) __FDS_BITS (__arr)[__i] = 0; } while (0)/* We don't use `memset' because this would require a prototype and
   the array isn't too big.  */__sigset_t_SIGSET_NWORDS(1024 / (8 * sizeof (unsigned long int)))____sigset_t_definedsigset_t__sigset_t_defined/* A set of signals to be blocked, unblocked, or waited for.  */timevaltv_usectv_sec__timeval_defined/* Microseconds.  *//* Seconds.  *//* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */timespectv_nsec_STRUCT_TIMESPEC__WORDSIZE == 64 \/* Padding.  *//* Nanoseconds.  *//* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  *//* NB: Include guard matches what <linux/time.h> uses.  */__ONCE_ALIGNMENT__LOCK_ALIGNMENT_BITS_PTHREADTYPES_ARCH_H/* bits/pthreadtypes.h *//* Extra attributes for the cleanup functions.  */__atomic_wide_counter__value32__value64__high__low_BITS_ATOMIC_WIDE_COUNTER_H/* _BITS_ATOMIC_WIDE_COUNTER_H *//* Counter that is monotonically increasing (by less than 2**31 per
   increment), with a single writer, and an arbitrary number of
   readers.  *//* Monotonically increasing wide counters (at least 62 bits).
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__pthread_mutex_s__elision__spins__nusers__PTHREAD_MUTEX_INITIALIZER(__kind)0, 0, 0, 0, __kind, 0, 0, { 0, 0 }__PTHREAD_MUTEX_HAVE_PREV_THREAD_MUTEX_INTERNAL_H/* KIND must stay at this position in the structure to maintain
     binary compatibility with static initializers.  *//* x86 internal mutex struct definitions.
   Copyright (C) 2019-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */__pthread_rwlock_arch_t__pad2unsigned char[7]__pad1__rwelision__shared__cur_writer__pad4__pad3__writers_futex__wrphase_futex__writers__readers__PTHREAD_RWLOCK_INITIALIZER(__flags)0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, __flags__PTHREAD_RWLOCK_ELISION_EXTRA0, { 0, 0, 0, 0, 0, 0, 0 }_RWLOCK_INTERNAL_H/* FLAGS must stay at this position in the structure to maintain
     binary compatibility.  *//* x86 internal rwlock struct definitions.
   Copyright (C) 2019-2022 Free Software Foundation, Inc.

   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */<bits/struct_rwlock.h><bits/struct_mutex.h><bits/atomic_wide_counter.h><bits/pthreadtypes-arch.h>__once_flag__thrd_t__tss_t__pthread_cond_s__pthread_slist_t__pthread_internal_slist__pthread_list_t__pthread_internal_list__g_signals__wrefs__g1_orig_size__g_size__g_refs__g1_start__wseq__pthread_internal_slist *__next__pthread_internal_list *__ONCE_FLAG_INIT{ 0 }_THREAD_SHARED_TYPES_H/* _THREAD_SHARED_TYPES_H  *//* Common definition of pthread_cond_t. *//* Arch-sepecific read-write lock definitions.  A generic implementation is
   provided by struct_rwlock.h.  If required, an architecture can override it
   by defining:

   1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
      It should contain at least the internal members defined in the
      generic version.

   2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
      It should initialize the rwlock internal type.  *//* Arch-specific mutex definitions.  A generic implementation is provided
   by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
   can override it by defining:

   1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
      definition).  It should contains at least the internal members
      defined in the generic version.

   2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
      atomic operations.

   3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
      It should initialize the mutex internal flag.  *//* Common definition of pthread_mutex_t. *//* Arch-specific definitions.  Each architecture must define the following
   macros to define the expected sizes of pthread data types:

   __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
   __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
   __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
   __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
   __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
   __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
   __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
   __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
   __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.

   The additional macro defines any constraint for the lock alignment
   inside the thread structures:

   __LOCK_ALIGNMENT - for internal lock/futex usage.

   Same idea but for the once locking primitive:

   __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.  *//* Common threading primitives definitions for both POSIX and C11.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */allocaalloca(size)__builtin_alloca (size)_ALLOCA_H/* alloca.h *//* GCC.  *//* Allocate a block that will be freed when the calling function exits.  *//* Remove any previous definition.  */__locale_struct *__locale_t__locale_struct__locale_dataconst char *[13]char *[13]__names__ctype_toupper__ctype_tolowerconst unsigned shortconst unsigned short *__ctype_b__locale_data *__locale_data *[13]__locales_BITS_TYPES___LOCALE_T_H/* bits/types/__locale_t.h *//* Note: LC_ALL is not a valid index into this array.  *//* To increase the speed of this solution we add some special members.  *//* 13 = __LC_LAST. *//* POSIX.1-2008: the locale_t type, representing a locale context
   (implementation-namespace version).  This type should be treated
   as opaque by applications; some details are exposed for the sake of
   efficiency in e.g. ctype functions.  *//* Definition of struct __locale_struct and __locale_t.
   Copyright (C) 1997-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/types/__locale_t.h>locale_t_BITS_TYPES_LOCALE_T_H/* bits/types/locale_t.h *//* Definition of locale_t.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__assert__assert_perror_fail__assert_fail__ASSERT_FUNCTION__extension__ __PRETTY_FUNCTION__((void) sizeof ((expr) ? 1 : 0), __extension__ ({ if (expr) ; else __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION); }))__assertion__line__function/home/atharvakale/390r-debugging-setup/p7zip/C/lz4/lib/xxhash.cXXH_sasizeof(state.reserved)sizeof(state) - sizeof(state.reserved)XXH64_finalizechar[64]806const char[15]__PRETTY_FUNCTION__XXH64_avalancheXXH32_finalize346XXH32_avalanche605XXH_isLittleEndianPROCESS8_64{ U64 const k1 = XXH64_round(0, XXH_get64bits(p)); p+=8; h64 ^= k1; h64 = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; }PROCESS4_64h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1; p+=4; h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;PROCESS1_64h64 ^= (*p++) * PRIME64_5; h64 = XXH_rotl64(h64, 11) * PRIME64_1;PROCESS4h32 += XXH_get32bits(p) * PRIME32_3; p+=4; h32 = XXH_rotl32(h32, 17) * PRIME32_4 ;PROCESS1h32 += (*p++) * PRIME32_5; h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;{ enum { XXH_sa = 1/(int)(!!(c)) }; }XXH_isLittleEndian()defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \(defined(__INTEL_COMPILER) && !defined(_WIN32)) || \defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)/*seed*//* do not write into reserved, planned to be removed in a future version *//* unreachable, but some compilers complain without it *//* impossible to reach *//* if compiler doesn't support unsigned long long, replace by another 64-bit type *//* *******************************************************************
*  64-bit hash functions
*********************************************************************//*! Default XXH result types are basic unsigned 32 and 64 bits.
*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
*   These functions allow transformation of hash result into and from its canonical format.
*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
*//* reaching this point is deemed impossible *//* or switch(bEnd - p) *//* mix all bits *//* *******************************************************************
*  32-bit hash functions
*********************************************************************//* assert *//*!XXH_ACCEPT_NULL_INPUT_POINTER :
 * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
 * When this macro is enabled, xxHash actively checks input for null pointer.
 * It it is, result for null input pointers is the same as a null-length input.
 */199901L/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/mem.hMEM_wildCopyMEM_copy8MEM_countsizeof(size_t)-1(sizeof(size_t)-1)MEM_NbCommonBytesMEM_read_ARCHsizeof(r)sizeof(void*)==8COPY8(d,s){ MEM_copy8(d,s); d+=8; s+=8; }MEM_read24(ptr)(U32)(MEM_read32(ptr)<<8)static inline/*static void MEM_wildcopy(void* dst, const void* src, size_t length)
{
    const BYTE* ip = (const BYTE*)src;
    BYTE* op = (BYTE*)dst;
    BYTE* const oend = op + length;
    do
        COPY8(op, ip)
    while (op < oend);
} *//*! MEM_wildcopy : custom version of memcpy(), can copy up to 7-8 bytes too many *//*static unsigned MEM_highbit(U32 val)
{
#   if defined(_MSC_VER)   // Visual 
    unsigned long r=0;
    _BitScanReverse(&r, val);
    return (unsigned)r;
#   elif defined(__GNUC__) && (__GNUC__ >= 3)   // GCC Intrinsic
    return 31 - __builtin_clz(val);
#   else   // Software version 
    static const int DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };
    U32 v = val;
    int r;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    r = DeBruijnClz[(U32)(v * 0x07C4ACDDU) >> 27];
    return r;
#   endif
}*/// MEM_FORCE_MEMORY_ACCESS/* violates C standard on structure alignment.
Only use if no other choice to achieve best performance on target platform *//* MEM_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets generating assembly depending on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//****************************************************************
*  Memory I/O
*****************************************************************//******************************************
*  Compiler-specific
******************************************//******************************************
*  Includes
******************************************//* ******************************************************************
   mem.h
   low-level memory access routines
   Copyright (C) 2013-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
    - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
    - Public forum : https://groups.google.com/forum/#!forum/lz4c
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5.hLZ5_streamDecode_tLZ5_stream_tLZ5_STREAMDECODESIZE_U64long long[131076]131076LZ5_STREAMSIZE_U64LZ5_DEPRECATED(message)LZ5_GCC_VERSIONLZ5_STREAMDECODESIZE(LZ5_STREAMDECODESIZE_U64 * sizeof(unsigned long long))LZ5_STREAMSIZE(LZ5_STREAMSIZE_U64 * sizeof(long long))((1 << (LZ5_MEMORY_USAGE-3)) + 4)LZ5_COMPRESSBOUND(isize)((unsigned)(isize) > (unsigned)LZ5_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/128) + 16)LZ5_MAX_INPUT_SIZELZ5_MEMORY_USAGELZ5HC_MAX_CLEVELLZ5_VERSION_NUMBER(LZ5_VERSION_MAJOR *100*100 + LZ5_VERSION_MINOR *100 + LZ5_VERSION_RELEASE)LZ5_VERSION_RELEASELZ5_VERSION_MINORLZ5_VERSION_MAJORLZ5_VERSION"v1.5.0"LZ5_DISABLE_DEPRECATE_WARNINGS(LZ5_GCC_VERSION >= 405) || defined(__clang__)(LZ5_GCC_VERSION >= 301)LZ5_decompress_fast_withPrefix64k"use LZ5_decompress_fast_usingDict() instead"use LZ5_decompress_fast_usingDict() insteadLZ5_decompress_safe_withPrefix64k"use LZ5_decompress_safe_usingDict() instead"use LZ5_decompress_safe_usingDict() insteadLZ5_slideInputBuffer"use LZ5_saveDict() instead"use LZ5_saveDict() insteadLZ5_resetStreamState"use LZ5_resetStream() instead"use LZ5_resetStream() insteadLZ5_sizeofStreamState"use LZ5_createStream() instead"use LZ5_createStream() insteadLZ5_createLZ5_compress_limitedOutput_continueLZ5_stream_t *LZ5_compress_continueLZ5_compress_limitedOutput_withStateLZ5_compress_withStateLZ5_compress_limitedOutputLZ5_compressLZ5_decompress_fast_usingDictLZ5_decompress_safe_usingDictLZ5_decompress_fast_continueLZ5_streamDecode_t *LZ5_decompress_safe_continueLZ5_setStreamDecodeLZ5_freeStreamDecodeLZ5_createStreamDecodeLZ5_saveDictLZ5_compress_fast_continueLZ5_loadDictLZ5_freeStreamLZ5_createStreamLZ5_resetStreamLZ5_decompress_safe_partialLZ5_decompress_fastLZ5_compress_destSizeLZ5_compress_fast_extStateLZ5_sizeofStateLZ5_compress_fastLZ5_compressBoundLZ5_decompress_safeLZ5_compress_defaultLZ5_versionNumber/* Obsolete streaming decoding functions *//* Obsolete streaming functions; use new streaming interface whenever possible *//* int LZ5_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize); *//* int LZ5_uncompress (const char* source, char* dest, int outputSize); *//* These function names are completely deprecated and must no longer be used.
   They are only provided in lz5.c for compatibility with older programs.
    - LZ5_uncompress is the same as LZ5_decompress_fast
    - LZ5_uncompress_unknownOutputSize is the same as LZ5_decompress_safe
   These function prototypes are now disabled; uncomment them only if you really need them.
   It is highly recommended to stop using these prototypes and migrate to maintained ones *//* Obsolete decompression functions *//* These functions will generate warnings in a future release *//* Obsolete compression functions *//* LZ5_DISABLE_DEPRECATE_WARNINGS *//* Should these warnings messages be a problem,
   it is generally possible to disable them,
   with -Wno-deprecated-declarations for gcc
   or _CRT_SECURE_NO_WARNINGS in Visual for example.
   Otherwise, you can also define LZ5_DISABLE_DEPRECATE_WARNINGS *//* Deprecate Warnings *//**************************************
*  Obsolete Functions
**************************************//*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as
    a combination of LZ5_setStreamDecode() followed by LZ5_decompress_x_continue()
    They are stand-alone. They don't need nor update an LZ5_streamDecode_t structure.
*//*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks *must* remain available at the memory position where they were decoded (up to 64 KB)
    In the case of a ring buffers, decoding buffer must be either :
    - Exactly same size as encoding buffer, with same update rule (block boundaries at same positions)
      In which case, the decoding & encoding ring buffer can have any size, including very small ones ( < 64 KB).
    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.
      maxBlockSize is implementation dependent. It's the maximum size you intend to compress into a single block.
      In which case, encoding and decoding buffers do not need to be synchronized,
      and encoding ring buffer can have any size, including small ones ( < 64 KB).
    - _At least_ 64 KB + 8 bytes + maxBlockSize.
      In which case, encoding and decoding buffers do not need to be synchronized,
      and encoding ring buffer can have any size, including larger than decoding buffer.
    Whenever these conditions are not possible, save the last 64KB of decoded data into a safe buffer,
    and indicate where it is saved using LZ5_setStreamDecode()
*//*
 * LZ5_setStreamDecode
 * Use this function to instruct where to find the dictionary.
 * Setting a size of 0 is allowed (same effect as reset).
 * Return : 1 if OK, 0 if error
 *//*
 * LZ5_streamDecode_t
 * information structure to track an LZ5 stream.
 * init this structure content using LZ5_setStreamDecode or memset() before first use !
 *
 * In the context of a DLL (liblz5) please prefer usage of construction methods below.
 * They are more future proof, in case of a change of LZ5_streamDecode_t size in the future.
 * LZ5_createStreamDecode will allocate and initialize an LZ5_streamDecode_t structure
 * LZ5_freeStreamDecode releases its memory.
 *//************************************************
*  Streaming Decompression Functions
************************************************//*
 * LZ5_saveDict
 * If previously compressed data block is not guaranteed to remain available at its memory location
 * save it into a safer place (char* safeBuffer)
 * Note : you don't need to call LZ5_loadDict() afterwards,
 *        dictionary is immediately usable, you can therefore call LZ5_compress_fast_continue()
 * Return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error
 *//*
 * LZ5_compress_fast_continue
 * Compress buffer content 'src', using data from previously compressed blocks as dictionary to improve compression ratio.
 * Important : Previous data blocks are assumed to still be present and unmodified !
 * 'dst' buffer must be already allocated.
 * If maxDstSize >= LZ5_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
 * If not, and if compressed data cannot fit into 'dst' buffer size, compression stops, and function returns a zero.
 *//*
 * LZ5_loadDict
 * Use this function to load a static dictionary into LZ5_stream.
 * Any previous data will be forgotten, only 'dictionary' will remain in memory.
 * Loading a size of 0 is allowed.
 * Return : dictionary size, in bytes (necessarily <= 64 KB)
 *//*
 * LZ5_createStream will allocate and initialize an LZ5_stream_t structure
 * LZ5_freeStream releases its memory.
 * In the context of a DLL (liblz5), please use these methods rather than the static struct.
 * They are more future proof, in case of a change of LZ5_stream_t size.
 *//*
 * LZ5_resetStream
 * Use this function to init an allocated LZ5_stream_t structure
 *//*
 * LZ5_stream_t
 * information structure to track an LZ5 stream.
 * important : init this structure content before first use !
 * note : only allocated directly the structure if you are statically linking LZ5
 *        If you are using liblz5 as a DLL, please use below construction methods instead.
 *//***********************************************
*  Streaming Compression Functions
***********************************************//*
LZ5_decompress_safe_partial() :
    This function decompress a compressed block of size 'compressedSize' at position 'source'
    into destination buffer 'dest' of size 'maxDecompressedSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxDecompressedSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*//*
LZ5_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             Destination buffer must be already allocated. Its size must be a minimum of 'originalSize' bytes.
    note : This function fully respect memory boundaries for properly formed compressed data.
           It is a bit faster than LZ5_decompress_safe().
           However, it does not provide any protection against intentionally modified data stream (malicious input).
           Use this function in trusted environment only (data to decode comes from a trusted source).
*//*
LZ5_compress_destSize() :
    Reverse the logic, by compressing as much data as possible from 'source' buffer
    into already allocated buffer 'dest' of size 'targetDestSize'.
    This function either compresses the entire 'source' content into 'dest' if it's large enough,
    or fill 'dest' buffer completely with as much data as possible from 'source'.
        *sourceSizePtr : will be modified to indicate how many bytes where read from 'source' to fill 'dest'.
                         New value is necessarily <= old value.
        return : Nb bytes written into 'dest' (necessarily <= targetDestSize)
              or 0 if compression fails
*//*
LZ5_compress_fast_extState() :
    Same compression function, just using an externally allocated memory space to store compression state.
    Use LZ5_sizeofState() to know how much memory must be allocated,
    and allocate it on 8-bytes boundaries (using malloc() typically).
    Then, provide it as 'void* state' to compression function.
*//*
LZ5_compress_fast() :
    Same as LZ5_compress_default(), but allows to select an "acceleration" factor.
    The larger the acceleration value, the faster the algorithm, but also the lesser the compression.
    It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
    An acceleration value of "1" is the same as regular LZ5_compress_default()
    Values <= 0 will be replaced by ACCELERATION_DEFAULT (see lz5.c), which is 1.
*//*
LZ5_compressBound() :
    Provides the maximum size that LZ5 compression may output in a "worst case" scenario (input data not compressible)
    This function is primarily useful for memory allocation purposes (destination buffer size).
    Macro LZ5_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
    Note that LZ5_compress_default() compress faster when dest buffer size is >= LZ5_compressBound(srcSize)
        inputSize  : max supported value is LZ5_MAX_INPUT_SIZE
        return : maximum output size in a "worst case" scenario
              or 0, if input size is too large ( > LZ5_MAX_INPUT_SIZE)
*//**************************************
*  Advanced Functions
**************************************//*
LZ5_compress_default() :
    Compresses 'sourceSize' bytes from buffer 'source'
    into already allocated 'dest' buffer of size 'maxDestSize'.
    Compression is guaranteed to succeed if 'maxDestSize' >= LZ5_compressBound(sourceSize).
    It also runs faster, so it's a recommended setting.
    If the function cannot compress 'source' into a more limited 'dest' budget,
    compression stops *immediately*, and the function result is zero.
    As a consequence, 'dest' content is not valid.
    This function never writes outside 'dest' buffer, nor read outside 'source' buffer.
        sourceSize  : Max supported value is LZ5_MAX_INPUT_VALUE
        maxDestSize : full or partial size of buffer 'dest' (which must be already allocated)
        return : the number of bytes written into buffer 'dest' (necessarily <= maxOutputSize)
              or 0 if compression fails

LZ5_decompress_safe() :
    compressedSize : is the precise full size of the compressed block.
    maxDecompressedSize : is the size of destination buffer, which must be already allocated.
    return : the number of bytes decompressed into destination buffer (necessarily <= maxDecompressedSize)
             If destination buffer is not large enough, decoding will stop and output an error code (<0).
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits, including malicious data packets.
             It never writes outside output buffer, nor reads outside input buffer.
*//**************************************
*  Simple Functions
**************************************//*
 * LZ5_MEMORY_USAGE :
 * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
 * Increasing memory usage improves compression ratio
 * Reduced memory usage can improve speed, due to cache effect
 *//**************************************
*  Tuning parameter
**************************************//**************************************
*  Version
**************************************//*
 * lz5.h provides block compression functions, and gives full buffer control to programmer.
 * If you need to generate inter-operable compressed data (respecting LZ5 frame specification),
 * and can let the library handle its own memory, please use lz5frame.h instead.
*//*
   LZ5 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ5 source repository : https://github.com/inikep/lz5
   - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*/LZ5_streamPtrLZ5_streamDecodeLZ5_stream/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5common.h"lz5.h"LZ5HC_optimal_tLZ5HC_match_tLZ5HC_Data_sLZ5HC_parametersLZ5HC_strategyLZ5HC_fastLZ5HC_price_fastLZ5HC_lowest_priceLZ5HC_optimal_priceLZ5HC_optimal_price_btoutputBufferhashTable3const LZ5HC_parametersconst LZ5HC_parameters[16]LZ5HC_defaultParametersLZ5HC_compressionLevel_defaultg_maxCompressionLevelLZ5_minLengthLZ5_STATIC_ASSERT(c){ enum { LZ5_static_assert = 1/(int)(!!(c)) }; }LZ5_MID_OFFSET_DISTANCE(1<<LZ5_MID_OFFSET_BITS)LZ5_MID_OFFSET_BITSLZ5_SHORT_OFFSET_DISTANCE(1<<LZ5_SHORT_OFFSET_BITS)LZ5_SHORT_OFFSET_BITSML_RUN_BITS2(ML_BITS + RUN_BITS2)(ML_BITS + RUN_BITS)RUN_MASK2((1U<<RUN_BITS2)-1)RUN_BITS2LZ5_DICT_SIZE(1 << MAXD_LOG)((1 << MAXD_LOG) - 1)MAXD_LOGACCELERATION_DEFAULTHEAPMODELZ5COMMON_H(LZ5_GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)LZ5HC_INCLUDES/* LZ5COMMON_H *///  {       24,         24, 28, 24, 1<<24,  7, 1<<24,  2, LZ5HC_optimal_price }, // max values//  {       10,         10, 10,  0,     0,  4,     0,  0, LZ5HC_fast          }, // min values// level 9// level 8// level 7// level 6// level 5// level 4// level 3// level 2// level 1// level 0 - never used/* windLog, contentLog,  H, H3,  Snum, SL, SuffL, FS, Strategy *//* for debugging *//** from faster to stronger *//* *************************************
*  HC Types
***************************************/// LZ5HC_INCLUDES//	return LZ5_CODEWORD_COST(sum - common, (off == last_off) ? 0 : (off), common - MINMATCH) <= LZ5_CODEWORD_COST(sum - best_common, (best_off == last_off) ? 0 : (best_off), best_common - MINMATCH);/**************************************
*  HC Local Macros
**************************************/// LZ5HC_MAX_CLEVEL// MEM_read/* *************************************
*  HC Inline functions and Macros
***************************************//****************************************************************
*  Basic Types
*****************************************************************//**************************************
*  Common Utils
**************************************/// should be 3 or 4/**************************************
*  Common Constants
**************************************//**************************************
*  Memory routines
**************************************//**************************************
*  Compiler Options
**************************************//*
 * ACCELERATION_DEFAULT :
 * Select "acceleration" for LZ5_compress_fast() when parameter value <= 0
 *//* Default stack size for VC++ is 1 MB and size of LZ5_stream_t exceeds that limit *//*
 * HEAPMODE :
 * Select how default compression functions will allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).
 *//**************************************
*  Tuning parameters
**************************************/gets/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5.c"lz5common.h"endOnOutputSizeendOnInputSizeLZ5_stream_t_internal *((1 << (20-3)) + 4)lz5dsLZ5_init1048608LZ5_uncompress_unknownOutputSizeLZ5_uncompressLZ5_decompress_safe_forceExtDictLZ5_decompress_usingDict_generic(int)(LZ5_DICT_SIZE - 1)LZ5_streamDecode_t_internal *lz5sdLZ5_Datasizeof(LZ5_streamDecode_t)lz5sLZ5_decompress_genericdec32tablesafeDecode(int)(LZ5_DICT_SIZE)(endOnInput)?ip<iend-RUN_MASK2:1(endOnInput)?ip<iend-((1U<<2)-1):1((endOnInput)?ip<iend-((1U<<2)-1):1) != 0(size_t)(ip+length)<(size_t)(ip)((size_t)(ip+length)<(size_t)(ip)) != 0(endOnInput)?ip<iend-RUN_MASK:1(endOnInput)?ip<iend-((1U<<3)-1):1((endOnInput)?ip<iend-((1U<<3)-1):1) != 0(size_t)(op+length)<(size_t)op((size_t)(op+length)<(size_t)op) != 0cpy>oend-(16-MINMATCH)cpy>oend-(16-3)(cpy>oend-(16-3)) != 00+10+1+LASTLITERALS(0+1+LASTLITERALS)endOnInputdec64LZ5_compress_forceExtDictsmallestLZ5_dictLZ5_renormDictTHASH_SIZE_U32U32[262144]unsigned int[262144]sizeof(LZ5_stream_t)LZ5_STREAMSIZE >= sizeof(LZ5_stream_t_internal)(((1 << (20-3)) + 4) * sizeof(long long)) >= sizeof(LZ5_stream_t_internal)LZ5_static_assertLZ5_compress_destSize_extState65546LZ5_64KlimitLZ5_compress_destSize_genericoMaxLitoMaxMatch(LASTLITERALS + 1 /* token */)oMaxSeq(U32)LZ5_MAX_INPUT_SIZELZ5_skipTrigger1 << LZ5_skipTrigger(RUN_MASK2<<ML_BITS)3<<ML_RUN_BITS2(3<<ML_RUN_BITS2)2<<ML_RUN_BITS2(2<<ML_RUN_BITS2)15-1(15-1)LZ5_compress_fast_forceLZ5_compress_genericLZ5_stream_t_internal *constdictPtrlowRefLimitrefDeltaip[-1]==match[refDelta-1](ip[-1]==match[refDelta-1]) != 0op + (1 + LASTLITERALS) + (matchLength>>8) > olimitop + (1 + 5) + (matchLength>>8) > olimit(op + (1 + 5) + (matchLength>>8) > olimit) != 0outputLimitedLZ5_getPositionLZ5_getPositionOnHashLZ5_putPositionLZ5_putPositionOnHashLZ5_hashPositionLZ5_hashSequenceTLZ5_hashSequence64LZ5_HASHLOGLZ5_hashSequence(32)(LZ5_HASHLOG+1)(32)-(LZ5_HASHLOG+1)((32)-(LZ5_HASHLOG+1))(32)-LZ5_HASHLOG((32)-LZ5_HASHLOG)10500LZ5_streamDecode_t_internalendCondition_directiveLZ5_stream_t_internalinitCheck(1 << LZ5_HASHLOG)(LZ5_MEMORY_USAGE-2)(HEAPMODE)/* Obsolete streaming decompression functions *//* Error : pointer is not aligned on 4-bytes boundary *//*
These function names are deprecated and should no longer be used.
They are only provided here for compatibility with older user programs.
- LZ5_uncompress is totally equivalent to LZ5_decompress_fast
- LZ5_uncompress_unknownOutputSize is totally equivalent to LZ5_decompress_safe
*//***************************************************
*  Obsolete Functions
***************************************************//*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ5_setStreamDecode()
*//*
 * LZ5_setStreamDecode
 * Use this function to instruct where to find the dictionary
 * This function is not necessary if previous data is still available where it was decoded.
 * Loading a size of 0 is allowed (same effect as no dictionary).
 * Return : 1 if OK, 0 if error
 *//*
 * If you prefer dynamic allocation methods,
 * LZ5_createStreamDecode()
 * provides a pointer (void*) towards an initialized LZ5_streamDecode_t structure.
 *//* streaming decompression functions *//* Nb of input bytes read *//* correction */// (token>>ML_RUN_BITS2) == 3// (token>>ML_RUN_BITS2) == 2/* Necessarily EOF, due to parsing restrictions *//* Error : block decoding must stop exactly there *//* Error : read attempt beyond end of input buffer *//* Error : write attempt beyond end of output buffer *//* targetOutputSize too high => decode everything *//* endOnOutputSize, endOnInputSize *//* If endOnInput==endOnInputSize, this value is the max size of Output Buffer. *//*
 * This generic decompression function cover all use cases.
 * It shall be instantiated several times, using different sets of directives
 * Note that it is essential this generic function is really inlined,
 * in order to remove useless branches during compilation optimization.
 *//*******************************
*  Decompression functions
*******************************//* useless to define a dictionary > LZ5_DICT_SIZE *//* Hidden debug function, to force external dictionary mode *//* Uninitialized structure detected *//* address space overflow *//*   if (dictSize < (int)HASH_UNIT)
    {
        dict->dictionary = NULL;
        dict->dictSize = 0;
        return 0;
    }*//* Uninitialized structure, or reuse overflow *//* A compilation error here means LZ5_STREAMSIZE is not large enough *//********************************
*  Streaming functions
********************************//* litLength *//* Test end of block *//* Not enough space for a last match *//* Unsupported input size, too large (or negative) *//* because 8+MINMATCH==MFLIMIT *//********************************
*  destSize variant
********************************//* strangely enough, gcc generates faster code when this function is uncommented, even if unused *//* hidden debug function *//* default, to ensure a return *//********************************
*  Compression functions
********************************//**************************************
*  Local Utils
**************************************//* obsolete, used for slideInputBuffer *//**************************************
*  Local Structures and types
**************************************//**************************************
*  Local Constants
**************************************//*
   LZ5 - Fast LZ compression algorithm
   Copyright (C) 2011-2015, Yann Collet.
   Copyright (C) 2015, Przemyslaw Skibinski <inikep@gmail.com>

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ5 source repository : https://github.com/inikep/lz5
   - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5frame.hLZ5F_decompressOptions_tLZ5F_dctx_s *LZ5F_decompressionContext_tLZ5F_compressOptions_tLZ5F_cctx_s *LZ5F_compressionContext_tLZ5F_preferences_tLZ5F_frameInfo_tLZ5F_frameType_tLZ5F_frameLZ5F_skippableFrameskippableFrame = LZ5F_skippableFrameLZ5F_contentChecksum_tLZ5F_noContentChecksumLZ5F_contentChecksumEnablednoContentChecksum = LZ5F_noContentChecksumcontentChecksumEnabled = LZ5F_contentChecksumEnabledLZ5F_blockMode_tLZ5F_blockLinkedLZ5F_blockIndependentblockLinked = LZ5F_blockLinkedblockIndependent = LZ5F_blockIndependentLZ5F_blockSizeID_tLZ5F_defaultLZ5F_max64KBLZ5F_max256KBLZ5F_max1MBLZ5F_max4MBLZ5F_max16MBLZ5F_max64MBLZ5F_max256MBmax64KB = LZ5F_max64KBmax256KB = LZ5F_max256KBmax1MB = LZ5F_max1MBmax4MB = LZ5F_max4MBLZ5F_errorCode_tLZ5F_VERSIONLZ5F_OBSOLETE_ENUM(x)LZ5F_DISABLE_OBSOLETE_ENUMSLZ5F_decompressconst LZ5F_decompressOptions_tconst LZ5F_decompressOptions_t *LZ5F_getFrameInfoLZ5F_frameInfo_t *LZ5F_freeDecompressionContextLZ5F_createDecompressionContextLZ5F_decompressionContext_t *LZ5F_dctx_s **LZ5F_dctx_sLZ5F_compressEndconst LZ5F_compressOptions_tconst LZ5F_compressOptions_t *LZ5F_flushLZ5F_compressUpdateLZ5F_compressBoundconst LZ5F_preferences_tconst LZ5F_preferences_t *LZ5F_compressBeginLZ5F_freeCompressionContextLZ5F_createCompressionContextLZ5F_compressionContext_t *LZ5F_cctx_s **LZ5F_cctx_sLZ5F_compressFrameLZ5F_compressFrameBoundLZ5F_getErrorNameLZ5F_isError/* LZ5F_decompress()
 * Call this function repetitively to regenerate data compressed within srcBuffer.
 * The function will attempt to decode *srcSizePtr bytes from srcBuffer, into dstBuffer of maximum size *dstSizePtr.
 *
 * The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).
 *
 * The number of bytes read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
 * If number of bytes read is < number of bytes provided, then decompression operation is not completed.
 * It typically happens when dstBuffer is not large enough to contain all decoded data.
 * LZ5F_decompress() must be called again, starting from where it stopped (srcBuffer + *srcSizePtr)
 * The function will check this condition, and refuse to continue if it is not respected.
 *
 * dstBuffer is supposed to be flushed between each call to the function, since its content will be overwritten.
 * dst arguments can be changed at will with each consecutive call to the function.
 *
 * The function result is an hint of how many srcSize bytes LZ5F_decompress() expects for next call.
 * Schematically, it's the size of the current (or remaining) compressed block + header of next block.
 * Respecting the hint provides some boost to performance, since it does skip intermediate buffers.
 * This is just a hint, you can always provide any srcSize you want.
 * When a frame is fully decoded, the function result will be 0 (no more data expected).
 * If decompression failed, function result is an error code, which can be tested using LZ5F_isError().
 *
 * After a frame is fully decoded, dctx can be used again to decompress another frame.
 *//* LZ5F_getFrameInfo()
 * This function decodes frame header information (such as max blockSize, frame checksum, etc.).
 * Its usage is optional. The objective is to extract frame header information, typically for allocation purposes.
 * A header size is variable and can be from 7 to 15 bytes. It's also possible to input more bytes than that. 
 * The number of bytes read from srcBuffer will be updated within *srcSizePtr (necessarily <= original value).
 * (note that LZ5F_getFrameInfo() can also be used anytime *after* starting decompression, in this case 0 input byte is enough)
 * Frame header info is *copied into* an already allocated LZ5F_frameInfo_t structure.
 * The function result is an hint about how many srcSize bytes LZ5F_decompress() expects for next call,
 *                        or an error code which can be tested using LZ5F_isError()
 *                        (typically, when there is not enough src bytes to fully decode the frame header)
 * Decompression is expected to resume from where it stopped (srcBuffer + *srcSizePtr)
 *//* Decompression *//* LZ5F_createDecompressionContext() :
 * The first thing to do is to create an LZ5F_decompressionContext_t object, which will be used in all decompression operations.
 * This is achieved using LZ5F_createDecompressionContext().
 * The version provided MUST be LZ5F_VERSION. It is intended to track potential breaking differences between different versions.
 * The function will provide a pointer to a fully allocated and initialized LZ5F_decompressionContext_t object.
 * The result is an errorCode, which can be tested using LZ5F_isError().
 * dctx memory can be released using LZ5F_freeDecompressionContext();
 * The result of LZ5F_freeDecompressionContext() is indicative of the current state of decompressionContext when being released.
 * That is, it should be == 0 if decompression has been completed fully and correctly.
 *//***********************************
*  Decompression functions
***********************************//* LZ5F_compressEnd()
 * When you want to properly finish the compressed frame, just call LZ5F_compressEnd().
 * It will flush whatever data remained within compressionContext (like LZ5_flush())
 * but also properly finalize the frame, with an endMark and a checksum.
 * The result of the function is the number of bytes written into dstBuffer (necessarily >= 4 (endMark), or 8 if optional frame checksum is enabled)
 * The function outputs an error code if it fails (can be tested using LZ5F_isError())
 * The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
 * A successful call to LZ5F_compressEnd() makes cctx available again for next compression task.
 *//* LZ5F_flush()
 * Should you need to generate compressed data immediately, without waiting for the current block to be filled,
 * you can call LZ5_flush(), which will immediately compress any remaining data buffered within cctx.
 * Note that dstMaxSize must be large enough to ensure the operation will be successful.
 * LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
 * The result of the function is the number of bytes written into dstBuffer
 * (it can be zero, this means there was no data left within cctx)
 * The function outputs an error code if it fails (can be tested using LZ5F_isError())
 *//* LZ5F_compressUpdate()
 * LZ5F_compressUpdate() can be called repetitively to compress as much data as necessary.
 * The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
 * You can get the minimum value of dstMaxSize by using LZ5F_compressBound().
 * If this condition is not respected, LZ5F_compress() will fail (result is an errorCode).
 * LZ5F_compressUpdate() doesn't guarantee error recovery, so you have to reset compression context when an error occurs.
 * The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
 * The result of the function is the number of bytes written into dstBuffer : it can be zero, meaning input data was just buffered.
 * The function outputs an error code if it fails (can be tested using LZ5F_isError())
 *//* LZ5F_compressBound() :
 * Provides the minimum size of Dst buffer given srcSize to handle worst case situations.
 * Different preferences can produce different results.
 * prefsPtr is optional : you can provide NULL as argument, all preferences will then be set to cover worst case.
 * This function includes frame termination cost (4 bytes, or 8 if frame checksum is enabled)
 *//* LZ5F_compressBegin() :
 * will write the frame header into dstBuffer.
 * dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header size is 15 bytes.
 * The LZ5F_preferences_t structure is optional : you can provide NULL as argument, all preferences will then be set to default.
 * The result of the function is the number of bytes written into dstBuffer for the header
 * or an error code (can be tested using LZ5F_isError())
 *//* LZ5F_createCompressionContext() :
 * The first thing to do is to create a compressionContext object, which will be used in all compression operations.
 * This is achieved using LZ5F_createCompressionContext(), which takes as argument a version and an LZ5F_preferences_t structure.
 * The version provided MUST be LZ5F_VERSION. It is intended to track potential version differences between different binaries.
 * The function will provide a pointer to a fully allocated LZ5F_compressionContext_t object.
 * If the result LZ5F_errorCode_t is not zero, there was an error during context creation.
 * Object can release its memory using LZ5F_freeCompressionContext();
 *//* 1 == src content will remain available on future calls to LZ5F_compress(); avoid saving src content within tmp buffer as future dictionary *//**********************************
*  Advanced compression functions
**********************************//* LZ5F_compressFrame()
 * Compress an entire srcBuffer into a valid LZ5 frame, as defined by specification v1.5.1
 * The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
 * You can get the minimum value of dstMaxSize by using LZ5F_compressFrameBound()
 * If this condition is not respected, LZ5F_compressFrame() will fail (result is an errorCode)
 * The LZ5F_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default.
 * The result of the function is the number of bytes written into dstBuffer.
 * The function outputs an error code if it fails (can be tested using LZ5F_isError())
 *//***********************************
*  Simple compression function
***********************************//* LZ5F_frame, skippableFrame ; 0 == default *///#define LZ5F_DISABLE_OBSOLETE_ENUMS/**************************************
*  Frame compression types
**************************************//**************************************
*  Error management
**************************************//* LZ5F is a stand-alone API to create LZ5-compressed frames
 * conformant with specification v1.5.1.
 * All related operations, including memory management, are handled internally by the library.
 * You don't need lz5.h when using lz5frame.h.
 * *//*
   LZ5 auto-framing library
   Header File
   Copyright (C) 2011-2015, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ5 source repository : https://github.com/inikep/lz5
   - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5frame_static.h"lz5frame.h"LZ5F_errorCodesLZ5F_OK_NoErrorLZ5F_GENERATE_ENUMLZ5F_ERROR_GENERICLZ5F_ERROR_maxBlockSize_invalidLZ5F_ERROR_blockMode_invalidLZ5F_ERROR_contentChecksumFlag_invalidLZ5F_ERROR_compressionLevel_invalidLZ5F_ERROR_headerVersion_wrongLZ5F_ERROR_blockChecksum_unsupportedLZ5F_ERROR_reservedFlag_setLZ5F_ERROR_allocation_failedLZ5F_ERROR_srcSize_tooLargeLZ5F_ERROR_dstMaxSize_tooSmallLZ5F_ERROR_frameHeader_incompleteLZ5F_ERROR_frameType_unknownLZ5F_ERROR_frameSize_wrongLZ5F_ERROR_srcPtr_wrongLZ5F_ERROR_decompressionFailedLZ5F_ERROR_headerChecksum_invalidLZ5F_ERROR_contentChecksum_invalidLZ5F_ERROR_maxCodeLZ5F_GENERATE_ENUM(ENUM)LZ5F_ ## ENUM, ENUM = LZ5F_ ## ENUM,LZ5F_LIST_ERRORS(ITEM)LZ5F_DISABLE_OLD_ENUMS//#define LZ5F_DISABLE_OLD_ENUMS/* lz5frame_static.h should be used solely in the context of static linking.
 * It contains definitions which may still change overtime.
 * Never use it in the context of DLL linking.
 * *//*
   LZ5 auto-framing library
   Header File for static linking only
   Copyright (C) 2011-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ5 source repository : https://github.com/inikep/lz5
   - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5hc.hLZ5_compressHC_limitedOutput_withStateHCLZ5_compressHC_withStateHCLZ5_compressHC_limitedOutput_continueLZ5_streamHC_t *LZ5_compressHC_continueLZ5_compressHC_limitedOutputLZ5_compressHCLZ5_saveDictHCLZ5_compress_HC_continueLZ5_loadDictHCLZ5_resetStreamHCLZ5_freeStreamHCLZ5_createStreamHCLZ5_compress_HC_extStateHCLZ5_sizeofStateHCLZ5_free_mem_HCLZ5HC_Data_Structure *LZ5HC_Data_s *LZ5_alloc_mem_HCLZ5_compress_HCLZ5_streamHC_tLZ5HC_Data_Structuresize_t[32774]unsigned long[32774]32774LZ5_STREAMHCSIZE_SIZETLZ5_DEPRECATE_WARNING_DEFBLOCK(LZ5_STREAMHCSIZE / sizeof(size_t))LZ5_STREAMHCSIZE/* these functions are planned to trigger warning messages by r132 approximately *//* compression functions */// LZ5_DEPRECATE_WARNING_DEFBLOCK/* Should these warnings messages be a problem,
   it is generally possible to disable them,
   with -Wno-deprecated-declarations for gcc
   or _CRT_SECURE_NO_WARNINGS in Visual for example.
   You can also define LZ5_DEPRECATE_WARNING_DEFBLOCK. *//**************************************
*  Deprecated Functions
**************************************//*
  These functions compress data in successive blocks of any size, using previous blocks as dictionary.
  One key assumption is that previous blocks (up to 64 KB) remain read-accessible while compressing next blocks.
  There is an exception for ring buffers, which can be smaller 64 KB.
  Such case is automatically detected and correctly handled by LZ5_compress_HC_continue().

  Before starting compression, state must be properly initialized, using LZ5_resetStreamHC().
  A first "fictional block" can then be designated as initial dictionary, using LZ5_loadDictHC() (Optional).

  Then, use LZ5_compress_HC_continue() to compress each successive block.
  It works like LZ5_compress_HC(), but use previous memory blocks as dictionary to improve compression.
  Previous memory blocks (including initial dictionary when present) must remain accessible and unmodified during compression.
  As a reminder, size 'dst' buffer to handle worst cases, using LZ5_compressBound(), to ensure success of compression operation.

  If, for any reason, previous data blocks can't be preserved unmodified in memory during next compression block,
  you must save it to a safer memory space, using LZ5_saveDictHC().
  Return value of LZ5_saveDictHC() is the size of dictionary effectively saved into 'safeBuffer'.
*//*
  These functions create and release memory for LZ5 HC streaming state.
  Newly created states are already initialized.
  Existing state space can be re-used anytime using LZ5_resetStreamHC().
  If you use LZ5 as a DLL, use these functions instead of static structure allocation,
  to avoid size mismatch between different versions.
*//*
  LZ5_streamHC_t
  This structure allows static allocation of LZ5 HC streaming state.
  State must then be initialized using LZ5_resetStreamHC() before first use.

  Static allocation should only be used in combination with static linking.
  If you want to use LZ5 as a DLL, please use construction functions below, which are future-proof.
*//**************************************
*  Streaming Compression
**************************************//*
LZ5_compress_HC_extStateHC() :
   Use this function if you prefer to manually allocate memory for compression tables.
   To know how much memory must be allocated for the compression tables, use :
      int LZ5_sizeofStateHC();

   Allocated memory must be aligned on 8-bytes boundaries (which a normal malloc() will do properly).

   The allocated memory can then be provided to the compression functions using 'void* state' parameter.
   LZ5_compress_HC_extStateHC() is equivalent to previously described function.
   It just uses externally allocated memory for stateHC.
*//* Note :
   Decompression functions are provided within LZ5 source code (see "lz5.h") (BSD license)
*//*
LZ5_compress_HC :
    Destination buffer 'dst' must be already allocated.
    Compression completion is guaranteed if 'dst' buffer is sized to handle worst circumstances (data not compressible)
    Worst size evaluation is provided by function LZ5_compressBound() (see "lz5.h")
      srcSize  : Max supported value is LZ5_MAX_INPUT_SIZE (see "lz5.h")
      compressionLevel : Recommended values are between 4 and 9, although any value between 0 and LZ5HC_MAX_CLEVEL (equal to 15) will work.
                         0 means "use default value" (see lz5hc.c).
                         Values >LZ5HC_MAX_CLEVEL behave the same as LZ5HC_MAX_CLEVEL.
      return : the number of bytes written into buffer 'dst'
            or 0 if compression fails.
*//**************************************
*  Block Compression
**************************************//*****************************
*  Includes
*****************************//*
   LZ5 HC - High Compression Mode of LZ5
   Header File
   Copyright (C) 2011-2015, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ5 source repository : https://github.com/inikep/lz5
   - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*/LZ5_streamHCPtr/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/xxhash.hLZ5_XXH64_digestLZ5_XXH64_updateLZ5_XXH64_resetLZ5_XXH32_digestLZ5_XXH32_updateLZ5_XXH32_resetLZ5_XXH64_freeStateLZ5_XXH64_createStateLZ5_XXH32_freeStateLZ5_XXH32_createStateLZ5_XXH64LZ5_XXH32long long[11]long long[6]LZ5_/*
These functions calculate the xxHash of an input provided in multiple smaller packets,
as opposed to an input provided as a single block.

XXH state space must first be allocated, using either static or dynamic method provided above.

Start a new hash by initializing state with a seed, using XXHnn_reset().

Then, feed the hash state by calling XXHnn_update() as many times as necessary.
Obviously, input must be valid, meaning allocated and read accessible.
The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.

Finally, you can produce a hash anytime, by using XXHnn_digest().
This function returns the final nn-bits hash.
You can nonetheless continue feeding the hash state with more input,
and therefore get some new hashes, by calling again XXHnn_digest().

When you are done, don't forget to free XXH state space, using typically XXHnn_freeState().
*//*
These functions create and release memory for XXH state.
States must then be initialized using XXHnn_reset() before first use.
*//*
These structures allow static allocation of XXH states.
States must then be initialized using XXHnn_reset() before first use.

If you prefer dynamic allocation, please refer to functions below.
*//*****************************
*  Advanced Hash Functions
*****************************//*
XXH32() :
    Calculate the 32-bits hash of sequence "length" bytes stored at memory address "input".
    The memory between input & input+length must be valid (allocated and read-accessible).
    "seed" can be used to alter the result predictably.
    This function successfully passes all SMHasher tests.
    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s
XXH64() :
    Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".
    Faster on 64-bits systems. Slower on 32-bits systems.
*//*****************************
*  Simple Hash Functions
*****************************//* Motivations :

If you need to include xxHash into your library,
but wish to avoid xxHash symbols to be present on your library interface
in an effort to avoid potential name collision if another library also includes xxHash,

you can use XXH_NAMESPACE, which will automatically prefix any symbol from xxHash
with the value of XXH_NAMESPACE (so avoid to keep it NULL, and avoid numeric values).

Note that no change is required within the calling program :
it can still call xxHash functions using their regular name.
They will be automatically translated by this header.
*//*****************************
*  Namespace Emulation
*****************************//*****************************
*  Definitions
*****************************//*
   xxHash - Extremely Fast Hash algorithm
   Header File
   Copyright (C) 2012-2015, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - xxHash source repository : https://github.com/Cyan4973/xxHash
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5frame.c"lz5hc.h""lz5frame_static.h"LZ5F_dctx_t *LZ5F_decompressOptions_t *(size_t)-LZ5F_ERROR_srcPtr_wrong(size_t)-LZ5F_ERROR_GENERICLZ5F_BLOCKUNCOMPRESSED_FLAG(size_t)-LZ5F_ERROR_decompressionFailed(size_t)-LZ5F_ERROR_frameSize_wrong(size_t)-LZ5F_ERROR_contentChecksum_invalidLZ5F_updateDictLZ5F_decompress_safe(size_t)-LZ5F_ERROR_frameHeader_incompleteLZ5F_decodeHeaderLZ5F_MAGIC_SKIPPABLE_START407708165LZ5F_MAGICNUMBER(size_t)-LZ5F_ERROR_frameType_unknown(size_t)-LZ5F_ERROR_headerVersion_wrong(size_t)-LZ5F_ERROR_blockChecksum_unsupported(size_t)-LZ5F_ERROR_reservedFlag_set(size_t)-LZ5F_ERROR_maxBlockSize_invalid(size_t)-LZ5F_ERROR_headerChecksum_invalidLZ5F_DICT_SIZEdctxPtr->maxBufferSizesizeof(LZ5F_dctx_t)(LZ5F_errorCode_t)-LZ5F_ERROR_GENERICLZ5F_cctx_t *(size_t)-LZ5F_ERROR_dstMaxSize_tooSmallLZ5F_preferences_t *LZ5F_compressOptions_t *LZ5F_localSaveDictminHClevelLZ5F_selectCompressionLZ5F_localLZ5_compressHC_limitedOutput_continueLZ5F_localLZ5_compress_limitedOutput_continueLZ5F_localLZ5_compress_limitedOutput_withStateLZ5F_decompressionContextLZ5F_decompressionContextPtrLZ5F_compressBlocktableIDLZ5F_BLOCKSIZEID_DEFAULT(size_t)-LZ5F_ERROR_allocation_failedsizeof(LZ5F_cctx_t)-LZ5F_ERROR_allocation_failed(LZ5F_errorCode_t)(-LZ5F_ERROR_allocation_failed)const LZ5F_blockSizeID_tLZ5F_freeStreamLZ5F_optimalBSIDLZ5F_headerChecksumLZ5F_writeLE64LZ5F_readLE64LZ5F_writeLE32LZ5F_readLE32LZ5F_getBlockSize-LZ5F_ERROR_maxCode(LZ5F_errorCode_t)(-LZ5F_ERROR_maxCode)LZ5F_lastBlockStatusLZ5F_dctx_tLZ5F_cctx_tlz5CtxLevellz5CtxPtrLZ5F_errorStringsLZ5F_GENERATE_STRINGlz5ctxLZ5F_compressionContextLZ5F_compressionContextPtrLZ5F_GENERATE_STRING(STRING)0x184D2205UALLOCATOR(s)/* LZ5F_decompress()
* Call this function repetitively to regenerate data compressed within srcBuffer.
* The function will attempt to decode *srcSizePtr from srcBuffer, into dstBuffer of maximum size *dstSizePtr.
*
* The number of bytes regenerated into dstBuffer will be provided within *dstSizePtr (necessarily <= original value).
*
* The number of bytes effectively read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
* If the number of bytes read is < number of bytes provided, then the decompression operation is not complete.
* You will have to call it again, continuing from where it stopped.
*
* The function result is an hint of the better srcSize to use for next call to LZ5F_decompress.
* Basically, it's the size of the current (or remaining) compressed block + header of next block.
* Respecting the hint provides some boost to performance, since it allows less buffer shuffling.
* Note that this is just a hint, you can always provide any srcSize you want.
* When a frame is fully decoded, the function result will be 0.
* If decompression failed, function result is an error code which can be tested using LZ5F_isError().
*//* note : dstSize < 64 KB *//* LZ5F_getFrameInfo()
* This function decodes frame header information, such as blockSize.
* It is optional : you could start by calling directly LZ5F_decompress() instead.
* The objective is to extract header information without starting decompression, typically for allocation purposes.
* LZ5F_getFrameInfo() can also be used *after* starting decompression, on a valid LZ5F_decompressionContext_t.
* The number of bytes read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).
* You are expected to resume decompression from where it stopped (srcBuffer + *srcSizePtr)
* The function result is an hint of the better srcSize to use for next call to LZ5F_decompress,
* or an error code which can be tested using LZ5F_isError().
*//* LZ5F_decodeHeader
   return : nb Bytes read from srcVoidPtr (necessarily <= srcSize)
            or an error code (testable with LZ5F_isError())
   output : set internal values of dctx, such as
            dctxPtr->frameInfo and dctxPtr->dStage.
   input  : srcVoidPtr points at the **beginning of the frame**
*//* LZ5F_createDecompressionContext() :
* The first thing to do is to create a decompressionContext object, which will be used in all decompression operations.
* This is achieved using LZ5F_createDecompressionContext().
* The function will provide a pointer to a fully allocated and initialized LZ5F_decompressionContext object.
* If the result LZ5F_errorCode_t is not zero, there was an error during context creation.
* Object can release its memory using LZ5F_freeDecompressionContext();
*//**********************************
*  Decompression functions
**********************************//* LZ5F_compressEnd()
* When you want to properly finish the compressed frame, just call LZ5F_compressEnd().
* It will flush whatever data remained within compressionContext (like LZ5_flush())
* but also properly finalize the frame, with an endMark and a checksum.
* The result of the function is the number of bytes written into dstBuffer (necessarily >= 4 (endMark size))
* The function outputs an error code if it fails (can be tested using LZ5F_isError())
* The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
* compressionContext can then be used again, starting with LZ5F_compressBegin(). The preferences will remain the same.
*//* necessarily LZ5F_blockLinked *//* LZ5F_flush()
* Should you need to create compressed data immediately, without waiting for a block to be filled,
* you can call LZ5_flush(), which will immediately compress any remaining data stored within compressionContext.
* The result of the function is the number of bytes written into dstBuffer
* (it can be zero, this means there was no data left within compressionContext)
* The function outputs an error code if it fails (can be tested using LZ5F_isError())
* The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
*//* necessarily LZ5F_blockLinked && lastBlockCompressed==fromTmpBuffer *//* LZ5F_compressUpdate()
* LZ5F_compressUpdate() can be called repetitively to compress as much data as necessary.
* The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
* If this condition is not respected, LZ5F_compress() will fail (result is an errorCode)
* You can get the minimum value of dstMaxSize by using LZ5F_compressBound()
* The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.
* The result of the function is the number of bytes written into dstBuffer : it can be zero, meaning input data was just buffered.
* The function outputs an error code if it fails (can be tested using LZ5F_isError())
*//* LZ5F_compressBound() : gives the size of Dst buffer given a srcSize to handle worst case situations.
*                        The LZ5F_frameInfo_t structure is optional :
*                        you can provide NULL as argument, preferences will then be set to cover worst case situations.
* *///  printf("BEFORE lz5CtxLevel=%d tableID=%d compressionLevel=%d minHClevel=%d\n", (int)cctxPtr->lz5CtxLevel, (int)tableID, (int)cctxPtr->prefs.compressionLevel, minHClevel);/* 0:nothing ; 1:LZ5_createStream ; 2:LZ5_createStreamHC *//* LZ5F_compressBegin() :
* will write the frame header into dstBuffer.
* dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header size is LZ5F_MAXHEADERFRAME_SIZE bytes.
* The result of the function is the number of bytes written into dstBuffer for the header
* or an error code (can be tested using LZ5F_isError())
*//* LZ5F_createCompressionContext() :
* The first thing to do is to create a compressionContext object, which will be used in all compression operations.
* This is achieved using LZ5F_createCompressionContext(), which takes as argument a version and an LZ5F_preferences_t structure.
* The version provided MUST be LZ5F_VERSION. It is intended to track potential version differences between different binaries.
* The function will provide a pointer to an allocated LZ5F_compressionContext_t object.
* If the result LZ5F_errorCode_t is not OK_NoError, there was an error during context creation.
* Object can release its memory using LZ5F_freeCompressionContext();
*//***********************************
*  Advanced compression functions
***********************************//* LZ5F_compressFrame()
* Compress an entire srcBuffer into a valid LZ5 frame, as defined by specification v1.5.0, in a single step.
* The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.
* You can get the minimum value of dstMaxSize by using LZ5F_compressFrameBound()
* If this condition is not respected, LZ5F_compressFrame() will fail (result is an errorCode)
* The LZ5F_preferences_t structure is optional : you can provide NULL as argument. All preferences will then be set to default.
* The result of the function is the number of bytes written into dstBuffer.
* The function outputs an error code if it fails (can be tested using LZ5F_isError())
*//**************************************
*  Simple compression functions
**************************************///  printf("LZ5F_getBlockSize %d %d\n", blockSizeID+1, (int)blockSizes[blockSizeID]);/**************************************
*  Private functions
**************************************//* 0: unallocated;  1: LZ5_stream_t;  3: LZ5_streamHC_t *//**************************************
*  Structures and local types
**************************************//**************************************
*  Constants
**************************************//**************************************
*  Basic Types
**************************************//* LZ5F is a stand-alone API to create LZ5-compressed Frames
*  in full conformance with specification v1.5.0
*  All related operations, including memory management, are handled by the library.
* *//*
LZ5 auto-framing library
Copyright (C) 2011-2015, Yann Collet.

BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You can contact the author at :
- LZ5 source repository : https://github.com/inikep/lz5
- LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*/LZ5HC_more_profitablecommon - MINMATCHcommon - 3(off == last_off) ? 0 : offsum - commonbest_common - MINMATCHbest_common - 3(best_off == last_off) ? 0 : (best_off)sum - best_commonLZ5HC_better_price(best_off == last_off) ? 0 : best_offcommon - best_commonLZ5HC_get_priceLZ5_MATCH_COSTLZ5_LIT_COSTLZ5HC_hashPtrLZ5HC_hash7PtrLZ5HC_hash7LZ5HC_hash6PtrLZ5HC_hash6LZ5HC_hash5PtrLZ5HC_hash5LZ5HC_hash4PtrLZ5HC_hash4LZ5HC_hash3PtrLZ5HC_hash3prime3bytes32-24(32-24)506832829ULZ5_NORMAL_LIT_COST(len)(len)LZ5_NORMAL_MATCH_COST(mlen,offset)(LZ5_MATCH_COST(mlen,offset))LZ5_LIT_ONLY_COST(len)((len)+(LZ5_LEN_COST(len))+1)LZ5_CODEWORD_COST(litlen,offset,mlen)(LZ5_MATCH_COST(mlen,offset) + LZ5_LIT_COST(litlen,offset))LZ5_LEN_COST(len)(len<LZ5_LITERALS ? 0 : (len-LZ5_LITERALS < 255 ? 1 : (len-LZ5_LITERALS-255 < (1<<7) ? 2 : 3)))LZ5_SHORT_LITLEN_COST(len)(len<LZ5_SHORT_LITERALS ? 0 : (len-LZ5_SHORT_LITERALS < 255 ? 1 : (len-LZ5_SHORT_LITERALS-255 < (1<<7) ? 2 : 3)))LZ5_LITERALS((1<<RUN_BITS)-1)LZ5_SHORT_LITERALS((1<<RUN_BITS2)-1)LZ5_OPT_NUMLZ5_LOG_ENCODE(fmt,__VA_ARGS__...)LZ5_LOG_PRICE(fmt,__VA_ARGS__...)LZ5_LOG_PARSER(fmt,__VA_ARGS__...)LZ5HC_DEBUG(fmt,__VA_ARGS__...)/home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/lz5hc.cnoLimitLZ5_compressHC_continue_genericLZ5HC_setExternalDictsizeof(LZ5HC_Data_Structure) <= sizeof(LZ5_streamHC_t)sizeof(LZ5_streamHC_t)LZ5HC_Data_Structure *constsizeof(LZ5HC_Data_Structure)LZ5HC_compress_genericLZ5HC_compress_fastLZ5HC_compress_price_fastHashTable3HashPos3LZ5HC_compress_lowest_priceip - anchor(off0 == ctx->last_off) ? 0 : off0common0 - MINMATCHcommon0 - 3(off1 == off0) ? 0 : (off1)common1 - MINMATCHcommon1 - 3start2 - anchor(off1 == ctx->last_off) ? 0 : off1ml2 - MINMATCHml2 - 3LZ5HC_compress_optimal_priceLZ5HC_optimal_t[4100]LZ5HC_match_t[4097]"%d: start try REP rep=%d mlen=%d\n"(int)(ip-source), ctx->last_off, mlenllen + litlen(int)(inr-source), price, cur, litlen, LZ5_LIT_ONLY_COST(litlen)(int)(inr-source), price, cur, litlen, LZ5HC_get_price(litlen, 0, mlen - MINMATCH)"%d: LZ5HC_GetAllMatches match_num=%d\n""%d: LZ5HC_BinTree_GetAllMatches match_num=%d\n""out=%d\n"(int)((char*)op - dest)LZ5HC_optimal_t *sizeof(LZ5HC_optimal_t)LZ5HC_match_t *"%d: ENCODE_LAST literals=%d out=%d\n"(int)(ip-source), (int)(iend-anchor), (int)((char*)op -dest)LZ5HC_encodeSequence(int)RUN_MASK2(int)ML_MASK509"%u: ENCODE literals=%u off=%u mlen=%u out=%u\n"(U32)(*ip - ctx->inputBuffer), (U32)(*ip - *anchor), (U32)(*ip-match), (U32)matchLength, 2+(U32)(*op - ctx->outputBuffer)LZ5HC_BinTree_GetAllMatcheslimitedOutputBufferLZ5HC_GetAllMatchesLZ5HC_GetWiderMatchLZ5HC_FindMatchFastestLZ5HC_FindMatchFasterLZ5HC_FindMatchFastLZ5HC_FindBestMatchLZ5HC_InsertLZ5HC_BinTree_InsertFullLZ5HC_BinTree_InsertLZ5HC_initconst LZ5HC_parameters *{ while (last_pos < pos) { opt[last_pos+1].price = 1<<30; last_pos++; } opt[pos].mlen = (int)mlen; opt[pos].off = (int)offset; opt[pos].litlen = (int)litlen; opt[pos].price = (int)price; LZ5_LOG_PARSER("%d: SET price[%d/%d]=%d litlen=%d len=%d off=%d\n", (int)(inr-source), pos, last_pos, opt[pos].price, opt[pos].litlen, opt[pos].mlen, opt[pos].off); }LZ5_RESET_MEM_DEBUG/* These functions are planned to start generate warnings by r132 approximately *//* Deprecated compression functions *//***********************************
*  Deprecated Functions
***********************************///  if (dictSize < 4) dictSize = 0;/* if compilation fails here, LZ5_STREAMHCSIZE must be increased *///    LZ5HC_DEBUG("%u: TRY last_off=%d literals=%u off=%u mlen=%u literals2=%u off2=%u mlen2=%u best=%d\n", (U32)(ip - ctx->inputBuffer), ctx->last_off, (U32)(ip - anchor), off0, (U32)ml,  (U32)(start2 - anchor), off1, ml2, (U32)(best_pos - ip));//    if (inputSize > LASTLITERALS && lastRun < LASTLITERALS) { printf("ERROR: lastRun=%d\n", lastRun); }// best_mlen = 0;// check rep/*
LZ5 uses 3 types of codewords from 2 to 4 bytes long:
- 1_OO_LL_MMM OOOOOOOO - 10-bit offset, 3-bit match length, 2-bit literal length
- 00_LLL_MMM OOOOOOOO OOOOOOOO - 16-bit offset, 3-bit match length, 3-bit literal length
- 010_LL_MMM OOOOOOOO OOOOOOOO OOOOOOOO - 24-bit offset, 3-bit match length, 2-bit literal length 
- 011_LL_MMM - last offset, 3-bit match length, 2-bit literal length
*///		printf("delta1=%d\n", delta1);//		printf("delta0=%d\n", delta0);//          if (!longest || (mlt > longest && LZ5_NORMAL_MATCH_COST(mlt - MINMATCH, (ip - match == ctx->last_off) ? 0 : (ip - match)) < LZ5_NORMAL_MATCH_COST(longest - MINMATCH, (ip+back - *matchpos == ctx->last_off) ? 0 : (ip+back - *matchpos)) + LZ5_NORMAL_LIT_COST(mlt - longest)))//                if (ml==0 || ((mlt > ml) && LZ5_NORMAL_MATCH_COST(mlt - MINMATCH, (ip - match == ctx->last_off) ? 0 : (ip - match)) < LZ5_NORMAL_MATCH_COST(ml - MINMATCH, (ip - *matchpos == ctx->last_off) ? 0 : (ip - *matchpos)) + (LZ5_NORMAL_LIT_COST(mlt - ml))))//       if (ml==0 || ((mlt > ml) && LZ5_NORMAL_MATCH_COST(mlt - MINMATCH, (ip - match == ctx->last_off) ? 0 : (ip - match)) < LZ5_NORMAL_MATCH_COST(ml - MINMATCH, (ip - *matchpos == ctx->last_off) ? 0 : (ip - *matchpos)) + (LZ5_NORMAL_LIT_COST(mlt - ml))))//MEM_count(ip+MINMATCH, match+MINMATCH, iLimit) + MINMATCH;//   if (mlt > ml && (LZ5_NORMAL_MATCH_COST(mlt - MINMATCH, (ip - match == ctx->last_off) ? 0 : (ip - match)) < LZ5_NORMAL_MATCH_COST(ml - MINMATCH, (ip - *matchpos == ctx->last_off) ? 0 : (ip - *matchpos)) + (LZ5_NORMAL_LIT_COST(mlt - ml))))//                if (mlt > ml && (LZ5_NORMAL_MATCH_COST(mlt - MINMATCH, (ip - match == ctx->last_off) ? 0 : (ip - match)) < LZ5_NORMAL_MATCH_COST(ml - MINMATCH, (ip - *matchpos == ctx->last_off) ? 0 : (ip - *matchpos)) + (LZ5_NORMAL_LIT_COST(mlt - ml))))//        if (chainTable[idx & contentMask] == 1) chainTable[idx & contentMask] = (U32)0x01010101;//    LZ5_LOG_MATCH("%d: LZMAX_UPDATE_HASH_BINTREE hash=%d inp=%d,%d,%d,%d (%c%c%c%c)\n", (int)(inp-base), hash, inp[0], inp[1], inp[2], inp[3], inp[0], inp[1], inp[2], inp[3]);//      while ((matchIndex >= dictLimit) && (matchIndex < idx) && (idx - matchIndex) < MAX_DISTANCE && nbAttempts)/* Update chains up to "end" (excluded) *//*
    LZ5 HC - High Compression Mode of LZ5
    Copyright (C) 2011-2015, Yann Collet.
    Copyright (C) 2015, Przemyslaw Skibinski <inikep@gmail.com>

    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    You can contact the author at :
       - LZ5 source repository : https://github.com/inikep/lz5
       - LZ5 public forum : https://groups.google.com/forum/#!forum/lz5c
*//home/atharvakale/390r-debugging-setup/p7zip/C/lz5/lib/xxhash.cconst XXH_istate64_tconst XXH_istate64_t *U64[4]XXH_istate64_t *p64const XXH_istate32_tconst XXH_istate32_t *XXH_istate32_t *sizeof(XXH64_state_t) >= sizeof(XXH_istate64_t)sizeof(XXH32_state_t) >= sizeof(XXH_istate32_t)XXH_istate64_tXXH_istate32_t{ enum { XXH_static_assert = 1/(!!(c)) }; }(*(const char*)(&one))XXH_USELESS_ALIGN_BRANCH!defined(XXH_USELESS_ALIGN_BRANCH)/* A compilation error here means XXH64_state_t is not large enough *//* A compilation error here means XXH32_state_t is not large enough *//* defined as U64 for alignment *//* defined as U32 for alignment *//*** Allocation ***//****************************************************
*  Advanced Hash Functions
****************************************************//***************************************
*  Constants
***************************************//***************************************
*  Macros
***************************************//*****************************
*  Memory reads
*****************************//* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example one the compiler command line *//***************************************
*  Architecture Macros
***************************************//******************************************
*  Compiler-specific Functions and Macros
******************************************/// XXH_FORCE_DIRECT_MEMORY_ACCESS/**************************************
*  Basic Types
***************************************//**************************************
*  Includes & Memory related functions
***************************************//**************************************
*  Compiler Specific Options
***************************************//* XXH_USELESS_ALIGN_BRANCH :
 * This is a minor performance trick, only useful with lots of very small keys.
 * It means : don't make a test between aligned/unaligned, because performance will be the same.
 * It saves one initial branch per hash.
 *//* XXH_FORCE_NATIVE_FORMAT :
 * By default, xxHash library provides endian-independant Hash values, based on little-endian convention.
 * Results are therefore identical for little-endian and big-endian CPU.
 * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
 * Should endian-independance be of no importance for your application, you may set the #define below to 1,
 * to improve speed for Big-endian CPU.
 * This option has no impact on Little_Endian CPU.
 *//* XXH_ACCEPT_NULL_INPUT_POINTER :
 * If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.
 * When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.
 * By default, this option is disabled. To enable it, uncomment below define :
 *//* XXH_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets which generate assembly depending on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See http://stackoverflow.com/a/32095106/646947 for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 *//*
xxHash - Fast Hash algorithm
Copyright (C) 2012-2015, Yann Collet

BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You can contact the author at :
- xxHash source repository : https://github.com/Cyan4973/xxHash
*//home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_core.h"lzham_vector.h""lzham_utils.h""lzham_math.h""lzham_mem.h""lzham_traits.h""lzham_helpers.h""lzham_platform.h""lzham_assert.h""lzham_types.h""lzham_config.h""lzham.h"<algorithm><memory.h><malloc.h>const boolc_lzham_big_endian_platformc_lzham_little_endian_platform!c_lzham_little_endian_platformLZHAM_NOTE_UNUSED(x)(void)xLZHAM_FORCE_INLINEinline __attribute__((__always_inline__,__gnu_inline__))LZHAM_RESTRICTLZHAM_USE_GCC_ATOMIC_BUILTINSLZHAM_USE_PTHREADS_APILZHAM_LITTLE_ENDIAN_CPULZHAM_USE_UNALIGNED_INT_LOADSLZHAM_CPU_HAS_64BIT_REGISTERSLZHAM_64BIT_POINTERSLZHAM_PLATFORM_PC_X64LZHAM_PLATFORM_PCdefined(__FreeBSD__) || defined(__NetBSD__)defined(_XBOX) && !defined(LZHAM_ANSI_CPLUSPLUS)defined(WIN32) && !defined(LZHAM_ANSI_CPLUSPLUS)_DLLdefined(__MINGW32__) || defined(__MINGW64__)_WIN64defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)defined(__APPLE__) && !defined(LZHAM_ANSI_CPLUSPLUS)(TARGET_IPHONE_SIMULATOR == 1) || (TARGET_OS_IPHONE == 1)defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)__BIG_ENDIAN__(TARGET_OS_MAC == 1)defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) && !defined(LZHAM_ANSI_CPLUSPLUS)defined(_LP64) || defined(__LP64__) || defined(__x86_64__)!defined(__APPLE__) && !defined(__FreeBSD__)// No threading support, unaligned loads are NOT okay, no atomic ops.// --- Vanilla ANSI-C/C++// 64-bit build assumes pointers are always 64-bit// --- Generic GCC/clang path for x86/x64, clang or GCC, Linux, OSX, FreeBSD or NetBSD, pthreads for threading, GCC built-ins for atomic ops.// --- Apple: iOS or OSX// Otherwise, we disable exceptions for a small speed boost.// If we're using the DLL form of the run-time libs, we're also going to be enabling exceptions because we'll be building CLR apps.// Ensure checked iterators are disabled.// --- Windows: MSVC or MinGW, x86 or x64, Win32 API's for threading and Win32 Interlocked API's or GCC built-ins for atomic ops.// --- X360 - This hasn't been tested since early an alpha.// Apple OSX and iOS// TODO: I haven't compiled/tested on these platforms yet, let's play it safe for now.//#define LZHAM_ANSI_CPLUSPLUS 1// Enable this when first porting to new platforms - disables all threading and atomic ops in compressor:// conditional expression is constant// See Copyright Notice and license at the end of include/lzham.h// File: lzham_core.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzbase.h"lzham_lzdecompbase.h"CLZBaseCLZBase &operator=CLZBase &&const CLZBaseconst CLZBase &compute_lzx_position_slotuint &unsigned int &CLZBase *uint8[4096]uint8 *0x100000uint8[512]0x1000000uint8[256]0x20000000x4000000uint[128]uint *s < m_num_lzx_slotsCLZDecompBase *const char[20]const char[84]char[84](m_lzx_position_base[slot] + ofs) == distconst char[42]ofs < (1U << m_lzx_position_extra_bits[slot])uint8[128]const char[46]char[46]init_slot_tabsm_slot_tab2m_slot_tab1m_slot_tab0// namespace lzham//#define LZHAM_DISABLE_RAW_BLOCKS//#define LZHAM_LZVERIFY// File: lzham_lzbase.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcompofscompiled as c++/usr/include/c++/12/stdlib.h/usr/include/c++/12/cstdlib/usr/include/c++/12/x86_64-redhat-linux/bits/c++config.h/usr/include/c++/12/x86_64-redhat-linux/bits/os_defines.h/usr/include/c++/12/x86_64-redhat-linux/bits/cpu_defines.h/usr/include/c++/12/pstl/pstl_config.h/usr/include/c++/12/bits/std_abs.h/usr/include/bits/types/cookie_io_functions_t.h/usr/include/c++/12/math.h/usr/include/c++/12/cmath/usr/include/c++/12/bits/cpp_type_traits.h/usr/include/c++/12/ext/type_traits.h/usr/include/bits/mathcalls-narrow.h/usr/include/bits/iscanonical.h/usr/include/c++/12/bits/specfun.h/usr/include/c++/12/bits/stl_algobase.h/usr/include/c++/12/bits/functexcept.h/usr/include/c++/12/bits/exception_defines.h/usr/include/c++/12/ext/numeric_traits.h/usr/include/c++/12/bits/stl_pair.h/usr/include/c++/12/type_traits/usr/include/c++/12/bits/move.h/usr/include/c++/12/bits/utility.h/usr/include/c++/12/bits/stl_iterator_base_types.h/usr/include/c++/12/bits/stl_iterator_base_funcs.h/usr/include/c++/12/bits/concept_check.h/usr/include/c++/12/debug/assertions.h/usr/include/c++/12/bits/stl_iterator.h/usr/include/c++/12/bits/ptr_traits.h/usr/include/c++/12/debug/debug.h/usr/include/c++/12/bits/predefined_ops.h/usr/include/c++/12/limits/usr/include/c++/12/tr1/gamma.tcc/usr/include/c++/12/tr1/special_function_util.h/usr/include/c++/12/tr1/bessel_function.tcc/usr/include/c++/12/tr1/beta_function.tcc/usr/include/c++/12/tr1/ell_integral.tcc/usr/include/c++/12/tr1/exp_integral.tcc/usr/include/c++/12/tr1/hypergeometric.tcc/usr/include/c++/12/tr1/legendre_function.tcc/usr/include/c++/12/tr1/modified_bessel_func.tcc/usr/include/c++/12/tr1/poly_hermite.tcc/usr/include/c++/12/tr1/poly_laguerre.tcc/usr/include/c++/12/tr1/riemann_zeta.tcc/usr/include/malloc.h/usr/include/memory.h/usr/include/bits/xopen_lim.h/usr/include/bits/uio_lim.h/usr/include/c++/12/algorithm/usr/include/c++/12/bits/stl_algo.h/usr/include/c++/12/bits/algorithmfwd.h/usr/include/c++/12/initializer_list/usr/include/c++/12/bits/stl_heap.h/usr/include/c++/12/bits/stl_tempbuf.h/usr/include/c++/12/bits/stl_construct.h/usr/include/c++/12/new/usr/include/c++/12/bits/exception.h/usr/include/c++/12/bits/uniform_int_dist.h/usr/include/c++/12/pstl/glue_algorithm_defs.h/usr/include/c++/12/pstl/execution_defs.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/include/lzham.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_config.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_types.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_assert.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_platform.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_helpers.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_traits.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_mem.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_math.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_utils.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_vector.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_lzdecompbase.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzbase.cpp"lzham_lzbase.h""lzham_core.h"slot == iconst char[10]const char[86]char[86]i == m_lzx_position_base[slot] + ofsconst char[37]512U1024U512U*1024U(m_dict_size - 1) == m_lzx_position_base[slot] + ofsconst char[53]LZHAM_BUILD_DEBUG//namespace lzham//printf("%u: 0x%08X - 0x%08X, %u\n", i, m_lzx_position_base[i], m_lzx_position_base[i] + (1 << m_lzx_position_extra_bits[i]) - 1, m_lzx_position_extra_bits[i]);// File: lzham_lzbase.cppcompute_mask_shiftcompute_mask_sizeceil_log2iconst uintcIntBitsfloor_log2inext_pow2align_up_pointeris_power_of_2maximumminimummathdefined(LZHAM_USE_MSVC_INTRINSICS) && !defined(__MINGW32__)defined(__MINGW32__)defined(LZHAM_USE_MSVC_INTRINSICS)is_power_of_2(alignment)// Returns the total number of bits needed to encode v.// val remains unchanged if it is already a power of 2.// From "Hackers Delight"// Just don't use them on non-simple (non built-in) types!// http://www.stepanovpapers.com/notes.pdf// Yes I know these should probably be pass by ref, not val:// File: lzham_math.hswapvector<T> &vector_testincrease_capacityvector<T> *elemental_vector *cFlagobject_moverT *pSrcT *constpSrc_endpDstset_allconst Tconst T &T &count_occurencesfind_sortedfinduniquesortoperator<const vector<T>const vector<T> &operator==erase_unorderederaseappendconst T *try_push_frontpop_backtry_push_backtry_enlargetry_resize_no_constructtry_resizedestruct_arrayconstruct_arraytry_reserveclear_no_destructionclearget_ptrconst vector<T> *atoperator[]i < m_sizeconst char[11]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/../lzhamdecomp/lzham_vector.hconst char[99]char[99]capacitysize_in_bytesempty~vectorvectorexplicitelemental_vector &elemental_vector &&const elemental_vectorconst elemental_vector &bitwise_movable<vector<T>>vector<T>is_vector<vector<Q>>is_vector<Q>const_pointerpointerconst_referencereferencevalue_typeconst_iteratorelemental_vectorm_capacitym_sizem_p(int)m_size(i >= 0) && (i < (int)m_size)index < m_size(p >= m_p) && (p < (m_p + m_size))(start + n) <= m_size(pDst - m_p) < (int)m_sizeindex <= m_size!m_p || (&obj < m_p) || (&obj >= (m_p + m_size))"lzham::vector operator=: Out of memory!"// Uniform binary search - Knuth Algorithm 6.2.1 U, unrolled twice.// push_front() isn't going to be very fast - it's only here for usability.// The first element is returned if the index is out of range.// at() always includes range checking, even in final builds, unlike operator [].// operator[] will assert on out of range indices, but in final builds there is (and will never be) any range checking on this method.// File: lzham_vector.hmin_new_capacitygrow_hintnofailpDst_voidpSrc_voidotherrhsnew_sizenew_capacityinitless_thanelement_sizepRelocate/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_comp.hlzham_lib_z_compressBoundlzham_lib_z_compresslzham_z_ulong *lzham_lib_z_compress2lzham_lib_z_deflateBoundlzham_lib_z_deflateEndlzham_lib_z_deflatelzham_lib_z_deflateResetlzham_lib_z_deflateInit2lzham_lib_z_deflateInitlzham_lib_compress_memoryconst lzham_compress_paramsconst lzham_compress_params *lzham_compress_params *lzham_uint8 *const lzham_uint8const lzham_uint8 *lzham_uint32 *lzham_lib_compress2lzham_lib_compresslzham_lib_compress_deinitlzham_lib_compress_reinitlzham_lib_compress_init// File: lzham_comp.hsource_lenpDestpDest_lenpSourcepStreammethodmem_levelpParamspDst_bufpDst_lenpSrc_bufpAdler32pIn_bufpIn_buf_sizepOut_bufpOut_buf_sizeflush_typeno_more_input_bytes_flag/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_pthreads_threading.h<semaphore.h>lzham_get_max_helper_threadslzham_sleepmillisecondsmsecs_to_sleepexecute_taskvirtualget_methodget_objectobject_taskthread_funcprocess_tasktask &joinqueue_multiple_object_tasksS *queue_object_taskqueue_taskexecutable_task *get_num_outstanding_tasksconst task_poolconst task_pool *task_pool *volatile atomic32_tget_num_threadsdeinittask_pool &const task_pool &~task_pooltask_pooltask &&const taskconst task &tasktask *union <unnamed> &union <unnamed> &&const union <unnamed> &executable_task &executable_task &&const executable_taskconst executable_task &executable_taskpoptry_push~tsstacktsstackspinlock &const spinlockconst spinlock &spinlockunlockspinlock *"spinlock: pthread_spin_unlock() failed"const char[41]const char[96]char[96]lock"spinlock: pthread_spin_lock() failed"const char[39]~spinlock"spinlock: pthread_spin_init() failed"const uint32semaphore *sem_t *interval1000000L"semaphore: sem_wait() or sem_timedwait() failed"const char[50]char[50]releasereleaseCount >= 1const char[18]"semaphore: sem_post() or sem_post_multiple() failed"const char[54]~semaphoresemaphorepNamemaximumCountmaximumCount >= initialCountconst char[29]"semaphore: sem_init() failed"const char[31]semaphore &const semaphoreconst semaphore &object_task<T>object_method_ptrobject_task_flagscObjectTaskFlagDefaultcObjectTaskFlagDeleteAfterExecutioncMaxThreadsLZHAM_MAX_HELPER_THREADStask_flagscTaskFlagObjecttask_callback_functsstack<T, cMaxSize>cMaxSizem_flagsm_pMethodm_pObjectm_exit_flagm_num_outstanding_tasksm_tasks_availablepthread_t[64]unsigned long[64]m_threadsm_num_threadsm_task_stackm_pObjm_callbackm_pData_ptrm_datam_topT[]m_stackm_spinlockm_semLZHAM_RND_CONG(jcong)(69069U * jcong + 1234567U)LZHAM_NO_ATOMICSWIN32num_taskspObjectpObject && pMethod// LZHAM_USE_PTHREADS_API// Returns number of helper threads we can add to the process on the current system (i.e. for a 4 CPU system this returns 3).// Sleep// It's the caller's responsibility to delete pObj within the execute_task() method, if needed!// C-style task callback// Simple task pool// Thread safe stack// spinlock   // Argh this stinks. Try to choose a name that won't conflict with anything the calling process uses.// semaphore// File: lzham_task_pool_pthreads.hpData_ptrpMethodinitialCountpObject_methodfirst_datapContexttskpObjpFuncnum_threads/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_threading.h"lzham_pthreads_threading.h"LZHAM_USE_WIN32_API// File: lzham_threading.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_match_accel.h"lzham_threading.h"search_accelerator &search_accelerator &&const search_acceleratorconst search_accelerator &~search_acceleratorsearch_accelerator *search_acceleratorfind_len2_matchesfind_all_matchesfind_all_matches_callbackget_match_lenconst search_accelerator *lookahead_ofs < m_lookahead_sizeconst char[33]const char[89]char[89]start_match_len <= max_match_lenmax_match_len <= (get_lookahead_size() - lookahead_ofs)..(..)const char[56]find_dict_sizecomp_poslookahead_posconst uint8const uint8 *pCompconst unsigned char &unsigned char &pLookaheadadvance_bytesdict_match *find_matchesget_len2_matchget_fill_dict_sizeget_fill_lookahead_sizeget_fill_lookahead_posadd_bytes_endget_num_completed_helper_threadsadd_bytes_beginget_max_add_bytesget_max_helper_threadsget_charget_lookahead_sizeget_lookahead_posget_cur_dict_sizeget_max_dict_size_maskget_max_dict_sizeresetbitwise_movable<dict_match> &bitwise_movable<dict_match> &&const bitwise_movable<dict_match>const bitwise_movable<dict_match> &dict_match &dict_match &&const dict_matchconst dict_match &const dict_match *get_lenget_distbitwise_movable<node> &bitwise_movable<node> &&const bitwise_movable<node>const bitwise_movable<node> &node &node &&const nodeconst node &cDigramHashSizecHashSizebitwise_movable<dict_match>dict_matchbitwise_movable<node>m_num_completed_helper_threadsm_next_match_refm_all_matchesm_max_matchesm_max_probesm_fill_dict_sizem_fill_lookahead_sizem_fill_lookahead_posm_digram_nextm_digram_hashm_hash_thread_indexm_match_refsm_matchesm_nodesm_hashm_dictm_cur_dict_sizem_lookahead_sizem_lookahead_posm_max_dict_size_maskm_max_dict_sizem_max_helper_threadsm_pTask_poolm_pLZBasem_lenm_distm_rightm_leftcMatchAccelMaxSupportedProbespack(push, 1)pack(pop)// Returns the lookahead's raw position/size/dict_size at the time add_bytes_begin() is called.// For each length, it will discard matches with worse distances (in the coding sense).// Otherwise, the finder will tend to return lists of matches with mostly unique lengths.// If all_matches is true, the match finder returns all found matches with no filtering.// File: lzham_match_accel.hlookahead_ofsstart_match_lencur_dict_posdelta_posspinpBytespLZBasepPoolmax_helper_threadsmax_dict_sizemax_matchesall_matchesmax_probes/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_symbol_codec.h"lzham_prefix_coding.h"convert_to_scaled_bitcostbits <= 255const char[12]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/../lzhamdecomp/lzham_symbol_codec.hconst char[105]scaled_bitscBitCostScaleShiftsymbol_codec &symbol_codec &&const symbol_codecconst symbol_codec &~symbol_codecsymbol_codec *symbol_codecdecode_need_bytesremove_bitsget_bitsassemble_output_bufflush_bitsput_bits_align_to_byteput_bitsarith_stop_encodingarith_start_encodingarith_renorm_enc_intervalarith_propagate_carryrecord_put_bitsput_bits_initget_total_model_updatesconst symbol_codec *stop_decodingdecodeadaptive_arith_data_model &adaptive_bit_model &quasi_adaptive_huffman_data_model &decode_remove_byte_from_bit_bufdecode_align_to_bytedecode_remove_bitsdecode_peek_bitsdecode_bitsstart_arith_decodingdecode_get_bits_remainingdecode_get_bytes_consumeddecode_set_input_bufferstart_decodingvector<unsigned char> &get_encoding_bufconst vector<unsigned char>const vector<unsigned char> &stop_encodingencode_get_total_bits_writtenencode_align_to_byteencode_arith_initencode_bitsstart_encodingoutput_symbol &output_symbol &&const output_symbolconst output_symbol &get_costget_total_symsconst adaptive_arith_data_modelconst adaptive_arith_data_model *adaptive_arith_data_model *updatereset_update_ratefast_encodingconst adaptive_arith_data_model &~adaptive_arith_data_modeladaptive_arith_data_modelconst adaptive_bit_modelconst adaptive_bit_model *adaptive_bit_model *uint32[2048]cSymbolCodecArithProbScaleuint32 *cSymbolCodecArithProbMoveBitsm_bit_0_prob >= 1m_bit_0_prob < cSymbolCodecArithProbScaleset_probability_0cSymbolCodecArithProbBitscSymbolCodecArithProbBits - 1(cSymbolCodecArithProbBits - 1)1U << (cSymbolCodecArithProbBits - 1)const adaptive_bit_model &adaptive_bit_modelquasi_adaptive_huffman_data_model &&const quasi_adaptive_huffman_data_modelconst quasi_adaptive_huffman_data_model &~quasi_adaptive_huffman_data_modelquasi_adaptive_huffman_data_model *quasi_adaptive_huffman_data_modelupdate_tablesconst raw_quasi_adaptive_huffman_data_modelconst raw_quasi_adaptive_huffman_data_model *raw_quasi_adaptive_huffman_data_model *update_syminit2const uint16const uint16 *raw_quasi_adaptive_huffman_data_model &const raw_quasi_adaptive_huffman_data_model &assign~raw_quasi_adaptive_huffman_data_modelraw_quasi_adaptive_huffman_data_modelcNullcEncodingcDecodingcBitBufSizebit_buf_tconst uint8 *&unsigned char *&size_t &unsigned long &bool &need_bytes_func_ptroutput_symbolcArithSymcAlignToByteSymcArithInitbit_cost_tm_modem_saved_node_indexm_pSaved_modelm_pSaved_huff_modelm_arith_total_bitsm_arith_lengthm_arith_valuem_arith_basem_total_bits_writtenm_output_symsm_arith_output_bufm_output_bufm_total_model_updatesm_bit_countm_bit_bufm_pDecode_private_datam_pDecode_need_bytes_funcm_decode_buf_eofm_decode_buf_sizem_pDecode_buf_endm_pDecode_buf_nextm_pDecode_bufm_arith_prob0m_num_bitsm_bitsm_probsm_total_symsm_bit_0_probsizeof(raw_quasi_adaptive_huffman_data_model)128 - sizeof(raw_quasi_adaptive_huffman_data_model)m_unused_alignmentm_encodingm_adapt_ratem_max_update_intervalm_decoder_table_bitsm_total_countm_symbols_until_updatem_update_cyclem_max_cycledecoder_tables *m_pDecode_tablesm_code_sizesm_codesm_sym_freqm_initial_sym_freqg_prob_costconst bit_cost_tcBitCostMaxconst uint64cBitCostScale1U << cBitCostScaleShift(1U << cBitCostScaleShift)cSymbolCodecArithProbHalfScale1 << (cSymbolCodecArithProbBits - 1)1 << cSymbolCodecArithProbBitscSymbolCodecArithMaxLencSymbolCodecArithMinLen0x01000000ULZHAM_SYMBOL_CODEC_DECODE_ARITH_START(codec){ for ( arith_value = 0, arith_length = 0; arith_length < 4; ++arith_length ) { uint val; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, val, 8); arith_value = (arith_value << 8) | val; } arith_length = cSymbolCodecArithMaxLen; }LZHAM_SYMBOL_CODEC_DECODE_REMOVE_BYTE_FROM_BIT_BUF(codec,result){ result = -1; if (bit_count >= 8) { result = static_cast<int>(bit_buf >> (symbol_codec::cBitBufSize - 8)); bit_buf <<= 8; bit_count -= 8; } }LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec)if (bit_count & 7) { int dummy_result; LZHAM_NOTE_UNUSED(dummy_result); LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, dummy_result, bit_count & 7); }LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_HUFFMAN(codec,result,model){ quasi_adaptive_huffman_data_model* pModel; const prefix_coding::decoder_tables* pTables; pModel = &model; pTables = model.m_pDecode_tables; if (LZHAM_BUILTIN_EXPECT(bit_count < 24, 0)) { uint c; pDecode_buf_next += sizeof(uint32); if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next >= codec.m_pDecode_buf_end, 0)) { pDecode_buf_next -= sizeof(uint32); while (bit_count < 24) { if (!codec.m_decode_buf_eof) { codec.m_pSaved_huff_model = pModel; LZHAM_SYMBOL_CODEC_DECODE_END(codec) LZHAM_DECODE_NEEDS_BYTES LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) pModel = codec.m_pSaved_huff_model; pTables = pModel->m_pDecode_tables; } c = 0; if (pDecode_buf_next < codec.m_pDecode_buf_end) c = *pDecode_buf_next++; bit_count += 8; bit_buf |= (static_cast<symbol_codec::bit_buf_t>(c) << (symbol_codec::cBitBufSize - bit_count)); } } else { c = LZHAM_READ_BIG_ENDIAN_UINT32(pDecode_buf_next - sizeof(uint32)); bit_count += 32; bit_buf |= (static_cast<symbol_codec::bit_buf_t>(c) << (symbol_codec::cBitBufSize - bit_count)); } } uint k = static_cast<uint>((bit_buf >> (symbol_codec::cBitBufSize - 16)) + 1); uint len; if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_table_max_code, 1)) { uint32 t = pTables->m_lookup[bit_buf >> (symbol_codec::cBitBufSize - pTables->m_table_bits)]; result = t & UINT16_MAX; len = t >> 16; } else { len = pTables->m_decode_start_code_size; for ( ; ; ) { if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_max_codes[len - 1], 0)) break; len++; } int val_ptr = pTables->m_val_ptrs[len - 1] + static_cast<int>(bit_buf >> (symbol_codec::cBitBufSize - len)); if (((uint)val_ptr >= pModel->m_total_syms)) val_ptr = 0; result = pTables->m_sorted_symbol_order[val_ptr]; } bit_buf <<= len; bit_count -= len; uint freq = pModel->m_sym_freq[result]; freq++; pModel->m_sym_freq[result] = static_cast<uint16>(freq); LZHAM_ASSERT(freq <= UINT16_MAX); if (LZHAM_BUILTIN_EXPECT(--pModel->m_symbols_until_update == 0, 0)) { pModel->update_tables(); } }LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_ARITHMETIC(codec,result,model){ adaptive_arith_data_model *pArith_data_model; pArith_data_model = &model; uint node_index; node_index = 1; do { while (LZHAM_BUILTIN_EXPECT(arith_length < cSymbolCodecArithMinLen, 0)) { uint c; codec.m_saved_node_index = node_index; codec.m_pSaved_model = pArith_data_model; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, c, 8); node_index = codec.m_saved_node_index; pArith_data_model = static_cast<adaptive_arith_data_model *>(codec.m_pSaved_model); arith_value = (arith_value << 8) | c; arith_length <<= 8; } adaptive_bit_model *pBit_model; pBit_model = &pArith_data_model->m_probs[node_index]; uint x = pBit_model->m_bit_0_prob * (arith_length >> cSymbolCodecArithProbBits); uint bit; bit = (arith_value >= x); if (!bit) { pBit_model->m_bit_0_prob += ((cSymbolCodecArithProbScale - pBit_model->m_bit_0_prob) >> cSymbolCodecArithProbMoveBits); arith_length = x; } else { pBit_model->m_bit_0_prob -= (pBit_model->m_bit_0_prob >> cSymbolCodecArithProbMoveBits); arith_value -= x; arith_length -= x; } node_index = (node_index << 1) + bit; } while (node_index < pArith_data_model->m_total_syms); result = node_index - pArith_data_model->m_total_syms; }LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec,result,model){ adaptive_bit_model *pModel; pModel = &model; while (LZHAM_BUILTIN_EXPECT(arith_length < cSymbolCodecArithMinLen, 0)) { uint c; codec.m_pSaved_model = pModel; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, c, 8); pModel = static_cast<adaptive_bit_model*>(codec.m_pSaved_model); arith_value = (arith_value << 8) | c; arith_length <<= 8; } uint x = pModel->m_bit_0_prob * (arith_length >> cSymbolCodecArithProbBits); result = (arith_value >= x); if (!result) { pModel->m_bit_0_prob += ((cSymbolCodecArithProbScale - pModel->m_bit_0_prob) >> cSymbolCodecArithProbMoveBits); arith_length = x; } else { pModel->m_bit_0_prob -= (pModel->m_bit_0_prob >> cSymbolCodecArithProbMoveBits); arith_value -= x; arith_length -= x; } }LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec,result,num_bits){ while (LZHAM_BUILTIN_EXPECT(bit_count < (int)(num_bits), 0)) { uint r; if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next == codec.m_pDecode_buf_end, 0)) { if (LZHAM_BUILTIN_EXPECT(!codec.m_decode_buf_eof, 1)) { LZHAM_SYMBOL_CODEC_DECODE_END(codec) LZHAM_DECODE_NEEDS_BYTES LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) } r = 0; if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next < codec.m_pDecode_buf_end, 1)) r = *pDecode_buf_next++; } else r = *pDecode_buf_next++; bit_count += 8; bit_buf |= (static_cast<symbol_codec::bit_buf_t>(r) << (symbol_codec::cBitBufSize - bit_count)); } result = (num_bits) ? static_cast<uint>(bit_buf >> (symbol_codec::cBitBufSize - (num_bits))) : 0; bit_buf <<= (num_bits); bit_count -= (num_bits); }LZHAM_SYMBOL_CODEC_DECODE_END(codec)codec.m_arith_value = arith_value; codec.m_arith_length = arith_length; codec.m_bit_buf = bit_buf; codec.m_bit_count = bit_count; codec.m_pDecode_buf_next = pDecode_buf_next;LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec)arith_value = codec.m_arith_value; arith_length = codec.m_arith_length; bit_buf = codec.m_bit_buf; bit_count = codec.m_bit_count; pDecode_buf_next = codec.m_pDecode_buf_next;LZHAM_SYMBOL_CODEC_DECODE_DECLARE(codec)uint arith_value = 0; uint arith_length = 0; symbol_codec::bit_buf_t bit_buf = 0; int bit_count = 0; const uint8* pDecode_buf_next = NULL;LZHAM_SYMBOL_CODEC_USE_64_BIT_BUFFER// The user must declare the LZHAM_DECODE_NEEDS_BYTES macro.// The user must define the LZHAM_DECODE_NEEDS_BYTES macro, which is invoked when the decode buffer is exhausted.// member variables on the stack so they're hopefully put in registers (avoiding horrible load hit stores on some CPU's).// This is hard to debug (and just plain ugly), but using these macros eliminate function calls, and they place the most important // Optional macros for faster decompression. These macros implement the symbol_codec class's decode functionality.// Decoding// Encoding// clear() is like reset(), except it also frees all memory.// This class is not actually used by LZHAM - it's only here for comparison/experimental purposes.// Ensures sizeof(quasi_adaptive_huffman_data_model) is 128 bytes on x64 (it's 64 on x86).// def=10, 8 or higher, scaled by 8, controls the slowing of the update update freq, higher=more rapid slowing (faster decode/lower ratio)// def=16, typical range 12-128, controls the max interval between table updates, higher=longer max interval (faster decode/lower ratio)// File: lzham_symbol_codec.hpBufpBuf_nexteof_flagtotal_symsexpected_sizeupdate_modelpNeed_bytes_funcpPrivate_datasupport_arithexpected_file_sizeprob0force_update_cyclesym_freq_all_onesmax_update_intervaladapt_ratepInitial_sym_freq/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzcomp_internal.h"lzham_symbol_codec.h""lzham_match_accel.h"lzcompressor &const lzcompressorconst lzcompressor &~lzcompressorlzcompressor *parse_thread_state[9]cMaxParseThreadscMaxParseThreads + 1~parse_thread_stateparse_thread_state *~raw_parse_thread_stateraw_parse_thread_state *~statestate *quasi_adaptive_huffman_data_model[2]lzcompressorsend_sync_blockcode_decisioncompress_block_internalcompress_blockparse_job_callbackgreedy_parseparse_thread_state &enumerate_lz_decisionsconst stateconst state &state &vector<lzpriced_decision> &optimal_parseextreme_parsesend_configurationsend_final_blockinit_seed_bytessend_zlib_headerget_total_recent_reset_update_rateget_max_block_ratioget_min_block_ratioget_recent_block_ratioupdate_block_historyget_src_adler32const lzcompressor *byte_vec &get_compressed_dataconst byte_vecconst byte_vec &put_bytesconst init_paramsconst init_params &init_params &block_history &block_history &&const block_historyconst block_history &parse_thread_state &&const parse_thread_stateconst parse_thread_state &parse_thread_stateraw_parse_thread_state &raw_parse_thread_state &&const raw_parse_thread_stateconst raw_parse_thread_state &raw_parse_thread_statenode_state &node_state &&const node_stateconst node_state &node_statenode_state *add_stateconst lzdecisionconst lzdecision &lzdecision &node *coding_stats &coding_stats &&const coding_statsconst coding_stats &coding_statsprintcoding_stats *tracked_stat[4]CLZBase::cMatchHistSizetracked_stat[258]cMaxMatchLencMaxMatchLen + 1tracked_stat &tracked_stat &&const tracked_statconst tracked_stat &tracked_statget_max_valconst tracked_stat *tracked_stat *get_min_valget_std_devget_averageget_totalget_number_of_values32(0x7fffffff * 2U + 1U)m_numget_number_of_valuesoperator doubleoperator+=m_min_valm_max_val8.999999999999999949e+999e+99-8.999999999999999949e+99-9e+99init_params &&init_paramsinit_params *cCompressionLevelDefaultcDefaultBlockSizelzpriced_decision &lzpriced_decision &&const lzpriced_decisionconst lzpriced_decision &lzpriced_decisionconst lzpriced_decision *lzpriced_decision *lzdecision *lzdecision &&lzdecisionget_min_codable_lenconst lzdecision *CLZBase::cMinMatchLenget_complexitycRep0Complexity == 2assume_typedef__COUNTER__cLitComplexityassume_typedef0cLongMatchComplexityLenThreshcLongMatchComplexitycShortMatchComplexityget_match_diststate &&will_reference_last_matchconst state *const state_baseconst state_base *state_base *CLZBase::cNumLitStatesget_pred_charstart_of_blockreset_state_partialfind_match_distupdate_match_histencode_reset_state_partialencode_eobadvanceupdate_statsget_full_match_costsbit_cost_t *get_rep_match_costsget_lit_costget_len2_match_coststate_base &state_base &&const state_base &restore_partial_stateuint[4]const uint *sizeof(m_match_hist)save_partial_statepartial_advancelzdecis_rep0is_full_matchis_litcomp_settings &comp_settings &&const comp_settingsconst comp_settings &cMaxBlockHistorySizecBlockHistoryCompRatioScale1000Ublock_historycRep0ComplexitycRep3Complexitystate_basecMaxNodeStatescMinDictSizeLog2CLZBase::cMinDictSizeLog2cMaxDictSizeLog2CLZBase::cMaxDictSizeLog21024U*512Ucomp_settingscompression_levelcCompressionLevelFastestcCompressionLevelFastercCompressionLevelBettercCompressionLevelUbercCompressionLevelCountblock_history[6]m_block_historym_block_history_sizem_block_history_nextm_reset_update_ratem_raw_blockm_ratiom_src_sizem_comp_sizem_parse_jobs_completem_parse_jobs_remainingm_parse_thread_stateuint8[40]714200sizeof(raw_parse_thread_state)sizeof(raw_parse_thread_state) & 127(sizeof(raw_parse_thread_state) & 127)128 - (sizeof(raw_parse_thread_state) & 127)m_unused_alignment_arraym_failedm_issue_reset_state_partialm_greedy_parse_gave_upm_greedy_parse_total_bytes_codedm_max_greedy_decisionsm_temp_decisionsm_emit_decisions_backwardsm_best_decisionsnode[3073]3072cMaxParseGraphNodes3073cMaxParseGraphNodes + 1node_state[4]m_node_statesm_parent_state_indexm_parent_indexm_total_complexitym_total_costm_saved_statem_lzdecm_num_node_statesm_initial_statem_bytes_to_matchm_start_ofsm_num_parse_threadsm_statem_start_of_block_statem_use_task_poolm_finishedm_block_indexm_block_start_dict_ofsm_stepm_comp_bufm_block_bufm_statsm_max_len2_distm_total_update_rate_resetsm_total_near_len2_matchesm_total_far_len2_matchesm_full_match_statsm_rep0_len2_plus_statsm_rep0_len1_statsm_rep_statsm_delta_lit_statsm_lit_statsm_total_matchesm_total_nonmatchesuint[5]uint[12][5]unsigned int[12][5]CLZBase::cNumStatesm_match_type_was_not_truncated_histm_match_type_truncation_histuint[258]CLZBase::cMaxMatchLenCLZBase::cMaxMatchLen + 1m_match_truncation_histm_match_truncation_len_histm_total_truncated_matchesm_total_is_match1_bits_costm_total_is_match0_bits_costm_worst_match_bits_costm_total_match_bits_costm_context_statsm_total2m_totalm_total_contextsm_total_bytesm_codecm_accelm_src_adler32m_settingsm_paramsm_table_update_interval_slow_ratem_table_max_update_intervalm_num_seed_bytesm_pSeed_bytesm_lzham_compress_flagsm_block_sizem_dict_size_log2m_compression_levelm_costm_match_histm_cur_statem_cur_ofsm_dist_lsb_tablem_large_len_tablem_rep_len_tablem_main_tablem_delta_lit_tablem_lit_tableadaptive_bit_model[12]m_is_rep2_modelm_is_rep1_modelm_is_rep0_single_byte_modelm_is_rep0_modelm_is_rep_modelm_is_match_modelm_posm_match_accel_max_probesm_match_accel_max_matches_per_probem_fast_adaptive_huffman_updatingm_fast_bytes// +1 extra for the greedy parser thread (only used for delta compression)// main thread's current coding state// state at start of block// Parent node state index (only valid when extreme parsing).// Parent node index.// Total cost to arrive at this node state.// This is either the state of the parent node (optimal parsing), or the state of the child node (extreme parsing).// the lzdecision that led from parent to this node_state//math::cNearlyInfinite;// Returns actual cost.// 2, 3, 4, or 5// may be a rep or full match// <0 if match rep, else >=1 is match dist// 0 if literal, 1+ if match// dict position where decision was evaluated// sync, or sync+dictionary flush // File: lzham_lzcomp_internal.hcur_ofsbytes_to_matchparse_statecur_statedecisionsmin_match_lencomp_sizeraw_blockparent_indexparent_state_indexparent_statetotal_costtotal_complexitybackward_ofsblock_indexmatch_histmatch_distcodecdict_poslzbasepBitcostsis_match_model_indexmatch_hist_indexlit_pred0len2_match_disttable_max_update_intervaltable_update_interval_slow_rate/usr/include/semaphore.h/usr/include/bits/semaphore.h/usr/include/linux/close_range.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_prefix_coding.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzcomp.cpp"lzham_lzcomp_internal.h""lzham_comp.h"LZHAM_Z_DEFAULT_COMPRESSION(int)LZHAM_Z_DEFAULT_COMPRESSIONlzham_z_stream *sizeof(stream)-10000LZHAM_Z_PARAM_ERRORLZHAM_Z_OKLZHAM_Z_FINISHLZHAM_Z_STREAM_ENDLZHAM_Z_BUF_ERRORLZHAM_Z_STREAM_ERRORlzham_z_internal_state *LZHAM_Z_PARTIAL_FLUSHLZHAM_Z_SYNC_FLUSHlzham_statusorig_total_inorig_total_outin_byteslzham_compress_state *pStateLZHAM_COMP_STATUS_FIRST_FAILURE_CODELZHAM_COMP_STATUS_SUCCESSLZHAM_Z_DEFLATEDLZHAM_Z_LZHAMLZHAM_Z_DEFAULT_WINDOW_BITSmax_window_bitsLZHAM_MAX_DICT_SIZE_LOG2_X64LZHAM_MAX_DICT_SIZE_LOG2_X86LZHAM_MIN_DICT_SIZE_LOG2comp_paramslzham_compress_params &sizeof(lzham_compress_params)LZHAM_COMP_LEVEL_UBERLZHAM_COMP_LEVEL_FASTESTLZHAM_COMP_LEVEL_FASTERLZHAM_COMP_LEVEL_DEFAULTLZHAM_COMP_LEVEL_BETTERLZHAM_COMP_FLAG_EXTREME_PARSINGLZHAM_COMP_FLAG_WRITE_ZLIB_STREAMLZHAM_Z_ADLER32_INITLZHAM_Z_DEFAULT_STRATEGYLZHAM_COMP_STATUS_INVALID_PARAMETERsizeof(uint32)sizeof(size_t) > sizeof(uint32)internal_paramspTPLZHAM_COMP_STATUS_FAILEDpCompressorcomp_datadst_buf_sizeLZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALLLZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODEnum_bytes_written_to_out_bufcomp_data.size() - pState->m_comp_data_ofs*pOut_buf_sizehas_no_more_outputLZHAM_COMP_STATUS_HAS_MORE_OUTPUTLZHAM_FINISHcMaxBytesToPutPerIteration4*10244*1024*1024*pIn_buf_sizebytes_to_putconsumed_entire_input_bufLZHAM_NO_FLUSHLZHAM_SYNC_FLUSHLZHAM_FULL_FLUSHLZHAM_TABLE_FLUSHnum_comp_bytes_to_outputLZHAM_COMP_STATUS_NEEDS_MORE_INPUTLZHAM_COMP_STATUS_NOT_FINISHEDadler32create_internal_init_paramsinternal_params.m_max_helper_threadsrateLZHAM_DEFAULT_TABLE_UPDATE_RATELZHAM_FASTEST_TABLE_UPDATE_RATEtable_update_settings[]table_update_settings *lzham_compress_state &const lzham_compress_stateconst lzham_compress_state &~lzham_compress_statelzham_compress_statem_statusm_finished_compressionm_comp_data_ofsm_pOut_buf_sizem_pOut_bufm_pIn_buf_sizem_pIn_bufm_compressorm_tpLZHAM_Z_API_FORCE_WINDOW_BITS// In case lzham_z_ulong is 64-bits (argh I hate longs).// Can't make forward progress without some input.// Use all CPU's. TODO: This is not always the best idea depending on the dictionary size and the # of bytes to compress.// Force Deflate to LZHAM with default window_bits.// ----------------- zlib-style API's// task_pool requires 8 or 16 alignment// File: lzham_lzcomp.cppvector<unsigned int>const unsigned int &vector<node>vector<dict_match>vector<long>const longconst long &long &vector<lzdecision>vector<lzpriced_decision>byte_veclzham_new6447288sizeof(T)LZHAM_IS_SCALAR_TYPE(T)lzham_delete!LZHAM_IS_SCALAR_TYPE(T)vector<unsigned char> *const vector<unsigned char> *64445442632zero_objectsizeof(obj)vector<lzdecision> *vector<lzpriced_decision> *vector<node> *vector<dict_match> *vector<long> *vector<unsigned int> *scalar_type<dict_match>scalar_type<dict_match> &scalar_type<dict_match> &&const scalar_type<dict_match>const scalar_type<dict_match> &scalar_type<node>scalar_type<node> &scalar_type<node> &&const scalar_type<node>const scalar_type<node> &scalar_type<lzpriced_decision>scalar_type<lzpriced_decision> &scalar_type<lzpriced_decision> &&const scalar_type<lzpriced_decision>const scalar_type<lzpriced_decision> &scalar_type<lzdecision>scalar_type<lzdecision> &scalar_type<lzdecision> &&const scalar_type<lzdecision>const scalar_type<lzdecision> &scalar_type<task_pool>scalar_type<task_pool> &scalar_type<task_pool> &&const scalar_type<task_pool>const scalar_type<task_pool> &scalar_type<lzcompressor>scalar_type<lzcompressor> &scalar_type<lzcompressor> &&const scalar_type<lzcompressor>const scalar_type<lzcompressor> &scalar_type<lzham_compress_state>scalar_type<lzham_compress_state> &scalar_type<lzham_compress_state> &&const scalar_type<lzham_compress_state>const scalar_type<lzham_compress_state> &rel_ops<vector<lzpriced_decision>>rel_ops<vector<lzpriced_decision>> &rel_ops<vector<lzpriced_decision>> &&const rel_ops<vector<lzpriced_decision>>const rel_ops<vector<lzpriced_decision>> &rel_ops<vector<lzdecision>>rel_ops<vector<lzdecision>> &rel_ops<vector<lzdecision>> &&const rel_ops<vector<lzdecision>>const rel_ops<vector<lzdecision>> &constructoperator newnodiscardoperator deletedestructLZHAM_HAS_DESTRUCTOR(T)operator>=const vector<lzpriced_decision>const vector<lzpriced_decision> &operator<=operator>operator!=const vector<lzdecision>const vector<lzdecision> &vector<lzdecision> &const vector<output_symbol>const vector<output_symbol> &vector<output_symbol> &const vector<adaptive_bit_model>const vector<adaptive_bit_model> &vector<adaptive_bit_model> &const vector<unsigned short>const vector<unsigned short> &vector<unsigned short> &const vector<long>const vector<long> &vector<long> &const vector<dict_match>const vector<dict_match> &vector<dict_match> &const vector<node>const vector<node> &vector<node> &const vector<unsigned int>const vector<unsigned int> &vector<unsigned int> &Uconst Uconst U &U &rel_ops<T>LZHAM_NO_COPY_OR_ASSIGNMENT_OP(c)c(const c&); c& operator= (const c&);helpers// namespace helpers// File: lzham_helpers.hlzham_print_mem_statsnum && (num == ~num_check)num_checkconst char[27]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/../lzhamdecomp/lzham_mem.hLZHAM_MIN_ALLOC_ALIGNMENTlzham_delete_arraylzham_new_arrayconst Aconst A &A &const Bconst B &B &const Cconst C &C &const Dconst D &D &lzham_msizelzham_freelzham_realloclzham_malloclzham_mem_init// File: lzham_mem.hinit0init1init3pActual_sizemovabledecay_array_to_subtypeT(&)[]count_leading_zeros16v < 0x10000/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/../lzhamdecomp/lzham_utils.hconst char[98]char[98]swap32167116800x00FF0000U652800x0000FF00ULZHAM_ARRAY_SIZE(X)(sizeof(X) / sizeof(decay_array_to_subtype(X)))LZHAM_MAX(a,b)(((a) < (b)) ? (b) : (a))LZHAM_MIN(a,b)(((a) < (b)) ? (a) : (b))LZHAM_GET_ALIGNMENT(v)((!sizeof(v)) ? 1 : (__alignof(v) ? __alignof(v) : sizeof(uint32)))utils// namespace utils// File: lzham_utils.hconst char[16]orig_sizenum_to_move266280const char[49]const char[7]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_checksum.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_timer.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzcomp_internal.cpp"lzham_timer.h""lzham_checksum.h"cSyncBlockcBlockHeaderBitsflush_codecBlockFlushTypeBitsbytes_to_match >= lenconst char[22]const char[95]compress_block_timercVarArgs****** compress_block %u"****** compress_block %u"const char[25]const char[5]1528buf_len <= m_params.m_block_size1529m_src_size >= 01531(unnamed local variable)const quasi_adaptive_huffman_data_model *cur_dict_ofscCompBlockemit_reset_update_rate_command falseLZHAM_COMP_FLAG_TRADEOFF_DECOMPRESSION_RATE_FOR_COMP_RATIOprev_block_historyblock_history *cMaxBlockHistorySize - 1(cMaxBlockHistorySize - 1)95U95000cBlockHistoryCompRatioScale * 95U100U950cBlockHistoryCompRatioScale * 95U / 100U(cBlockHistoryCompRatioScale * 95U / 100U)recent_min_block_ratioinitial_stepstatic_cast<uint>(CLZBase::cMaxHugeMatchLen)(bytes_to_match / cAvgAcceptableGreedyMatchLen)dec.get_len()best_decisions[i].m_pos == (int)cur_dict_ofsi < best_decisions.size()(bytes_to_match + cMaxParseGraphNodes - 1) / cMaxParseGraphNodesnum_parse_jobscMaxParseGraphNodes * num_parse_jobsparse_thread_total_sizeparse_thread.m_bytes_to_matchparse_thread.m_bytes_to_match > 0best_decisions.back().m_pos == (int)parse_thread.m_start_ofsbest_decisions.front().m_pos == (int)parse_thread.m_start_ofsi >= 0i < (int)best_decisions.size()cur_dict_ofs == parse_thread.m_start_ofs + parse_thread.m_bytes_to_matchcAvgAcceptableGreedyMatchLenforce_small_blockparse_thread_start_ofsparse_thread_remaininggreedy_parse_statenum_greedy_decisions_to_codebest_decisionsnum_small_decisionstotal_match_lenconst char[45]1673const char[26]1675LZHAM_COMP_FLAG_DETERMINISTIC_PARSINGparse_thread_indexparse_threadconst char[34]1744parse_timerparsing"parsing"const char[8]queue_task_timerqueuing parse tasks"queuing parse tasks"wait_timerwaiting for jobs"waiting for jobs"const char[17]coding_timercoding"coding"end_dec_indexdec_stepconst char[61]char[61]1813const char[62]char[62]1817182318241825const char[73]char[73]1843add_bytes_timer"add_bytes_end"const char[14]stop_encoding_timer"stop_encoding"used_raw_blockbuf_len <= 0x1000000buf_len0buf_len1buf_len2cRawBlockconst char[21]1907scaled_ratioappend_timer"append"bytes_remainingbytes_to_compressparse_job_indexparse_job_timerparse_job_callback %u"parse_job_callback %u"volatile atomic32_t *bytes_to_parselookahead_start_ofscur_lookahead_ofsapprox_statebytes_to_parse - cur_ofsmatch_len <= max_admissable_match_lenmax_admissable_match_lenlargest_dec_indexconst char[38]1430cur_ofs == bytes_to_parse1445min_match_len >= 1const char[19]1289start_ofsofs >= start_ofs1292largest_indexlargest_lenlargest_costlit_decmatch_hist_max_lencMatchHistSizehist_match_len(pMatches->get_dist() > 0) && (pMatches->get_dist() <= m_dict_size)pMatchesconst char[68]char[68]1358parse_state.m_bytes_to_match <= cMaxParseGraphNodesconst char[52]966pNodessizeof(node_state)172032cMaxParseGraphNodes * sizeof(node_state)cur_node_indexcMaxFullMatchesmatch_lensmatch_distancesbit_cost_t[258]unsigned long long[258]lzdec_bitcostsstatic_cast<uint>(CLZBase::cMaxMatchLen)bytes_to_parse - cur_node_indexpCur_node->m_parent_index >= 0(cBitCostMax - cur_node_total_cost) > (cBitCostScale * 64)approx_state.m_cur_statemin_truncate_match_lenstart_len <= end_lenpCur_nodecur_node_total_costcur_node_total_complexitymatch_hist_min_match_lenlit_total_costlit_total_complexity1010const char[59]char[59]1019rep_match_indexrep_match_total_complexitydst_noderep_match_total_costnum_full_matchesmatch_total_costmatch_total_complexityprev_max_match_lenfull_match_indexend_len1168match_complexitynode_indexpDst_dec(node_index >= 0) && (node_index <= (int)cMaxParseGraphNodes)cur_node1249695first_node_stateprev_lit_nodecur_node_state.m_parent_index >= 0max_full_match_len757cur_node_state_indexcur_node_stateconst char[35]784actual_cost864lowest_final_costnode_state_indexpLast_node_states936cEOFBlockcur_seed_ofstotal_bytes_remainingnum_bytes_to_addcmfflg0 << 62 << 63 << 60 == (((cmf << 8) + flg) % 31)271dict_adler32total_resetsmax_scaled_ratiom_block_history[i].m_ratiomin_scaled_ratiototal_scaled_ratiocur_block_historym_block_history_size + 1static_cast<uint>(cMaxBlockHistorySize)!m_finished474 truenum_src_bytes_remainingm_params.m_block_size - m_block_buf.size()!m_block_buf.size()m_block_buf.size() <= m_params.m_block_sizepSrcBufnum_bytes_to_copyconst char[44]523cInitAdler32444comp_settings[5]comp_settings *cMaxParseThreads >= 4m_params.m_max_helper_threads + 1assume_typedef1(int)m_params.m_max_helper_threads - num_parse_jobsmatch_accel_helper_threadsm_num_parse_threads >= 1m_num_parse_threads <= cMaxParseThreadsconst char[40]!match_accel_helper_threads && (m_num_parse_threads == 1)(match_accel_helper_threads + (m_num_parse_threads - 1)) <= m_params.m_max_helper_threadsconst char[58]char[58]const char[90]char[90]((uint32_ptr)this & (LZHAM_GET_ALIGNMENT(lzcompressor) - 1)) == 0((uint32_ptr)this & (((!sizeof(lzcompressor)) ? 1 : (__alignof(lzcompressor) ? __alignof(lzcompressor) : sizeof(uint32))) - 1)) == 0const char[66]char[66]m_finished(false)trial_statestdinsert_indexnum_behind(insert_index + 1 + num_to_move) <= cMaxNodeStatesconst char[51]char[51]664pNew_node_statem_num_node_states + 1static_cast<uint>(cMaxNodeStates)s_level_settingsLZHAM_FORCE_ALL_RAW_BLOCKSLZHAM_VERIFY_MATCH_COSTSLZHAM_FORCE_SINGLE_THREADED_PARSINGLZHAM_UPDATE_STATS!LZHAM_FORCE_SINGLE_THREADED_PARSINGLZHAM_LZDEBUGLZHAM_LZVERIFY!LZHAM_FORCE_ALL_RAW_BLOCKS(defined(LZHAM_DISABLE_RAW_BLOCKS) || defined(LZHAM_LZDEBUG))//printf("\n%u, %u, %u, %u\n", m_block_index, 500*emit_reset_update_rate_command, scaled_ratio, get_recent_block_ratio());// Write buf len check bits, to help increase the probability of detecting corrupted data more early.//m_stats = initial_stats;// Failed to compress the block, so go back to our original state and just code a raw block.// TODO: Allow the user to control this threshold, i.e. if less than 1% then just store uncompressed.// Coded the entire block - now see if it makes more sense to just send a raw/uncompressed block.// parse_thread_index//m_state.print(m_codec, *this, m_accel, best_decisions[i]);// Loop rearranged to avoid bad x64 codegen problem with MSVC2008.// Reduce block size near the beginning of the file so statistical models get going a bit faster.// Increase the number of active parse jobs as the match finder finishes up to keep CPU utilization up.//LZHAM_ASSERT(i >= 0);//coding_stats initial_stats(m_stats);//printf("Emitting reset: %u %u\n", prev_block_history.m_ratio, recent_min_block_ratio);// Compression ratio has recently dropped quite a bit - slam the table update rates back up.//uint recent_max_block_ratio = get_max_block_ratio();// Determine if it makes sense to reset the Huffman table update frequency back to their initial (maximum) rates.// Important: Don't do any expensive work until after add_bytes_begin() is called, to increase parallelism.// Full matches are very likely to be more expensive than rep matches of the same length, so don't bother evaluating them.// Now add full matches.// Add rep matches.// TODO: Doesn't find len2 matches// ofs is the absolute dictionary offset, must be >= the lookahead offset.// m_best_decisions is filled backwards.// Now get the optimal decisions by starting from the goal node.// graph search// literal// nibble of match distances is separately coded.)// in the nibble of each match distance, all other things being equal, to help exploit how the lowest// always get the nearest match. The match finder favors those matches which have the lowest value// Now get all full matches: the nearest matches at each match length. (Actually, we don't// Get the nearest len2 match if we didn't find a rep len2.// full matches// rep matches// This assert includes a fudge factor - make sure we don't overflow our scaled costs.// Move to this node's state using the lowest cost LZ decision found.// In very early versions of LZHAM the parse was much more understandable (straight Dijkstra with almost no bit price optimizations or coding heuristics).// graph must pass through this node. LZMA tracks cumulative bitprices relative to this node, while LZHAM currently always tracks cumulative bitprices relative to the first node in the lookahead buffer.// This function always sequentially pushes "forward" the unvisited node horizon. This horizon frequently collapses to a single node, which guarantees that the shortest path through the// unique symbol statistics for each lookahead character, which would be very costly.)// To simplify the problem, it assumes the input statistics are locally stationary over the input block to parse. (Otherwise, it would need to store, track, and update// The major CPU expense of this function is the complexity of LZ decision cost evaluation, so a lot of implementation effort is spent here reducing this overhead.// There is no need to track visited/unvisted nodes, or find the next cheapest unvisted node in each iteration. The search always proceeds sequentially, visiting each lookahead character in turn from left/right.// Graph edges are LZ "decisions", cost is measured in fractional bits needed to code each graph edge, and graph nodes are lookahead characters.// This function finds the shortest path through an extremely dense node graph using a streamlined/simplified Dijkstra's algorithm with some coding heuristics.// The regular "optimal" parser only tracks the single cheapest candidate LZ decision per lookahead character.// Parsing notes:// cur_node_state_index// nearest len2 match// It assumes the input statistics are locally stationary over the input block to parse.// This allows the compressor to make locally suboptimal decisions that ultimately result in a better parse.// The "extreme" parser tracks the best node::cMaxNodeStates (4) candidate LZ decisions per lookahead character.//   return false;//if (!m_codec.encode_bits(0, 1))//if (!m_codec.encode_bits(m_settings.m_fast_adaptive_huffman_updating, 1))// TODO: Currently unused.// Less than a full block available - append to already accumulated bytes.// Full-block available - compress in-place.// Compress blocks.// Last block - flush whatever's left and send the final block.// send adler32 of DICT// set FDICT flag// set FLEVEL by mapping LZHAM's compression level to zlib's// set CM (method) and CINFO (dictionary size) fields// Method is set to 14 (LZHAM) and CINFO is (window_size - 15).// See http://www.gzip.org/zlib/rfc-zlib.html//m_settings.m_fast_adaptive_huffman_updating// 8-16// m_match_accel_max_probes// m_match_accel_max_matches_per_probe// m_fast_adaptive_huffman_updating// m_fast_bytes// cCompressionLevelUber// cCompressionLevelBetter// cCompressionLevelDefault// cCompressionLevelFaster// cCompressionLevelFastest// Set to 1 to force all blocks to be uncompressed (raw).// Verify all computed match costs against the generic/slow state::get_cost() method.// Only parse on the main thread, for easier debugging.// TODO: Add match distance coding statistics.// Update and print high-level coding statistics if set to 1.// File: lzham_lzcomp_internal.cpp_Requiretype &&const vector<lzpriced_decision> *const vector<lzdecision> *455456457object_task<lzcompressor> *lzcompressor *constlzcompressor *const &lzcompressor *&..(*const)(..)..(*const &)(..)..(*&)(..)const object_task_flagsconst object_task_flags &object_task_flags &object_task<lzcompressor>object_task<lzcompressor> &object_task<lzcompressor> &&const object_task<lzcompressor>const object_task<lzcompressor> &__and_<is_nothrow_move_constructible<node_state>, is_nothrow_move_assignable<node_state>>__and___and_<is_nothrow_move_constructible<node_state>, is_nothrow_move_assignable<node_state>> &__and_<is_nothrow_move_constructible<node_state>, is_nothrow_move_assignable<node_state>> &&const __and_<is_nothrow_move_constructible<node_state>, is_nothrow_move_assignable<node_state>>const __and_<is_nothrow_move_constructible<node_state>, is_nothrow_move_assignable<node_state>> &is_rvalue_reference<node_state>is_rvalue_referenceis_rvalue_reference<node_state> &is_rvalue_reference<node_state> &&const is_rvalue_reference<node_state>const is_rvalue_reference<node_state> &__or_<is_function<node_state>, is_void<node_state>, __is_array_unknown_bounds<node_state>>__or___or_<is_function<node_state>, is_void<node_state>, __is_array_unknown_bounds<node_state>> &__or_<is_function<node_state>, is_void<node_state>, __is_array_unknown_bounds<node_state>> &&const __or_<is_function<node_state>, is_void<node_state>, __is_array_unknown_bounds<node_state>>const __or_<is_function<node_state>, is_void<node_state>, __is_array_unknown_bounds<node_state>> &__or_<is_void<node_state>, __is_array_unknown_bounds<node_state>>__or_<is_void<node_state>, __is_array_unknown_bounds<node_state>> &__or_<is_void<node_state>, __is_array_unknown_bounds<node_state>> &&const __or_<is_void<node_state>, __is_array_unknown_bounds<node_state>>const __or_<is_void<node_state>, __is_array_unknown_bounds<node_state>> &__is_array_unknown_bounds<node_state>__is_array_unknown_bounds__is_array_unknown_bounds<node_state> &__is_array_unknown_bounds<node_state> &&const __is_array_unknown_bounds<node_state>const __is_array_unknown_bounds<node_state> &is_array<node_state>is_arrayis_array<node_state> &is_array<node_state> &&const is_array<node_state>const is_array<node_state> &is_vector<lzpriced_decision>is_vector<lzpriced_decision> &is_vector<lzpriced_decision> &&const is_vector<lzpriced_decision>const is_vector<lzpriced_decision> &is_vector<lzdecision>is_vector<lzdecision> &is_vector<lzdecision> &&const is_vector<lzdecision>const is_vector<lzdecision> &LZHAM_IS_BITWISE_MOVABLE(T)(is_vector<T>::cFlag)(LZHAM_IS_BITWISE_MOVABLE(T) || (is_vector<T>::cFlag))LZHAM_IS_BITWISE_COPYABLE(T)movetype &bitwise_movable<lzdecision>bitwise_movable<lzdecision> &bitwise_movable<lzdecision> &&const bitwise_movable<lzdecision>const bitwise_movable<lzdecision> &bitwise_copyable<lzdecision>bitwise_copyable<lzdecision> &bitwise_copyable<lzdecision> &&const bitwise_copyable<lzdecision>const bitwise_copyable<lzdecision> &bitwise_movable<lzpriced_decision>bitwise_movable<lzpriced_decision> &bitwise_movable<lzpriced_decision> &&const bitwise_movable<lzpriced_decision>const bitwise_movable<lzpriced_decision> &bitwise_copyable<lzpriced_decision>bitwise_copyable<lzpriced_decision> &bitwise_copyable<lzpriced_decision> &&const bitwise_copyable<lzpriced_decision>const bitwise_copyable<lzpriced_decision> &__and_<is_array<node_state>, __not_<extent<node_state, 0U>>>__and_<is_array<node_state>, __not_<extent<node_state, 0U>>> &__and_<is_array<node_state>, __not_<extent<node_state, 0U>>> &&const __and_<is_array<node_state>, __not_<extent<node_state, 0U>>>const __and_<is_array<node_state>, __not_<extent<node_state, 0U>>> &__conditional_tis_void<node_state>is_voidis_void<node_state> &is_void<node_state> &&const is_void<node_state>const is_void<node_state> &is_function<node_state>is_functionis_function<node_state> &is_function<node_state> &&const is_function<node_state>const is_function<node_state> &is_nothrow_move_assignable<node_state>is_nothrow_move_assignableis_nothrow_move_assignable<node_state> &is_nothrow_move_assignable<node_state> &&const is_nothrow_move_assignable<node_state>const is_nothrow_move_assignable<node_state> &is_nothrow_move_constructible<node_state>is_nothrow_move_constructibleis_nothrow_move_constructible<node_state> &is_nothrow_move_constructible<node_state> &&const is_nothrow_move_constructible<node_state>const is_nothrow_move_constructible<node_state> &remove_reference<node_state &>remove_reference<node_state &> &remove_reference<node_state &> &&const remove_reference<node_state &>const remove_reference<node_state &> &lzdecision *constlzpriced_decision *const412scalar_type<object_task<lzcompressor>>scalar_type<object_task<lzcompressor>> &scalar_type<object_task<lzcompressor>> &&const scalar_type<object_task<lzcompressor>>const scalar_type<object_task<lzcompressor>> &__is_nt_move_assignable_impl<node_state, true>__is_nt_move_assignable_impl__is_nt_move_assignable_impl<node_state, true> &__is_nt_move_assignable_impl<node_state, true> &&const __is_nt_move_assignable_impl<node_state, true>const __is_nt_move_assignable_impl<node_state, true> &__not_<extent<node_state, 0U>>extent<node_state, 0U>__is_referenceable<node_state, void>__is_referenceable__is_referenceable<node_state, void> &__is_referenceable<node_state, void> &&const __is_referenceable<node_state, void>const __is_referenceable<node_state, void> &__is_nothrow_assignable_impl__and_<is_move_constructible<node_state>, is_move_assignable<node_state>>__and_<is_move_constructible<node_state>, is_move_assignable<node_state>> &__and_<is_move_constructible<node_state>, is_move_assignable<node_state>> &&const __and_<is_move_constructible<node_state>, is_move_assignable<node_state>>const __and_<is_move_constructible<node_state>, is_move_assignable<node_state>> &is_move_assignable<node_state>is_move_assignableis_move_assignable<node_state> &is_move_assignable<node_state> &&const is_move_assignable<node_state>const is_move_assignable<node_state> &is_move_constructible<node_state>is_move_constructibleis_move_constructible<node_state> &is_move_constructible<node_state> &&const is_move_constructible<node_state>const is_move_constructible<node_state> &__is_move_constructible_impl<node_state, true>__is_move_constructible_impl__is_move_constructible_impl<node_state, true> &__is_move_constructible_impl<node_state, true> &&const __is_move_constructible_impl<node_state, true>const __is_move_constructible_impl<node_state, true> &__is_constructible_impl<node_state, node_state &&>__is_constructible_impl__is_constructible_impl<node_state, node_state &&> &__is_constructible_impl<node_state, node_state &&> &&const __is_constructible_impl<node_state, node_state &&>const __is_constructible_impl<node_state, node_state &&> &<bits/c++config.h>__call_is_nt_Fn_Args_Tpdeclval__declval_Up__is_complete_or_unbounded_TypeIdentity_NestedType(unnamed template parameter constant)_S_test(unnamed template parameter)_S_conv_S_get__do_is_nothrow_swappable_with_impl &__do_is_nothrow_swappable_with_impl &&const __do_is_nothrow_swappable_with_implconst __do_is_nothrow_swappable_with_impl &__test__do_is_swappable_with_impl &__do_is_swappable_with_impl &&const __do_is_swappable_with_implconst __do_is_swappable_with_impl &__do_is_nothrow_swappable_impl &__do_is_nothrow_swappable_impl &&const __do_is_nothrow_swappable_implconst __do_is_nothrow_swappable_impl &__do_is_swappable_impl &__do_is_swappable_impl &&const __do_is_swappable_implconst __do_is_swappable_impl &__result_of_other_impl &__result_of_other_impl &&const __result_of_other_implconst __result_of_other_impl &__result_of_memobj_deref_impl &__result_of_memobj_deref_impl &&const __result_of_memobj_deref_implconst __result_of_memobj_deref_impl &_Fp_Tp1__result_of_memobj_ref_impl &__result_of_memobj_ref_impl &&const __result_of_memobj_ref_implconst __result_of_memobj_ref_impl &__result_of_memfun_deref_impl &__result_of_memfun_deref_impl &&const __result_of_memfun_deref_implconst __result_of_memfun_deref_impl &__result_of_memfun_ref_impl &__result_of_memfun_ref_impl &&const __result_of_memfun_ref_implconst __result_of_memfun_ref_impl &__invoke_other &__invoke_other &&const __invoke_otherconst __invoke_other &__invoke_memobj_deref &__invoke_memobj_deref &&const __invoke_memobj_derefconst __invoke_memobj_deref &__invoke_memobj_ref &__invoke_memobj_ref &&const __invoke_memobj_refconst __invoke_memobj_ref &__invoke_memfun_deref &__invoke_memfun_deref &&const __invoke_memfun_derefconst __invoke_memfun_deref &__invoke_memfun_ref &__invoke_memfun_ref &&const __invoke_memfun_refconst __invoke_memfun_ref &common_type<> &common_type<> &&const common_type<>const common_type<> &__do_common_type_impl &__do_common_type_impl &&const __do_common_type_implconst __do_common_type_impl &_S_test_2__make_signed<char32_t> &__make_signed<char32_t> &&const __make_signed<char32_t>const __make_signed<char32_t> &__make_signed<char16_t> &__make_signed<char16_t> &&const __make_signed<char16_t>const __make_signed<char16_t> &__make_signed<wchar_t> &__make_signed<wchar_t> &&const __make_signed<wchar_t>const __make_signed<wchar_t> &__make_signed<__uint128_t> &__make_signed<__uint128_t> &&const __make_signed<__uint128_t>const __make_signed<__uint128_t> &__make_signed<unsigned long long> &__make_signed<unsigned long long> &&const __make_signed<unsigned long long>const __make_signed<unsigned long long> &__make_signed<unsigned long> &__make_signed<unsigned long> &&const __make_signed<unsigned long>const __make_signed<unsigned long> &__make_signed<unsigned int> &__make_signed<unsigned int> &&const __make_signed<unsigned int>const __make_signed<unsigned int> &__make_signed<unsigned short> &__make_signed<unsigned short> &&const __make_signed<unsigned short>const __make_signed<unsigned short> &__make_signed<unsigned char> &__make_signed<unsigned char> &&const __make_signed<unsigned char>const __make_signed<unsigned char> &__make_signed<char> &__make_signed<char> &&const __make_signed<char>const __make_signed<char> &__make_unsigned<char32_t> &__make_unsigned<char32_t> &&const __make_unsigned<char32_t>const __make_unsigned<char32_t> &__make_unsigned<char16_t> &__make_unsigned<char16_t> &&const __make_unsigned<char16_t>const __make_unsigned<char16_t> &__make_unsigned<wchar_t> &__make_unsigned<wchar_t> &&const __make_unsigned<wchar_t>const __make_unsigned<wchar_t> &__make_unsigned_selector_base &__make_unsigned_selector_base &&const __make_unsigned_selector_baseconst __make_unsigned_selector_base &__make_unsigned<__int128_t> &__make_unsigned<__int128_t> &&const __make_unsigned<__int128_t>const __make_unsigned<__int128_t> &__make_unsigned<long long> &__make_unsigned<long long> &&const __make_unsigned<long long>const __make_unsigned<long long> &__make_unsigned<long> &__make_unsigned<long> &&const __make_unsigned<long>const __make_unsigned<long> &__make_unsigned<int> &__make_unsigned<int> &&const __make_unsigned<int>const __make_unsigned<int> &__make_unsigned<short> &__make_unsigned<short> &&const __make_unsigned<short>const __make_unsigned<short> &__make_unsigned<signed char> &__make_unsigned<signed char> &&const __make_unsigned<signed char>const __make_unsigned<signed char> &__make_unsigned<char> &__make_unsigned<char> &&const __make_unsigned<char>const __make_unsigned<char> &_From1_To1__test_aux__do_is_implicitly_default_constructible_impl &__do_is_implicitly_default_constructible_impl &&const __do_is_implicitly_default_constructible_implconst __do_is_implicitly_default_constructible_impl &const _Tpconst _Tp &_Tp &decltype((<expression>)) *<unnamed> *__helper__do_is_nt_destructible_impl &__do_is_nt_destructible_impl &&const __do_is_nt_destructible_implconst __do_is_nt_destructible_impl &__do_is_destructible_impl &__do_is_destructible_impl &&const __do_is_destructible_implconst __do_is_destructible_impl &__is_null_pointer_helper__is_null_pointer_helper<std::nullptr_t> &__is_null_pointer_helper<std::nullptr_t> &&const __is_null_pointer_helper<std::nullptr_t>const __is_null_pointer_helper<std::nullptr_t> &__is_floating_point_helper__is_floating_point_helper<__float128> &__is_floating_point_helper<__float128> &&const __is_floating_point_helper<__float128>const __is_floating_point_helper<__float128> &__is_floating_point_helper<long double> &__is_floating_point_helper<long double> &&const __is_floating_point_helper<long double>const __is_floating_point_helper<long double> &__is_floating_point_helper<double> &__is_floating_point_helper<double> &&const __is_floating_point_helper<double>const __is_floating_point_helper<double> &__is_floating_point_helper<float> &__is_floating_point_helper<float> &&const __is_floating_point_helper<float>const __is_floating_point_helper<float> &__is_integral_helper__is_integral_helper<__uint128_t> &__is_integral_helper<__uint128_t> &&const __is_integral_helper<__uint128_t>const __is_integral_helper<__uint128_t> &__is_integral_helper<__int128_t> &__is_integral_helper<__int128_t> &&const __is_integral_helper<__int128_t>const __is_integral_helper<__int128_t> &__is_integral_helper<unsigned long long> &__is_integral_helper<unsigned long long> &&const __is_integral_helper<unsigned long long>const __is_integral_helper<unsigned long long> &__is_integral_helper<long long> &__is_integral_helper<long long> &&const __is_integral_helper<long long>const __is_integral_helper<long long> &__is_integral_helper<unsigned long> &__is_integral_helper<unsigned long> &&const __is_integral_helper<unsigned long>const __is_integral_helper<unsigned long> &__is_integral_helper<long> &/usr/include/c++/12/usr/include/c++__is_integral_helper<long> &&const __is_integral_helper<long>const __is_integral_helper<long> &__is_integral_helper<unsigned int> &__is_integral_helper<unsigned int> &&const __is_integral_helper<unsigned int>const __is_integral_helper<unsigned int> &__is_integral_helper<int> &__is_integral_helper<int> &&const __is_integral_helper<int>const __is_integral_helper<int> &__is_integral_helper<unsigned short> &__is_integral_helper<unsigned short> &&const __is_integral_helper<unsigned short>const __is_integral_helper<unsigned short> &__is_integral_helper<short> &__is_integral_helper<short> &&const __is_integral_helper<short>const __is_integral_helper<short> &__is_integral_helper<char32_t> &__is_integral_helper<char32_t> &&const __is_integral_helper<char32_t>const __is_integral_helper<char32_t> &__is_integral_helper<char16_t> &__is_integral_helper<char16_t> &&const __is_integral_helper<char16_t>const __is_integral_helper<char16_t> &__is_integral_helper<wchar_t> &__is_integral_helper<wchar_t> &&const __is_integral_helper<wchar_t>const __is_integral_helper<wchar_t> &__is_integral_helper<unsigned char> &__is_integral_helper<unsigned char> &&const __is_integral_helper<unsigned char>const __is_integral_helper<unsigned char> &__is_integral_helper<signed char> &__is_integral_helper<signed char> &&const __is_integral_helper<signed char>const __is_integral_helper<signed char> &__is_integral_helper<char> &__is_integral_helper<char> &&const __is_integral_helper<char>const __is_integral_helper<char> &__is_integral_helper<bool> &__is_integral_helper<bool> &&const __is_integral_helper<bool>const __is_integral_helper<bool> &__is_void_helper__is_void_helper<void> &__is_void_helper<void> &&const __is_void_helper<void>const __is_void_helper<void> &__failure_type &__failure_type &&const __failure_typeconst __failure_type &__and_<> &__and_<> &&const __and_<>const __and_<> &__or_<> &__or_<> &&const __or_<>const __or_<> &__conditional<false> &__conditional<false> &&const __conditional<false>const __conditional<false> &operator()operator _Tpconst integral_constant<_Tp, __v>const integral_constant<_Tp, __v> *integral_constant<_Tp, __v> *const __nonesuchconst __nonesuch &__nonesuch &__nonesuch~__nonesuch__nonesuchbase &__nonesuchbase &&const __nonesuchbaseconst __nonesuchbase &is_aggregate<_Tp>has_unique_object_representations<_Tp>is_nothrow_invocable_r<_Ret, _Fn, _ArgTypes...>_Ret_ArgTypes__is_nt_invocable_impl<_Result, _Ret, __void_t<type>>_Result__is_nt_invocable_impl<_Result, _Ret, <unnamed>>is_nothrow_invocable<_Fn, _ArgTypes...>is_invocable_r<_Ret, _Fn, _ArgTypes...>is_invocable<_Fn, _ArgTypes...>invoke_result_tinvoke_result<_Functor, _ArgTypes...>_Functor__is_nothrow_invocable<_Fn, _Args...>__call_is_nothrow<_Result, _Fn, _Args...>__is_invocable<_Fn, _ArgTypes...>__is_invocable_impl<_Result, _Ret, false, __void_t<type>>__is_invocable_impl<_Result, _Ret, true, __void_t<type>>__is_invocable_impl<_Result, _Ret, <unnamed>, <unnamed>>is_nothrow_swappable_with<_Tp, _Up>is_swappable_with<_Tp, _Up>__is_nothrow_swappable_with_impl<_Tp &, _Tp &>__is_nothrow_swappable_with_impl<_Tp, _Up>__is_swappable_with_impl<_Tp &, _Tp &>__is_swappable_with_impl<_Tp, _Up>__do_is_nothrow_swappable_with_impl__do_is_swappable_with_implis_nothrow_swappable<_Tp>is_swappable<_Tp>__is_nothrow_swappable_impl<_Tp>__is_swappable_impl<_Tp>__do_is_nothrow_swappable_impl__do_is_swappable_impl__is_tuple_like<_Tp>__is_tuple_like_impl<<unnamed>>__is_nothrow_swappable<_Tp>__is_swappable<_Tp>__detected_or_t__detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>_Default__detector<_Default, _AlwaysVoid, _Op, _Args...>_AlwaysVoidvoid_tresult_of_tunderlying_type_tcommon_type_tconditional_tenable_if_tdecay_taligned_union_taligned_storage_tresult_of<..(..)>"std::invoke_result"use 'std::invoke_result' instead__invoke_result<_Functor, _ArgTypes...>__result_of_impl<false, false, _Functor, _ArgTypes...>__result_of_other_impl__result_of_impl<false, true, _MemPtr, _Arg, _Args...>_MemPtr_Arg__result_of_impl<true, false, _MemPtr, _Arg>__result_of_impl<<unnamed>, <unnamed>, _Functor, _ArgTypes...>__inv_unwrap<_Tp, reference_wrapper<_Up>>_Up &__inv_unwrap<_Tp, _Up>__result_of_memfun<_Res _Class::*, _Arg, _Args...>_Res_Argval__result_of_memfun<_MemPtr, _Arg, _Args...>__result_of_memobj<_Res _Class::*, _Arg>__result_of_memobj<_MemPtr, _Arg>__result_of_memobj_deref<_MemPtr, _Arg>__result_of_memobj_deref_impl__result_of_memobj_ref<_MemPtr, _Arg>__result_of_memobj_ref_impl__result_of_memfun_deref<_MemPtr, _Arg, _Args...>__result_of_memfun_deref_impl__result_of_memfun_ref<_MemPtr, _Arg, _Args...>__result_of_memfun_ref_impl__result_of_success<_Tp, _Tag>_Tag__invoke_type__invoke_other__invoke_memobj_deref__invoke_memobj_ref__invoke_memfun_deref__invoke_memfun_refresult_of<_Signature>_Signature__declval_protector<_Tp>underlying_type<_Tp>__underlying_type_impl<_Tp, false>__underlying_type_impl<_Tp, <unnamed>>__common_type_fold<_CTp, _Rp, void>_CTp_Rp__common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<type>>common_type<_Tp1, _Tp2, _Rp...>_Tp2__common_type_fold<<unnamed>, <unnamed>, <unnamed>>__common_type_pack<<unnamed>...>common_type<_Tp1, _Tp2>__common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>__common_type_impl<_Tp1, _Tp2, _Dp1, _Dp2>_Dp1_Dp2common_type<_Tp0>_Tp0common_type<>__do_common_type_impl__cond_tcommon_type<_Tp...>conditional<false, _Iftrue, _Iffalse>_Iftrue_Iffalseconditional<_Cond, _Iftrue, _Iffalse>_Cond__remove_cvref_t__enable_if_tenable_if<true, _Tp>enable_if<<unnamed>, _Tp>__decay_t__strip_reference_wrapper<reference_wrapper<_Tp>>__strip_reference_wrapper<_Tp>decay<_Tp>__remove_type__decay_selector<_Up, false, true>__decay_selector<_Up, true, false>type *__decay_selector<_Up, false, false>__decay_selector<_Up, _IsArray, _IsFunction>_IsArray_IsFunctionaligned_union<_Len, _Types...>_Len_Types__strictest_alignment<_Tp, _Types...>__strictest_alignment<_Types...>aligned_storage<_Len, _Align>_Align__aligned_storage_msa<_Len>add_pointer_tremove_pointer_tadd_pointer<_Tp>__add_pointer_helper<_Tp, true>__add_pointer_helper<_Tp, <unnamed>>remove_pointer<_Tp>__remove_pointer_helper<_Tp, _Up *>_Up *__remove_pointer_helper<_Tp, <unnamed>>remove_all_extents_tremove_extent_tremove_all_extents<_Tp[]>_Tp[]remove_extent<_Tp[]>remove_extent<_Tp>make_unsigned_tmake_signed_tmake_signed<bool>make_signed<_Tp>__make_signed<char32_t>__make_signed<char16_t>__make_signed<wchar_t>__make_signed_selector<_Tp, false, true>__unsigned_type__make_signed_selector<_Tp, true, false>__signed_type__make_signed_selector<_Tp, _IsInt, _IsEnum>_IsInt_IsEnum__make_signed<__uint128_t>__make_signed<unsigned long long>__make_signed<unsigned long>__make_signed<unsigned int>__make_signed<unsigned short>__make_signed<unsigned char>__make_signed<char>__make_signed<_Tp>make_unsigned<bool>make_unsigned<_Tp>__make_unsigned<char32_t>__make_unsigned<char16_t>__make_unsigned<wchar_t>__make_unsigned_selector<_Tp, false, true>__make_unsigned_selector_base__select<_Sz, _List<_Uint, _UInts...>, false>_Sz__select<_Sz, _List<_Uint, _UInts...>, true>_Uint__select<_Sz, _Tp, <unnamed>>_List<_Tp, _Up...>_List<<unnamed>...>__make_unsigned_selector<_Tp, true, false>__make_unsigned_selector<_Tp, _IsInt, _IsEnum>__make_unsigned<__int128_t>__make_unsigned<long long>__make_unsigned<long>__make_unsigned<int>__make_unsigned<short>__make_unsigned<signed char>__make_unsigned<char>__make_unsigned<_Tp>__match_cv_qualifiers<_Qualified, _Unqualified, _IsConst, _IsVol>_Qualified_Unqualified_IsConst_IsVol__cv_selector<_Unqualified, true, true>const volatile _Unqualified__cv_selector<_Unqualified, true, false>const _Unqualified__cv_selector<_Unqualified, false, true>volatile _Unqualified__cv_selector<_Unqualified, false, false>__cv_selector<_Unqualified, _IsConst, _IsVol>add_rvalue_reference_tadd_lvalue_reference_tremove_reference_tadd_rvalue_reference<_Tp>__add_rvalue_reference_helper<_Tp, true>_Tp &&__add_rvalue_reference_helper<_Tp, <unnamed>>add_lvalue_reference<_Tp>__add_lvalue_reference_helper<_Tp, true>__add_lvalue_reference_helper<_Tp, <unnamed>>remove_reference<_Tp &&>remove_reference<_Tp &>remove_reference<_Tp>add_cv_tadd_volatile_tadd_const_tremove_cv_tremove_volatile_tremove_const_tadd_cv<_Tp>add_volatile<_Tp>volatile _Tpadd_const<_Tp>remove_cv<const volatile _Tp>const volatile _Tpremove_cv<volatile _Tp>remove_cv<const _Tp>remove_volatile<volatile _Tp>remove_volatile<_Tp>remove_const<const _Tp>remove_const<_Tp>__is_nothrow_convertible<_From, _To>_From_To__is_nt_convertible_helper<_From, _To, false>__is_nt_convertible_helper<_From, _To, <unnamed>>is_convertible<_From, _To>__is_convertible_helper<_From, _To, false>__is_convertible_helper<_From, _To, <unnamed>>is_base_of<_Base, _Derived>_Base_Derivedextent<_Tp[], _Uint>rank<_Tp[]>rank<<unnamed>>alignment_of<_Tp>has_virtual_destructor<_Tp>is_trivially_destructible<_Tp>is_trivially_move_assignable<_Tp>__is_trivially_move_assignable_impl<_Tp, true>__is_trivially_move_assignable_impl<_Tp, false>__is_trivially_move_assignable_impl<_Tp, <unnamed>>is_trivially_copy_assignable<_Tp>__is_trivially_copy_assignable_impl<_Tp, true>__is_trivially_copy_assignable_impl<_Tp, false>__is_trivially_copy_assignable_impl<_Tp, <unnamed>>is_trivially_assignable<_Tp, _Up>is_trivially_move_constructible<_Tp>__is_trivially_move_constructible_impl<_Tp, true>__is_trivially_move_constructible_impl<_Tp, false>__is_trivially_move_constructible_impl<_Tp, <unnamed>>is_trivially_copy_constructible<_Tp>__is_trivially_copy_constructible_impl<_Tp, true>__is_trivially_copy_constructible_impl<_Tp, false>__is_trivially_copy_constructible_impl<_Tp, <unnamed>>__is_implicitly_default_constructible<_Tp>__is_implicitly_default_constructible_safe<_Tp>__is_implicitly_default_constructible_impl<_Tp>__do_is_implicitly_default_constructible_implis_trivially_default_constructible<_Tp>is_trivially_constructible<_Tp, _Args...>is_nothrow_move_assignable<_Tp>__is_nt_move_assignable_impl<_Tp, true>__is_nt_move_assignable_impl<_Tp, false>__is_nt_move_assignable_impl<_Tp, <unnamed>>is_nothrow_copy_assignable<_Tp>__is_nt_copy_assignable_impl<_Tp, true>__is_nt_copy_assignable_impl<_Tp, false>__is_nt_copy_assignable_impl<_Tp, <unnamed>>is_nothrow_assignable<_Tp, _Up>is_move_assignable<_Tp>__is_move_assignable_impl<_Tp, true>__is_move_assignable_impl<_Tp, false>__is_move_assignable_impl<_Tp, <unnamed>>is_copy_assignable<_Tp>__is_copy_assignable_impl<_Tp, true>__is_copy_assignable_impl<_Tp, false>__is_copy_assignable_impl<_Tp, <unnamed>>is_assignable<_Tp, _Up>is_nothrow_move_constructible<_Tp>__is_nothrow_move_constructible_impl<_Tp, true>__is_nothrow_move_constructible_impl<_Tp, false>__is_nothrow_move_constructible_impl<_Tp, <unnamed>>is_nothrow_copy_constructible<_Tp>__is_nothrow_copy_constructible_impl<_Tp, true>__is_nothrow_copy_constructible_impl<_Tp, false>__is_nothrow_copy_constructible_impl<_Tp, <unnamed>>is_nothrow_default_constructible<_Tp>is_nothrow_constructible<_Tp, _Args...>is_move_constructible<_Tp>__is_move_constructible_impl<_Tp, true>__is_move_constructible_impl<_Tp, false>__is_move_constructible_impl<_Tp, <unnamed>>is_copy_constructible<_Tp>__is_copy_constructible_impl<_Tp, true>__is_copy_constructible_impl<_Tp, false>__is_copy_constructible_impl<_Tp, <unnamed>>is_default_constructible<_Tp>is_constructible<_Tp, _Args...>__is_constructible_impl<_Tp, _Args...>is_nothrow_destructible<_Tp>__is_nt_destructible_safe<_Tp, false, true>__is_nt_destructible_safe<_Tp, true, false>__is_nt_destructible_safe<_Tp, false, false>__is_nt_destructible_safe<_Tp, <unnamed>, <unnamed>>__is_nt_destructible_impl<_Tp>__do_is_nt_destructible_implis_destructible<_Tp>__is_destructible_safe<_Tp, false, true>__is_destructible_safe<_Tp, true, false>__is_destructible_safe<_Tp, false, false>__is_destructible_safe<_Tp, <unnamed>, <unnamed>>__is_destructible_impl<_Tp>__do_is_destructible_impl__is_array_known_bounds<_Tp>remove_all_extents<_Tp>extent<<unnamed>, _Uint>is_unsigned<_Tp>is_signed<_Tp>__is_signed_helper<_Tp, true>__is_signed_helper<_Tp, <unnamed>>is_abstract<_Tp>is_final<_Tp>is_polymorphic<_Tp>is_empty<_Tp>is_literal_type<_Tp>is_pod<_Tp>is_standard_layout<_Tp>is_trivially_copyable<_Tp>is_trivial<_Tp>is_volatile<volatile _Tp>is_volatile<<unnamed>>is_const<const _Tp>__is_referenceable<_Tp, __void_t<_Tp &>>__is_referenceable<_Tp, <unnamed>>__void_tis_same<_Tp, _Up>__is_member_pointer_helper<_Tp _Cp::*>__is_member_pointer_helper<_Tp>is_compound<_Tp>is_scalar<_Tp>is_member_pointer<_Tp>is_object<_Tp>is_fundamental<_Tp>is_arithmetic<_Tp>__is_nullptr_t<_Tp>"std::is_null_pointer"use 'std::is_null_pointer' insteadis_null_pointer<_Tp>__is_null_pointer_helper<std::nullptr_t>__is_null_pointer_helper<<unnamed>>is_function<_Tp &&>is_function<_Tp &>is_class<_Tp>is_union<_Tp>is_enum<_Tp>is_member_function_pointer<_Tp>__is_member_function_pointer_helper<_Tp _Cp::*>__is_member_function_pointer_helper<<unnamed>>is_member_object_pointer<_Tp>__is_member_object_pointer_helper<_Tp _Cp::*>__is_member_object_pointer_helper<<unnamed>>is_rvalue_reference<_Tp &&>is_rvalue_reference<<unnamed>>is_lvalue_reference<_Tp &>is_lvalue_reference<<unnamed>>is_pointer<_Tp>__is_pointer_helper<_Tp *>_Tp *__is_pointer_helper<<unnamed>>is_array<_Tp[]>is_array<<unnamed>>is_floating_point<_Tp>__is_floating_point_helper<__float128>__is_floating_point_helper<long double>__is_floating_point_helper<double>__is_floating_point_helper<float>__is_floating_point_helper<<unnamed>>is_integral<_Tp>__is_integral_helper<__uint128_t>__is_integral_helper<__int128_t>__is_integral_helper<unsigned long long>__is_integral_helper<long long>__is_integral_helper<unsigned long>__is_integral_helper<long>__is_integral_helper<unsigned int>__is_integral_helper<int>__is_integral_helper<unsigned short>__is_integral_helper<short>__is_integral_helper<char32_t>__is_integral_helper<char16_t>__is_integral_helper<wchar_t>__is_integral_helper<unsigned char>__is_integral_helper<signed char>__is_integral_helper<char>__is_integral_helper<bool>__is_integral_helper<<unnamed>>__is_void_helper<void>__is_void_helper<<unnamed>>__remove_cv_t__failure_type__success_type<_Tp>__is_array_unknown_bounds<_Tp>is_const<<unnamed>>remove_cv<_Tp>is_void<_Tp>is_function<_Tp>is_reference<_Tp>negation<_Pp>_Ppdisjunction<_Bn...>_Bnconjunction<_Bn...>__not_<_Pp>__and_<_B1, _B2, _B3, _Bn...>_B1_B2_B3__and_<_B1, _B2>__and_<_B1>__and_<>__and_<<unnamed>...>__or_<_B1, _B2, _B3, _Bn...>__or_<_B1, _B2>__or_<_B1>__or_<>__or_<<unnamed>...>__type_identity_t__type_identity<_Type>_Type__conditional<false>__conditional<<unnamed>>integral_constant<_Tp, __v>reference_wrapper<_Tp>__nonesuchbase_Class_Cpis_aggregate_vhas_unique_object_representations_vis_nothrow_invocable_r_vis_invocable_r_vis_nothrow_invocable_vis_invocable_vis_convertible_vis_base_of_vis_same_vextent_vrank_valignment_of_vhas_virtual_destructor_vis_nothrow_destructible_vis_nothrow_move_assignable_vis_nothrow_copy_assignable_vis_nothrow_assignable_vis_nothrow_move_constructible_vis_nothrow_copy_constructible_vis_nothrow_default_constructible_vis_nothrow_constructible_vis_trivially_destructible_vis_trivially_move_assignable_vis_trivially_copy_assignable_vis_trivially_assignable_vis_trivially_move_constructible_vis_trivially_copy_constructible_vis_trivially_default_constructible_vis_trivially_constructible_vis_destructible_vis_move_assignable_vis_copy_assignable_vis_assignable_vis_move_constructible_vis_copy_constructible_vis_default_constructible_vis_constructible_vis_unsigned_vis_signed_vis_final_vis_abstract_vis_polymorphic_vis_empty_vis_literal_type_vis_pod_vis_standard_layout_vis_trivially_copyable_vis_trivial_vis_volatile_vis_const_vis_member_pointer_vis_compound_vis_scalar_vis_object_vis_fundamental_vis_arithmetic_vis_reference_vis_function_vis_class_vis_union_vis_enum_vis_member_function_pointer_vis_member_object_pointer_vis_rvalue_reference_vis_lvalue_reference_vis_pointer_vis_array_vis_floating_point_vis_integral_vis_null_pointer_vis_void_vis_nothrow_swappable_with_vis_swappable_with_vis_nothrow_swappable_vis_swappable_v_Op_ToElementType_FromElementTypenegation_vdisjunction_vconjunction_v__and_v__or_v_If_Else__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value_Tp(&)[]_Nm__is_nothrow_swappable<_Tp>::value_UInts_Idx__stopalignment_value_S_len_S_size_S_alignmenttemplate argument must be a complete class or an unbounded array_Ret must be a complete class or an unbounded arrayeach argument type must be a complete class or an unbounded array_Fn must be a complete class or an unbounded array_Functor must be a complete class or an unbounded arraysecond template argument must be a complete class or an unbounded arrayfirst template argument must be a complete class or an unbounded arrayAt least one type is required__cpp_lib_is_aggregate201703L__cpp_lib_has_unique_object_representations201606L__cpp_lib_type_trait_variable_templates201510L__cpp_lib_is_invocable__cpp_lib_is_swappable201603L_GLIBCXX_HAS_NESTED_TYPE(_NTYPE)template<typename _Tp, typename = __void_t<>> struct __has_ ## _NTYPE : false_type { }; template<typename _Tp> struct __has_ ## _NTYPE<_Tp, __void_t<typename _Tp::_NTYPE>> : true_type { };__cpp_lib_void_t201411L__cpp_lib_result_of_sfinae201210L__cpp_lib_transformation_trait_aliases201304L__cpp_lib_is_final201402L__cpp_lib_is_null_pointer201309L__cpp_lib_logical_traits__cpp_lib_bool_constant201505L__cpp_lib_integral_constant_callable_GLIBCXX_TYPE_TRAITS__swappable_with_details__swappable_detailsGCC system_header__cplusplus < 201103L__cplusplus > 201103L! __cpp_inline_variables_GLIBCXX_USE_CHAR8_Tdefined(__GLIBCXX_TYPE_INT_N_0)defined(__GLIBCXX_TYPE_INT_N_1)defined(__GLIBCXX_TYPE_INT_N_2)defined(__GLIBCXX_TYPE_INT_N_3)!defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)__cplusplus >= 201402L_GLIBCXX_HAVE_BUILTIN_IS_SAMEGCC diagnostic ignored "-Wctor-dtor-privacy"__cplusplus > 201703L&&defined(_GLIBCXX_USE_CHAR8_T)__cplusplus >= 201703L || !defined(__STRICT_ANSI__)__cplusplus > 201402L || !defined(__STRICT_ANSI__)GCC diagnostic ignored "-Wdeprecated-declarations"_GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP_GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE__cplusplus >= 202002L__has_builtin(__is_layout_compatible)__has_builtin(__builtin_is_corresponding_member)__has_builtin(__is_pointer_interconvertible_base_of)__has_builtin(__builtin_is_pointer_interconvertible_with_class)__cplusplus > 202002L_GLIBCXX_HAVE_IS_CONSTANT_EVALUATED__cpp_if_consteval >= 202106L"use is_standard_layout_v && is_trivial_v instead"__GLIBCXX_TYPE_INT_N_0__int128"use is_standard_layout && is_trivial instead"__cpp_inline_variables// _GLIBCXX_TYPE_TRAITS// C++11// namespace std/// @} group metaprogramming// C++2a/// @endcond// Reuse __common_type_fold for common_reference<T1, T2, Rest...>// Otherwise, if sizeof...(T) is greater than two, ...// Otherwise, there shall be no member type.// Otherwise, if common_type_t<T1, T2> is well-formed, ...// Otherwise, if COND-RES(T1, T2) is well-formed, ...// Otherwise, if basic_common_reference<...>::type is well-formed, ...// If T1 and T2 are reference types and COMMON-REF(T1, T2) is well-formed, ...// If sizeof...(T) is two .../// @cond undocumented// If sizeof...(T) is one ...// If sizeof...(T) is zero, there shall be no member type.// If A is an lvalue reference and B is an rvalue reference, ...// If A is an rvalue reference and B is an lvalue reference, ...// let D be COMMON-REF(const X&, Y&)// If A and B are both rvalue reference types, ...// let C be remove_reference_t<COMMON-REF(X&, Y&)>&&// If A and B are both lvalue reference types, ...// COND-RES(COPYCV(X, Y) &, COPYCV(Y, X) &)// [meta.trans.other], COMMON-REF(A, B)/// @since C++20/// Returns true only when called during constant evaluation.// C++23/// @since C++23/// @ingroup variable_templates// fails if incomplete// when PR c++/99968 is fixed.// FIXME remove this partial specialization and use remove_cv_t<_Tp> above/// True if the type is a scoped enumeration type./// @returns true if `s.*__mp` is pointer-interconvertible with `s`/// True if `__mp` points to the first member of a standard-layout type/// True if `_Derived` is standard-layout and has a base class of type `_Base`/// True for a type that is an array of unknown bound./// True for a type that is an array of known bound./// @}/** Decay type and if it's a reference_wrapper, unwrap it
   * @since C++20
   * @{
   *//** Unwrap a reference_wrapper
   * @since C++20
   * @{
   *//** * Identity metafunction.
   * @since C++20
   * @{
   *//** * Remove references and cv-qualifiers.
   * @since C++20
   * @{
   */// C++17/// @since C++17/// is_aggregate/// has_unique_object_representations/**
   * @{
   * @ingroup variable_templates
   *//**
   * @defgroup variable_templates Variable templates for type traits
   * @ingroup metaprogramming
   *
   * Each variable `is_xxx_v<T>` is a boolean constant with the same value
   * as the `value` member of the corresponding type trait `is_xxx<T>`.
   *
   * @since C++17 unless noted otherwise.
   *//// std::is_nothrow_invocable_r/// std::is_nothrow_invocable/// std::is_invocable_r/// std::is_invocable/// std::invoke_result_t/// std::invoke_result// __is_nothrow_invocable (std::is_nothrow_invocable for C++11)// This overload is viable if INVOKE(f, args...) can convert to _Tp.// Unlike declval, this doesn't add_rvalue_reference.// The type of the INVOKE expression./* is_void<_Ret> = */// Used for INVOKE<R> expressions to check the implicit conversion to R.// Used for valid INVOKE and INVOKE<void> expressions.// The primary template is used for invalid INVOKE expressions.// __is_invocable (std::is_invocable for C++11)// c++1z or gnu++11// __cplusplus >= 201402L/// is_nothrow_swappable_with_v/// is_swappable_with_v/// is_nothrow_swappable_with/// is_swappable_with// Optimization for the homogenous lvalue case, not required:// namespace __swappable_with_details/// is_nothrow_swappable_v/// is_swappable_v/// is_nothrow_swappable/// is_swappable/// Metafunctions used for detecting swappable types: p0185r1// namespace __swappable_details// Internal type trait that allows us to sfinae-protect tuple_cat./**
   *  Use SFINAE to determine if the type _Tp has a publicly-accessible
   *  member type _NTYPE.
   */// _Op<_Args...> if that is a valid type, otherwise _Default.// Detect whether _Op<_Args...> is a valid type, use _Default if not./// Implementation of the detection idiom (positive case)./// Implementation of the detection idiom (negative case)./// A metafunction that always yields void, used for detecting valid types.// c++17 or gnu++11// C++14/// Alias template for result_of/// Alias template for underlying_type/// Alias template for common_type/// Alias template for conditional/// Alias template for enable_if/// Alias template for decay/// Alias template for aligned_storage// __invoke_result (std::invoke_result for C++11)// [func.require] paragraph 1 bullet 5:// Used by result_of, invoke etc. to unwrap a reference_wrapper.//        as the object expression// 2219.  INVOKE-ing a pointer to member with a reference_wrapper// _GLIBCXX_RESOLVE_LIB_DEFECTS// [func.require] paragraph 1 bullet 4:// [func.require] paragraph 1 bullet 3:// [func.require] paragraph 1 bullet 2:// [func.require] paragraph 1 bullet 1:// Associate a tag type with a specialization of __success_type.// Sfinae-friendly result_of implementation:/// result_of/** Utility to simplify expressions used in unevaluated operands
   *  @since C++11
   *  @ingroup utilities
   *//// The underlying type of an enum.// as common_type_t<C, R...>.// If there is such a type C, type shall denote the same type, if any,// Let C denote the same type, if any, as common_type_t<T1, T2>.// If sizeof...(T) is greater than two, ...// If sizeof...(T) is two, ...// denotes a valid type, let C denote that type.// Otherwise, if decay_t<decltype(false ? declval<D1>() : declval<D2>())>// let C denote the same type, if any, as common_type_t<D1, D2>.// If is_same_v<T1, D1> is false or is_same_v<T2, D2> is false,// If sizeof...(T) is one, the same type, if any, as common_type_t<T0, T0>.// let C denote the type decay_t<COND-RES(CREF(D1), CREF(D2))>.// Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type,// if decay_t<decltype(false ? declval<D1>() : declval<D2>())>// Sfinae-friendly common_type implementation:/// common_type// Partial specialization for false./// Define a member typedef @c type to one of two argument types.// Primary template.// __remove_cvref_t (std::remove_cvref_t for C++11).// Helper for SFINAE constraints// __enable_if_t (std::enable_if_t for C++11)// Partial specialization for true./// Define a member typedef `type` only if a boolean constant is true.// __decay_t (std::decay_t for C++11).// Helper which adds a reference to a type when given a reference_wrapper/// decay// NB: DR 705.// in make_pair, make_tuple, etc.// Decay trait for arrays and functions, used for perfect forwarding/// The storage./// The value of the strictest alignment of _Types./**
   *  @brief Provide aligned storage for types.
   *
   *  [meta.trans.other]
   *
   *  Provides aligned storage for any of the provided types of at
   *  least size _Len.
   *
   *  @see aligned_storage
   *//**
   *  @brief Alignment type.
   *
   *  The value of _Align is a default-alignment which shall be the
   *  most stringent alignment requirement for any C++ object type
   *  whose size is no greater than _Len (3.9). The member typedef
   *  type shall be a POD type suitable for use as uninitialized
   *  storage for any object whose size is at most _Len and whose
   *  alignment is a divisor of _Align.
  *//// Alias template for add_pointer/// Alias template for remove_pointer/// add_pointer/// remove_pointer// Pointer modifications./// Alias template for remove_all_extents/// Alias template for remove_extent/// remove_all_extents/// remove_extent// Array modifications./// Alias template for make_unsigned/// Alias template for make_signed// Integral, but don't define./// make_signed// integer type.// Given an integral/enum type, return the corresponding signed// Use the partial specialization for enumeration types to do that.// transformed to the signed integer type with the smallest rank.// signed integer types nor unsigned integer types, so must be// wchar_t, char16_t and char32_t are integral types but are neither// Choose signed integer type with the smallest rank and same size as _Tp// Select between integral and enum: not possible to be both.// Utility for finding the signed versions of unsigned integral types./// make_unsigned// Given an integral/enum type, return the corresponding unsigned// transformed to the unsigned integer type with the smallest rank.// neither signed integer types nor unsigned integer types, so must be// wchar_t, char8_t, char16_t and char32_t are integral types but are// With -fshort-enums, an enum may be as small as a char.// Choose unsigned integer type with the smallest rank and same size as _Tp// Utility for finding the unsigned versions of signed integral types.// Utility for constructing identically cv-qualified types.// Sign modifications./// Alias template for add_rvalue_reference/// Alias template for add_lvalue_reference/// Alias template for remove_reference/// add_rvalue_reference/// add_lvalue_reference/// remove_reference// Reference transformations./// Alias template for add_cv/// Alias template for add_volatile/// Alias template for add_const/// Alias template for remove_cv/// Alias template for remove_volatile/// Alias template for remove_const/// add_cv/// add_volatile/// add_const/// remove_cv/// remove_volatile/// remove_const// Const-volatile modifications./// is_nothrow_convertible_v/// is_nothrow_convertible// is_nothrow_convertible for C++11// helper trait for unique_ptr<T[]>, shared_ptr<T[]>, and span<T, N>/// is_convertible/// is_base_of/// is_same// Type relations./// extent/// rank/// alignment_of// type property queries./// has_virtual_destructor/// is_trivially_destructible/// is_trivially_move_assignable/// is_trivially_copy_assignable/// is_trivially_assignable/// is_trivially_move_constructible/// is_trivially_copy_constructible/// is_trivially_default_constructible/// is_trivially_constructible/// is_nothrow_move_assignable/// is_nothrow_copy_assignable/// is_nothrow_assignable/// is_move_assignable/// is_copy_assignable/// is_assignable/// is_nothrow_move_constructible/// is_nothrow_copy_constructible/// is_nothrow_default_constructible/// is_nothrow_constructible/// is_move_constructible/// is_copy_constructible/// is_default_constructible/// is_constructible/// is_nothrow_destructible// instead of decltype(expr).// implementation of is_destructible but refer to noexcept(expr)// satisfied as well.  We realize that by mimicing the// is_nothrow_destructible requires that is_destructible is/// is_destructible// call expression is wellformed.// object types as destructible, iff the explicit destructor// describes function types as non-destructible and all complete// types and abstract types, see LWG 2049. This implementation// In N3290 is_destructible does not say anything about function// Destructible and constructible type properties./// is_unsigned/// is_signed/// is_abstract/// @since C++14/// is_final/// is_polymorphic/// is_empty/** is_literal_type
   * @deprecated Deprecated in C++17, removed in C++20.
   * The idea of a literal type isn't useful.
   */// Could use is_standard_layout && is_trivial instead of the builtin./** is_pod
   * @deprecated Deprecated in C++20.
   * Use `is_standard_layout && is_trivial` instead.
   *//// is_standard_layout/// is_trivially_copyable/// is_trivial/// is_volatile/// is_const// Type properties.// Utility to detect referenceable types ([defns.referenceable]).// __void_t (std::void_t for C++11)// Check if a type is one of the signed or unsigned integer types.// Check if a type is one of the unsigned integer types.// Check if a type is one of the signed integer types./// is_member_pointer/// is_compound/// is_scalar/// is_object/// is_fundamental/// is_arithmetic/// is_reference// Composite type categories./// @deprecated Non-standard. Use `is_null_pointer` instead./// __is_nullptr_t (deprecated extension)./// is_null_pointer (LWG 2247)./// is_function/// is_class/// is_union/// is_enum/// is_member_function_pointer/// is_member_object_pointer/// is_rvalue_reference/// is_lvalue_reference/// is_pointer/// is_array/// is_floating_point/// is_integral// uses one of these types for size_t.// Conditionalizing on __STRICT_ANSI__ here will break any port that// so don't check _GLIBCXX_USE_WCHAR_T here.// even when libc doesn't provide working <wchar.h> and related functions,// We want is_integral<wchar_t> to be true (and make_signed/unsigned to work)/// is_void// Primary type categories.// __remove_cv_t (std::remove_cv_t for C++11).// them, because we need to derive from them as an implementation detail.// member type). This is very similar to std::enable_if, but we cannot use// result information (as the member type) and the failure information (no// For several sfinae-friendly trait implementations we transport both the// incomplete unions and arrays of known bound from those.// Helper functions that return false_type for incomplete classes,// Forward declarations/** @ingroup variable_templates
   * @{
   */// More efficient version of std::conditional_t for internal use (and C++11)// Metaprogramming helper types./// Alias template for compile-time boolean constant types./// bool_constant for C++11/// The type used as a compile-time boolean with false value./// The type used as a compile-time boolean with true value./// integral_constant/**
   * @defgroup metaprogramming Metaprogramming
   * @ingroup utilities
   *
   * Template utilities for compile-time introspection and modification,
   * including type classification traits, type property inspection traits
   * and type transformation traits.
   *
   * @since C++11
   *
   * @{
   *//** @file include/type_traits
 *  This is a Standard C++ Library header.
 */// <http://www.gnu.org/licenses/>.// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// a copy of the GCC Runtime Library Exception along with this program;// You should have received a copy of the GNU General Public License and// 3.1, as published by the Free Software Foundation.// permissions described in the GCC Runtime Library Exception, version// Under Section 7 of GPL version 3, you are granted additional// GNU General Public License for more details.// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// but WITHOUT ANY WARRANTY; without even the implied warranty of// This library is distributed in the hope that it will be useful,// any later version.// Free Software Foundation; either version 3, or (at your option)// terms of the GNU General Public License as published by the// software; you can redistribute it and/or modify it under the// This file is part of the GNU ISO C++ Library.  This library is free// Copyright (C) 2007-2022 Free Software Foundation, Inc.// C++11 <type_traits> -*- C++ -*-<type_traits>__exchange_Up &&const _Tp *addressofconst _Tp &&move_if_noexceptforward__addressof__move_if_noexcept_cond<_Tp>_GLIBCXX_FORWARD(_Tp,__val)std::forward<_Tp>(__val)_GLIBCXX_MOVE(__val)std::move(__val)_GLIBCXX_FWDREF(_Tp)_Tp&&__cpp_lib_addressof_constexpr_MOVE_H__cplusplus > 201402L/* _MOVE_H */// namespace/// @} group utilities/// Swap the contents of two arrays.// DR 809. std::swap should be overloaded for array types.// concept requirements/**
   *  @brief Swaps two values.
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  *//**
   *  @addtogroup utilities
   *  @{
   */// C++11 version of std::exchange for internal use.// 2598. addressof works on temporaries/**
   *  @brief Returns the actual address of the object or function
   *         referenced by r, even in the presence of an overloaded
   *         operator&.
   *  @param  __r  Reference to an object or function.
   *  @return   The actual address.
  */// 2296. std::addressof should be constexpr// declval, from type_traits./**
   *  @brief  Conditionally convert a value to an rvalue.
   *  @param  __x  A thing of arbitrary type.
   *  @return The parameter, possibly cast to an rvalue-reference.
   *
   *  Same as std::move unless the type's move constructor could throw and the
   *  type is copyable, in which case an lvalue-reference is returned instead.
   *//**
   *  @brief  Convert a value to an rvalue.
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  *//**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   *//**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */// Brings in std::declval too./**
   *  @brief Same as C++11 std::addressof
   *  @ingroup utilities
   */// Used, in C++03 mode too, by allocators, etc./** @file bits/move.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */// Move, forward and identity for C++11 + swap -*- C++ -*-/usr/include/c++/12/bits__obj__new_val__r/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_lzcomp_state.cppget_huge_match_code_bits(len > CLZBase::cMaxMatchLen) && (len <= CLZBase::cMaxHugeMatchLen)const char[92]char[92](CLZBase::cMaxMatchLen + 1)r <= 1023r <= 4095r <= 65535256 + 1024(256 + 1024)5376256 + 1024 + 4096(256 + 1024 + 4096)6 << 12(6 << 12)4587527 << 16(7 << 16)get_huge_match_code_len1 + 82 + 103 + 123 + 16-----------
"-----------\n"const char[13]Coding statistics:
"Coding statistics:\n"Total update rate resets: %u
"Total update rate resets: %u\n"const char[30]Total Bytes: %u, Total Contexts: %u, Total Cost: %f bits (%f bytes)
Context ave cost: %f StdDev: %f Min: %f Max: %f
"Total Bytes: %u, Total Contexts: %u, Total Cost: %f bits (%f bytes)\nContext ave cost: %f StdDev: %f Min: %f Max: %f\n"const char[117]char[117]8.0fAve bytes per context: %f
"Ave bytes per context: %f\n"IsMatch:
"IsMatch:\n"  Total: %u, Cost: %f (%f bytes), Ave. Cost: %f, Worst Cost: %f
"  Total: %u, Cost: %f (%f bytes), Ave. Cost: %f, Worst Cost: %f\n"const char[65]  IsMatch(0): %u, Cost: %f (%f bytes), Ave. Cost: %f
"  IsMatch(0): %u, Cost: %f (%f bytes), Ave. Cost: %f\n"  IsMatch(1): %u, Cost: %f (%f bytes), Ave. Cost: %f
"  IsMatch(1): %u, Cost: %f (%f bytes), Ave. Cost: %f\n"Literal stats:
"Literal stats:\n"  Count: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f
"  Count: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f\n"const char[70]char[70]Delta literal stats:
"Delta literal stats:\n"Rep0 Len1 stats:
"Rep0 Len1 stats:\n"  Count: %u, Cost: %f (%f bytes), Ave. Cost: %f StdDev: %f Min: %f Max: %f
"  Count: %u, Cost: %f (%f bytes), Ave. Cost: %f StdDev: %f Min: %f Max: %f\n"const char[76]char[76]Rep0 Len2+ stats:
"Rep0 Len2+ stats:\n"Rep %u stats:
"Rep %u stats:\n"Match %u: Total: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f
"Match %u: Total: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f\n"const char[78]Total near len2 matches: %u, total far len2 matches: %u
"Total near len2 matches: %u, total far len2 matches: %u\n"const char[57]Total matches: %u, truncated matches: %u
"Total matches: %u, truncated matches: %u\n"Max full match len2 distance: %u
"Max full match len2 distance: %u\n"cost_in_bits16777216.0(float)cBitCostScalecost_in_bits > 0.0f1306cur_state.m_cur_statecur_lookahead_sizematch_len <= actual_match_lenCLZBase::cMatchHistSize == 4match_hist_index < CLZBase::cMatchHistSize(int)m_max_len2_distlzdec.m_distmatch_bit_costactual_match_lentype_index1342assume_typedef4uint(*)[5]unsigned int(*)[5]const char[43]1376unsigned int(&)[258]uint(&)[258]unsigned int(&)[12][5]uint(&)[12][5]index < CLZBase::cMatchHistSizeconst char[32]pos >= (int)m_block_start_dict_ofsquasi_adaptive_huffman_data_model(&)[2]LZHAM_ARRAY_SIZE(m_rep_len_table)LZHAM_ARRAY_SIZE(m_large_len_table)assume_typedef3assume_typedef2CLZBase::cLZXSpecialCodePartialStateResetCLZBase::cLZXSpecialCodeEndOfBlockCode  pos: %u, state: %u, match_pred: %u, is_match_model_index: %u, is_match: %u, cost: %f
"  pos: %u, state: %u, match_pred: %u, is_match_model_index: %u, is_match: %u, cost: %f\n"const char[88]char[88]actual_match_len >= lzdec.get_len()lzdec.m_len >= CLZBase::cMinMatchLenmatch_low_symlarge_len_symmatch_high_symmatch_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots)---Regular lit: %u '%c'
"---Regular lit: %u '%c'\n"rep_lit0delta_lit***Delta lit: %u '%c', Mismatch: %u '%c', Delta: 0x%02X
"***Delta lit: %u '%c', Mismatch: %u '%c', Delta: 0x%02X\n"const char[36]1013!!!Rep 0 len1
"!!!Rep 0 len1\n"!!!Rep 0 full len %u
"!!!Rep 0 full len %u\n"!!!Rep %u full len %u
"!!!Rep %u full len %u\n"const char[23]match_slotmatch_extranum_extra_bits10381057CLZBase::cLZXLowestUsableMatchSlot^^^Full match Len %u Dist %u, Slot %u, ExtraBits: %u"^^^Full match Len %u Dist %u, Slot %u, ExtraBits: %u"  (Low 4 bits: %u vs. %u)"  (Low 4 bits: %u vs. %u)"const char[2]  TRUNCATED match, actual len is %u, shortened by %u
"  TRUNCATED match, actual len is %u, shortened by %u\n"(CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLenmain_sym907CLZBase::cLZXNumSpecialLengths(CLZBase::cMaxMatchLen + 1) - 9CLZBase::cNumLitStates + 3721740min_len >= CLZBase::cMinMatchLen547555large_len_tablelen_costrep_len_tablerep0_match_base_costmatch_len - 2414is_match_model_index < LZHAM_ARRAY_SIZE(m_is_match_model)is_match_model_index < (sizeof(m_is_match_model) / sizeof(decay_array_to_subtype(m_is_match_model)))const adaptive_bit_model[12]const adaptive_bit_model(&)[12]adaptive_bit_model(&)[12]match_hist_index == 3339350374LZHAM_ARRAY_SIZE(m_is_match_model)LZHAM_ARRAY_SIZE(m_is_rep_model)LZHAM_ARRAY_SIZE(m_is_rep0_model)LZHAM_ARRAY_SIZE(m_is_rep0_single_byte_model)LZHAM_ARRAY_SIZE(m_is_rep1_model)LZHAM_ARRAY_SIZE(m_is_rep2_model)CLZBase::cNumHugeMatchCodesCLZBase::cMaxMatchLen - CLZBase::cMinMatchLenCLZBase::cMaxMatchLen - CLZBase::cMinMatchLen + 1(CLZBase::cMaxMatchLen - CLZBase::cMinMatchLen + 1)CLZBase::cNumHugeMatchCodes + (CLZBase::cMaxMatchLen - CLZBase::cMinMatchLen + 1)CLZBase::cLZXNumSecondaryLengthsCLZBase::cNumHugeMatchCodes + CLZBase::cLZXNumSecondaryLengths// TODO: Handle huge matches.// rep0 match// rep match//uint match_pred = cur_state.get_pred_char(dict, lzdec.m_pos, 1);// full match//const uint match_pred = get_pred_char(dict, dict_pos, 1);//uint main_sym = match_low_sym | (match_high_sym << 3);// match// delta literal// rep3// rep2// rep1// rep1-rep3 match// normal rep0// single byte rep0//const uint lit_pred0 = get_pred_char(dict, lzdec.m_pos, 1);// rep1-rep3 matches// full// File: lzham_lzcomp_state.cppunsigned int &&unsigned int(*)[12][5]unsigned int(*)[258]1032__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_assignable<unsigned int>>__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_assignable<unsigned int>> &__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_assignable<unsigned int>> &&const __and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_assignable<unsigned int>>const __and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_assignable<unsigned int>> &is_rvalue_reference<unsigned int>is_rvalue_reference<unsigned int> &is_rvalue_reference<unsigned int> &&const is_rvalue_reference<unsigned int>const is_rvalue_reference<unsigned int> &__or_<is_function<unsigned int>, is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>>__or_<is_function<unsigned int>, is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &__or_<is_function<unsigned int>, is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &&const __or_<is_function<unsigned int>, is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>>const __or_<is_function<unsigned int>, is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &__or_<is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>>__or_<is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &__or_<is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &&const __or_<is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>>const __or_<is_void<unsigned int>, __is_array_unknown_bounds<unsigned int>> &__is_array_unknown_bounds<unsigned int>__is_array_unknown_bounds<unsigned int> &__is_array_unknown_bounds<unsigned int> &&const __is_array_unknown_bounds<unsigned int>const __is_array_unknown_bounds<unsigned int> &is_array<unsigned int>is_array<unsigned int> &is_array<unsigned int> &&const is_array<unsigned int>const is_array<unsigned int> &__and_<is_array<unsigned int>, __not_<extent<unsigned int, 0U>>>__and_<is_array<unsigned int>, __not_<extent<unsigned int, 0U>>> &__and_<is_array<unsigned int>, __not_<extent<unsigned int, 0U>>> &&const __and_<is_array<unsigned int>, __not_<extent<unsigned int, 0U>>>const __and_<is_array<unsigned int>, __not_<extent<unsigned int, 0U>>> &is_void<unsigned int>is_void<unsigned int> &is_void<unsigned int> &&const is_void<unsigned int>const is_void<unsigned int> &is_function<unsigned int>is_function<unsigned int> &is_function<unsigned int> &&const is_function<unsigned int>const is_function<unsigned int> &is_nothrow_move_assignable<unsigned int>is_nothrow_move_assignable<unsigned int> &is_nothrow_move_assignable<unsigned int> &&const is_nothrow_move_assignable<unsigned int>const is_nothrow_move_assignable<unsigned int> &is_nothrow_move_constructible<unsigned int>is_nothrow_move_constructible<unsigned int> &is_nothrow_move_constructible<unsigned int> &&const is_nothrow_move_constructible<unsigned int>const is_nothrow_move_constructible<unsigned int> &remove_reference<unsigned int &>remove_reference<unsigned int &> &remove_reference<unsigned int &> &&const remove_reference<unsigned int &>const remove_reference<unsigned int &> &__is_nt_move_assignable_impl<unsigned int, true>__is_nt_move_assignable_impl<unsigned int, true> &__is_nt_move_assignable_impl<unsigned int, true> &&const __is_nt_move_assignable_impl<unsigned int, true>const __is_nt_move_assignable_impl<unsigned int, true> &__bool_constant__not_<extent<unsigned int, 0U>>enable_if<true, void>enable_if<true, void> &enable_if<true, void> &&const enable_if<true, void>const enable_if<true, void> &extent<unsigned int, 0U>__is_referenceable<unsigned int, void>__is_referenceable<unsigned int, void> &__is_referenceable<unsigned int, void> &&const __is_referenceable<unsigned int, void>const __is_referenceable<unsigned int, void> &__conditional<true>__conditional<true> &__conditional<true> &&const __conditional<true>const __conditional<true> &__and_<is_move_constructible<unsigned int>, is_move_assignable<unsigned int>>__and_<is_move_constructible<unsigned int>, is_move_assignable<unsigned int>> &__and_<is_move_constructible<unsigned int>, is_move_assignable<unsigned int>> &&const __and_<is_move_constructible<unsigned int>, is_move_assignable<unsigned int>>const __and_<is_move_constructible<unsigned int>, is_move_assignable<unsigned int>> &is_move_assignable<unsigned int>is_move_assignable<unsigned int> &is_move_assignable<unsigned int> &&const is_move_assignable<unsigned int>const is_move_assignable<unsigned int> &is_move_constructible<unsigned int>is_move_constructible<unsigned int> &is_move_constructible<unsigned int> &&const is_move_constructible<unsigned int>const is_move_constructible<unsigned int> &__is_move_constructible_impl<unsigned int, true>__is_move_constructible_impl<unsigned int, true> &__is_move_constructible_impl<unsigned int, true> &&const __is_move_constructible_impl<unsigned int, true>const __is_move_constructible_impl<unsigned int, true> &__is_constructible_impl<unsigned int, unsigned int &&>__is_constructible_impl<unsigned int, unsigned int &&> &__is_constructible_impl<unsigned int, unsigned int &&> &&const __is_constructible_impl<unsigned int, unsigned int &&>const __is_constructible_impl<unsigned int, unsigned int &&> &class_testbitwise_movable<empty_type> &bitwise_movable<empty_type> &&const bitwise_movable<empty_type>const bitwise_movable<empty_type> &bitwise_copyable<empty_type> &bitwise_copyable<empty_type> &&const bitwise_copyable<empty_type>const bitwise_copyable<empty_type> &scalar_type<long double> &scalar_type<long double> &&const scalar_type<long double>const scalar_type<long double> &const long doubleconst long double &long double &const long double *scalar_type<double> &scalar_type<double> &&const scalar_type<double>const scalar_type<double> &const double &double &scalar_type<float> &scalar_type<float> &&const scalar_type<float>const scalar_type<float> &const float &float &scalar_type<unsigned long> &scalar_type<unsigned long> &&const scalar_type<unsigned long>const scalar_type<unsigned long> &unsigned longconst unsigned longconst unsigned long &const unsigned long *scalar_type<long> &scalar_type<long> &&const scalar_type<long>const scalar_type<long> &const long *scalar_type<unsigned int> &scalar_type<unsigned int> &&const scalar_type<unsigned int>const scalar_type<unsigned int> &scalar_type<int> &scalar_type<int> &&const scalar_type<int>const scalar_type<int> &const int &int &scalar_type<unsigned short> &scalar_type<unsigned short> &&const scalar_type<unsigned short>const scalar_type<unsigned short> &unsigned shortconst unsigned short &unsigned short &scalar_type<short> &scalar_type<short> &&const scalar_type<short>const scalar_type<short> &shortconst short &short &scalar_type<unsigned char> &scalar_type<unsigned char> &&const scalar_type<unsigned char>const scalar_type<unsigned char> &unsigned charscalar_type<char> &scalar_type<char> &&const scalar_type<char>const scalar_type<char> &charconst char &char &scalar_type<bool> &scalar_type<bool> &&const scalar_type<bool>const scalar_type<bool> &bool *const bool &const bool *T **sizeof(yes_t)bitwise_movable<empty_type>empty_typebitwise_copyable<empty_type>is_pointer<T *>is_pointer<T>is_class<T>char(&)[2]no_tchar(&)[1]yes_tbitwise_copyable<T>bitwise_movable<T>scalar_type<long double>scalar_type<double>scalar_type<float>scalar_type<unsigned long>scalar_type<long>scalar_type<unsigned int>scalar_type<int>scalar_type<unsigned short>scalar_type<short>scalar_type<unsigned char>scalar_type<char>scalar_type<bool>scalar_type<T *>scalar_type<T>((!scalar_type<T>::cFlag) && (!LZHAM_IS_POD(T)))(LZHAM_IS_BITWISE_COPYABLE(T) || (bitwise_movable<T>::cFlag))((scalar_type<T>::cFlag) || (bitwise_copyable<T>::cFlag) || LZHAM_IS_POD(T))(scalar_type<T>::cFlag)LZHAM_IS_POD(T)__is_pod(T)LZHAM_DEFINE_BITWISE_COPYABLE(Q)template<> struct bitwise_copyable<Q> { enum { cFlag = true }; };LZHAM_DEFINE_BITWISE_MOVABLE(Q)template<> struct bitwise_movable<Q> { enum { cFlag = true }; };LZHAM_DEFINE_BUILT_IN_TYPELZHAM_DEFINE_BUILT_IN_TYPE(X)template<> struct scalar_type<X> { enum { cFlag = true }; static inline void construct(X* p) { memset(p, 0, sizeof(X)); } static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); } static inline void construct_array(X* p, uint n) { memset(p, 0, sizeof(X) * n); } static inline void destruct(X* p) { LZHAM_NOTE_UNUSED(p); } static inline void destruct_array(X* p, uint n) { LZHAM_NOTE_UNUSED(p); LZHAM_NOTE_UNUSED(n); } };defined(WIN32)defined(__APPLE__) || defined(__NetBSD__)// also found in the C++ Templates book by Vandevoorde and Josuttis// Credit goes to Boost;// From yasli_traits.h:// Defines type Q as bitwise copyable.// Defines type Q as bitwise movable.// See: http://erdani.org/publications/cuj-2004-06.pdf// File: lzham_traits.hobject_task<T> *tsstack<T, cMaxSize> */home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_match_accel.cpphash3_to_16hash2_to_12lookahead_dict_posc0cDigramHashSize - 1(cDigramHashSize - 1)next_thread_indexpDictnum_unique_trigramsfind_all_matches_timer"find_all_matches_callback"thread_indexdict_match[256]cMatchAccelMaxSupportedProbes * 2temp_matchesfill_lookahead_posfill_dict_sizefill_lookahead_size!m_hash_thread_index.size() || (m_hash_thread_index[h] != UINT8_MAX)(pDstMatch[-1].m_len + (uint)CLZBase::cMinMatchLen) == best_match_leninsert_pospDstMatchcur_pospLeftpRightbest_match_lenpInsconst char[69]char[69]const char[91]char[91]pNodeconst uint64 *pComp_endpComp_curpIns_curalt_match_lennew_posbestMatchDistcompMatchDistbestMatchSlotbestMatchSlotOfscompMatchSlotcompMatchOfs264desired_mismatch_bytecur_mismatch_bytecur_mismatch_distnew_mismatch_bytenew_mismatch_distnum_matches_to_writematch_ref_ofssizeof(temp_matches[0])atomic32_t *num_bytes <= m_lookahead_size554m_cur_dict_size <= m_max_dict_size560508match_refspin_countcMaxSpinCountnext_match_posCLZBase::cMaxLen2MatchDistpCur(uint)m_next_match_ref <= m_matches.size()num_bytes <= m_max_dict_size!m_lookahead_size475add_pos(add_pos + num_bytes) <= m_max_dict_size478dict_bytes_to_mirrormax_possible_dict_sizemax_dict_size && math::is_power_of_2(max_dict_size)m_all_matches(false)g_hamming_distLZHAM_PLATFORM_X360 || (LZHAM_USE_UNALIGNED_INT_LOADS == 0)LZVERIFY// This may spin until the match finder job(s) catch up to the caller's lookahead position.// FIXME: This is going to really hurt on platforms requiring export barriers.// TODO: This competes against the prev. optimization.// Choose the match which has lowest hamming distance in the mismatch byte for a tiny win on binary files.// This could choose a match which is further away in the absolute sense, but closer in a coding sense.// If both matches uses the same match slot, choose the one with the offset containing the lowest nibble as these bits separately entropy coded.// Compare a qword at a time for a bit more efficiency.// Unfortunately, the initial compare match_len must be 0 because of the way we hash and truncate matches at the end of each block.// Only process those strings that this worker thread was assigned to - this allows us to manipulate multiple trees in parallel with no worries about synchronization.// Clearing the hash tables is only necessary for determinism (otherwise, it's possible the matches returned after a reset will depend on the data processes before the reset).// File: lzham_match_accel.cppconst vector<unsigned int> *const vector<dict_match> *const vector<long> *object_task<search_accelerator> *search_accelerator *constsearch_accelerator *const &search_accelerator *&object_task<search_accelerator>object_task<search_accelerator> &object_task<search_accelerator> &&const object_task<search_accelerator>const object_task<search_accelerator> &rel_ops<vector<long>>rel_ops<vector<long>> &rel_ops<vector<long>> &&const rel_ops<vector<long>>const rel_ops<vector<long>> &is_vector<long>is_vector<long> &is_vector<long> &&const is_vector<long>const is_vector<long> &rel_ops<vector<dict_match>>rel_ops<vector<dict_match>> &rel_ops<vector<dict_match>> &&const rel_ops<vector<dict_match>>const rel_ops<vector<dict_match>> &is_vector<dict_match>is_vector<dict_match> &is_vector<dict_match> &&const is_vector<dict_match>const is_vector<dict_match> &rel_ops<vector<node>>rel_ops<vector<node>> &rel_ops<vector<node>> &&const rel_ops<vector<node>>const rel_ops<vector<node>> &is_vector<node>is_vector<node> &is_vector<node> &&const is_vector<node>const is_vector<node> &const node *rel_ops<vector<unsigned int>>rel_ops<vector<unsigned int>> &rel_ops<vector<unsigned int>> &&const rel_ops<vector<unsigned int>>const rel_ops<vector<unsigned int>> &is_vector<unsigned int>is_vector<unsigned int> &is_vector<unsigned int> &&const is_vector<unsigned int>const is_vector<unsigned int> &(LZHAM_IS_BITWISE_MOVABLE(T) || (is_vector<T>::cFlag)) ? NULL : object_moverbitwise_copyable<node>bitwise_copyable<node> &bitwise_copyable<node> &&const bitwise_copyable<node>const bitwise_copyable<node> &bitwise_movable<unsigned int>bitwise_movable<unsigned int> &bitwise_movable<unsigned int> &&const bitwise_movable<unsigned int>const bitwise_movable<unsigned int> &bitwise_copyable<unsigned int>bitwise_copyable<unsigned int> &bitwise_copyable<unsigned int> &&const bitwise_copyable<unsigned int>const bitwise_copyable<unsigned int> &bitwise_movable<long>bitwise_movable<long> &bitwise_movable<long> &&const bitwise_movable<long>const bitwise_movable<long> &bitwise_copyable<long>bitwise_copyable<long> &bitwise_copyable<long> &&const bitwise_copyable<long>const bitwise_copyable<long> &bitwise_copyable<dict_match>bitwise_copyable<dict_match> &bitwise_copyable<dict_match> &&const bitwise_copyable<dict_match>const bitwise_copyable<dict_match> &node *constlong *constdict_match *constscalar_type<object_task<search_accelerator>>scalar_type<object_task<search_accelerator>> &scalar_type<object_task<search_accelerator>> &&const scalar_type<object_task<search_accelerator>>const scalar_type<object_task<search_accelerator>> &__nullsched_param &sched_param &&const sched_param &cpu_set_t &cpu_set_t &&const cpu_set_t &__jmp_buf_tag &__jmp_buf_tag &&const __jmp_buf_tagconst __jmp_buf_tag &__pthread_cleanup_class &const __pthread_cleanup_classconst __pthread_cleanup_class &__pthread_cleanup_class__restoreconst __pthread_cleanup_class *__pthread_cleanup_class *__defer__setdoit~__pthread_cleanup_class__do_it (1)__pthread_cleanup_frame &__pthread_cleanup_frame &&const __pthread_cleanup_frameconst __pthread_cleanup_frame &__pthread_unwind_buf_t &__pthread_unwind_buf_t &&const __pthread_unwind_buf_tconst __pthread_unwind_buf_t &__cancel_jmp_buf_tag &__cancel_jmp_buf_tag &&const __cancel_jmp_buf_tagconst __cancel_jmp_buf_tag &_pthread_cleanup_buffer &_pthread_cleanup_buffer &&const _pthread_cleanup_bufferconst _pthread_cleanup_buffer &__clframe.__restore (); __clframe.__setdoit (execute); } while (0)do { __pthread_cleanup_class __clframe (routine, arg); __clframe.__defer ()__clframe.__setdoit (execute); } while (0)do { __pthread_cleanup_class __clframe (routine, arg)__newval__fctconst char[72]__EXCEPTIONSsem_t &sem_t &&const sem_tconst sem_t &sem_t__SIZEOF_SEM_TSEM_FAILED((sem_t *) 0)_SEMAPHORE_H/* Value returned if `sem_open' failed.  *//* Generic POSIX semaphore type layout
   Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/semaphore.h>sem_getvaluesem_t *__restrict__sem_postsem_trywaitsem_clockwaitsem_timedwaitsem_waitsem_unlinksem_closesem_opensem_destroysem_init/* semaphore.h *//* Get current value of SEM and store it in *SVAL.  *//* Post SEM.  *//* Test whether SEM is posted.  *//* Similar to `sem_wait' but wait only until ABSTIME.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wait for SEM being posted.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Remove named semaphore NAME.  *//* Close descriptor for named semaphore SEM.  *//* Open a named semaphore NAME with open flags OFLAG.  *//* Free resources associated with semaphore object SEM.  *//* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
   with other processes.  *//* Get the definition for sem_t.  */__sem__sval(1U << 2)(1U << 1)_LINUX_CLOSE_RANGE_H/* _LINUX_CLOSE_RANGE_H *//* Set the FD_CLOEXEC bit instead of closing the file descriptor. *//* Unshare the file descriptor table before closing file descriptors. */"linux/close_range.h"gettidclose_rangeswabcopy_file_range__off64_t *lockf64ftruncate64truncate64syncfs_Forksetresgidsetresuidgetresgid__gid_t *getresuid__uid_t *group_memberexecvpedup3get_current_dir_namepipe2pwrite64pread64lseek64execveateaccesseuidaccessenvironTEMP_FAILURE_RETRY(expression)(__extension__ ({ long int __result; do __result = (long int) (expression); while (__result == -1L && errno == EINTR); __result; }))(int __fd, int __cmd, __off64_t __len)(int __fd, __off64_t __length)(const char *__file, __off64_t __length)(int __fd, const void *__buf, size_t __nbytes, __off64_t __offset)(int __fd, void *__buf, size_t __nbytes, __off64_t __offset)(int __fd, __off64_t __offset, int __whence)"pwrite64""pread64""lseek64""lockf64""ftruncate64""truncate64"__max_fd__infd__pinoff__outfd__poutoff__sgid__suidfutimesatitimerval &itimerval &&const itimerval &timezone &timezone &&const timezone &TIMESPEC_TO_TIMEVAL(tv,ts){ (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }TIMEVAL_TO_TIMESPEC(tv,ts){ (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }m_top(0)/usr/include/asm-generic/bitsperlong.h__ASM_GENERIC_BITS_PER_LONG__BITS_PER_LONG/* __ASM_GENERIC_BITS_PER_LONG *//*
 * There seems to be no way of detecting this automatically from user
 * space, so 64 bit architectures should override this in their
 * bitsperlong.h. In particular, an architecture that supports
 * both 32 and 64 bit user space must not rely on CONFIG_64BIT
 * to decide it, but rather check a compiler provided macro.
 *//usr/include/asm/bitsperlong.h<asm-generic/bitsperlong.h>__ASM_X86_BITSPERLONG_Hdefined(__x86_64__) && !defined(__ILP32__)/* __ASM_X86_BITSPERLONG_H *//usr/include/asm-generic/int-ll64.h<asm/bitsperlong.h>__u64__s64__u32__s32__u16__s16__u8__s8_ASM_GENERIC_INT_LL64_H__ASSEMBLY__/* _ASM_GENERIC_INT_LL64_H *//* __ASSEMBLY__ *//*
 * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
 * header files exported to user space
 *//*
 * asm-generic/int-ll64.h
 *
 * Integer declarations for architectures which use "long long"
 * for 64-bit types.
 *//usr/include/asm-generic/types.h<asm-generic/int-ll64.h>_ASM_GENERIC_TYPES_H/* _ASM_GENERIC_TYPES_H *//*
 * int-ll64 is used everywhere now.
 *//usr/include/asm/types.h<asm-generic/types.h>/usr/include/linux/stddef.h__DECLARE_FLEX_ARRAY(TYPE,NAME)struct { struct { } __empty_ ## NAME; TYPE NAME[]; }__struct_group(TAG,NAME,ATTRS,MEMBERS...)union { struct { MEMBERS } ATTRS; struct TAG { MEMBERS } ATTRS NAME; }_LINUX_STDDEF_H/**
 * __DECLARE_FLEX_ARRAY() - Declare a flexible array usable in a union
 *
 * @TYPE: The type of each flexible array element
 * @NAME: The name of the flexible array member
 *
 * In order to have a flexible array member in a union or alone in a
 * struct, it needs to be wrapped in an anonymous struct with at least 1
 * named member, but that member can be empty.
 *//**
 * __struct_group() - Create a mirrored named and anonyomous struct
 *
 * @TAG: The tag name for the named sub-struct (usually empty)
 * @NAME: The identifier name of the mirrored sub-struct
 * @ATTRS: Any struct attributes (usually empty)
 * @MEMBERS: The member declarations for the mirrored structs
 *
 * Used to create an anonymous union of two structs with identical layout
 * and size: one anonymous and one named. The former's members can be used
 * normally without sub-struct naming, and the latter can be used to
 * reason about the start, end, and size of the group of struct members.
 * The named struct can also be explicitly tagged for layer reuse, as well
 * as both having struct attributes appended.
 *//usr/include/asm-generic/posix_types.h__kernel_fsid_t &__kernel_fsid_t &&const __kernel_fsid_tconst __kernel_fsid_t &__kernel_gid16_t__kernel_uid16_t__kernel_caddr_t__kernel_clockid_t__kernel_timer_t__kernel_clock_t__kernel_time64_t__kernel_time_t__kernel_old_time_t__kernel_loff_t__kernel_off_t__kernel_fsid_t__kernel_ptrdiff_t__kernel_ssize_t__kernel_size_t__kernel_gid32_t__kernel_uid32_t__kernel_daddr_t__kernel_suseconds_t__kernel_gid_t__kernel_uid_t__kernel_ipc_pid_t__kernel_pid_t__kernel_mode_t__kernel_ino_t__kernel_ulong_t__kernel_long_t__ASM_GENERIC_POSIX_TYPES_H__kernel_old_uid_t__kernel_old_dev_t__BITS_PER_LONG != 64/* __ASM_GENERIC_POSIX_TYPES_H *//*
 * anything below here should be completely generic
 *//*
 * Most 32 bit architectures use "unsigned int" size_t,
 * and all 64 bit architectures use "unsigned long" size_t.
 *//*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.
 *
 * First the types that are often defined in different ways across
 * architectures, so that you can override them.
 *//usr/include/asm/posix_types_64.h<asm-generic/posix_types.h>__kernel_old_gid_t_ASM_X86_POSIX_TYPES_64_H/* _ASM_X86_POSIX_TYPES_64_H *//*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.  Also, we cannot
 * assume GCC is being used.
 *//usr/include/asm/posix_types.h<asm/posix_types_64.h>defined(__ILP32__)/usr/include/linux/posix_types.h<asm/posix_types.h><linux/stddef.h>__kernel_fd_set &__kernel_fd_set &&const __kernel_fd_setconst __kernel_fd_set &__kernel_mqd_t__kernel_key_t__kernel_sighandler_t__kernel_fd_setsizeof(long)8 * sizeof(long)(8 * sizeof(long))_LINUX_POSIX_TYPES_H/* _LINUX_POSIX_TYPES_H *//* Type of a SYSV IPC key.  *//* Type of a signal handler.  *//*
 * This macro may have been defined in <gnu/types.h>. But we always
 * use the one here.
 *//*
 * This allows for 1024 file descriptors: if NR_OPEN is ever grown
 * beyond that you'll have to change this too. But 1024 fd's seem to be
 * enough even for such "real" unices like OSF/1, so hopefully this is
 * one limit that doesn't have to be changed [again].
 *
 * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
 * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
 * place for them. Solved by having dummy defines in <sys/time.h>.
 *//usr/include/linux/types.h<linux/posix_types.h><asm/types.h>__poll_t__wsum__sum16__be64__le64__be32__le32__be16__le16__aligned_le64__le64 __attribute__((aligned(8)))__aligned_be64__be64 __attribute__((aligned(8)))__aligned_u64__u64 __attribute__((aligned(8)))__bitwise____bitwise_LINUX_TYPES_H__CHECKER__/* _LINUX_TYPES_H *//*  __ASSEMBLY__ *//*
 * aligned_u64 should be used in defining kernel<->userspace ABIs to avoid
 * common 32/64-bit compat problems.
 * 64-bit values align to 4-byte boundaries on x86_32 (and possibly other
 * architectures) and to 8-byte boundaries on 64-bit architectures.  The new
 * aligned_64 type enforces 8-byte alignment so that structs containing
 * aligned_64 values have the same alignment on 32-bit and 64-bit architectures.
 * No conversions are necessary between 32-bit user-space and a 64-bit kernel.
 *//* The kernel doesn't use this legacy form, but user space does *//* sparse defines __CHECKER__; see Documentation/dev-tools/sparse.rst *//*
 * Below are truly Linux-specific types that should never collide with
 * any application/library that wants linux/types.h.
 *//usr/include/linux/sysinfo.h<linux/types.h>sysinfo &sysinfo &&const sysinfoconst sysinfo &sysinfochar[0]sizeof(__kernel_ulong_t)2*sizeof(__kernel_ulong_t)20-2*sizeof(__kernel_ulong_t)sizeof(__u32)20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)_fmem_unitfreehightotalhighprocsfreeswaptotalswapbufferramsharedramfreeramtotalram__kernel_ulong_t[3]loadsuptimeSI_LOAD_SHIFT_LINUX_SYSINFO_H/* _LINUX_SYSINFO_H *//* Padding: libc5 uses this.. *//* Memory unit size in bytes *//* Available high memory size *//* Total high memory size *//* Explicit padding for m68k *//* Number of current processes *//* swap space still available *//* Total swap space size *//* Memory used by buffers *//* Amount of shared memory *//* Available memory size *//* Total usable main memory size *//* 1, 5, and 15 minute load averages *//* Seconds since boot *//usr/include/linux/const.h__KERNEL_DIV_ROUND_UP(n,d)(((n) + (d) - 1) / (d))__ALIGN_KERNEL_MASK(x,mask)(((x) + (mask)) & ~(mask))__ALIGN_KERNEL(x,a)__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)_BITULL(x)(_ULL(1) << (x))_BITUL(x)(_UL(1) << (x))_ULL(x)(_AC(x, ULL))_UL(x)(_AC(x, UL))_AT(T,X)((T)(X))_AC(X,Y)__AC(X,Y)(X ## Y)_LINUX_CONST_H/* _LINUX_CONST_H *//* Some constant macros are used in both assembler and
 * C code.  Therefore we cannot annotate them always with
 * 'UL' and other type specifiers unilaterally.  We
 * use the following macros to deal with this.
 *
 * Similarly, _AT() will cast an expression with a type in C, but
 * leave it unchanged in asm.
 *//* const.h: Macros for dealing with constants.  *//usr/include/linux/kernel.h<linux/const.h><linux/sysinfo.h>_LINUX_KERNEL_H/* _LINUX_KERNEL_H *//usr/include/sys/sysinfo.h<linux/kernel.h>get_avphys_pagesget_phys_pagesget_nprocsget_nprocs_confsysinfo *_SYS_SYSINFO_H/* sys/sysinfo.h *//* Return number of available physical pages of memory in the system.  *//* Return number of physical pages of memory in the system.  *//* Return number of available processors.  *//* Return number of configured processors.  *//* Returns information on overall system statistics.  *//* Get sysinfo structure from kernel header.  */__info/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamcomp/lzham_pthreads_threading.cpp<sys/sysinfo.h>num_procsconst char[6]num_threads <= cMaxThreadssucceededunsigned long(&)[64]pthread_t(&)[64]defined(__GNUC__) && !defined(__APPLE__) && !defined(__MINGW32__) && !defined(__FreeBSD__)defined(__APPLE__) || defined(__FreeBSD__)// Just assume a dual-core machine.// It's the object's responsibility to delete pObj within the execute_task() method, if needed!// THE SOFTWARE.// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR// all copies or substantial portions of the Software.// The above copyright notice and this permission notice shall be included in// furnished to do so, subject to the following conditions:// copies of the Software, and to permit persons to whom the Software is// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell// in the Software without restriction, including without limitation the rights// of this software and associated documentation files (the "Software"), to deal// Permission is hereby granted, free of charge, to any person obtaining a copy// Copyright (c) 2009-2010 Richard Geldreich, Jr. <richgel99@gmail.com>// File: lzham_task_pool_pthreads.cpptsstack<task, 64U>tsstack<task, 64U> &const tsstack<task, 64U>const tsstack<task, 64U> &task[64]tsstack<task, 64U> *unsigned long(*)[64](int)cMaxSizenumeric_limits<long double> &numeric_limits<long double> &&const numeric_limits<long double>const numeric_limits<long double> &denorm_min3.6451995318824746025e-4951signaling_NaN__builtin_nansl""const char[1]NaN__builtin_nansl("")quiet_NaN__builtin_nanl__builtin_nanl("")infinity__builtin_huge_vall__builtin_huge_vall()round_error0.5Lepsilon1.084202172485504434e-19lowest1.189731495357231765e+4932-1.189731495357231765e+4932-__LDBL_MAX__3.3621031431120935063e-4932numeric_limits<double> &numeric_limits<double> &&const numeric_limits<double>const numeric_limits<double> &4.9406564584124654418e-3244.940656458412465442e-324__builtin_nans__builtin_nans("")__builtin_nan__builtin_nan("")__builtin_huge_val()2.2204460492503130808e-162.220446049250313081e-161.7976931348623157081e+3081.797693134862315708e+308-1.797693134862315708e+308-__DBL_MAX__2.2250738585072013831e-3082.225073858507201383e-308numeric_limits<float> &numeric_limits<float> &&const numeric_limits<float>const numeric_limits<float> &1.401298464e-45__builtin_nansf__builtin_nansf("")__builtin_nanf__builtin_nanf("")__builtin_huge_valf__builtin_huge_valf()0.5F1.192092896e-073.402823466e+38-3.402823466e+38-__FLT_MAX__1.175494351e-38numeric_limits<__uint128_t> &numeric_limits<__uint128_t> &&const numeric_limits<__uint128_t>const numeric_limits<__uint128_t> &__GLIBCXX_BITSIZE_INT_N_0__INT_N_201103 (__GLIBCXX_TYPE_INT_N_0)static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0;__INT_N_U201103 (__GLIBCXX_TYPE_INT_N_0)static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0;unsigned __int128340282366920938463463374607431768211455170141183460469231731687303715884105728170141183460469231731687303715884105727340282366920938463463374607431768211454numeric_limits<__int128_t> &numeric_limits<__int128_t> &&const numeric_limits<__int128_t>const numeric_limits<__int128_t> &-1701411834604692317316873037158841057288507059173023461586584365185794205286485070591730234615865843651857942052863170141183460469231731687303715884105726-170141183460469231731687303715884105727numeric_limits<unsigned long long> &numeric_limits<unsigned long long> &&const numeric_limits<unsigned long long>const numeric_limits<unsigned long long> &static_cast<unsigned long long>(0)min()2ULLnumeric_limits<long long> &numeric_limits<long long> &&const numeric_limits<long long>const numeric_limits<long long> &static_cast<long long>(0)numeric_limits<unsigned long> &numeric_limits<unsigned long> &&const numeric_limits<unsigned long>const numeric_limits<unsigned long> &static_cast<unsigned long>(0)2ULnumeric_limits<long> &numeric_limits<long> &&const numeric_limits<long>const numeric_limits<long> &static_cast<long>(0)-__LONG_MAX__-__LONG_MAX__ - 1numeric_limits<unsigned int> &numeric_limits<unsigned int> &&const numeric_limits<unsigned int>const numeric_limits<unsigned int> &static_cast<unsigned int>(0)numeric_limits<int> &numeric_limits<int> &&const numeric_limits<int>const numeric_limits<int> &static_cast<int>(0)numeric_limits<unsigned short> &numeric_limits<unsigned short> &&const numeric_limits<unsigned short>const numeric_limits<unsigned short> &static_cast<unsigned short>(0)65534numeric_limits<short> &numeric_limits<short> &&const numeric_limits<short>const numeric_limits<short> &short()-32768-32767-__SHRT_MAX__-__SHRT_MAX__ - 1numeric_limits<char32_t> &numeric_limits<char32_t> &&const numeric_limits<char32_t>const numeric_limits<char32_t> &char32_t()char32_tsizeof(char32_t) * __CHAR_BIT__sizeof(char32_t) * 8numeric_limits<char16_t> &numeric_limits<char16_t> &&const numeric_limits<char16_t>const numeric_limits<char16_t> &char16_t()char16_tsizeof(char16_t) * __CHAR_BIT__sizeof(char16_t) * 8numeric_limits<wchar_t> &numeric_limits<wchar_t> &&const numeric_limits<wchar_t>const numeric_limits<wchar_t> &wchar_t()sizeof(wchar_t) * __CHAR_BIT__sizeof(wchar_t) * 82147483646numeric_limits<unsigned char> &numeric_limits<unsigned char> &&const numeric_limits<unsigned char>const numeric_limits<unsigned char> &static_cast<unsigned char>(0)numeric_limits<signed char> &numeric_limits<signed char> &&const numeric_limits<signed char>const numeric_limits<signed char> &static_cast<signed char>(0)-128-127-__SCHAR_MAX__-__SCHAR_MAX__ - 1numeric_limits<char> &numeric_limits<char> &&const numeric_limits<char>const numeric_limits<char> &static_cast<char>(0)char()sizeof(char) * __CHAR_BIT__sizeof(char) * 8numeric_limits<bool> &numeric_limits<bool> &&const numeric_limits<bool>const numeric_limits<bool> &__numeric_limits_base &__numeric_limits_base &&const __numeric_limits_baseconst __numeric_limits_base &numeric_limits<long double>numeric_limits<double>numeric_limits<float>numeric_limits<__uint128_t>numeric_limits<__int128_t>numeric_limits<unsigned long long>numeric_limits<long long>numeric_limits<unsigned long>numeric_limits<long>numeric_limits<unsigned int>numeric_limits<int>numeric_limits<unsigned short>numeric_limits<short>numeric_limits<char32_t>numeric_limits<char16_t>numeric_limits<wchar_t>numeric_limits<unsigned char>numeric_limits<signed char>numeric_limits<char>numeric_limits<bool>numeric_limits<const volatile _Tp>numeric_limits<volatile _Tp>numeric_limits<const _Tp>numeric_limits<_Tp>__numeric_limits_basefloat_denorm_styledenorm_indeterminatedenorm_absentdenorm_presentfloat_round_styleround_indeterminateround_toward_zeroround_to_nearestround_toward_infinityround_toward_neg_infinityround_styletinyness_before__glibcxx_long_double_tinyness_beforetraps__glibcxx_long_double_trapsis_modulois_boundedis_iec559has_infinityhas_quiet_NaNhas_infinity && has_quiet_NaNhas_denormhas_denorm == denorm_presenthas_infinity && has_quiet_NaN && has_denorm == denorm_presenthas_denorm_loss__glibcxx_long_double_has_denorm_lossbool(__LDBL_HAS_DENORM__)bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absenthas_signaling_NaNmax_exponent104932max_exponentmin_exponent104931-4931min_exponent16381-16381radixis_exactis_integeris_signedmax_digits10__LDBL_MANT_DIG__643411522136__glibcxx_max_digits10 (__LDBL_MANT_DIG__)digits10digitsis_specialized__glibcxx_double_tinyness_before__glibcxx_double_traps__glibcxx_double_has_denorm_lossbool(__DBL_HAS_DENORM__)bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent308307-3071021-1021__DBL_MANT_DIG__34079__glibcxx_max_digits10 (__DBL_MANT_DIG__)__glibcxx_float_tinyness_before__glibcxx_float_traps__glibcxx_float_has_denorm_lossbool(__FLT_HAS_DENORM__)bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent-37-125__FLT_MANT_DIG__15432__glibcxx_max_digits10 (__FLT_MANT_DIG__)8230481661__glibcxx_integral_trapsunsigned long longsizeof(unsigned long long) * __CHAR_BIT__sizeof(unsigned long long) * 8sizeof(long long) * __CHAR_BIT__sizeof(long long) * 840509sizeof(unsigned long) * __CHAR_BIT__sizeof(unsigned long) * 8sizeof(long) * __CHAR_BIT__sizeof(long) * 8sizeof(unsigned int) * __CHAR_BIT__sizeof(unsigned int) * 820576sizeof(int) * __CHAR_BIT__sizeof(int) * 819933sizeof(unsigned short) * __CHAR_BIT__sizeof(unsigned short) * 810288sizeof(short) * __CHAR_BIT__sizeof(short) * 89645!is_signedsizeof(unsigned char) * __CHAR_BIT__sizeof(unsigned char) * 85144signed charsizeof(signed char) * __CHAR_BIT__sizeof(signed char) * 84501__glibcxx_max_digits10__glibcxx_digits10__glibcxx_digits__glibcxx_max__glibcxx_min__glibcxx_signed__INT_N_U201103__INT_N_201103__INT_N__INT_N_U201103(TYPE)static constexpr unsigned TYPE lowest() noexcept { return min(); } static constexpr int max_digits10 = 0;__INT_N_201103(TYPE)static constexpr TYPE lowest() noexcept { return min(); } static constexpr int max_digits10 = 0;__INT_N(TYPE,BITSIZE,EXT,UEXT)__extension__ template<> struct numeric_limits<TYPE> { static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; static _GLIBCXX_CONSTEXPR TYPE min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min_b (TYPE, BITSIZE); } static _GLIBCXX_CONSTEXPR TYPE max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max_b (TYPE, BITSIZE); } static _GLIBCXX_USE_CONSTEXPR int digits = BITSIZE - 1; static _GLIBCXX_USE_CONSTEXPR int digits10 = (BITSIZE - 1) * 643L / 2136; static _GLIBCXX_USE_CONSTEXPR bool is_signed = true; static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; static _GLIBCXX_USE_CONSTEXPR int radix = 2; static _GLIBCXX_CONSTEXPR TYPE epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } static _GLIBCXX_CONSTEXPR TYPE round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } EXT static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent; static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; static _GLIBCXX_CONSTEXPR TYPE infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<TYPE>(0); } static _GLIBCXX_CONSTEXPR TYPE quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<TYPE>(0); } static _GLIBCXX_CONSTEXPR TYPE signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<TYPE>(0); } static _GLIBCXX_CONSTEXPR TYPE denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<TYPE>(0); } static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false; static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps; static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned TYPE> { static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true; static _GLIBCXX_CONSTEXPR unsigned TYPE min() _GLIBCXX_USE_NOEXCEPT { return 0; } static _GLIBCXX_CONSTEXPR unsigned TYPE max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max_b (unsigned TYPE, BITSIZE); } UEXT static _GLIBCXX_USE_CONSTEXPR int digits = BITSIZE; static _GLIBCXX_USE_CONSTEXPR int digits10 = BITSIZE * 643L / 2136; static _GLIBCXX_USE_CONSTEXPR bool is_signed = false; static _GLIBCXX_USE_CONSTEXPR bool is_integer = true; static _GLIBCXX_USE_CONSTEXPR bool is_exact = true; static _GLIBCXX_USE_CONSTEXPR int radix = 2; static _GLIBCXX_CONSTEXPR unsigned TYPE epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; } static _GLIBCXX_CONSTEXPR unsigned TYPE round_error() _GLIBCXX_USE_NOEXCEPT { return 0; } static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0; static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0; static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0; static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0; static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false; static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false; static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false; static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent; static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false; static _GLIBCXX_CONSTEXPR unsigned TYPE infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned TYPE>(0); } static _GLIBCXX_CONSTEXPR unsigned TYPE quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned TYPE>(0); } static _GLIBCXX_CONSTEXPR unsigned TYPE signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned TYPE>(0); } static _GLIBCXX_CONSTEXPR unsigned TYPE denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned TYPE>(0); } static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false; static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true; static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true; static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps; static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false; static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = round_toward_zero; };__glibcxx_max_digits10(T)(2 + (T) * 643L / 2136)__glibcxx_digits10(T)__glibcxx_digits10_b (T, sizeof(T) * __CHAR_BIT__)__glibcxx_digits(T)__glibcxx_digits_b (T, sizeof(T) * __CHAR_BIT__)__glibcxx_max(T)__glibcxx_max_b (T, sizeof(T) * __CHAR_BIT__)__glibcxx_min(T)__glibcxx_min_b (T, sizeof(T) * __CHAR_BIT__)__glibcxx_signed(T)__glibcxx_signed_b (T, sizeof(T) * __CHAR_BIT__)__glibcxx_digits10_b(T,B)(__glibcxx_digits_b (T,B) * 643L / 2136)__glibcxx_digits_b(T,B)(B - __glibcxx_signed_b (T,B))__glibcxx_max_b(T,B)(__glibcxx_signed_b (T,B) ? (((((T)1 << (__glibcxx_digits_b (T,B) - 1)) - 1) << 1) + 1) : ~(T)0)__glibcxx_min_b(T,B)(__glibcxx_signed_b (T,B) ? -__glibcxx_max_b (T,B) - 1 : (T)0)__glibcxx_signed_b(T,B)((T)(-1) < 0)_GLIBCXX_NUMERIC_LIMITS!defined(__STRICT_ANSI__)__GLIBCXX_TYPE_INT_N_1__GLIBCXX_TYPE_INT_N_2__GLIBCXX_TYPE_INT_N_3defined __STRICT_ANSI__ && defined __SIZEOF_INT128____FLT_EPSILON__1.19209289550781250000000000000000000e-7F__FLT_RADIX____FLT_DIG____FLT_MAX__3.40282346638528859811704183484516925e+38F__FLT_MIN__1.17549435082228750796873653722224568e-38F__LDBL_DENORM_MIN__3.64519953188247460252840593361941982e-4951L__LDBL_HAS_DENORM____LDBL_HAS_QUIET_NAN____LDBL_HAS_INFINITY____LDBL_MAX_10_EXP____LDBL_MAX_EXP____LDBL_MIN_10_EXP__(-4931)__LDBL_MIN_EXP__(-16381)__LDBL_EPSILON__1.08420217248550443400745280086994171e-19L__LDBL_DIG____LDBL_MAX__1.18973149535723176502126385303097021e+4932L__LDBL_MIN__3.36210314311209350626267781732175260e-4932L__DBL_DENORM_MIN__double(4.94065645841246544176568792868221372e-324L)__DBL_HAS_DENORM____DBL_HAS_QUIET_NAN____DBL_HAS_INFINITY____DBL_MAX_10_EXP____DBL_MAX_EXP____DBL_MIN_10_EXP__(-307)__DBL_MIN_EXP__(-1021)__DBL_EPSILON__double(2.22044604925031308084726333618164062e-16L)__DBL_DIG____DBL_MAX__double(1.79769313486231570814527423731704357e+308L)__DBL_MIN__double(2.22507385850720138309023271733240406e-308L)__FLT_DENORM_MIN__1.40129846432481707092372958328991613e-45F__FLT_HAS_DENORM____FLT_HAS_QUIET_NAN____FLT_HAS_INFINITY____FLT_MAX_10_EXP____FLT_MAX_EXP____FLT_MIN_10_EXP__(-37)__FLT_MIN_EXP__(-125)0x7fffffffffffffffL// _GLIBCXX_NUMERIC_LIMITS/// numeric_limits<long double> specialization./// numeric_limits<double> specialization./// numeric_limits<float> specialization./// numeric_limits<unsigned long long> specialization./// numeric_limits<long long> specialization./// numeric_limits<unsigned long> specialization./// numeric_limits<long> specialization./// numeric_limits<unsigned int> specialization./// numeric_limits<int> specialization./// numeric_limits<unsigned short> specialization./// numeric_limits<short> specialization./// numeric_limits<char32_t> specialization./// numeric_limits<char16_t> specialization./// numeric_limits<char8_t> specialization./// numeric_limits<wchar_t> specialization./// numeric_limits<unsigned char> specialization./// numeric_limits<signed char> specialization./// numeric_limits<char> specialization.// promotion semantics.// This is a DR on the LWG issue list.  Here, I use integer// It is not clear what it means for a boolean type to trap./// numeric_limits<bool> specialization.// 184. numeric_limits<bool> wording problems// (+1 if char8_t is enabled.)// you get the count right. (18 in C++11 mode, with char16_t and char32_t.)// Now there follow 16 explicit specializations.  Yes, 16.  Make sure// 559. numeric_limits<const T>/** The minimum positive denormalized value.  For types where
	  @c has_denorm is false, this is the minimum positive normalized
	  value.  *//** The representation of a signaling Not a Number, if
	  @c has_signaling_NaN. *//** The representation of a quiet Not a Number,
	  if @c has_quiet_NaN. *//** The representation of positive infinity, if @c has_infinity.  *//** The maximum rounding error measurement (see LIA-1).  *//** The @e machine @e epsilon:  the difference between 1 and the least
	  value greater than 1 that is representable.  *//** A finite value x such that there is no other finite value y
       *  where y < x.  *//** The maximum finite value.  *//** The minimum finite value, or for floating types with
	  denormalization, the minimum positive normalized value.  *//**
   *  @brief Properties of fundamental types.
   *
   *  This class allows a program to obtain information about the
   *  representation of a fundamental type on a given platform.  For
   *  non-fundamental types, the functions will return 0 and the data
   *  members will all be @c false.
  *//** See std::float_round_style for more information.  This is only
	meaningful for floating types; integer types will all be
	round_toward_zero.  *//** True if tininess is detected before rounding.  (see IEC 559)  *//** True if trapping is implemented for this type.  *//** True if the type is @e modulo. A type is modulo if, for any
	operation involving +, -, or * on values of that type whose
	result would fall outside the range [min(),max()], the value
	returned differs from the true value by an integer multiple of
	max() - min() + 1. On most machines, this is false for floating
	types, true for unsigned integers, and true for signed integers.
	See PR22200 about signed integers.  *//** True if the set of values representable by the type is
	finite.  All built-in types are bounded, this member would be
	false for arbitrary precision types. *//** True if-and-only-if the type adheres to the IEC 559 standard, also
	known as IEEE 754.  (Only makes sense for floating point types.)  *//** True if loss of accuracy is detected as a denormalization loss,
	rather than as an inexact result. *//** See std::float_denorm_style for more information.  *//** True if the type has a representation for a signaling
	Not a Number.  *//** True if the type has a representation for a quiet (non-signaling)
	Not a Number.  *//** True if the type has a representation for positive infinity.  *//** The maximum positive integer such that 10 raised to that power is in
	the range of representable finite floating point numbers.  *//** The maximum positive integer such that @c radix raised to the power of
	(one less than that integer) is a representable finite floating point
	number.  *//** The minimum negative integer such that 10 raised to that power is in
	the range of normalized floating point numbers.  *//** The minimum negative integer such that @c radix raised to the power of
	(one less than that integer) is a normalized floating point number.  *//** For integer types, specifies the base of the representation.  For
	floating types, specifies the base of the exponent representation.  *//** True if the type uses an exact representation. All integer types are
	exact, but not all exact types are integer.  For example, rational and
	fixed-exponent representations are exact but not integer. *//** True if the type is integer.  *//** True if the type is signed.  *//** The number of base 10 digits required to ensure that values which
	differ are always differentiated.  *//** The number of base 10 digits that can be represented without change. *//** The number of @c radix digits that be represented without change:  for
	integer types, the number of non-sign bits in the mantissa; for
	floating types, the number of @c radix digits in the mantissa.  *//** This will be true for all fundamental types (which have
	specializations), and false for everything else.  *//**
   *  @brief Part of std::numeric_limits.
   *
   *  The @c static @c const members are usable as integral constant
   *  expressions.
   *
   *  @note This is a separate class for purposes of efficiency; you
   *        should only access these members as part of an instantiation
   *        of the std::numeric_limits class.
  *//// The type allows denormalized values./// The type does not allow denormalized values./// Indeterminate at compile time whether denormalized values are allowed./**
   *  @brief Describes the denormalization for floating-point types.
   *
   *  These values represent the presence or absence of a variable number
   *  of exponent bits.  This type is used in the std::numeric_limits class.
  *//// To negative infinity./// To infinity./// To the nearest representable value./// To zero./// Intermediate./**
   *  @brief Describes the rounding style for floating-point types.
   *
   *  This is used in the std::numeric_limits class.
  */// The fraction 643/2136 approximates log10(2) to 7 significant digits.// You should not need to define any macros below this point.// Default values.  Should be overridden in configuration files if necessary.// long double// double// float// signal division by zero in some "hard to ignore" way should use false.// integral exceptional values is division by zero.  Only targets that do not// GCC only intrinsically supports modulo integral types.  The only remaining// The default values are appropriate for many 32-bit targets.// These values can be overridden in the target configuration file.// definitions given here.// or config/cpu when they differ from the generic (read arbitrary)// an interface composed of macros which should be defined in config/os// Since a numeric_limits<> is a bit tricky to get right, we rely on// which brings us to 16 fundamental arithmetic data types in GNU C++.//         long long, unsigned long long			(2)//   * integer// GNU C++ understands (where supported by the host C-library)//         long double						(1)//         double						(1)//         float						(1)//   * floating points//         long, unsigned long					(2)//         int, unsigned					(2)//         short, unsigned short				(2)//         char, signed char, unsigned char, wchar_t            (4)//         bool							(1)//   * integers// From Standard C++ point of view, there are 14 such types:// of fundamental arithmetic data types (integers and floating points).// The numeric_limits<> traits document implementation-defined aspects// 18.2.1// ISO 14882:1998// Written by Gabriel Dos Reis <gdr@codesourcery.com>// Note: this is not a conforming implementation./** @file include/limits
 *  This is a Standard C++ Library header.
 */// Copyright (C) 1999-2022 Free Software Foundation, Inc.// The template and inlines for the numeric_limits classes. -*- C++ -*-__a_nint__b_nint__c_nint__toler"Argument outside unit circle " "in __hyperg."Argument outside unit circle in __hyperg.__N("Argument outside unit circle "
                                      "in __hyperg.")0.9950.995L0.250.25L__hyperg__d__intd__eps__log_max__d_integer..."Overflow of gamma functions" " in __hyperg_luke.""Sum F2 failed to converge " "in __hyperg_reflect""Overflow of gamma functions " "in __hyperg_reflect""Underflow of gamma functions " "in __hyperg_reflect"__ln_omx__ad__F1__F2__d1__d2__lng_c__ok_d2__lng_ad2__lng_bd2__sgn_2__ok_d1__lng_ad__lng_ad1__lng_bd1__sum1__term__ln_pre1__jOverflow of gamma functions in __hyperg_luke.__N("Overflow of gamma functions"
                                                   " in __hyperg_luke.")__maxiter 2000__psi_1__gamma_e__psi_1pd__psi_apd1__psi_bpd1__psi_term__fact__sum2__ln_pre2__term1__term2Sum F2 failed to converge in __hyperg_reflect__N("Sum F2 failed to converge "
                                               "in __hyperg_reflect")__ok1__sgn_g1ca__ln_g1ca__sgn_g1cb__ln_g1cb__ok2__sgn_g2a__ln_g2a__sgn_g2b/usr/include/c++/12/tr1__ln_g2b__sgn_gc__ln_gc__sgn_gd__ln_gd__sgn_gmd__ln_gmd__sgn1__sgn2__pre1__pre2Overflow of gamma functions in __hyperg_reflectconst char[48]__N("Overflow of gamma functions "
                                                 "in __hyperg_reflect")Underflow of gamma functions in __hyperg_reflect__N("Underflow of gamma functions "
                                             "in __hyperg_reflect")__hyperg_reflect__big0.160.16L__nmax20000 20000__x3__t0__t1__t2__Bnm3__Bnm2__Bnm1__Anm3__Anm2__Anm1__npam1__npbm1__npcm1__npam2__npbm2__npcm2__tnm1__tnm3__tnm5__n2__F3__An__Bn__prec"Iteration failed to converge " "in __hyperg_luke."Iteration failed to converge in __hyperg_luke.const char[47]__N("Iteration failed to converge "
                                       "in __hyperg_luke.")__hyperg_luke__Fabc__max_iter100000"Series failed to converge " "in __hyperg_series."Series failed to converge in __hyperg_series.__N("Series failed to converge "
                                       "in __hyperg_series.")__hyperg_series__conf_hyperg"Iteration failed to converge " "in __conf_hyperg_luke."Iteration failed to converge in __conf_hyperg_luke.__N("Iteration failed to converge "
                                       "in __conf_hyperg_luke.")__conf_hyperg_luke__Fac"Series failed to converge " "in __conf_hyperg_series."Series failed to converge in __conf_hyperg_series.__N("Series failed to converge "
                                       "in __conf_hyperg_series.")__conf_hyperg_series_GLIBCXX_MATH_NS::std_GLIBCXX_TR1_HYPERGEOMETRIC_TCC_GLIBCXX_USE_STD_SPEC_FUNCSdefined(_GLIBCXX_TR1_CMATH)_GLIBCXX_USE_C99_MATH_TR1! _GLIBCXX_USE_STD_SPEC_FUNCS && defined(_GLIBCXX_TR1_CMATH)// _GLIBCXX_TR1_HYPERGEOMETRIC_TCC// namespace tr1// namespace __detail//  finite polynomial.//  For integer a and b the hypergeometric function is a/**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *///  catch their harmless domain errors and set the terms to zero.//  These gamma functions appear in the denominator, so we//  d = c - a - b not an integer.// end F2 evaluation// So the F2 term is zero.// Gamma functions in the denominator not ok.//  Abramowitz & Stegun 6.3.5//  Values for psi functions use recurrence;// Do F2 sum.//  Proceed with evaluation.//  Gamma functions in the denominator are ok.// Evaluate F2.// end F1 evaluation//  So the F1 term is zero.//  Gamma functions in the denominator were not ok./* Do F1 sum.
                   *//* Gamma functions in the denominator are ok.
                   * Proceed with evaluation.
                   *///  d = c - a - b = 0.//  Evaluate F1./**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$ 
     *  by the reflection formulae in Abramowitz & Stegun formula
     *  15.3.6 for d = c - a - b not integral and formula 15.3.11 for
     *  d = c - a - b integral.  This assumes a, b, c != negative
     *  integer.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   The reflection formula for nonintegral @f$ d = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)\Gamma(d)}{\Gamma(c-a)\Gamma(c-b)}
     *                            _2F_1(a,b;1-d;1-x)
     *                    + \frac{\Gamma(c)\Gamma(-d)}{\Gamma(a)\Gamma(b)}
     *                            _2F_1(c-a,c-b;1+d;1-x)
     *   @f]
     *
     *   The reflection formula for integral @f$ m = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;a+b+m;x) = \frac{\Gamma(m)\Gamma(a+b+m)}{\Gamma(a+m)\Gamma(b+m)}
     *                        \sum_{k=0}^{m-1} \frac{(m+a)_k(m+b)_k}{k!(1-m)_k}
     *                      - 
     *   @f]
     *//**
     *   @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *           by an iterative procedure described in
     *           Luke, Algorithms for the Computation of Mathematical Functions.
     *//**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *   by series expansion.
     * 
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   This works and it's pretty fast.
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *   @brief  Return the confluent hypogeometric function
     *           @f$ _1F_1(a;c;x) @f$.
     * 
     *   @todo  Handle b == nonpositive integer blowup - return NaN.
     *
     *   @param  __a  The @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *          by an iterative procedure described in
     *          Luke, Algorithms for the Computation of Mathematical Functions.
     *
     *  Like the case of the 2F1 rational approximations, these are 
     *  probably guaranteed to converge for x < 0, barring gross    
     *  numerical instability in the pre-asymptotic regime.         
     *//**
     *   @brief This routine returns the confluent hypergeometric function
     *          by series expansion.
     * 
     *   @f[
     *     _1F_1(a;c;x) = \frac{\Gamma(c)}{\Gamma(a)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   If a and b are integers and a < 0 and either b > 0 or b < a
     *   then the series is a polynomial with a finite number of
     *   terms.  If b is an integer and b <= 0 the confluent
     *   hypergeometric function is undefined.
     *
     *   @param  __a  The "numerator" parameter.
     *   @param  __c  The "denominator" parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     */// Implementation-space details.// [5.2] Special functions//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl//       Section 6, pp. 555-566//       Dover Publications,//       ed. Milton Abramowitz and Irene A. Stegun,//   (1) Handbook of Mathematical Functions,// Written by Edward Smith-Rowland based:// ISO C++ 14882 TR1: 5.2  Special functions/** @file tr1/hypergeometric.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */// Copyright (C) 2006-2022 Free Software Foundation, Inc.// Special functions -*- C++ -*-__xin__laguerre__assoc_laguerre"Negative argument " "in __poly_laguerre."Negative argument in __poly_laguerre.__N("Negative argument "
                                      "in __poly_laguerre.")_Tpa__prod__k10000000__poly_laguerre__l_0__l_1__l_n2__l_n1__l_n__nn__poly_laguerre_recursion__mx__tc_sgn__tc__ax__sum__poly_laguerre_hyperg__eta__cos2th__sin2th__pre_h__pi_2__lg_b__lnfact__pre_term1__pre_term2__lnpre__ser_term1__pi__ser_term2__pi_4__ser__poly_laguerre_large_n_GLIBCXX_TR1_POLY_LAGUERRE_TCC// _GLIBCXX_TR1_POLY_LAGUERRE_TCC/**
     *   @brief This routine returns the Laguerre polynomial
     *          of order n: @f$ L_n(x) @f$.
     *
     *   The Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the Laguerre polynomial of order n
     *           and argument x.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree m: @f$ L_n^m(x) @f$.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __m The degree of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the associated Laguerre polynomial of order n,
     *           degree m, and argument x.
     *///  Return NaN on NaN input./**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree @f$ \alpha @f$: @f$ L_n^alpha(x) @f$.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Compute l_n^alpha by recursion on n.//  Compute l_1^alpha.//   Compute l_0./**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$: @f$ L_n^\alpha(x) @f$
     *          by recursion.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Get |x|^n/n!/**
     *  @brief  Evaluate the polynomial based on the confluent hypergeometric
     *          function in a safe way, with no restriction on the arguments.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *  This function assumes x != 0.
     *
     *  This is from the GNU Scientific Library.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$ for large n.
     *   Abramowitz & Stegun, 13.5.21
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *
     *  This is from the GNU Scientific Library.
     *///       Section 13, pp. 509-510, Section 22 pp. 773-802//       Ed. Milton Abramowitz and Irene A. Stegun,// Written by Edward Smith-Rowland based on:/** @file tr1/poly_laguerre.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__alpha1<bits/specfun.h><bits/std_abs.h><ext/type_traits.h><bits/cpp_type_traits.h>_Vp__hypot3__builtin_truncl__builtin_truncf__builtin_tgammal__builtin_tgammaf__builtin_scalbnl__builtin_scalbnf__builtin_scalblnl__builtin_scalblnf__builtin_roundl__builtin_roundf__builtin_rintl__builtin_rintf__builtin_remquol__builtin_remquof__builtin_remainderl__builtin_remainderf__builtin_nexttowardl__builtin_nexttowardf__builtin_nextafterl__builtin_nextafterf__builtin_nearbyintl__builtin_nearbyintf__builtin_lroundl__builtin_lroundf__builtin_lrintl__builtin_lrintf__builtin_logbl__builtin_logbf__builtin_log2l__builtin_log2f__builtin_log1pl__builtin_log1pf__builtin_llroundl__builtin_llroundf__builtin_llrintl__builtin_llrintf__builtin_lgammal__builtin_lgammaf__builtin_ilogbl__builtin_ilogbf__builtin_hypotl__builtin_hypotf__builtin_fminl__builtin_fminf__builtin_fmaxl__builtin_fmaxf__builtin_fmal__builtin_fmaf__builtin_fdiml__builtin_fdimf__builtin_expm1l__builtin_expm1f__builtin_exp2l__builtin_exp2f__builtin_erfcl__builtin_erfcf__builtin_erfl__builtin_erff__builtin_copysignl__builtin_copysignf__ex__pquo__builtin_cbrtl__builtin_cbrtf__builtin_atanhl__builtin_atanhf__builtin_asinhl__builtin_asinhf__builtin_acoshl__builtin_acoshfisunordered__builtin_isunorderedislessgreater__builtin_islessgreaterislessequal__builtin_islessequalisless__builtin_islessisgreaterequal__builtin_isgreaterequalisgreater__builtin_isgreater__builtin_signbitisnormal__builtin_isnormal__builtin_isnan__builtin_isinfisfinite__builtin_isfinite__builtin_fpclassify__builtin_tanhl__builtin_tanhf__builtin_tanl__builtin_tanf__builtin_sqrtl__builtin_sqrtf__builtin_sinhl__builtin_sinhf__builtin_sinl__builtin_sinf__builtin_powl__builtin_powf__builtin_modfl__builtin_modff__builtin_log10l__builtin_log10f__builtin_logl__builtin_logf__builtin_ldexpl__builtin_ldexpf__builtin_frexpl__builtin_frexpf__builtin_fmodl__builtin_fmodf__builtin_floorl__builtin_floorf__builtin_fabsl__builtin_fabsf__builtin_expl__builtin_expf__builtin_coshl__builtin_coshf__builtin_cosl__builtin_cosf__builtin_ceill__builtin_ceilf__builtin_atan2l__builtin_atan2f__builtin_atanl__builtin_atanf__builtin_asinl__builtin_asinf__builtin_acosl__builtin_acosf__cpp_lib_hypot_GLIBCXX_CMATH_GLIBCXX_INCLUDE_NEXT_C_HEADERS__CORRECT_ISO_CPP_MATH_H_PROTO_GLIBCXX_USE_C99_MATH!_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC__CORRECT_ISO_CPP11_MATH_H_PROTO_FP__CORRECT_ISO_CPP11_MATH_H_PROTO_INT_GLIBCXX_HAVE_OBSOLETE_ISINF \_GLIBCXX_HAVE_OBSOLETE_ISNAN \_GLIBCXX_NO_C99_ROUNDING_FUNCS// extern "C++"// C++20// monotonic near __t=1// bounded, determinate, and consistent:// Exact at __t=0, monotonic except near __t=1,// exact// linear interpolation// [c.math.hypot3], three-dimensional hypotenuse// _GLIBCXX_USE_C99_MATH_TR1// DR 568./// Additional overloads.// functions// types/* _GLIBCXX_USE_C99_MATH *//* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */// Note: middle-end/36757 is fixed, __builtin_signbit is type-generic.// These are possible macros imported from C99-land.// DR 550. What should the return type of pow(float,int) be?// Get rid of those macros defined in <math.h> in lieu of real functions.// ISO C++ 14882: 26.5  C library/** @file include/cmath
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c math.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */// Copyright (C) 1997-2022 Free Software Foundation, Inc.// -*- C++ -*- C forwarding header.<bits/xopen_lim.h><initializer_list><bits/stl_iterator_base_types.h><bits/stl_pair.h>_OIterunique_copy_IIter_BinaryPredicate_InputIterator_OutputIterator_IIter1_IIter2_BinaryOperation_InputIterator1_InputIterator2_UnaryOperationstable_sort_RAIter_Compare_RandomAccessIteratorset_unionset_symmetric_differenceset_intersectionset_difference_FItersearch_n_Size_ForwardIterator_Integer_FIter1search_FIter2_ForwardIterator1_ForwardIterator2replace_if_Predicatereplacerandom_shuffle"std::shuffle"use 'std::shuffle' instead_Generator_Generator &&_RandomNumberGenerator_RandomNumberGenerator &&_BIterpartitionpartial_sortnth_elementmismatchmin_elementmergemax_elementlexicographical_compare_II1_II2generate_ngenerate_Functfor_each_Functionfind_iffind_first_ofequaldifference_typecount_ifadjacent_findswap_rangesstable_partitionsort_heapshuffle_UGenerator_UGenerator &&_UniformRandomNumberGenerator_UniformRandomNumberGenerator &&rotate_copyreverse_copy_BidirectionalIteratorreplace_copy_if_Iterreplace_copyremove_copy_ifremove_copyremove_ifpush_heap__first__last__binary_pred__first1__last1__first2__binary_op__unary_op__comp__last2__predicate__pred__new_value__old_value__rand__middle__nth__gen__gprev_permutationpop_heappartition_pointpartition_copy_OIter1_OIter2_OutputIterator1_OutputIterator2partial_sort_copynone_ofnext_permutationminmaxminmax_elementmake_heaplower_bounditer_swapis_sorted_untilis_sortedis_permutationis_partitionedis_heap_untilis_heapinplace_mergeincludesfind_if_notfind_end_OIfill_nfillequal_rangecopy_ncopy_if_BI2copy_backward_BI1_BIter1_BIter2_IIbinary_searchany_ofall_of_GLIBCXX_ALGORITHMFWD_H_V2(__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99_STDINT_TR1)_GLIBCXX_PARALLEL// unique_copy// transform// For C++11 swap() is declared in <type_traits>.// set_union// set_symmetric_difference// set_intersection// set_difference// search_n// search// replace_if// replace// random_shuffle// partition// partial_sort// nth_element// mismatch// min_element// merge// max_element// generate_n// generate// for_each// find_if// find_first_of// find// count_if// count// adjacent_find/**
   * @defgroup binary_search_algorithms Binary Search
   * @ingroup sorting_algorithms
   *
   * These algorithms are variations of a classic binary search, and
   * all assume that the sequence being searched is already sorted.
   *
   * The number of comparisons will be logarithmic (and as few as
   * possible).  The number of steps through the sequence will be
   * logarithmic for random-access iterators (e.g., pointers), and
   * linear otherwise.
   *
   * The LWG has passed Defect Report 270, which notes: <em>The
   * proposed resolution reinterprets binary search. Instead of
   * thinking about searching for a value in a sorted range, we view
   * that as an important special case of a more general algorithm:
   * searching for the partition point in a partitioned range.  We
   * also add a guarantee that the old wording did not: we ensure that
   * the upper bound is no earlier than the lower bound, that the pair
   * returned by equal_range is a valid range, and that the first part
   * of that pair is the lower bound.</em>
   *
   * The actual effect of the first sentence is that a comparison
   * functor passed by the user doesn't necessarily need to induce a
   * strict weak ordering relation.  Rather, it partitions the range.
   *//**
   * @defgroup set_algorithms Set Operations
   * @ingroup sorting_algorithms
   *
   * These algorithms are common set operations performed on sequences
   * that are already sorted. The number of comparisons will be
   * linear.
   *//**
   * @defgroup sorting_algorithms Sorting
   * @ingroup algorithms
   *//**
   * @defgroup non_mutating_algorithms Non-Mutating
   * @ingroup algorithms
   *//**
   * @defgroup mutating_algorithms Mutating
   * @ingroup algorithms
   *//**
   * @defgroup algorithms Algorithms
   *
   * Components for performing algorithmic operations. Includes
   * non-modifying sequence, modifying (mutating) sequence, sorting,
   * searching, merge, partition, heap, set, minima, maxima, and
   * permutation operations.
   *//*
    adjacent_find
    all_of (C++11)
    any_of (C++11)
    binary_search
    clamp (C++17)
    copy
    copy_backward
    copy_if (C++11)
    copy_n (C++11)
    count
    count_if
    equal
    equal_range
    fill
    fill_n
    find
    find_end
    find_first_of
    find_if
    find_if_not (C++11)
    for_each
    generate
    generate_n
    includes
    inplace_merge
    is_heap (C++11)
    is_heap_until (C++11)
    is_partitioned (C++11)
    is_sorted (C++11)
    is_sorted_until (C++11)
    iter_swap
    lexicographical_compare
    lower_bound
    make_heap
    max
    max_element
    merge
    min
    min_element
    minmax (C++11)
    minmax_element (C++11)
    mismatch
    next_permutation
    none_of (C++11)
    nth_element
    partial_sort
    partial_sort_copy
    partition
    partition_copy (C++11)
    partition_point (C++11)
    pop_heap
    prev_permutation
    push_heap
    random_shuffle
    remove
    remove_copy
    remove_copy_if
    remove_if
    replace
    replace_copy
    replace_copy_if
    replace_if
    reverse
    reverse_copy
    rotate
    rotate_copy
    search
    search_n
    set_difference
    set_intersection
    set_symmetric_difference
    set_union
    shuffle (C++11)
    sort
    sort_heap
    stable_partition
    stable_sort
    swap
    swap_ranges
    transform
    unique
    unique_copy
    upper_bound
  *//** @file bits/algorithmfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */// <algorithm> Forward declarations  -*- C++ -*-__out_true__out_false__result_first__result_last__lo__hi<cstdlib><bits/uniform_int_dist.h><bits/predefined_ops.h><bits/stl_tempbuf.h><bits/stl_heap.h><bits/algorithmfwd.h>__rotate_SampleIterator_PopulationIterator_Distance_UniformRandomBitGenerator_UniformRandomBitGenerator &&__sample_Cat__max_element__min_element__set_symmetric_difference__set_difference__set_intersection__set_union__stable_sort__merge_Searcherconst _Searcherconst _Searcher &_Searcher &for_each_n__gen_two_uniform_ints_IntType__is_permutation__minmax_element__is_sorted_until__replace_copy_if__prev_permutation__next_permutation__includes__inplace_stable_sort__stable_sort_adaptive_Pointer__merge_sort_with_buffer__chunk_insertion_sort__merge_sort_loop_RandomAccessIterator1_RandomAccessIterator2__move_merge__inplace_merge__merge_without_buffer__merge_adaptive_BidirectionalIterator1__rotate_adaptive_BidirectionalIterator2__move_merge_adaptive_backward_BidirectionalIterator3__move_merge_adaptive__equal_range_CompareItTp_CompareTpIt__introselect__sort__introsort_loop__partial_sort__unguarded_partition_pivot__unguarded_partition__final_insertion_sort__unguarded_insertion_sort__insertion_sort__unguarded_linear_insert__partial_sort_copy__heap_select__stable_partition__stable_partition_adaptive__partition_EuclideanRingElement__gcd__reverse__unique_copy__unique__adjacent_find__copy_n__remove_copy_if__find_end__search_n_UnaryPredicate_RandomAccessIter__search_n_aux__search__find_if_not_n_Distance &__find_if_not__move_median_to_first_Iterator_S_chunk_size_S_threshold__out__searcher__buffer_size__chunk_size__step_size__len1__len2__comp_it_val__comp_val_it__depth_limit__pivot__cpp_lib_sample__cpp_lib_clamp_STL_ALGO_H_GLIBCXX_HOSTED && (__cplusplus <= 201103L || _GLIBCXX_USE_DEPRECATED)_GLIBCXX_CONCEPT_CHECKS_GLIBCXX_USE_C99_STDINT_TR1__cplusplus <= 201103L || _GLIBCXX_USE_DEPRECATED_GLIBCXX_HOSTED_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator1>::value_type, typename iterator_traits<_ForwardIterator2>::value_type>_ForwardIteratorConcept<_ForwardIterator2>_ForwardIteratorConcept<_ForwardIterator1>_EqualOpConcept< typename iterator_traits<_ForwardIterator1>::value_type, typename iterator_traits<_ForwardIterator2>::value_type>_BidirectionalIteratorConcept< _BidirectionalIterator2>_BidirectionalIteratorConcept< _BidirectionalIterator1>__l.begin()__l.end()_BinaryPredicateConcept<_Compare, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_ForwardIteratorConcept<_ForwardIterator>_LessThanComparableConcept< typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_InputIterator2>::value_type, typename iterator_traits<_InputIterator1>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator2>::value_type>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator1>::value_type>_InputIteratorConcept<_InputIterator2>_InputIteratorConcept<_InputIterator1>_LessThanOpConcept< typename iterator_traits<_InputIterator2>::value_type, typename iterator_traits<_InputIterator1>::value_type>_LessThanOpConcept< typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_OutputIteratorConcept<_OutputIterator, __typeof__(__binary_op(*__first1,*__first2))>_OutputIteratorConcept<_OutputIterator, __typeof__(__unary_op(*__first))>_InputIteratorConcept<_InputIterator>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, _Tp>_EqualOpConcept< typename iterator_traits<_ForwardIterator>::value_type, _Tp>_UnaryPredicateConcept<_Predicate, typename iterator_traits<_InputIterator>::value_type>_EqualOpConcept< typename iterator_traits<_InputIterator>::value_type, _Tp>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_EqualityComparableConcept< typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_EqualOpConcept< typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_Mutable_RandomAccessIteratorConcept< _RandomAccessIterator>!__comp(__hi, __lo)!(__hi < __lo)_LessThanComparableConcept<_Tp>_BinaryPredicateConcept<_Compare, typename iterator_traits<_RandomAccessIterator>::value_type, typename iterator_traits<_RandomAccessIterator>::value_type>_LessThanComparableConcept< typename iterator_traits<_RandomAccessIterator>::value_type>_UnaryPredicateConcept<_Predicate, typename iterator_traits<_ForwardIterator>::value_type>_Mutable_ForwardIteratorConcept< _ForwardIterator>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator>::value_type>_EqualityComparableConcept< typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator, __typeof__(__gen())>_GeneratorConcept<_Generator, typename iterator_traits<_ForwardIterator>::value_type>_ConvertibleConcept<_Tp, typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_BidirectionalIterator>::value_type, typename iterator_traits<_BidirectionalIterator>::value_type>_BidirectionalIteratorConcept< _BidirectionalIterator>_LessThanComparableConcept< typename iterator_traits<_BidirectionalIterator>::value_type>_GLIBCXX_MOVE3(__first1, __last1, __result)std::move(__first1, __last1, __result)*__first1*__first2_Mutable_BidirectionalIteratorConcept< _BidirectionalIterator>__buffer_end*__last2++__last2*__last1_BinaryPredicateConcept<_Compare, _Tp, typename iterator_traits<_ForwardIterator>::value_type>_LessThanOpConcept< _Tp, typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_ForwardIterator>::value_type, _Tp>_LessThanOpConcept< typename iterator_traits<_ForwardIterator>::value_type, _Tp>__i + 1*__i*__next*__last_BinaryPredicateConcept<_Compare, _OutputValueType, _OutputValueType>_BinaryPredicateConcept<_Compare, _InputValueType, _OutputValueType>_ConvertibleConcept<_InputValueType, _OutputValueType>_LessThanComparableConcept<_OutputValueType>_LessThanOpConcept<_InputValueType, _OutputValueType>__result2__result1*__first_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_ForwardIterator>::value_type>__p + __n - 1__p + __n*(__p + __n - 1)__p + 1*__p_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_BidirectionalIterator>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_InputIterator>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator2, typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator1, typename iterator_traits<_InputIterator>::value_type>/* _STL_ALGO_H *//// Take a random sample from a population.// The loop above is otherwise equivalent to this one-at-a-time version:// wrapping issues.// I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without// two random numbers using a single distribution invocation:// If possible, we use __gen_two_uniform_ints to efficiently produce/// Selection sampling algorithm./// Reservoir sampling algorithm.// N2722 + DR 915./**
   *  @brief  Return the maximum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the largest value
   *  according to __comp.
  *//**
   *  @brief  Return the maximum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.
  *//**
   *  @brief  Return the minimum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the smallest value
   *  according to __comp.
  *//**
   *  @brief  Return the minimum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the smallest value.
  *//**
   *  @brief  Return the symmetric difference of two sorted ranges using
   *  comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other according to @p comp, that element is copied and the
   *  iterator advances.  If an element is contained in both ranges according
   *  to @p __comp, no elements are copied and both ranges advance.  The output
   *  range may not overlap either input range.
  *//**
   *  @brief  Return the symmetric difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other, that element is copied and the iterator advances.  If an
   *  element is contained in both ranges, no elements are copied and both
   *  ranges advance.  The output range may not overlap either input range.
  *//**
   *  @brief  Return the difference of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second according to @p __comp, that element
   *  is copied and the iterator advances.  If the current element of the
   *  second range is less, no element is copied and the iterator advances.
   *  If an element is contained in both ranges according to @p __comp, no
   *  elements are copied and both ranges advance.  The output range may not
   *  overlap either input range.
  *//**
   *  @brief Return the difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second, that element is copied and the
   *  iterator advances.  If the current element of the second range is less,
   *  the iterator advances, but no element is copied.  If an element is
   *  contained in both ranges, no elements are copied and both ranges
   *  advance.  The output range may not overlap either input range.
  *//**
   *  @brief Return the intersection of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that iterator advances.  If an element is
   *  contained in both ranges according to @p __comp, the element from the
   *  first range is copied and both ranges advance.  The output range may not
   *  overlap either input range.
  *//**
   *  @brief Return the intersection of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that iterator advances.  If an element is contained in both ranges, the
   *  element from the first range is copied and both ranges advance.  The
   *  output range may not overlap either input range.
  *//**
   *  @brief Return the union of two sorted ranges using a comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that element is copied and the iterator advanced.
   *  If an equivalent element according to @p __comp is contained in both
   *  ranges, the element from the first range is copied and both ranges
   *  advance.  The output range may not overlap either input range.
  *//**
   *  @brief Return the union of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that element is copied and the iterator advanced.  If an element is
   *  contained in both ranges, the element from the first range is copied and
   *  both ranges advance.  The output range may not overlap either input
   *  range.
  *//**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p __comp(*(i+1),*i) is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  *//**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  */// so the buffer only needs to fit half the range at once.// __stable_sort_adaptive sorts the range in two halves,/**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @param  __comp    A functor to use for comparisons.
   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
   *            + (__last2 - __first2).
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
   *            + (__last2 - __first2).
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
  *//**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  *//**
   *  @brief Sort the elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @e i in the range @p [__first,__last-1),  
   *  *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  *//**
   *  @brief Sort a sequence just enough to find a particular position
   *         using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that @p __comp(*j,*i) is false.
  *//**
   *  @brief Sort a sequence just enough to find a particular position.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that *j < *i is false.
  *//**
   *  @brief Sort the smallest elements of a sequence using a predicate
   *         for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
   *  are both false.
  *//**
   *  @brief Sort the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [first,last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
  *//**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [__first,middle) and false for each @p i
   *  in the range @p [middle,__last).
   *
   *  @p __pred must not modify its operand. @p partition() does not preserve
   *  the relative ordering of elements in each group, use
   *  @p stable_partition() if this is needed.
  */// C++11 || USE_DEPRECATED/**
   *  @brief Shuffle the elements of a sequence using a random number
   *         generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __rand    The RNG functor or function.
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
   *  provide a random distribution. Calling @p __rand(N) for a positive
   *  integer @p N should return a randomly chosen integer from the
   *  range [0,N).
   *
   *  @deprecated
   *  Since C++14 `std::random_shuffle` is not part of the C++ standard.
   *  Use `std::shuffle` instead, which was introduced in C++11.
  */// XXX rand() % N is not uniformly distributed/**
   *  @brief Randomly shuffle the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  Nothing.
   *
   *  Reorder the elements in the range @p [__first,__last) using a random
   *  distribution, so that every possible ordering of the sequence is
   *  equally likely.
   *
   *  @deprecated
   *  Since C++14 `std::random_shuffle` is not part of the C++ standard.
   *  Use `std::shuffle` instead, which was introduced in C++11.
  */// concept requirements -- predicates checked later/**
   *  @brief Copy a sequence, removing consecutive values using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        An input iterator.
   *  @param  __last         An input iterator.
   *  @param  __result       An output iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements for which @p __binary_pred returns
   *  true.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
  *//**
   *  @brief Copy a sequence, removing consecutive duplicate values.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements that compare equal.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
   *  Assignable?
  */// "the type returned by a _Generator"// DR 426. search_n(), fill_n(), and generate_n() with negative n// DR 865. More algorithms that throw away information/**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __n      The length of the sequence.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   The end of the sequence, @p __first+__n
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__first+__n).
   *
   * If @p __n is negative, the function does nothing and returns @p __first.
  *//**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   generate() returns no value.
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__last).
  *//**
   *  @brief Replace each value in a sequence for which a predicate returns
   *         true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   replace_if() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
   *  is true then the assignment @c *i = @p __new_value is performed.
  *//**
   *  @brief Replace each occurrence of one value in a sequence with another
   *         value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   replace() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
  */// "the type returned by a _BinaryOperation"/**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */// "the type returned by a _UnaryOperation"/**
   *  @brief Perform an operation on a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A unary operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  *//** @brief Search a sequence using a Searcher object.
   *
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __searcher     A callable object.
   *  @return @p __searcher(__first,__last).first
  *//**
   *  @brief Search a sequence for a number of consecutive values using a
   *         predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __count        The number of consecutive values.
   *  @param  __val          The value to find.
   *  @param  __binary_pred  A binary predicate.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @p
   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
   *  @p [0,__count), or @p __last if no such iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p __count
   *  consecutive elements for which the predicate returns true.
  *//**
   *  @brief Search a sequence for a number of consecutive values.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __count  The number of consecutive values.
   *  @param  __val    The value to find.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
   *  each @c N in the range @p [0,__count), or @p __last if no such
   *  iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p count consecutive elements
   *  equal to @p __val.
  *//**
   *  @brief Search a sequence for a matching sub-sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1     A forward iterator.
   *  @param  __last1      A forward iterator.
   *  @param  __first2     A forward iterator.
   *  @param  __last2      A forward iterator.
   *  @param  __predicate  A binary predicate.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that
   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2), using @p __predicate to determine equality,
   *  and returns an iterator to the first element of the
   *  sub-sequence, or @p __last1 if no such iterator exists.
   *
   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
  *//**
   *  @brief Search a sequence for a matching sub-sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @param  __last2   A forward iterator.
   *  @return The first iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
   *  *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the first element
   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
   *  found.
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.
   *
   *  This means that the returned iterator @c i will be in the range
   *  @p [__first1,__last1-(__last2-__first2))
  *//**
   *  @brief Count the elements of a sequence for which a predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @p __pred(*i) is true.
  *//**
   *  @brief Count the number of copies of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be counted.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @c *i == @p __value
  *//**
   *  @brief Find two adjacent values in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first         A forward iterator.
   *  @param  __last          A forward iterator.
   *  @param  __binary_pred   A binary predicate.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that
   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
   *  exists.
  *//**
   *  @brief Find two adjacent values in a sequence that are equal.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
   *  or @p __last if no such iterator exists.
  *//**
   *  @brief  Find element from a set in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @param  __comp    Predicate to use.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
   *  such iterator exists.
   *

   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  *//**
   *  @brief  Find element from a set in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  *//**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
  *//**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    The value to find.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
  *//**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      A value convertible to an integer.
   *  @param  __f      A unary function object.
   *  @return   `__first+__n`
   *
   *  Applies the function object `__f` to each element in the range
   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
   *  If `__f` has a return value it is ignored.
  */// N.B. [alg.foreach] says std::move(f) but it's redundant./**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __f      A unary function object.
   *  @return   @p __f
   *
   *  Applies the function object @p __f to each element in the range
   *  @p [first,last).  @p __f must not modify the order of the sequence.
   *  If @p __f has a return value it is ignored.
  */// USE C99_STDINT// for two successive elements at a time:// using a single distribution invocation to produce swap positions// Now we know that __last - __i is even, so we do the rest in pairs,// do the first one up front:// means an uneven number of elements /to swap/, in which case we// Since we know the range isn't empty, an even number of elements// I.e. (__urngrange >= __urange * __urange) but without wrap issues./**
   *  @brief Shuffle the elements of a sequence using a uniform random
   *         number generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __g to
   *  provide random numbers.
  *//**
   *  @brief Generate two uniformly distributed integers using a
   *         single distribution invocation.
   *  @param  __b0    The upper bound for the first integer.
   *  @param  __b1    The upper bound for the second integer.
   *  @param  __g     A UniformRandomBitGenerator.
   *  @return  A pair (i, j) with i and j uniformly distributed
   *           over [0, __b0) and [0, __b1), respectively.
   *
   *  Requires: __b0 * __b1 <= __g.max() - __g.min().
   *
   *  Using uniform_int_distribution with a range that is very
   *  small relative to the range of the generator ends up wasting
   *  potentially expensively generated randomness, since
   *  uniform_int_distribution does not store leftover randomness
   *  between invocations.
   *
   *  If we know we want two integers in ranges that are sufficiently
   *  small, we can compose the ranges, use a single distribution
   *  invocation, and significantly reduce the waste.
  *//**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val   A value of arbitrary type.
   *  @param  __lo    A lower limit of arbitrary type.
   *  @param  __hi    An upper limit of arbitrary type.
   *  @param  __comp  A comparison functor.
   *  @retval `__lo` if `__comp(__val, __lo)`
   *  @retval `__hi` if `__comp(__hi, __val)`
   *  @retval `__val` otherwise.
   *  @pre `__comp(__hi, __lo)` is false.
   *//**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val  A value of arbitrary type.
   *  @param  __lo   A lower limit of arbitrary type.
   *  @param  __hi   An upper limit of arbitrary type.
   *  @retval `__lo` if `__val < __lo`
   *  @retval `__hi` if `__hi < __val`
   *  @retval `__val` otherwise.
   *  @pre `_Tp` is LessThanComparable and `(__hi < __lo)` is false.
   *//**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  *//**
   *  @brief  Checks whether a permutaion of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, begin) returns true;
   *          otherwise, returns false.
  */// We've seen this one before.// have the same elements in the same order.// Efficiently compare identical prefixes:  O(N) if sequences/**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in
   *          the range [__first2, __first2 + (__last1 - __first1)),
   *          beginning with ForwardIterator2 begin, such that
   *          equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  *//**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  *//**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  *//**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  *//**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  *//**
   *  @brief  Determines the end of a sorted sequence using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  *//**
   *  @brief  Determines the end of a sorted sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  *//**
   *  @brief  Determines whether the elements of a sequence are sorted
   *          according to a comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  True if the elements are sorted, false otherwise.
  *//**
   *  @brief  Determines whether the elements of a sequence are sorted.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  True if the elements are sorted, false otherwise.
  *//**
   *  @brief Copy a sequence, replacing each value for which a predicate
   *         returns true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p __result+(__last-__first).
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  @p [__result,__result+(__last-__first)) replacing elements for which
   *  @p __pred returns true with @p __new_value.
  *//**
   *  @brief Copy a sequence, replacing each element of one value with another
   *         value.
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the input range @p [__first,__last) to the
   *  output range @p [__result,__result+(__last-__first)) replacing elements
   *  equal to @p __old_value with @p __new_value.
  *//**
   *  @brief  Permute range into the previous @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the previous one of this set.  Returns true if there are
   *  more sequences to generate.  If the sequence is the smallest of the set,
   *  the largest is generated and false returned.
  *//**
   *  @brief  Permute range into the previous @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the previous one of this
   *  set.  Returns true if there are more sequences to generate.  If the
   *  sequence is the smallest of the set, the largest is generated and false
   *  returned.
  *//**
   *  @brief  Permute range into the next @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the next one of this set.  Returns true if there are more
   *  sequences to generate.  If the sequence is the largest of the set, the
   *  smallest is generated and false returned.
  *//**
   *  @brief  Permute range into the next @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the next one of this set.
   *  Returns true if there are more sequences to generate.  If the sequence
   *  is the largest of the set, the smallest is generated and false returned.
  */// stable_sort/**
   *  @brief Determines whether all elements of a sequence exists in a range
   *  using comparison.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @param  __comp    Comparison function to use.
   *  @return True if each element in [__first2,__last2) is contained
   *  in order within [__first1,__last1) according to comp.  False
   *  otherwise.  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1),
   *  using comp to decide.  The iterators over each range only move
   *  forward, so this is a linear algorithm.  If an element in
   *  [__first2,__last2) is not found before the search iterator
   *  reaches @p __last2, false is returned.
  *//**
   *  @brief Determines whether all elements of a sequence exists in a range.
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @return  True if each element in [__first2,__last2) is contained in order
   *  within [__first1,__last1).  False otherwise.
   *  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1).
   *  The iterators over each range only move forward, so this is a
   *  linear algorithm.  If an element in [__first2,__last2) is not
   *  found before the search iterator reaches @p __last2, false is
   *  returned.
  */// ranges are sorted.// that their input ranges are sorted and the postcondition that their output// set_symmetric_difference.  All of these algorithms have the precondition// Set algorithms: includes, set_union, set_intersection, set_difference,/// This is a helper function for the stable sorting routines./// This is a helper function for the __merge_sort_loop routines./**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [middle,last), and puts the result in [__first,__last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [__middle,__last), and puts the result in [__first,__last).  The
   *  output will be sorted.  The sort is @e stable, that is, for
   *  equivalent elements in the two ranges, elements from the first
   *  range will always come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
  */// [first,middle) and [middle,last).// __merge_adaptive will use a buffer for the smaller of/// This is a helper function for the merge routines./// This is a helper function for the __merge_adaptive routines./**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return True if @p __val (or its equivalent) is in [@p
   *  __first,@p __last ].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
  *//**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
   *                   upper_bound(__first, __last, __val, __comp))
   *  @endcode
   *  but does not actually call those functions.
  *//**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val),
   *                   upper_bound(__first, __last, __val))
   *  @endcode
   *  but does not actually call those functions.
  *//**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
  *//**
   *  @brief Finds the first position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return An iterator pointing to the first element <em>not less
   *           than</em> @p __val, or end() if every element is less
   *           than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */// lower_bound moved to stl_algobase.h// Place the nth largest element in its final position.// sort/// This is a helper function for the sort routine./// This is a helper function.../**
   *  @doctodo
   *  This controls some aspect of the sort routines.
  *//**
   *  @brief Copy the smallest elements of a sequence using a predicate for
   *         comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    Another input iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @param  __comp    A comparison functor.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  @p __comp(*j,*i) is false.
   *  The value returned is @p __result_first+N.
  *//**
   *  @brief Copy the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p __result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  *j<*i is false.
   *  The value returned is @p __result_first+N.
  *//// This is a helper function for the sort routines./**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence, preserving relative ordering.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  Performs the same function as @p partition() with the additional
   *  guarantee that the relative ordering of elements in each group is
   *  preserved, so any two elements @p x and @p y in the range
   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
   *  relative ordering after calling @p stable_partition().
  */// function's preconditions.// Advance past true-predicate values to satisfy this// This ensures that we only call __pred once per element.// move that element to the buffer before starting the loop.// The precondition guarantees that !__pred(__first), so/// move-assign an element onto itself./// !__pred(__first) allows us to guarantee that we don't////// and __len == distance(__first, __last)./// Requires __first != __last and !__pred(__first)/**
   *  @brief Copy a sequence, rotating its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements of the range @p [__first,__last) to the
   *  range beginning at @result, rotating the copied elements by 
   *  @p (__middle-__first) positions so that the element at @p __middle
   *  is moved to @p __result, the element at @p __middle+1 is moved
   *  to @p __result+1 and so on for each element in the range @p
   *  [__first,__last).
   *
   *  Performs 
   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */// namespace _V2/**
   *  @brief Rotate the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  first + (last - middle).
   *
   *  Rotates the elements of the range @p [__first,__last) by 
   *  @p (__middle - __first) positions so that the element at @p __middle
   *  is moved to @p __first, the element at @p __middle+1 is moved to
   *  @p __first+1 and so on for each element in the range
   *  @p [__first,__last).
   *
   *  This effectively swaps the ranges @p [__first,__middle) and
   *  @p [__middle,__last).
   *
   *  Performs
   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */// DR 488. rotate throws away useful information/// This is a helper function for the rotate algorithm./**
   *  This is a helper function for the rotate algorithm specialized on RAIs.
   *  It returns the greatest common divisor of two integer values.
  *//**
   *  @brief Copy a sequence, reversing its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A bidirectional iterator.
   *  @param  __last    A bidirectional iterator.
   *  @param  __result  An output iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements in the range @p [__first,__last) to the
   *  range @p [__result,__result+(__last-__first)) such that the
   *  order of the elements is reversed.  For every @c i such that @p
   *  0<=i<=(__last-__first), @p reverse_copy() performs the
   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
   *  The ranges @p [__first,__last) and @p
   *  [__result,__result+(__last-__first)) must not overlap.
  *//**
   *  @brief Reverse a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @return   reverse() returns no value.
   *
   *  Reverses the order of the elements in the range @p [__first,__last),
   *  so that the first element becomes the last etc.
   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
   *  swaps @p *(__first+i) and @p *(__last-(i+1))
  *//**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for random access iterators.
  *//**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for bidirectional iterators.
  */// concept requirements -- iterators already checked/**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and forward iterator as result.
  *//**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and output iterator as result.
  *//**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for forward iterators and output iterator as result.
  *//**
   *  @brief Remove consecutive values from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values for which @p __binary_pred returns true.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Remove consecutive duplicate values from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values that compare equal.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */// Do the real copy work.// Skip the beginning, if already unique./**
   *  @brief Remove elements from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __pred   A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements for which @p __pred returns true are removed from the range
   *  @p [__first,__last).
   *
   *  remove_if() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Remove elements from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements equal to @p __value are removed from the range
   *  @p [__first,__last).
   *
   *  remove() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Copy the elements of a sequence to separate output sequences
   *         depending on the truth value of a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __out_true   An output iterator.
   *  @param  __out_false  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   A pair designating the ends of the resulting sequences.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p out_true
   *  and each element for which @p __pred returns false to @p __out_false.
  *//**
   *  @brief Copies the range [first,first+n) into [result,result+n).
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  result+n.
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
  *//**
   *  @brief Copy the elements of a sequence for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p __result.
   *
   *  copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  *//**
   *  @brief Copy a sequence, removing elements for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns false to the range beginning at @p __result.
   *
   *  remove_copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  *//**
   *  @brief Copy a sequence, removing elements of a given value.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __value   The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) not equal
   *  to @p __value to the range beginning at @p __result.
   *  remove_copy() is stable, so the relative order of elements that
   *  are copied is unchanged.
  */// A specific debug-mode test will be necessary.../**
   *  @brief  Find the partition point of a partitioned range.
   *  @ingroup mutating_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __pred    A predicate.
   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
   *           and @p none_of(mid, __last, __pred) are both true.
  *//**
   *  @brief  Checks whether the sequence is partitioned.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
   *  i.e. if all elements that satisfy @p __pred appear before those that
   *  do not.
  *//**
   *  @brief  Find the first element in a sequence for which a
   *          predicate is false.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
  *//**
   *  @brief  Checks that a predicate is true for at least one element
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if an element exists in the range @p
   *  [__first,__last) such that @p __pred is true, and false
   *  otherwise.
  *//**
   *  @brief  Checks that a predicate is false for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is false for each element in the range
   *  @p [__first,__last), and false otherwise.
  *//**
   *  @brief  Checks that a predicate is true for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is true for each element in the range
   *  @p [__first,__last), and false otherwise.
  *//**
   *  @brief  Find last matching subsequence in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @param  __comp    The predicate to use.
   *  @return The last iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c
   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
   *  exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) using comp as a predicate and returns an
   *  iterator to the first element of the sub-sequence, or @p __last1
   *  if the sub-sequence is not found.  The sub-sequence will be the
   *  last such subsequence contained in [__first,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  *//**
   *  @brief  Find last matching subsequence in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @return   The last iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
   *  @p *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the __first
   *  element of the sub-sequence, or @p __last1 if the sub-sequence
   *  is not found.  The sub-sequence will be the last such
   *  subsequence contained in [__first1,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */// find_end for bidirectional iterators (much faster).// find_end for forward iterators.// Failure// Success// next possible match.// __first here is always pointing to one past the last element of// the main loop.../**
   *  This is an helper function for search_n overloaded for random access
   *  iterators.
  *//**
   *  This is an helper function for search_n overloaded for forward iterators.
  */// General case.// Test for a pattern of length 1.// Test for empty ranges/// iterator./// remaining range length instead of comparing against an end/// Like find_if_not(), but uses and updates a count of the/// Provided for stable_partition to use./// Swaps the median value of *__a, *__b and *__c under __comp to *__result// See concept_check.h for the __glibcxx_*_requires macros.// for rand// for _Temporary_buffer/** @file bits/stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Copyright (C) 2001-2022 Free Software Foundation, Inc.// Algorithm implementation -*- C++ -*-__unary_predvsprintf_ssprintf_slzham_yield_processorlzham_output_debug_stringlzham_debug_breaklzham_is_debugger_presentlzham_flush_buffered_printflzham_buffered_printfatomic_exchange_add(reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0atomic_add32__sync_add_and_fetch_8atomic_exchange32__sync_lock_test_and_set_8atomic_decrement32__sync_sub_and_fetch_8atomic_increment32atomic_compare_exchange64volatile atomic64_tvolatile atomic64_t *(reinterpret_cast<ptr_bits_t>(pDest) & 7) == 0__sync_val_compare_and_swap_8atomic_compare_exchange32atomic64_tatomic32_tLZHAM_READ_BIG_ENDIAN_UINT32(p)__builtin_bswap32(*reinterpret_cast<const uint32*>(p))LZHAM_MEMORY_IMPORT_BARRIERLZHAM_MEMORY_EXPORT_BARRIERLZHAM_BUILTIN_EXPECT(c,v)__builtin_expect(c, v)LZHAM_BREAKPOINTasm("int $3");defined(__GNUC__) && LZHAM_PLATFORM_PCLZHAM_PLATFORM_X360LZHAM_USE_MSVC_INTRINSICSLZHAM_BIG_ENDIAN_CPULZHAM_USE_WIN32_ATOMIC_FUNCTIONSLZHAM_BUFFERED_PRINTFlzham_faillzham_assert// Atomic ops not supported - but try to do something reasonable. Assumes no threading at all.// Returns the original value.// Returns the resulting value.// Returns the resulting decremented value.// Returns the resulting incremented value.// LZHAM_USE_WIN32_ATOMIC_FUNCTIONS// This is used to read every DWORD from the input stream.// Note: It's very important that LZHAM_READ_BIG_ENDIAN_UINT32() is fast on the target platform.// TODO: Should use __sync_synchronize() on other platforms that support GCC.// Barriers shouldn't be necessary on x86/x64.// No implementation// actually in lzham_assert.cpp// File: lzham_platform.hexchangecomparandsizeOfBufferpExppFileline/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_assert.cpplzham_tracepFmtchar[512]sizeof(buf)%s(%u): Failure: "%s"
"%s(%u): Failure: \"%s\"\n"%s"%s"const char[3]%s(%u): Assertion failed: "%s"
"%s(%u): Assertion failed: \"%s\"\n"lzham_enable_fail_exceptionsg_exit_on_failureg_fail_exceptions// File: lzham_assert.cppenabledvector<Q>rel_ops<vector<T>>__enable_if_execution_policyiterator_traits<_ForwardIterator>pair<_ForwardIterator, _ForwardIterator>iterator_traits<_InputIterator>initializer_list<_Tp>pair<_FIter, _FIter>pair<_Tp, _Tp>pair<_OIter1, _OIter2>iterator_traits<_IIter>pair<_IIter1, _IIter2>__is_integer<_Tp>__is_arithmetic<_Tp>__is_arithmetic<_Up>__promote_2__numeric_constants<_Tp>is_nothrow_copy_constructible<_Iterator>_Safe_iterator<_Ite, _Seq, random_access_iterator_tag>_Ite_Seq__enable_if<__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>_Safe_iterator<_Ite, _Seq, _Cat>_Iter_comp_iter<_Compare>_Val_comp_iter<_Compare>_Iter_equals_val<_Value>_Value_Iter_equals_iter<_Iterator>_Iter_comp_to_val<_Compare, _Value>_Iter_negate<_Predicate>_Iter_pred<_Predicate>__is_move_iterator<_Iterator>reverse_iterator<_Iterator>reverse_iterator<_IteratorL>_IteratorLreverse_iterator<_IteratorR>_IteratorRinsert_iterator<_Container>_Container__normal_iterator<_IteratorL, _Container>__normal_iterator<_Iterator, _Container>move_iterator<_IteratorL>move_iterator<_IteratorR>move_iterator<_Iterator>is_void<_Elt>_Eltiterator_traits<_RandomAccessIterator>__iterator_traits<_Iterator, void>iterator_category__iterator_category_tpair<_U1, _U2>_U1_U2_Index_tuple<_Indexes1...>_Indexes1tuple<_Args2...>_Args2tuple<_Args1...>_Args1__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>pair<_T1, _T2>_T1_T2__is_swappable<_T2>__and_<__is_swappable<_T1>, __is_swappable<_T2>>enable_if<value, void>enable_if<<expression>, void>pair<__type, __type>pair<_Tp1, _Tp2>pair<_Tp, _Up>tuple_element<_Int, pair<_Tp1, _Tp2>>_Intpair<_Up, _Tp>tuple_size<_Tp>__enable_if_has_tuple_sizein_place_index_t<_Idx>in_place_type_t<_Tp>__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>__type_identity<_Tp>__type_identity<_Up>__type_identity<_Fn>__type_identity<_ArgTypes>__type_identity<_Ret>__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>__and_<is_array<_Tp>, __not_<extent<_Tp, 0U>>>_List<unsigned long, unsigned long long>_List_List<unsigned long, unsigned long long> &_List<unsigned long, unsigned long long> &&const _List<unsigned long, unsigned long long>const _List<unsigned long, unsigned long long> &__remove_pointer_helper<_Tp, type>__result_of_memobj<type, type>is_void<_From>__is_referenceable<_Tp, void>_List<_Uint, _UInts...>__make_unsigned_selector<wchar_t, false, true>__make_unsigned_selector__make_unsigned_selector<wchar_t, false, true> &__make_unsigned_selector<wchar_t, false, true> &&const __make_unsigned_selector<wchar_t, false, true>const __make_unsigned_selector<wchar_t, false, true> &__common_type_pack<_Rp...>__result_of_success<decltype((<expression>)), __invoke_memfun_ref>is_void<_Ret>__numeric_traits_integer<_Value>__numeric_traits_floating<float>__numeric_traits_floating<float> &__numeric_traits_floating<float> &&const __numeric_traits_floating<float>const __numeric_traits_floating<float> &__promote_4__if_type__traits_type__call_is_nothrow___strictest__is_nothrow_constructible_implbool_constantrank<_Tp>__is_destructible_safe<_Tp, value, value>_Tp(0.5L)std::numeric_limits<_Tp>::epsilon()1000.0_Tp(1000)1.084202172485504434e-16_Tp(1000) * __epsstd::numeric_limits<_Tp>::max()_Tp(1)-1.0-_Tp(1)_Tp(0)__riemann_zeta_sum"Bad argument in zeta sum."Bad argument in zeta sum.__N("Bad argument in zeta sum.")max_iter__zeta__bessel_jnstd::numeric_limits<_Tp>::infinity()__fp_minstd::numeric_limits<_Tp>::min()15000 15000__x_min_Tp(2)__nl1.51.5L_Tp(1.5L)__mu__mu2__xi__xi2__isign__h__del"Argument x too large in __bessel_jn; " "try asymptotic expansion."Argument x too large in __bessel_jn; try asymptotic expansion.const char[63]char[63]__N("Argument x too large in __bessel_jn; "
                                       "try asymptotic expansion.")__Jnul__Jpnul__Jnul1__Jpnu1__Jnutemp__Nmu__Nnu1__Npmu__Jmu"Bessel y series failed to converge " "in __bessel_jn.""Lentz's method failed " "in __bessel_jn."__x2__pimu__e__fact2__gam1__gam2__gampl__gammi__ff__q__pimu2__fact3__del1Bessel y series failed to converge in __bessel_jn.__N("Bessel y series failed to converge "
                                           "in __bessel_jn.")_Tp(0.25L)__br__bi__cr__ci__den__dr__di__dlr__dli__temp__gam__nu__Jnu__Nnu__Jpnu__NpnuLentz's method failed in __bessel_jn.__N("Lentz's method failed "
                                           "in __bessel_jn.")__Nnutemp__bernoulli_seriesconst long double[28]long double[28]__num-0.5-_Tp(1) / _Tp(2)_Tp(-1)_Tp(1UL)-_Tp(1UL)_Tp(2UL)-_Tp(1UL) / _Tp(2UL)6UL6.0_Tp(6UL)0.16666666666666666667_Tp(1UL) / _Tp(6UL)0UL_Tp(0UL)30UL30.0_Tp(30UL)-0.033333333333333333335-_Tp(1UL) / _Tp(30UL)42UL42.0_Tp(42UL)0.023809523809523809523_Tp(1UL) / _Tp(42UL)5UL5.0_Tp(5UL)66UL66.0_Tp(66UL)0.075757575757575757578_Tp(5UL) / _Tp(66UL)691691UL691.0_Tp(691UL)-691.0-_Tp(691UL)2730UL2730.0_Tp(2730UL)-0.25311355311355311355-_Tp(691UL) / _Tp(2730UL)7UL7.0_Tp(7UL)1.1666666666666666666_Tp(7UL) / _Tp(6UL)36173617UL3617.0_Tp(3617UL)-3617.0-_Tp(3617UL)510UL510.0_Tp(510UL)-7.0921568627450980392-_Tp(3617UL) / _Tp(510UL)4386743867UL43867.0_Tp(43867UL)798798UL798.0_Tp(798UL)54.97117794486215539_Tp(43867UL) / _Tp(798UL)174611174611.0_Tp(174611)-174611.0-_Tp(174611)330330UL330.0_Tp(330UL)-529.12424242424242427-_Tp(174611) / _Tp(330UL)854513854513UL854513.0_Tp(854513UL)138UL138.0_Tp(138UL)6192.1231884057971016_Tp(854513UL) / _Tp(138UL)236364091236364091UL236364091.0_Tp(236364091UL)-236364091.0-_Tp(236364091UL)-86580.25311355311355-_Tp(236364091UL) / _Tp(2730UL)85531038553103UL8553103.0_Tp(8553103UL)1425517.1666666666666_Tp(8553103UL) / _Tp(6UL)setpayloadsigf64_Float64 *setpayloadf64__getpayloadf64const _Float64const _Float64 *getpayloadf64totalordermagf64totalorderf64__fminimum_mag_numf64fminimum_mag_numf64__fmaximum_mag_numf64fmaximum_mag_numf64__fminimum_magf64fminimum_magf64__fmaximum_magf64fmaximum_magf64__fminimum_numf64fminimum_numf64__fmaximum_numf64fmaximum_numf64__fminimumf64fminimumf64__fmaximumf64fmaximumf64__fminmagf64fminmagf64__fmaxmagf64fmaxmagf64canonicalizef64__ufromfpxf64ufromfpxf64__fromfpxf64fromfpxf64__ufromfpf64ufromfpf64__fromfpf64fromfpf64__roundevenf64roundevenf64__fmaf64fmaf64__fminf64fminf64__fmaxf64fmaxf64__fdimf64fdimf64__llroundf64llroundf64__lroundf64lroundf64__llrintf64llrintf64__lrintf64lrintf64__remquof64remquof64__truncf64truncf64__roundf64roundf64__nearbyintf64nearbyintf64__scalblnf64scalblnf64__llogbf64llogbf64__ilogbf64ilogbf64__scalbnf64scalbnf64__remainderf64remainderf64__nextupf64nextupf64__nextdownf64nextdownf64__nextafterf64nextafterf64__rintf64rintf64__lgammaf64_rlgammaf64_r__tgammaf64tgammaf64__lgammaf64lgammaf64__erfcf64erfcf64__erff64erff64__ynf64ynf64__y1f64y1f64__y0f64y0f64__jnf64jnf64__j1f64j1f64__j0f64j0f64__nanf64nanf64__copysignf64copysignf64__fmodf64fmodf64__floorf64floorf64__fabsf64fabsf64__ceilf64ceilf64__cbrtf64cbrtf64__hypotf64hypotf64__sqrtf64sqrtf64__powf64powf64__log2f64log2f64__exp2f64exp2f64__logbf64logbf64__log1pf64log1pf64__expm1f64expm1f64__exp10f64exp10f64__modff64modff64__log10f64log10f64__logf64logf64__ldexpf64ldexpf64__frexpf64frexpf64__expf64expf64__atanhf64atanhf64__asinhf64asinhf64__acoshf64acoshf64__sincosf64sincosf64__tanhf64tanhf64__sinhf64sinhf64__coshf64coshf64__tanf64tanf64__sinf64sinf64__cosf64cosf64__atan2f64atan2f64__atanf64atanf64__asinf64asinf64__acosf64acosf64setpayloadsig(_Mdouble_ *__x, _Mdouble_ __payload)(_Float64 *__x, _Float64 __payload)setpayloadgetpayload(const _Mdouble_ *__x)(const _Float64 *__x)__CONCAT(__,getpayload)__getpayloadtotalordermag(const _Mdouble_ *__x, const _Mdouble_ *__y)(const _Float64 *__x, const _Float64 *__y)totalorderfminimum_mag_num(_Float64 __x, _Float64 __y)__CONCAT(__,fminimum_mag_num)__fminimum_mag_numfmaximum_mag_num__CONCAT(__,fmaximum_mag_num)__fmaximum_mag_numfminimum_mag__CONCAT(__,fminimum_mag)__fminimum_magfmaximum_mag__CONCAT(__,fmaximum_mag)__fmaximum_magfminimum_num__CONCAT(__,fminimum_num)__fminimum_numfmaximum_num__CONCAT(__,fmaximum_num)__fmaximum_numfminimum__CONCAT(__,fminimum)__fminimumfmaximum__CONCAT(__,fmaximum)__fmaximumfminmag__CONCAT(__,fminmag)__fminmagfmaxmag__CONCAT(__,fmaxmag)__fmaxmagcanonicalize(_Mdouble_ *__cx, const _Mdouble_ *__x)(_Float64 *__cx, const _Float64 *__x)ufromfpx(_Mdouble_ __x, int __round, unsigned int __width)(_Float64 __x, int __round, unsigned int __width)__CONCAT(__,ufromfpx)__ufromfpxfromfpx__CONCAT(__,fromfpx)__fromfpxufromfp__CONCAT(__,ufromfp)__ufromfpfromfp__CONCAT(__,fromfp)__fromfproundeven(_Float64 __x)__CONCAT(__,roundeven)__roundeven(_Float64 __x, _Float64 __y, _Float64 __z)(_Float64 __x, _Float64 __y, int *__quo)(_Float64 __x, long int __n)llogb__CONCAT(__,llogb)__llogb(_Float64 __x, int __n)nextup__CONCAT(__,nextup)__nextupnextdown__CONCAT(__,nextdown)__nextdown(_Float64, int *__signgamp)(_Float64)__payload__cx__width(int, _Float64)exp10__CONCAT(__,exp10)__exp10(_Float64 __x, _Float64 *__iptr)(_Float64 __x, int __exponent)(_Float64 __x, int *__exponent)sincos(_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx)(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx)__CONCAT(__,sincos)__sincos(_Float64 __y, _Float64 __x)__MATH_PRECNAME (sincos, )__MATH_PRECNAME (exp10, )__sinx__cosxsetpayloadsigf32x_Float32x *setpayloadf32x__getpayloadf32xconst _Float32xconst _Float32x *getpayloadf32xtotalordermagf32xtotalorderf32x__fminimum_mag_numf32xfminimum_mag_numf32x__fmaximum_mag_numf32xfmaximum_mag_numf32x__fminimum_magf32xfminimum_magf32x__fmaximum_magf32xfmaximum_magf32x__fminimum_numf32xfminimum_numf32x__fmaximum_numf32xfmaximum_numf32x__fminimumf32xfminimumf32x__fmaximumf32xfmaximumf32x__fminmagf32xfminmagf32x__fmaxmagf32xfmaxmagf32xcanonicalizef32x__ufromfpxf32xufromfpxf32x__fromfpxf32xfromfpxf32x__ufromfpf32xufromfpf32x__fromfpf32xfromfpf32x__roundevenf32xroundevenf32x__fmaf32xfmaf32x__fminf32xfminf32x__fmaxf32xfmaxf32x__fdimf32xfdimf32x__llroundf32xllroundf32x__lroundf32xlroundf32x__llrintf32xllrintf32x__lrintf32xlrintf32x__remquof32xremquof32x__truncf32xtruncf32x__roundf32xroundf32x__nearbyintf32xnearbyintf32x__scalblnf32xscalblnf32x__llogbf32xllogbf32x__ilogbf32xilogbf32x__scalbnf32xscalbnf32x__remainderf32xremainderf32x__nextupf32xnextupf32x__nextdownf32xnextdownf32x__nextafterf32xnextafterf32x__rintf32xrintf32x__lgammaf32x_rlgammaf32x_r__tgammaf32xtgammaf32x__lgammaf32xlgammaf32x__erfcf32xerfcf32x__erff32xerff32x__ynf32xynf32x__y1f32xy1f32x__y0f32xy0f32x__jnf32xjnf32x__j1f32xj1f32x__j0f32xj0f32x__nanf32xnanf32x__copysignf32xcopysignf32x__fmodf32xfmodf32x__floorf32xfloorf32x__fabsf32xfabsf32x__ceilf32xceilf32x__cbrtf32xcbrtf32x__hypotf32xhypotf32x__sqrtf32xsqrtf32x__powf32xpowf32x__log2f32xlog2f32x__exp2f32xexp2f32x__logbf32xlogbf32x__log1pf32xlog1pf32x__expm1f32xexpm1f32x__exp10f32xexp10f32x__modff32xmodff32x__log10f32xlog10f32x__logf32xlogf32x__ldexpf32xldexpf32x__frexpf32xfrexpf32x__expf32xexpf32x__atanhf32xatanhf32x__asinhf32xasinhf32x__acoshf32xacoshf32x__sincosf32xsincosf32x__tanhf32xtanhf32x__sinhf32xsinhf32x__coshf32xcoshf32x__tanf32xtanf32x__sinf32xsinf32x__cosf32xcosf32x__atan2f32xatan2f32x__atanf32xatanf32x__asinf32xasinf32x__acosf32xacosf32x(_Float32x *__x, _Float32x __payload)(const _Float32x *__x)(const _Float32x *__x, const _Float32x *__y)(_Float32x __x, _Float32x __y)(_Float32x *__cx, const _Float32x *__x)(_Float32x __x, int __round, unsigned int __width)(_Float32x __x)(_Float32x __x, _Float32x __y, _Float32x __z)(_Float32x __x, _Float32x __y, int *__quo)(_Float32x __x, long int __n)(_Float32x __x, int __n)(_Float32x, int *__signgamp)(_Float32x)(int, _Float32x)(_Float32x __x, _Float32x *__iptr)(_Float32x __x, int __exponent)(_Float32x __x, int *__exponent)(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx)(_Float32x __y, _Float32x __x)f32xsubf64f32xsqrtf64f32xmulf64f32xfmaf64f32xdivf64f32xaddf64__MATHCALL_NAME (sub)__MATHCALL_REDIR_NAME (sub)sub__MATHCALL_NAME (sqrt)__MATHCALL_REDIR_NAME2 (sqrt)__MATHCALL_NAME (mul)__MATHCALL_REDIR_NAME (mul)mul__MATHCALL_NAME (fma)__MATHCALL_REDIR_NAME2 (fma)__MATHCALL_NAME (div)__MATHCALL_REDIR_NAME (div)__MATHCALL_NAME (add)__MATHCALL_REDIR_NAME (add)/* Subtract.  *//* Square root.  *//* Multiply.  *//* Fused multiply-add.  *//* Divide.  *//* Add.  *//* Declare functions returning a narrower type.
   Copyright (C) 2018-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */f64xsubf128f64xsqrtf128f64xmulf128f64xfmaf128f64xdivf128f64xaddf128<bits/iscanonical.h><bits/mathcalls-narrow.h>iszero__iseqsig_type<__float128> &__iseqsig_type<__float128> &&const __iseqsig_type<__float128>const __iseqsig_type<__float128> &__call__iseqsig_type<long double> &__iseqsig_type<long double> &&const __iseqsig_type<long double>const __iseqsig_type<long double> &__iseqsig_type<double> &__iseqsig_type<double> &&const __iseqsig_type<double>const __iseqsig_type<double> &__iseqsig_type<float> &__iseqsig_type<float> &&const __iseqsig_type<float>const __iseqsig_type<float> &__iseqsig_type<__float128>__iseqsig_type<long double>__iseqsig_type<double>__iseqsig_type<float>__iseqsig_type<<unnamed>>FP_INT_UPWARDFP_INT_DOWNWARDFP_INT_TOWARDZEROFP_INT_TONEARESTFROMZEROFP_INT_TONEAREST__MATH_EVAL_FMT2(x,y)((x) + (y) + 0.0f)M_SQRT1_2f64x__f64x (0.707106781186547524400844362104849039)M_SQRT2f64x__f64x (1.414213562373095048801688724209698079)M_2_SQRTPIf64x__f64x (1.128379167095512573896158903121545172)M_2_PIf64x__f64x (0.636619772367581343075535053490057448)M_1_PIf64x__f64x (0.318309886183790671537767526745028724)M_PI_4f64x__f64x (0.785398163397448309615660845819875721)M_PI_2f64x__f64x (1.570796326794896619231321691639751442)M_PIf64x__f64x (3.141592653589793238462643383279502884)M_LN10f64x__f64x (2.302585092994045684017991454684364208)M_LN2f64x__f64x (0.693147180559945309417232121458176568)M_LOG10Ef64x__f64x (0.434294481903251827651128918916605082)M_LOG2Ef64x__f64x (1.442695040888963407359924681001892137)M_Ef64x__f64x (2.718281828459045235360287471352662498)M_SQRT1_2f32x__f32x (0.707106781186547524400844362104849039)M_SQRT2f32x__f32x (1.414213562373095048801688724209698079)M_2_SQRTPIf32x__f32x (1.128379167095512573896158903121545172)M_2_PIf32x__f32x (0.636619772367581343075535053490057448)M_1_PIf32x__f32x (0.318309886183790671537767526745028724)M_PI_4f32x__f32x (0.785398163397448309615660845819875721)M_PI_2f32x__f32x (1.570796326794896619231321691639751442)M_PIf32x__f32x (3.141592653589793238462643383279502884)M_LN10f32x__f32x (2.302585092994045684017991454684364208)M_LN2f32x__f32x (0.693147180559945309417232121458176568)M_LOG10Ef32x__f32x (0.434294481903251827651128918916605082)M_LOG2Ef32x__f32x (1.442695040888963407359924681001892137)M_Ef32x__f32x (2.718281828459045235360287471352662498)M_SQRT1_2f128__f128 (0.707106781186547524400844362104849039)M_SQRT2f128__f128 (1.414213562373095048801688724209698079)M_2_SQRTPIf128__f128 (1.128379167095512573896158903121545172)M_2_PIf128__f128 (0.636619772367581343075535053490057448)M_1_PIf128__f128 (0.318309886183790671537767526745028724)M_PI_4f128__f128 (0.785398163397448309615660845819875721)M_PI_2f128__f128 (1.570796326794896619231321691639751442)M_PIf128__f128 (3.141592653589793238462643383279502884)M_LN10f128__f128 (2.302585092994045684017991454684364208)M_LN2f128__f128 (0.693147180559945309417232121458176568)M_LOG10Ef128__f128 (0.434294481903251827651128918916605082)M_LOG2Ef128__f128 (1.442695040888963407359924681001892137)M_Ef128__f128 (2.718281828459045235360287471352662498)M_SQRT1_2f64__f64 (0.707106781186547524400844362104849039)M_SQRT2f64__f64 (1.414213562373095048801688724209698079)M_2_SQRTPIf64__f64 (1.128379167095512573896158903121545172)M_2_PIf64__f64 (0.636619772367581343075535053490057448)M_1_PIf64__f64 (0.318309886183790671537767526745028724)M_PI_4f64__f64 (0.785398163397448309615660845819875721)M_PI_2f64__f64 (1.570796326794896619231321691639751442)M_PIf64__f64 (3.141592653589793238462643383279502884)M_LN10f64__f64 (2.302585092994045684017991454684364208)M_LN2f64__f64 (0.693147180559945309417232121458176568)M_LOG10Ef64__f64 (0.434294481903251827651128918916605082)M_LOG2Ef64__f64 (1.442695040888963407359924681001892137)M_Ef64__f64 (2.718281828459045235360287471352662498)M_SQRT1_2f32__f32 (0.707106781186547524400844362104849039)M_SQRT2f32__f32 (1.414213562373095048801688724209698079)M_2_SQRTPIf32__f32 (1.128379167095512573896158903121545172)M_2_PIf32__f32 (0.636619772367581343075535053490057448)M_1_PIf32__f32 (0.318309886183790671537767526745028724)M_PI_4f32__f32 (0.785398163397448309615660845819875721)M_PI_2f32__f32 (1.570796326794896619231321691639751442)M_PIf32__f32 (3.141592653589793238462643383279502884)M_LN10f32__f32 (2.302585092994045684017991454684364208)M_LN2f32__f32 (0.693147180559945309417232121458176568)M_LOG10Ef32__f32 (0.434294481903251827651128918916605082)M_LOG2Ef32__f32 (1.442695040888963407359924681001892137)M_Ef32__f32 (2.718281828459045235360287471352662498)M_SQRT1_2l0.707106781186547524400844362104849039LM_SQRT2l1.414213562373095048801688724209698079LM_2_SQRTPIl1.128379167095512573896158903121545172LM_2_PIl0.636619772367581343075535053490057448LM_1_PIl0.318309886183790671537767526745028724LM_PI_4l0.785398163397448309615660845819875721LM_PI_2l1.570796326794896619231321691639751442LM_PIl3.141592653589793238462643383279502884LM_LN10l2.302585092994045684017991454684364208LM_LN2l0.693147180559945309417232121458176568LM_LOG10El0.434294481903251827651128918916605082LM_LOG2El1.442695040888963407359924681001892137LM_El2.718281828459045235360287471352662498LM_SQRT1_2f0.70710678118654752440fM_SQRT2f1.41421356237309504880fM_2_SQRTPIf1.12837916709551257390fM_2_PIf0.63661977236758134308fM_1_PIf0.31830988618379067154fM_PI_4f0.78539816339744830962fM_PI_2f1.57079632679489661923fM_PIf3.14159265358979323846fM_LN10f2.30258509299404568402fM_LN2f0.69314718055994530942fM_LOG10Ef0.43429448190325182765fM_LOG2Ef1.4426950408889634074fM_Ef2.7182818284590452354fMAXFLOAT3.40282347e+38Fissubnormal(x)(fpclassify (x) == FP_SUBNORMAL)__builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), float), FUNC ## f ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), double), FUNC ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), long double), FUNC ## l ARGS, FUNC ## f128 ARGS)))__MATHCALL_NAME_Marg__Mret___MATHCALL_NAME(name)f64x ## name ## f128f64 ## name ## f128f64 ## name ## f64xf32x ## name ## f128f32x ## name ## f64xf32x ## name ## f64f32 ## name ## f128f32 ## name ## f64xf32 ## name ## f64f32 ## name ## f32xd ## name ## lf ## name ## lf ## nameFP_LLOGBNAN(-__FP_LONG_MAX - 1)FP_LLOGB0__FP_LONG_MAXSNANF64X(__builtin_nansf64x (""))SNANF32X(__builtin_nansf32x (""))SNANF128(__builtin_nansf128 (""))SNANF64(__builtin_nansf64 (""))SNANF32(__builtin_nansf32 (""))SNANL(__builtin_nansl (""))SNAN(__builtin_nans (""))SNANF(__builtin_nansf (""))HUGE_VAL_F64X(__builtin_huge_valf64x ())HUGE_VAL_F32X(__builtin_huge_valf32x ())HUGE_VAL_F128(__builtin_huge_valf128 ())HUGE_VAL_F64(__builtin_huge_valf64 ())HUGE_VAL_F32(__builtin_huge_valf32 ())<bits/move.h><debug/debug.h><bits/concept_check.h><bits/stl_iterator.h><bits/stl_iterator_base_funcs.h><ext/numeric_traits.h><bits/functexcept.h>__remove_if__count_if__find_if__mismatch__equal4__lg(int)sizeof(long long)(int)sizeof(long long) * __CHAR_BIT__(int)sizeof(long long) * __CHAR_BIT__ - 1(int)sizeof(long)(int)sizeof(long) * __CHAR_BIT__(int)sizeof(long) * __CHAR_BIT__ - 1__builtin_clzl(int)sizeof(int)(int)sizeof(int) * __CHAR_BIT__(int)sizeof(int) * __CHAR_BIT__  - 1__lower_bound__lexicographical_compare_auxconst _Safe_iterator<_Iter1, _Seq1, _Cat1>const _Safe_iterator<_Iter1, _Seq1, _Cat1> &_Safe_iterator<_Iter1, _Seq1, _Cat1> &const _Safe_iterator<_Iter2, _Seq2, _Cat2>const _Safe_iterator<_Iter2, _Seq2, _Cat2> &_Safe_iterator<_Iter2, _Seq2, _Cat2> &_Iter1_Seq1_Cat1_Iter2_Seq2_Cat2__lexicographical_compare_aux1_Ref1_Ptr1_Ref2_Ptr2_Tp1 *_Tp2 *__lexicographical_compare_impl__equal_auxconst _Safe_iterator<_II1, _Seq1, _Cat1>const _Safe_iterator<_II1, _Seq1, _Cat1> &_Safe_iterator<_II1, _Seq1, _Cat1> &const _Safe_iterator<_II2, _Seq2, _Cat2>const _Safe_iterator<_II2, _Seq2, _Cat2> &_Safe_iterator<_II2, _Seq2, _Cat2> &__equal_aux1_Ref_Ptr__fill_n_aconst _Safe_iterator<_Ite, _Seq, _Cat>const _Safe_iterator<_Ite, _Seq, _Cat> &_Safe_iterator<_Ite, _Seq, _Cat> &__fill_n_a1__size_to_integer__fill_a_FIte__fill_a1const _Deque_iterator<_Tp, _Tp &, _Tp *>const _Deque_iterator<_Tp, _Tp &, _Tp *> &_Deque_iterator<_Tp, _Tp &, _Tp *> &_VTpconst _VTpconst _VTp &_VTp &_Contmove_backward__copy_move_backward_aconst _Safe_iterator<_IIte, _ISeq, _ICat>const _Safe_iterator<_IIte, _ISeq, _ICat> &_Safe_iterator<_IIte, _ISeq, _ICat> &const _Safe_iterator<_OIte, _OSeq, _OCat>const _Safe_iterator<_OIte, _OSeq, _OCat> &_Safe_iterator<_OIte, _OSeq, _OCat> &_IsMove_IIte_ISeq_ICat_OIte_OSeq_OCat__copy_move_backward_a1_ITp_IRef_IPtr_OTp__copy_move_backward_a2__copy_n_a_CharT_CharT *__copy_move_a__copy_move_a1__copy_move_a2const _CharTconst _CharT *__niter_wrapconst _Iteratorconst _Iterator &_Iterator &__niter_baseconst _Safe_iterator<_Ite, _Seq, random_access_iterator_tag>const _Safe_iterator<_Ite, _Seq, random_access_iterator_tag> &_Safe_iterator<_Ite, _Seq, random_access_iterator_tag> &__memcmpconst _Upconst _Up *__lexicographical_compare<true> &__lexicographical_compare<true> &&const __lexicographical_compare<true>const __lexicographical_compare<true> &__3way__lc__lc_rai<random_access_iterator_tag, random_access_iterator_tag> &__lc_rai<random_access_iterator_tag, random_access_iterator_tag> &&const __lc_rai<random_access_iterator_tag, random_access_iterator_tag>const __lc_rai<random_access_iterator_tag, random_access_iterator_tag> &__cnd2_RAI_RAI1__newlast1_RAI2__equal<true> &__equal<true> &&const __equal<true>const __equal<true> &__copy_move_b__copy_move_backward<true, false, random_access_iterator_tag> &__copy_move_backward<true, false, random_access_iterator_tag> &&const __copy_move_backward<true, false, random_access_iterator_tag>const __copy_move_backward<true, false, random_access_iterator_tag> &__copy_move_backward<false, false, random_access_iterator_tag> &__copy_move_backward<false, false, random_access_iterator_tag> &&const __copy_move_backward<false, false, random_access_iterator_tag>const __copy_move_backward<false, false, random_access_iterator_tag> &__copy_m__copy_move<true, false, random_access_iterator_tag> &__copy_move<true, false, random_access_iterator_tag> &&const __copy_move<true, false, random_access_iterator_tag>const __copy_move<true, false, random_access_iterator_tag> &__copy_move<false, false, random_access_iterator_tag> &__copy_move<false, false, random_access_iterator_tag> &&const __copy_move<false, false, random_access_iterator_tag>const __copy_move<false, false, random_access_iterator_tag> &__lexicographical_compare<true>__lexicographical_compare<_BoolType>_BoolType__lc_rai<random_access_iterator_tag, random_access_iterator_tag>__lc_rai<<unnamed>, <unnamed>>__equal<true>__equal<_BoolType>__copy_move_backward<_IsMove, true, random_access_iterator_tag>__copy_move_backward<true, false, random_access_iterator_tag>__copy_move_backward<false, false, random_access_iterator_tag>__copy_move_backward<true, false, _Category>_Category__copy_move_backward<_IsMove, _IsSimple, _Category>_IsSimpleostreambuf_iterator<_CharT, _Traits>_Traitsistreambuf_iterator<_CharT, _Traits>char_traits<_CharT>_Bit_iterator_Deque_iterator<_Tp, _Ref, _Ptr>__copy_move<_IsMove, true, random_access_iterator_tag>__copy_move<true, false, random_access_iterator_tag>__copy_move<false, false, random_access_iterator_tag>__copy_move<true, false, _Category>__copy_move<_IsMove, _IsSimple, _Category>std::is_nothrow_copy_constructible<_Iterator>::value__cpp_lib_robust_nonmodifying_seq_ops_GLIBCXX_MOVE_BACKWARD3(_Tp,_Up,_Vp)std::move_backward(_Tp, _Up, _Vp)_GLIBCXX_MOVE3(_Tp,_Up,_Vp)std::move(_Tp, _Up, _Vp)_STL_ALGOBASE_H__cpp_lib_is_constant_evaluated__cplusplus > 201703L && __cpp_lib_concepts__cpp_lib_three_way_comparison_EqualOpConcept< typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_InputIteratorConcept<_II2>_InputIteratorConcept<_II1>_LessThanOpConcept<_ValueType2, _ValueType1>_LessThanOpConcept<_ValueType1, _ValueType2>_InputIteratorConcept<_IIter2>_InputIteratorConcept<_IIter1>_EqualOpConcept< typename iterator_traits<_II1>::value_type, typename iterator_traits<_II2>::value_type>_OutputIteratorConcept<_OI, const _Tp&>_OutputIteratorConcept<_BI2, typename iterator_traits<_BI1>::value_type&&>_Mutable_BidirectionalIteratorConcept<_BI2>_BidirectionalIteratorConcept<_BI1>_OutputIteratorConcept<_BI2, typename iterator_traits<_BI1>::reference>_OutputIteratorConcept<_OI, typename iterator_traits<_II>::value_type&&>_InputIteratorConcept<_II>_OutputIteratorConcept<_OI, typename iterator_traits<_II>::reference>_Mutable_ForwardIteratorConcept< _ForwardIterator2>_Mutable_ForwardIteratorConcept< _ForwardIterator1>// come in too if requested.// of getting the base algorithms. So, make sure that parallel bits// NB: This file is included within many other C++ includes, as a way/**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __first2 + (__last1 - __first1)), beginning with
   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
   *          returns true; otherwise, returns false.
  */// rest of the list.// Establish __last2 assuming equal ranges by iterating over the// FALLTHRU/// This is an overload used by find algos for the RAI case./// This is an overload used by find algos for the Input Iterator case./**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */// three_way_comparison// See PR 94006/**
   *  @brief Performs dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The comparison category that `__comp(*__first1, *__first2)`
   *		returns.
  */// (or x if they compare equal) and the result of the comparison x <=> y.// Return a struct with two members, initialized to the smaller of x and y// or std::byte, suitable for comparison by memcmp.// Iter points to a contiguous range of unsigned narrow character type/**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   A boolean true or false.
   *
   *  The same as the four-parameter @c lexicographical_compare, but uses the
   *  comp parameter instead of @c <.
  *//**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  <em>Returns true if the sequence of elements defined by the range
   *  [first1,last1) is lexicographically less than the sequence of elements
   *  defined by the range [first2,last2).  Returns false otherwise.</em>
   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
   *  then this is an inline call to @c memcmp.
  *//**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *//**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */// 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.// 4-iterator version of std::equal<It1, It2> for use in C++11./**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *//**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *///  Precondition: __n > 0./// This is a helper function for the sort routines and for random.tcc./**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @a val, or end() if every element is less than
   *                  @a val.
   *  @ingroup binary_search_algorithms
  */// volatile data.// so __is_byte<T> could be true, but we can't use memcmp with// For C++20 iterator_traits<volatile T*>::value_type is non-volatile/**
   *  @brief Fills the range [first,first+n) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  An output iterator.
   *  @param  __n      The count of copies to perform.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   The iterator at first+n.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
   *
   *  If @p __n is negative, the function does nothing.
  */// Used by fill_n, generate_n, etc. to convert _Size to an integral type:/**
   *  @brief Fills the range [first,last) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   Nothing.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */// Specialization: for char types we can use memset./**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (last - first)
   *
   *  The function has the same effect as move, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use move instead.  Note
   *  that the start of the output range may overlap [first,last).
  *//**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (last - first)
   *
   *  The function has the same effect as copy, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */// trivial types can have deleted assignment/**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (last - first)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the move_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  *//**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (last - first)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */// NB: avoid including <iosfwd>, relatively large.// Helpers for streambuf iterators (either istream or ostream).// a for loop with an explicit count.// (2) If we're using random access iterators, then write the loop as// because the input and output ranges are permitted to overlap.)// calls to copy with memmove whenever possible.  (Memmove, not memcpy,// All of these auxiliary structs serve two purposes.  (1) Replace// No need to wrap, iterator already has the right type.// is only used to wrap random access iterators, like pointers).// __normal_iterator back again (this assumes that __normal_iterator// Reverse the __niter_base transformation to get a// remove the __normal_iterator wrapper. See copy, fill, ...// Fallback implementation of the function in bits/stl_iterator.h used to//return __comp(__a, __b) ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  *///return __comp(__b, __a) ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The lesser of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  *///return  __a < __b ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  *///return __b < __a ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  *//**
   *  @brief Swap the elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  */// 187. iter_swap underspecified/**
   *  @brief Swaps the contents of two iterators.
   *  @ingroup mutating_algorithms
   *  @param  __a  An iterator.
   *  @param  __b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */// C++03// when it's safe, i.e., the value_types are equal.// nutshell, we are partially implementing the resolution of DR 187,// See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a/*
   * A constexpr wrapper for __builtin_memcmp.
   * @param __num The number of elements of type _Tp (not bytes).
   */// For std::swap/** @file bits/stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Core algorithmic facilities -*- C++ -*-__it<tr1/special_function_util.h>__hurwitz_zeta__hurwitz_zeta_glob__glob__riemann_zetaconst _Tp[]__prime__num_primesconst _Tp[29]_Tp[29]__riemann_zeta_product__max_bincoeff__maxit__punt__sgn__bincoeff__riemann_zeta_glob__riemann_zeta_alt_GLIBCXX_TR1_RIEMANN_ZETA_TCC// _GLIBCXX_TR1_RIEMANN_ZETA_TCC/**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     *///  This only gets hit for x << 0.//  Max e exponent before overflow./**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     * 
     *   This functions uses the double sum that converges for s != 1
     *   and x > -1:
     *   @f[
     *     \zeta(x,s) = \frac{1}{s-1}
     *                \sum_{n=0}^{\infty} \frac{1}{n + 1}
     *                \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (x+k)^{-s}
     *   @f]
     *///  Global double sum or McLaurin?/**
     *   @brief  Return the Riemann zeta function @f$ \zeta(s) @f$.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} k^{-s} for s > 1
     *                 \frac{(2\pi)^s}{pi} sin(\frac{\pi s}{2})
     *                 \Gamma (1 - s) \zeta (1 - s) for s < 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           using the product over prime factors.
     *    \f[
     *      \zeta(s) = \Pi_{i=1}^\infty \frac{1}{1 - p_i^{-s}}
     *    \f]
     *    where @f$ {p_i} @f$ are the prime numbers.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  so use reflection.//  This series works until the binomial coefficient blows up/**
     *   @brief  Evaluate the Riemann zeta function by series for all s != 1.
     *           Convergence is great until largish negative numbers.
     *           Then the convergence of the > 0 sum gets better.
     *
     *   The series is:
     *    \f[
     *      \zeta(s) = \frac{1}{1-2^{1-s}}
     *                 \sum_{n=0}^{\infty} \frac{1}{2^{n+1}}
     *                 \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (k+1)^{-s}
     *    \f]
     *   Havil 2003, p. 206.
     *
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Evaluate the Riemann zeta function @f$ \zeta(s) @f$
     *           by an alternate series for s > 0.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  A user shouldn't get to this./**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           by summation for s > 1.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///       Princeton, 2003.//   (3) Gamma, Exploring Euler's Constant, Julian Havil,//       Dover Publications, New-York, Section 5, pp. 807-808.//       Ed. by Milton Abramowitz and Irene A. Stegun,/** @file tr1/riemann_zeta.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */cInitCRC32// File: lzham_checksum.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_checksum.cppconst lzham_uint32const lzham_uint32[16]const lzham_uint32 *ADLER_MOD65521blocklen5552s_crc324985365480x1db710649970730960x3b6e20c86517679800x26d930ac19941461920x76dc419018021954440x6b6b51f413035359600x4db2615813425339480x5005713c0xedb8832040275525800xf00f934436043908880xd6d6a3e834121778040xcb61b38c26070719200x9b64c2b022620290120x86d3d2d426850678960xa00ae27831833421080xbdbdf21c// http://www.geocities.com/malbrain/// See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": // Karl Malbrain's compact CRC-32, with pre and post conditioning. // Originally from the public domain stb.h header.// File: lzham_checksum.cpppair<_ForwardIterator1, _ForwardIterator2>pair<_Tp *, ptrdiff_t>__enable_if<__value, double>_Deque_iterator<_ITp, _IRef, _IPtr>_Iter_comp_val<_Compare>iterator<output_iterator_tag, void, void, void, void>iterator<output_iterator_tag, void, void, void, void> &iterator<output_iterator_tag, void, void, void, void> &&const iterator<output_iterator_tag, void, void, void, void>const iterator<output_iterator_tag, void, void, void, void> &front_insert_iterator<_Container>__normal_iterator<_IteratorR, _Container>__get_first_arg<_Ptr>__rebind<_Ptr, _Up, void>_List_const_iterator<_Tp>iterator_traits<_BidirectionalIterator>__pair_base<_T1, _T2>__is_swappable<_T1>__decay_and_strip__type_identity<_Functor>_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long> &_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long> &&const _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>const _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long> &is_array<_To>__or_<is_void<_From>, is_function<_To>, is_array<_To>>__not_<__is_tuple_like<_Tp>>__matchintegral_constant<bool, noexcept(<expression>)>__psi_asymp__xx__xp_G_fpos_t &_G_fpos_t &&const _G_fpos_tconst _G_fpos_t &_IO_FILE &_IO_FILE &&const _IO_FILEconst _IO_FILE &_IO_cookie_io_functions_t &_IO_cookie_io_functions_t &&const _IO_cookie_io_functions_tconst _IO_cookie_io_functions_t &cookie_io_functions_t_IO_cookie_io_functions_tcookie_close_function_tcookie_seek_function_tcookie_write_function_tcookie_read_function_tcookie_close_function_t *cookie_seek_function_t *cookie_write_function_t *cookie_read_function_t *__cookie_io_functions_t_defined/* Close file.  *//* Seek/tell file position.  *//* Write bytes.  *//* Read bytes.  *//* The structure with the cookie function pointers.
   The tag name of this struct is _IO_cookie_io_functions_t to
   preserve historic C++ mangled names for functions taking
   cookie_io_functions_t arguments.  That name should not be used in
   new code.  *//* Close COOKIE.  *//* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  *//* Write NBYTES bytes pointed to by BUF to COOKIE.  Write all NBYTES bytes
   unless there is an error.  Return number of bytes written.  If
   there is an error, return 0 and do not write anything.  If the file
   has been opened for append (__mode.__append set), then set the file
   pointer to the end of the file and then do the write; if not, just
   write at the current file pointer.  *//* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  *//* Functions to do I/O and file management for a stream.  */<bits/types/cookie_io_functions_t.h>obstack_vprintfobstack *obstack *__restrict__obstack_printfcuseridconst fpos64_tconst fpos64_t *fpos64_t *fpos64_t *__restrict__fputs_unlockedfgets_unlockedasprintf__asprintfvasprintffopencookiefcloseallrenameat2obstackfpos64_tRENAME_WHITEOUTRENAME_EXCHANGERENAME_NOREPLACE_PRINTF_NAN_LEN_MAXSEEK_HOLESEEK_DATA__obstack__args__magic_cookie__io_funcs__miter_base__is_memcmp_ordered_with<byte, byte, true> &__is_memcmp_ordered_with<byte, byte, true> &&const __is_memcmp_ordered_with<byte, byte, true>const __is_memcmp_ordered_with<byte, byte, true> &__is_byte<byte> &__is_byte<byte> &&const __is_byte<byte>const __is_byte<byte> &__is_byte<unsigned char> &__is_byte<unsigned char> &&const __is_byte<unsigned char>const __is_byte<unsigned char> &__is_byte<signed char> &__is_byte<signed char> &&const __is_byte<signed char>const __is_byte<signed char> &__is_byte<char> &__is_byte<char> &&const __is_byte<char>const __is_byte<char> &__is_char<wchar_t> &__is_char<wchar_t> &&const __is_char<wchar_t>const __is_char<wchar_t> &__is_char<char> &__is_char<char> &&const __is_char<char>const __is_char<char> &__is_floating<long double> &__is_floating<long double> &&const __is_floating<long double>const __is_floating<long double> &__is_floating<double> &__is_floating<double> &&const __is_floating<double>const __is_floating<double> &__is_floating<float> &__is_floating<float> &&const __is_floating<float>const __is_floating<float> &__is_integer<__uint128_t> &__is_integer<__uint128_t> &&const __is_integer<__uint128_t>const __is_integer<__uint128_t> &__is_integer<__int128_t> &__is_integer<__int128_t> &&const __is_integer<__int128_t>const __is_integer<__int128_t> &__is_integer<unsigned long long> &__is_integer<unsigned long long> &&const __is_integer<unsigned long long>const __is_integer<unsigned long long> &__is_integer<long long> &__is_integer<long long> &&const __is_integer<long long>const __is_integer<long long> &__is_integer<unsigned long> &__is_integer<unsigned long> &&const __is_integer<unsigned long>const __is_integer<unsigned long> &__is_integer<long> &__is_integer<long> &&const __is_integer<long>const __is_integer<long> &__is_integer<unsigned int> &__is_integer<unsigned int> &&const __is_integer<unsigned int>const __is_integer<unsigned int> &__is_integer<int> &__is_integer<int> &&const __is_integer<int>const __is_integer<int> &__is_integer<unsigned short> &__is_integer<unsigned short> &&const __is_integer<unsigned short>const __is_integer<unsigned short> &__is_integer<short> &__is_integer<short> &&const __is_integer<short>const __is_integer<short> &__is_integer<char32_t> &__is_integer<char32_t> &&const __is_integer<char32_t>const __is_integer<char32_t> &__is_integer<char16_t> &__is_integer<char16_t> &&const __is_integer<char16_t>const __is_integer<char16_t> &__is_integer<wchar_t> &__is_integer<wchar_t> &&const __is_integer<wchar_t>const __is_integer<wchar_t> &__is_integer<unsigned char> &__is_integer<unsigned char> &&const __is_integer<unsigned char>const __is_integer<unsigned char> &__is_integer<signed char> &__is_integer<signed char> &&const __is_integer<signed char>const __is_integer<signed char> &__is_integer<char> &__is_integer<char> &&const __is_integer<char>const __is_integer<char> &__is_integer<bool> &__is_integer<bool> &&const __is_integer<bool>const __is_integer<bool> &__is_void<void> &__is_void<void> &&const __is_void<void>const __is_void<void> &__truth_type<true> &__truth_type<true> &&const __truth_type<true>const __truth_type<true> &__true_type &__true_type &&const __true_typeconst __true_type &__false_type &__false_type &&const __false_typeconst __false_type &__is_move_iterator<_Tp>__is_memcmp_ordered_with<byte, _Up, _SameSize>_SameSize__is_memcmp_ordered_with<_Tp, byte, _SameSize>__is_memcmp_ordered_with<byte, byte, true>__is_memcmp_ordered_with<_Tp, _Up, false>__is_memcmp_ordered_with<_Tp, _Up, <unnamed>>__is_memcmp_ordered<_Tp, false>__is_memcmp_ordered<_Tp, _TreatAsBytes>_TreatAsBytes__memcmpable<_Tp *, const _Tp *>__memcmpable<const _Tp *, _Tp *>__memcmpable<_Tp *, _Tp *>__memcmpable<_Iter1, _Iter2>__memcpyable<_Tp *, const _Tp *>__memcpyable<_Tp *, _Tp *>__memcpyable<_OutputIter, _InputIter>_OutputIter_InputIter__is_nonvolatile_trivially_copyable<volatile _Tp>__is_nonvolatile_trivially_copyable<_Tp>__is_byte<byte>__is_byte<unsigned char>__is_byte<signed char>__is_byte<char>__is_byte<_Tp>__is_char<wchar_t>__is_char<char>__is_char<_Tp>__is_scalar<_Tp>__is_pointer<_Tp *>__is_pointer<_Tp>__is_floating<long double>__is_floating<double>__is_floating<float>__is_floating<_Tp>__is_integer<__uint128_t>__is_integer<__int128_t>__is_integer<unsigned long long>__is_integer<long long>__is_integer<unsigned long>__is_integer<long>__is_integer<unsigned int>__is_integer<int>__is_integer<unsigned short>__is_integer<short>__is_integer<char32_t>__is_integer<char16_t>__is_integer<wchar_t>__is_integer<unsigned char>__is_integer<signed char>__is_integer<char>__is_integer<bool>__is_void<void>__is_void<_Tp>__are_same<_Tp, _Tp>__are_same<<unnamed>, <unnamed>>__traitor<_Sp, _Tp>_Sp__truth_type<true>__truth_type<<unnamed>>__true_type__false_typeiterator_traits<_Iterator>__INT_N(TYPE)__extension__ template<> struct __is_integer<TYPE> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned TYPE> { enum { __value = 1 }; typedef __true_type __type; };_CPP_TYPE_TRAITS_H__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__//_CPP_TYPE_TRAITS_H// remove the move_iterator wrapper.// Move iterator type// std::byte can only be compared to itself, not to other types.// std::byte is not an integer, but it can be compared using memcmp.// Whether two types can be compared using memcmp.// is unsigned// character types (and std::byte) on little endian targets.// unsigned integers on big endian targets, but only unsigned narrow// as an unsigned char yields the right result. This is true for all// True for unsigned integer-like types where comparing each byte in turn// e.g. in std::lexicographical_compare or three-way comparisons.// Whether memcmp can be used to determine ordering for a type// OK to use memcmp with pointers to trivially copyable types.// because other trivially copyable types can overload operator==.// needs to add additional checks that the types are integers or pointers,// gives the right answer for a given algorithm. So for example, std::equal// This trait only says it's well-formed to use memcmp, not that it// Whether two iterator types can be used with memcmp.// Whether two iterator types can be used with memcpy/memmove.// and similar will be false.// trivially copyable, so ensure __memcpyable<volatile int*, volatile int*>// Cannot use memcpy/memmove/memcmp on volatile types even if they are// A type that is safe for use with memcpy, memmove, memcmp etc.// For use in std::copy and std::find overloads for streambuf iterators.// // A scalar type is an arithmetic type or a pointer type// An arithmetic type is an integer type or a floating point type// Pointer types// three specializations (float, double and 'long double')// Floating point types// types are supported as well.// supported as extensions).  Up to four target-specific __int<N>// types; <em>long long</em> and <em>unsigned long long</em> are// Thirteen specializations (yes there are eleven standard integer// Integer types// Holds if the template-argument is a void type.// Compare for equality of types.// explained in c++/19404.// N.B. The conversions to bool are needed due to the issue// removed.// Update 2005: types are also provided and <bits/type_traits.h> has been// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.// See valarray_array.h for a case use.// keep these resource consumption as least as possible.// is highly costly in terms of compiler-resource.  It is a Good Thing to// Thirdly, partial ordering and overload resolution (of function templates)// glance.// one. As a net effect, the overall structure isn't very clear at first// overloaded functions and to hope that the compiler will select the right// information is -not- *that* convenient.  One has to write lots of// Secondly, from the point of view of ease of use, type-based compile-time// We're left with types and constant  integral expressions.// so function return values won't work:  We need compile-time entities.// Firstly, these compile-time entities are used as template-arguments// Why integral expressions, and not functions nor types?// the obvious thing.// can be used in control structures and the optimizer hopefully will do// and not types as found in <bits/type_traits.h>.  In particular, they// These representations were designed, on purpose, to be constant-expressions// This file provides some compile-time information about various types.// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>/** @file bits/cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ext/type_traits}
 */// Copyright (C) 2000-2022 Free Software Foundation, Inc.// The  -*- C++ -*- type traits classes for internal use in libstdc++(double *__x, double __payload)(const double *__x)(const double *__x, const double *__y)(double *__cx, const double *__x)(double __x, int __round, unsigned int __width)(double __x, double *__sinx, double *__cosx)setpayloadsigfsetpayloadf__getpayloadfgetpayloadftotalordermagftotalorderf__fminimum_mag_numffminimum_mag_numf__fmaximum_mag_numffmaximum_mag_numf__fminimum_magffminimum_magf__fmaximum_magffmaximum_magf__fminimum_numffminimum_numf__fmaximum_numffmaximum_numf__fminimumffminimumf__fmaximumffmaximumf__fminmagffminmagf__fmaxmagffmaxmagfcanonicalizef__ufromfpxfufromfpxf__fromfpxffromfpxf__ufromfpfufromfpf__fromfpffromfpf__roundevenfroundevenf__llogbfllogbf__nextupfnextupf__nextdownfnextdownf__exp10fexp10f__sincosfsincosf(float *__x, float __payload)(const float *__x)(const float *__x, const float *__y)(float *__cx, const float *__x)(float __x, int __round, unsigned int __width)(float __x, float *__sinx, float *__cosx)setpayloadsiglsetpayloadl__getpayloadlgetpayloadltotalordermagltotalorderl__fminimum_mag_numlfminimum_mag_numl__fmaximum_mag_numlfmaximum_mag_numl__fminimum_maglfminimum_magl__fmaximum_maglfmaximum_magl__fminimum_numlfminimum_numl__fmaximum_numlfmaximum_numl__fminimumlfminimuml__fmaximumlfmaximuml__fminmaglfminmagl__fmaxmaglfmaxmaglcanonicalizel__ufromfpxlufromfpxl__fromfpxlfromfpxl__ufromfplufromfpl__fromfplfromfpl__roundevenlroundevenl__llogblllogbl__nextuplnextupl__nextdownlnextdownl__exp10lexp10l__sincoslsincosl(long double *__x, long double __payload)(const long double *__x)(const long double *__x, const long double *__y)(long double *__cx, const long double *__x)(long double __x, int __round, unsigned int __width)(long double __x, long double *__sinx, long double *__cosx)setpayloadsigf32_Float32 *setpayloadf32__getpayloadf32const _Float32const _Float32 *getpayloadf32totalordermagf32totalorderf32__fminimum_mag_numf32fminimum_mag_numf32__fmaximum_mag_numf32fmaximum_mag_numf32__fminimum_magf32fminimum_magf32__fmaximum_magf32fmaximum_magf32__fminimum_numf32fminimum_numf32__fmaximum_numf32fmaximum_numf32__fminimumf32fminimumf32__fmaximumf32fmaximumf32__fminmagf32fminmagf32__fmaxmagf32fmaxmagf32canonicalizef32__ufromfpxf32ufromfpxf32__fromfpxf32fromfpxf32__ufromfpf32ufromfpf32__fromfpf32fromfpf32__roundevenf32roundevenf32__fmaf32fmaf32__fminf32fminf32__fmaxf32fmaxf32__fdimf32fdimf32__llroundf32llroundf32__lroundf32lroundf32__llrintf32llrintf32__lrintf32lrintf32__remquof32remquof32__truncf32truncf32__roundf32roundf32__nearbyintf32nearbyintf32__scalblnf32scalblnf32__llogbf32llogbf32__ilogbf32ilogbf32__scalbnf32scalbnf32__remainderf32remainderf32__nextupf32nextupf32__nextdownf32nextdownf32__nextafterf32nextafterf32__rintf32rintf32__lgammaf32_rlgammaf32_r__tgammaf32tgammaf32__lgammaf32lgammaf32__erfcf32erfcf32__erff32erff32__ynf32ynf32__y1f32y1f32__y0f32y0f32__jnf32jnf32__j1f32j1f32__j0f32j0f32__nanf32nanf32__copysignf32copysignf32__fmodf32fmodf32__floorf32floorf32__fabsf32fabsf32__ceilf32ceilf32__cbrtf32cbrtf32__hypotf32hypotf32__sqrtf32sqrtf32__powf32powf32__log2f32log2f32__exp2f32exp2f32__logbf32logbf32__log1pf32log1pf32__expm1f32expm1f32__exp10f32exp10f32__modff32modff32__log10f32log10f32__logf32logf32__ldexpf32ldexpf32__frexpf32frexpf32__expf32expf32__atanhf32atanhf32__asinhf32asinhf32__acoshf32acoshf32__sincosf32sincosf32__tanhf32tanhf32__sinhf32sinhf32__coshf32coshf32__tanf32tanf32__sinf32sinf32__cosf32cosf32__atan2f32atan2f32__atanf32atanf32__asinf32asinf32__acosf32acosf32(_Float32 *__x, _Float32 __payload)(const _Float32 *__x)(const _Float32 *__x, const _Float32 *__y)(_Float32 __x, _Float32 __y)(_Float32 *__cx, const _Float32 *__x)(_Float32 __x, int __round, unsigned int __width)(_Float32 __x)(_Float32 __x, _Float32 __y, _Float32 __z)(_Float32 __x, _Float32 __y, int *__quo)(_Float32 __x, long int __n)(_Float32 __x, int __n)(_Float32, int *__signgamp)(_Float32)(int, _Float32)(_Float32 __x, _Float32 *__iptr)(_Float32 __x, int __exponent)(_Float32 __x, int *__exponent)(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx)(_Float32 __y, _Float32 __x)setpayloadsigf128_Float128 *__float128 *setpayloadf128__getpayloadf128const _Float128const _Float128 *getpayloadf128totalordermagf128totalorderf128__fminimum_mag_numf128fminimum_mag_numf128__fmaximum_mag_numf128fmaximum_mag_numf128__fminimum_magf128fminimum_magf128__fmaximum_magf128fmaximum_magf128__fminimum_numf128fminimum_numf128__fmaximum_numf128fmaximum_numf128__fminimumf128fminimumf128__fmaximumf128fmaximumf128__fminmagf128fminmagf128__fmaxmagf128fmaxmagf128canonicalizef128__ufromfpxf128ufromfpxf128__fromfpxf128fromfpxf128__ufromfpf128ufromfpf128__fromfpf128fromfpf128__roundevenf128roundevenf128__fmaf128fmaf128__fminf128fminf128__fmaxf128fmaxf128__fdimf128fdimf128__llroundf128llroundf128__lroundf128lroundf128__llrintf128llrintf128__lrintf128lrintf128__remquof128remquof128__truncf128truncf128__roundf128roundf128__nearbyintf128nearbyintf128__scalblnf128scalblnf128__llogbf128llogbf128__ilogbf128ilogbf128__scalbnf128scalbnf128__remainderf128remainderf128__nextupf128nextupf128__nextdownf128nextdownf128__nextafterf128nextafterf128__rintf128rintf128__lgammaf128_rlgammaf128_r__tgammaf128tgammaf128__lgammaf128lgammaf128__erfcf128erfcf128__erff128erff128__ynf128ynf128__y1f128y1f128__y0f128y0f128__jnf128jnf128__j1f128j1f128__j0f128j0f128__nanf128nanf128__copysignf128copysignf128__fmodf128fmodf128__floorf128floorf128__fabsf128fabsf128__ceilf128ceilf128__cbrtf128cbrtf128__hypotf128hypotf128__sqrtf128sqrtf128__powf128powf128__log2f128log2f128__exp2f128exp2f128__logbf128logbf128__log1pf128log1pf128__expm1f128expm1f128__exp10f128exp10f128__modff128modff128__log10f128log10f128__logf128logf128__ldexpf128ldexpf128__frexpf128frexpf128__expf128expf128__atanhf128atanhf128__asinhf128asinhf128__acoshf128acoshf128__sincosf128sincosf128__tanhf128tanhf128__sinhf128sinhf128__coshf128coshf128__tanf128tanf128__sinf128sinf128__cosf128cosf128__atan2f128atan2f128__atanf128atanf128__asinf128asinf128__acosf128acosf128(_Float128 *__x, _Float128 __payload)(const _Float128 *__x)(const _Float128 *__x, const _Float128 *__y)(_Float128 *__cx, const _Float128 *__x)(_Float128 __x, int __round, unsigned int __width)(_Float128 __x)(_Float128 __x, _Float128 __y, _Float128 __z)(_Float128 __x, _Float128 __y, int *__quo)(_Float128 __x, long int __n)(_Float128 __x, int __n)(_Float128, int *__signgamp)(_Float128)(int, _Float128)(_Float128 __x, _Float128 *__iptr)(_Float128 __x, int __exponent)(_Float128 __x, int *__exponent)(_Float128 __x, _Float128 *__sinx, _Float128 *__cosx)(_Float128 __y, _Float128 __x)iscanonical__iscanonicall__iscanonicalf128(x)((void) (__typeof (x)) (x), 1)__iscanonical(x)__iscanonicalf(x)/* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  On the
   other hand, overloading provides the means to distinguish between
   the floating-point types.  The overloading resolution will match
   the correct parameter (regardless of type qualifiers (i.e.: const
   and volatile)).  *//* Return nonzero value if X is canonical.  In IEEE interchange binary
   formats, all values are canonical, but the argument must still be
   converted to its semantic type for any exceptions arising from the
   conversion, before being discarded; in extended precision, there
   are encodings that are not consistently handled as corresponding to
   any particular value of the type, and we return 0 for those.  *//* Define iscanonical macro.  ldbl-96 version.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */<bits/exception_defines.h>__throw_bad_function_call__throw_future_error__throw_system_error__throw_ios_failure__throw_underflow_error__throw_overflow_error__throw_range_error__throw_runtime_error__throw_out_of_range_fmt__throw_out_of_range__throw_length_error__throw_invalid_argument__throw_domain_error__throw_logic_error__throw_bad_typeid__throw_bad_cast__throw_bad_array_new_length__throw_bad_alloc__throw_bad_exception_FUNCTEXCEPT_H__gnu_printf__// Helpers for exception objects in <functional>// Helpers for exception objects in <future>// Helpers for exception objects in <system_error>// Helpers for exception objects in <ios>// Helpers for exception objects in <stdexcept>// Helper for exception objects in <typeinfo>// Helper for exception objects in <new>// Helper for exception objects in <except>// ISO C++ 14882: 19.1  Exception classes/** @file bits/functexcept.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 *
 *  This header provides support for -fno-exceptions.
 */// Function-Based Exception Support -*- C++ -*-__numeric_traits__numeric_traits<long double> &__numeric_traits<long double> &&const __numeric_traits<long double>const __numeric_traits<long double> &__numeric_traits<double> &__numeric_traits<double> &&const __numeric_traits<double>const __numeric_traits<double> &__numeric_traits<float> &__numeric_traits<float> &&const __numeric_traits<float>const __numeric_traits<float> &__numeric_traits<long double>__numeric_traits<double>__numeric_traits<float>__numeric_traits<_Value>__numeric_traits_floating<_Value>__is_integer_nonstrict<_Tp>__max_exponent10__digits10__is_signed__max_digits10const _Value__min__max__digitsinvalid specialization__glibcxx_max_exponent10__glibcxx_floating__glibcxx_max_exponent10(_Tp)__glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, __LDBL_MAX_10_EXP__)__glibcxx_digits10(_Tp)__glibcxx_floating(_Tp, __FLT_DIG__, __DBL_DIG__, __LDBL_DIG__)__glibcxx_max_digits10(_Tp)(2 + __glibcxx_floating(_Tp, __FLT_MANT_DIG__, __DBL_MANT_DIG__, __LDBL_MANT_DIG__) * 643L / 2136)__glibcxx_floating(_Tp,_Fval,_Dval,_LDval)(std::__are_same<_Tp, float>::__value ? _Fval : std::__are_same<_Tp, double>::__value ? _Dval : _LDval)_GLIBCXX_INT_N_TRAITS_GLIBCXX_INT_N_TRAITS(T,WIDTH)__extension__ template<> struct __is_integer_nonstrict<T> { enum { __value = 1 }; typedef std::__true_type __type; enum { __width = WIDTH }; }; __extension__ template<> struct __is_integer_nonstrict<unsigned T> { enum { __value = 1 }; typedef std::__true_type __type; enum { __width = WIDTH }; };_EXT_NUMERIC_TRAITSdefined __GLIBCXX_TYPE_INT_N_0 && __GLIBCXX_BITSIZE_INT_N_0 % __CHAR_BIT__defined __GLIBCXX_TYPE_INT_N_1 && __GLIBCXX_BITSIZE_INT_N_1 % __CHAR_BIT__defined __GLIBCXX_TYPE_INT_N_2 && __GLIBCXX_BITSIZE_INT_N_2 % __CHAR_BIT__defined __GLIBCXX_TYPE_INT_N_3 && __GLIBCXX_BITSIZE_INT_N_3 % __CHAR_BIT___GLIBCXX_LONG_DOUBLE_ALT128_COMPATdefined __LONG_DOUBLE_IEEE128__defined __LONG_DOUBLE_IBM128____SIZEOF_INT128__// long double is __ibm128, define traits for __ieee128// long double is __ieee128, define traits for __ibm128// See above comment...// Only floating point types. See N1822.// N.B. this only supports float, double and long double (no __float128 etc.)/// Convenience alias for __numeric_traits<integer-type>.// but we still want to define __numeric_traits_integer<__int128>.// In strict modes __is_integer<__int128> is false,// but its width (number of bits in the value representation) is only 20.// have padding bits, e.g. the object representation of __int20 has 32 bits,// We need to specify the width for some __intNN types because they// primary template doesn't give the right answer.// Enable __numeric_traits_integer for types where the __is_integer_nonstrict// The initializers must be constants so that __max and __min are too.// time constants, but <limits> is big and we can avoid including it.// NB: these two are also available in std::numeric_limits as compile// The number of bits in the value representation.// non-standard built-in integer types such as __int128 and __int20.// Unlike __is_integer (and std::is_integral) this trait is true for// or is_signed, digits10, max_digits10, or max_exponent10 for floats.// when only is_signed, digits, min, or max values are needed for integers,// Even for C++11, this header is smaller than <limits> and can be used// (that changed in C++11 with the addition of 'constexpr').// In C++98 std::numeric_limits member functions are not constant expressions// Compile time constants for builtin types./** @file ext/numeric_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */// General Public License for more details.// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU// WITHOUT ANY WARRANTY; without even the implied warranty of// This library is distributed in the hope that it will be useful, but// version.// Foundation; either version 3, or (at your option) any later// of the GNU General Public License as published by the Free Software// software; you can redistribute it and/or modify it under the terms// -*- C++ -*-/usr/include/c++/12/ext<bits/ptr_traits.h>operator+const __normal_iterator<_Iterator, _Container>const __normal_iterator<_Iterator, _Container> &__normal_iterator<_Iterator, _Container> &operator-const __normal_iterator<_IteratorL, _Container>const __normal_iterator<_IteratorL, _Container> &__normal_iterator<_IteratorL, _Container> &const __normal_iterator<_IteratorR, _Container>const __normal_iterator<_IteratorR, _Container> &__normal_iterator<_IteratorR, _Container> &operator-=operator--operator++operator->operator*__normal_iteratorconst __normal_iterator<_Iter, _Container>const __normal_iterator<_Iter, _Container> &__normal_iterator<_Iter, _Container> &_ReturnType__make_move_if_noexcept_iteratormake_move_iteratorconst move_iterator<_Iterator>const move_iterator<_Iterator> &move_iterator<_Iterator> &const move_iterator<_IteratorL>const move_iterator<_IteratorL> &move_iterator<_IteratorL> &const move_iterator<_IteratorR>const move_iterator<_IteratorR> &move_iterator<_IteratorR> &__to_addressinserter_Container &front_inserterback_insertermake_reverse_iterator__make_reverse_iteratorconst reverse_iterator<_Iterator>const reverse_iterator<_Iterator> &reverse_iterator<_Iterator> &const reverse_iterator<_IteratorR>const reverse_iterator<_IteratorR> &reverse_iterator<_IteratorR> &const reverse_iterator<_IteratorL>const reverse_iterator<_IteratorL> &reverse_iterator<_IteratorL> &const move_iterator<_Iter>const move_iterator<_Iter> &move_iterator<_Iter> &move_iteratorinsert_iterator<_Container> &value_type &&const value_typeconst value_type &value_type &insert_iteratorfront_insert_iterator<_Container> &front_insert_iteratorback_insert_iterator<_Container> &back_insert_iterator_S_to_pointerconst reverse_iterator<_Iter>const reverse_iterator<_Iter> &reverse_iterator<_Iter> &reverse_iteratoriterator_type__convertible_fromsecond_type__iter_val_t__iter_key_t__is_move_iterator<move_iterator<_Iterator>>__base_refcontainer_typeback_insert_iterator<_Container>__is_move_iterator<reverse_iterator<_Iterator>>__lhs__rhs_M_current_Container *container_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter)std::__make_move_if_noexcept_iterator(_Iter)_GLIBCXX_MAKE_MOVE_ITERATOR(_Iter)std::make_move_iterator(_Iter)__cpp_lib_make_reverse_iterator__cpp_lib_array_constexpr201803L_STL_ITERATOR_H__detail__cplusplus == 201703L__cpp_lib_concepts! __cpp_lib_concepts__cplusplus > 201703L && __cpp_concepts >= 201907L__cplusplus <= 201703L || ! defined __cpp_lib_concepts__cplusplus > 201703L && defined __cpp_lib_concepts__cplusplus <= 201703L! (__cplusplus > 201703L && __cpp_lib_concepts)__cpp_deduction_guides >= 201606_GLIBCXX_DEBUG__cpp_deduction_guidesnoexcept(_Iterator(current))noexcept(current = __x.current)noexcept(_Iterator(__x.current))noexcept(_Iterator(__x))noexcept(_Iterator())// __cpp_deduction_guides// of associative containers.// These helper traits are used for deduction guides/// @} group iterators// iterator_category defined in __counted_iter_cat// iterator_concept defined in __counted_iter_concept// value_type defined in __counted_iter_value_type/// An iterator adaptor that keeps track of the distance to the end.// [iterators.counted] Counted iterators// 0 == _M_it, 1 == _M_sent, 2 == valueless/// An iterator/sentinel adaptor for representing a non-common range.// [iterators.common] Common iterators// returning a constant iterator when we don't want to move.// Overload for pointers that matches std::move_if_noexcept more closely,// DR 685.// ! C++20// why we have these extra overloads for some move_iterator operators.// Note: See __normal_iterator operators note from Gaby to understand// 2106. move_iterator wrapping iterators returning prvalues// NB: DR 680.// iterator_category defined in __move_iter_cat// 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>/**
   *  Class template move_iterator is an iterator adapter with the same
   *  behavior as the underlying iterator except that its dereference
   *  operator implicitly converts the value returned by the underlying
   *  iterator's dereference operator to an rvalue reference.  Some
   *  generic algorithms can be called with move iterators to replace
   *  copying with moving.
   */// 24.4.3  Move iterators/**
   * @addtogroup iterators
   * @{
   */// will deduce element_type of __normal_iterator<T*, C> as T* rather than T.// Need to overload __to_address because the pointer_traits primary template// parameters.// operators but also operator- must accept mixed iterator/const_iterator// According to the resolution of DR179 not only the various comparison// three-way comparison// Random access iterator requirements// Forward iterator requirements// remind me what generic programming is about? -- Gaby// provide overloads whose operands are of the same type.  Can someone// will make overload resolution ambiguous (when in scope) if we don't// valid.  However, the greedy and unfriendly operators in std::rel_ops// comparison between cv-qualified and non-cv-qualified iterators be// allowed to vary in types (conceptually in cv-qualification) so that// Note: In what follows, the left- and right-hand-side iterators are// Bidirectional iterator requirements// but is present in std::vector and std::basic_string.// N.B. _Container::pointer is not actually in container requirements,// Allow iterator to const_iterator conversion// _Iterator parameter is the same.// using this template can instantiate different types, even if the// The _Container parameter exists solely so that different containers// not a class, e.g. a pointer, into an iterator that is a class.// parameter.  Its primary purpose is to convert an iterator that is// change the semantics of any of the operators of its iterator// This iterator adapter is @a normal in the sense that it does not/**
   *  @param __x  A container of arbitrary type.
   *  @param __i  An iterator into the container.
   *  @return  An instance of insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//// Simply returns *this.  (This %iterator does not @a move.)/// Simply returns *this./**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator maintains its own position in the
       *  container.  Assigning a value to the %iterator will insert the
       *  value into the container at the place before the %iterator.
       *
       *  The position is maintained such that subsequent assignments will
       *  insert values immediately after one another.  For example,
       *  @code
       *     // vector v contains A and Z
       *
       *     insert_iterator i (v, ++v.begin());
       *     i = 1;
       *     i = 2;
       *     i = 3;
       *
       *     // vector v contains A, 1, 2, 3, and Z
       *  @endcode
      *//**
       *  The only way to create this %iterator is with a container and an
       *  initial position (a normal %iterator into the container).
      *//// A nested typedef for the type of whatever container you used./**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
  *//**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of front_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating front_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the front, if you like).  Assigning a value to the %iterator will
       *  always prepend the value to the front of the container.
      *//// The only way to create this %iterator is with a container./**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator prepends it to the container using
   *  push_front.
   *
   *  Tip:  Using the front_inserter function to create these iterators can
   *  save typing.
  *//**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of back_insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating back_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      *//**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */// 24.4.2.2.1 back_insert_iterator/// Generator function for reverse_iterator.// DR 2285. make_reverse_iterator// Same as C++14 make_reverse_iterator but used in C++11 mode too.// DR 685. reverse_iterator/move_iterator difference has invalid signatures///@}// unconstrained overloads in associated namespaces.// Additional, non-standard overloads to avoid ambiguities with greedy,// DR 280. Comparison of reverse_iterator to const reverse_iterator./**
   *  @param  __x  A %reverse_iterator.
   *  @param  __y  A %reverse_iterator.
   *  @return  A simple bool.
   *
   *  Reverse iterators forward comparisons to their underlying base()
   *  iterators.
   *
  *////@{/**
       *  @return  The value at @c current - @a __n - 1
       *
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  *this
       *
       *  Moves the underlying iterator forwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  A reverse_iterator that refers to @c current - @a __n
       *
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  *this
       *
       *  Moves the underlying iterator backwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  A reverse_iterator with the previous value of @c *this
       *
       *  Increments the underlying iterator.
      *//**
       *  @return  @c *this
       *
       *  Increments the underlying iterator.
      *//**
       *  @return  The original value of @c *this
       *
       *  Decrements the underlying iterator.
      *//**
       *  @return  @c *this
       *
       *  Decrements the underlying iterator.
      */// 1052. operator-> should also support smart pointers/**
       *  @return  A pointer to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
      *//**
       *  @return  A reference to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
       *
       *  @warning This implementation requires that for an iterator of the
       *           underlying iterator type, @c x, a reference obtained by
       *           @c *x remains valid after @c x has been modified or
       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
      *//**
       *  @return  @c current, the %iterator used for underlying work.
      *//**
       *  A %reverse_iterator across other types can be copied if the
       *  underlying %iterator can be converted to the type of @c current.
      *//**
       *  The copy constructor is normal.
      *//**
       *  This %iterator will move in the opposite direction that @p x does.
      */// 1012. reverse_iterator default ctor should value initialize// 235 No specification of default ctor for reverse_iterator/**
       *  The default constructor value-initializes member @p current.
       *  If it is a pointer, that means it is zero-initialized.
      *//**
   *  Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  <em>This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array.</em> [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
  */// 24.4.1 Reverse iterators// Ignore warnings about std::iterator.// otherwise use _Otherwise.// Weaken iterator_category _Cat to _Limit if it is derived from that,/** @file bits/stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 */// Iterators -*- C++ -*-__negate__iter_comp_iter__iter_comp_val_Value &__pred_iter__iter_equals_val__val_comp_iter__iter_equal_to_val__iter_equal_to_iter__val_less_iter__iter_less_val__iter_less_iter_Iter_negate_Iterator2_Iter_comp_to_iter_Iterator1_Iter_comp_to_val_Iter_pred_Iter_equals_iter_Iter_equals_val_Val_comp_iter_Iter_comp_iter<_Compare> &&const _Iter_comp_iter<_Compare>const _Iter_comp_iter<_Compare> &_Iter_comp_iter<_Compare> &_Iter_comp_val_Iter_comp_iter_Iter_equal_to_val &_Iter_equal_to_val &&const _Iter_equal_to_valconst _Iter_equal_to_val &_Iter_equal_to_iter &_Iter_equal_to_iter &&const _Iter_equal_to_iterconst _Iter_equal_to_iter &_Val_less_iter &_Val_less_iter &&const _Val_less_iterconst _Val_less_iter &_Val_less_iter_Val_less_iter *_Iter_less_val &_Iter_less_val &&const _Iter_less_valconst _Iter_less_val &_Iter_less_val_Iter_less_val *_Iter_less_iter &_Iter_less_iter &&const _Iter_less_iterconst _Iter_less_iter &_Iter_comp_to_iter<_Compare, _Iterator1>_Iter_equals_iter<_Iterator1>_Iter_equal_to_val_Iter_equal_to_iter_Iter_less_iter_M_pred_M_it1_M_comp_M_value_GLIBCXX_PREDEFINED_OPS_H__ops__pred._M_pred__comp._M_comp// namespace __gnu_cxx// namespace __ops/** @file predefined_ops.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly. @headername{algorithm}
 */// Copyright (C) 2013-2022 Free Software Foundation, Inc.// Default predicates for internal use -*- C++ -*-__it1__it2__psi__psi_series__bincoef__log_bincoef__sin_fact__log_gamma_sign"Argument is nonpositive integer " "in __log_gamma"Argument is nonpositive integer in __log_gamma__N("Argument is nonpositive integer "
                                          "in __log_gamma")__lnpi__log_gamma__xm1const _Tp[9]_Tp[9]__lanczos_cheb_7__LOGROOT2PI7.57.5L__euler0.91893853320467274180.9189385332046727417803297364056176L0.999999999999809932260.99999999999980993227684700473478L676.52036812188509857676.520368121885098567009190444019L1259.13921672240287041259.13921672240287047156078755283L-1259.1392167224028704-1259.13921672240287047156078755283L771.32342877765307887771.3234287776530788486528258894L176.61502916214059906176.61502916214059906584551354L-176.61502916214059906-176.61502916214059906584551354L12.50734327868690481412.507343278686904814458936853L0.13857109526572011690.13857109526572011689554707L-0.1385710952657201169-0.13857109526572011689554707L9.9843695780195708595e-069.984369578019570859563e-6L1.5056327351493115584e-071.50563273514931155834e-7L__log_gamma_lanczos__log_gamma_bernoulli__bernoulliconst _Tp[28]_Tp[28]_GLIBCXX_TR1_GAMMA_TCC"Argument out of range " "in __psi"// _GLIBCXX_TR1_GAMMA_TCC/**
     *   @brief  Return the polygamma function @f$ \psi^{(n)}(x) @f$.
     * 
     *   The polygamma function is related to the Hurwitz zeta function:
     *   @f[
     *     \psi^{(n)}(x) = (-1)^{n+1} m! \zeta(m+1,x)
     *   @f]
     *//**
     *   @brief  Return the digamma function.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *   For negative argument the reflection formula is used:
     *   @f[
     *     \psi(x) = \psi(1-x) - \pi \cot(\pi x)
     *   @f]
     *//**
     *   @brief  Return the digamma function for large argument.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The asymptotic series is given by:
     *   @f[
     *     \psi(x) = \ln(x) - \frac{1}{2x}
     *             - \sum_{n=1}^{\infty} \frac{B_{2n}}{2 n x^{2n}}
     *   @f]
     *//**
     *   @brief  Return the digamma function by series expansion.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The series is given by:
     *   @f[
     *     \psi(x) = -\gamma_E - \frac{1}{x}
     *              \sum_{k=1}^{\infty} \frac{x}{k(x + k)}
     *   @f]
     *//**
     *   @brief Return \f$ \Gamma(x) \f$.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The gamma function.
     *//**
     *   @brief Return the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the logarithm of the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the sign of \f$ \Gamma(x) \f$.
     *          At nonpositive integers zero is returned.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The sign of the gamma function.
     *//**
     *   @brief Return \f$ log(|\Gamma(x)|) \f$.
     *          This will return values even for \f$ x < 0 \f$.
     *          To recover the sign of \f$ \Gamma(x) \f$ for
     *          any argument use @a __log_gamma_sign.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by the Lanczos method.
     *          This method dominates all others on the positive axis I think.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by asymptotic expansion
     *          with Bernoulli number coefficients.  This is like
     *          Sterling's approximation.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief This returns Bernoulli number \f$B_n\f$.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     *///  Take care of some small evens that are painful for the series.//  Take care of the rest of the odd ones./**
     *   @brief This returns Bernoulli numbers from a table or by summation
     *          for larger values.
     *
     *   Recursion is unstable.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     *///   (4) Gamma, Exploring Euler's Constant, Julian Havil,//       2nd ed, pp. 213-216//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,//       Section 6, pp. 253-266/** @file tr1/gamma.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */"Bad argument " "in __sph_neumann."Bad argument in __sph_neumann.__N("Bad argument "
                                      "in __sph_neumann.")__j_n__n_n__jp_n__np_n__sph_neumann"Bad argument " "in __sph_bessel."Bad argument in __sph_bessel.__N("Bad argument "
                                      "in __sph_bessel.")__sph_bessel__J_nu__N_nu__Jp_nu__Np_nu__factor__sqrtpio2__sph_bessel_jn"Bad argument " "in __cyl_neumann_n."Bad argument in __cyl_neumann_n.__N("Bad argument "
                                      "in __cyl_neumann_n.")__cyl_neumann_n"Bad argument " "in __cyl_bessel_j."Bad argument in __cyl_bessel_j.__N("Bad argument "
                                      "in __cyl_bessel_j.")__cyl_bessel_j__xx4__Jn__cyl_bessel_ij_series__8x__epsP__epsQ2.__chi__coef__cyl_bessel_jn_asymp__gamma_temme_GLIBCXX_TR1_BESSEL_FUNCTION_TCC// _GLIBCXX_TR1_BESSEL_FUNCTION_TCC/**
     *   @brief  Return the spherical Neumann function
     *           @f$ n_n(x) @f$.
     *
     *   The spherical Neumann function is defined by:
     *   @f[
     *    n_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Neumann function.
     *   @param  __x  The argument of the spherical Neumann function.
     *   @return  The output spherical Neumann function.
     *//**
     *   @brief  Return the spherical Bessel function
     *           @f$ j_n(x) @f$ of order n.
     *
     *   The spherical Bessel function is defined by:
     *   @f[
     *    j_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @return  The output spherical Bessel function.
     *//**
     *   @brief  Compute the spherical Bessel @f$ j_n(x) @f$
     *           and Neumann @f$ n_n(x) @f$ functions and their first
     *           derivatives @f$ j'_n(x) @f$ and @f$ n'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @param  __j_n  The output spherical Bessel function.
     *   @param  __n_n  The output spherical Neumann function.
     *   @param  __jp_n The output derivative of the spherical Bessel function.
     *   @param  __np_n The output derivative of the spherical Neumann function.
     *//**
     *   @brief  Return the Neumann function of order \f$ \nu \f$:
     *           \f$ N_{\nu}(x) \f$.
     *
     *   The Neumann function is defined by:
     *   @f[
     *      N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
     *                        {\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the Neumann function.
     *   @param  __x   The argument of the Neumann function.
     *   @return  The output Neumann function.
     *//**
     *   @brief  Return the Bessel function of order \f$ \nu \f$:
     *           \f$ J_{\nu}(x) \f$.
     *
     *   The cylindrical Bessel function is:
     *   @f[
     *    J_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine returns the cylindrical Bessel functions
     *          of order \f$ \nu \f$: \f$ J_{\nu} \f$ or \f$ I_{\nu} \f$
     *          by series expansion.
     *
     *   The modified cylindrical Bessel function is:
     *   @f[
     *    Z_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{\sigma^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *   where \f$ \sigma = +1 \f$ or\f$  -1 \f$ for
     *   \f$ Z = I \f$ or \f$ J \f$ respectively.
     * 
     *   See Abramowitz & Stegun, 9.1.10
     *       Abramowitz & Stegun, 9.6.7
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Equation 9.1.10 p. 360 and Equation 9.6.10 p. 375
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @param  __sgn  The sign of the alternate terms
     *                  -1 for the Bessel function of the first kind.
     *                  +1 for the modified Bessel function of the first kind.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine computes the asymptotic cylindrical Bessel
     *          and Neumann functions of order nu: \f$ J_{\nu} \f$,
     *          \f$ N_{\nu} \f$.
     *
     *   References:
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Section 9 p. 364, Equations 9.2.5-9.2.10
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *///const _Tp __fp_min = _Tp(20) * std::numeric_limits<_Tp>::min();//  Then J_0 and N_0 tank at x = 8 * N (J_0 = 0 and N_0 = nan)!//  fp_min = N * min()//  When the multiplier is N i.e./**
     *   @brief  Compute the Bessel @f$ J_\nu(x) @f$ and Neumann
     *           @f$ N_\nu(x) @f$ functions and their first derivatives
     *           @f$ J'_\nu(x) @f$ and @f$ N'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *   @param  __Jpnu  The output derivative of the Bessel function of the first kind.
     *   @param  __Npnu  The output derivative of the Neumann function.
     *//**
     *   @brief Compute the gamma functions required by the Temme series
     *          expansions of @f$ N_\nu(x) @f$ and @f$ K_\nu(x) @f$.
     *   @f[
     *     \Gamma_1 = \frac{1}{2\mu}
     *                [\frac{1}{\Gamma(1 - \mu)} - \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   and
     *   @f[
     *     \Gamma_2 = \frac{1}{2}
     *                [\frac{1}{\Gamma(1 - \mu)} + \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   where @f$ -1/2 <= \mu <= 1/2 @f$ is @f$ \mu = \nu - N @f$ and @f$ N @f$.
     *   is the nearest integer to @f$ \nu @f$.
     *   The values of \f$ \Gamma(1 + \mu) \f$ and \f$ \Gamma(1 - \mu) \f$
     *   are returned as well.
     * 
     *   The accuracy requirements on this are exquisite.
     *
     *   @param __mu     The input parameter of the gamma functions.
     *   @param __gam1   The output function \f$ \Gamma_1(\mu) \f$
     *   @param __gam2   The output function \f$ \Gamma_2(\mu) \f$
     *   @param __gampl  The output function \f$ \Gamma(1 + \mu) \f$
     *   @param __gammi  The output function \f$ \Gamma(1 - \mu) \f$
     *///       2nd ed, pp. 240-245//       Section 9, pp. 355-434, Section 10 pp. 435-478// References:// Written by Edward Smith-Rowland./* __cyl_bessel_jn_asymp adapted from GNU GSL version 2.4 specfunc/bessel_j.c
 * Copyright (C) 1996-2003 Gerard Jungman
 *//** @file tr1/bessel_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__y_mp1m_factor__lncirc__lnpoch__lnpre_val__sr__y_mm__y_mp1m__y_lm__rat1__rat2__fact1__sph_legendre__p_mm__p_mp1m__p_lm2m__P_lm1m__p_lm__root__assoc_legendre_p__p_lm2__p_lm1__p_l__poly_legendre_p_GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// Compute Y_l^m, l > m+1, upward recursion on l.//  Gamma(m+1/2) / Gamma(m)//             (-1)^m (1-x^2)^(m/2) / pi^(1/4)// Y_m^m(x) = sqrt( (2m+1)/(4pi m) gamma(m+1/2)/gamma(m) )// Starting value for recursion.// m > 0 and |x| < 1 here//  m > 0 here/**
     *   @brief  Return the spherical associated Legendre function.
     * 
     *   The spherical associated Legendre function of @f$ l @f$, @f$ m @f$,
     *   and @f$ \theta @f$ is defined as @f$ Y_l^m(\theta,0) @f$ where
     *   @f[
     *      Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
     *                                  \frac{(l-m)!}{(l+m)!}]
     *                     P_l^m(\cos\theta) \exp^{im\phi}
     *   @f]
     *   is the spherical harmonic function and @f$ P_l^m(x) @f$ is the
     *   associated Legendre function.
     * 
     *   This function differs from the associated Legendre function by
     *   argument (@f$x = \cos(\theta)@f$) and by a normalization factor
     *   but this factor is rather large for large @f$ l @f$ and @f$ m @f$
     *   and so this function is stable for larger differences of @f$ l @f$
     *   and @f$ m @f$.
     *   @note Unlike the case for __assoc_legendre_p the Condon-Shortley
     *         phase factor @f$ (-1)^m @f$ is present here.
     *   @note @f$ Y_l^m(\theta) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the spherical associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the spherical associated Legendre function.
     *   @param  theta  The radian angle argument of the spherical associated
     *                  Legendre function.
     *///  than just one.//  Two square roots seem more accurate more of the time/**
     *   @brief  Return the associated Legendre function by recursion
     *           on @f$ l @f$.
     * 
     *   The associated Legendre function is derived from the Legendre function
     *   @f$ P_l(x) @f$ by the Rodrigues formula:
     *   @f[
     *     P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
     *   @f]
     *   @note @f$ P_l^m(x) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the associated Legendre function.
     *   @param  x  The argument of the associated Legendre function.
     *              @f$ |x| <= 1 @f$.
     *   @param  phase  The phase of the associated Legendre function.
     *                  Use -1 for the Condon-Shortley phase convention.
     *///  protection, Arfken, 2nd Ed, Eq 12.17a.//  This arrangement is supposed to be better for roundoff/**
     *   @brief  Return the Legendre polynomial by recursion on degree
     *           @f$ l @f$.
     * 
     *   The Legendre function of @f$ l @f$ and @f$ x @f$,
     *   @f$ P_l(x) @f$, is defined by:
     *   @f[
     *     P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
     *   @f]
     * 
     *   @param  l  The degree of the Legendre polynomial.  @f$l >= 0@f$.
     *   @param  x  The argument of the Legendre polynomial.  @f$|x| <= 1@f$.
     *///       2nd ed, pp. 252-254//       Section 8, pp. 331-341/** @file tr1/legendre_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__theta__phase__absx__rootx_S_inf__I_nu__Ip_nu__K_nu__Kp_nu__sqrt30.355028053887817239260.35502805388781723926L0.258819403792806798390.25881940379280679840L__airy__sph_bessel_ik"Bad argument " "in __cyl_bessel_k."Bad argument in __cyl_bessel_k.__N("Bad argument "
                                      "in __cyl_bessel_k.")__cyl_bessel_k"Bad argument " "in __cyl_bessel_i."Bad argument in __cyl_bessel_i.__N("Bad argument "
                                      "in __cyl_bessel_i.")__cyl_bessel_i"Argument x too large " "in __bessel_ik; " "try asymptotic expansion."Argument x too large in __bessel_ik; try asymptotic expansion.__N("Argument x too large "
                                       "in __bessel_ik; "
                                       "try asymptotic expansion.")__Inul__Ipnul__Inul1__Ipnu1__Inutemp__Kmu__Knu1"Bessel k series failed to converge " "in __bessel_ik.""Steed's method failed " "in __bessel_ik."Bessel k series failed to converge in __bessel_ik.__N("Bessel k series failed to converge "
                                           "in __bessel_ik.")__delh__a1__qnew__delsSteed's method failed in __bessel_ik.__N("Steed's method failed "
                                           "in __bessel_ik.")__Kpmu__Inumu__Knutemp__bessel_ik_GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC// _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC//  The number is Ai'(0) = -3^{-1/3}/\Gamma(1/3).//    Abramowitz & Stegun, page 446 section 10.4.5 on Airy functions.//  Reference://  The number is Ai(0) = 3^{-2/3}/\Gamma(2/3).//    Abramowitz & Stegun, page 446 section 10.4.4 on Airy functions./**
     *   @brief  Compute the Airy functions
     *           @f$ Ai(x) @f$ and @f$ Bi(x) @f$ and their first
     *           derivatives @f$ Ai'(x) @f$ and @f$ Bi(x) @f$
     *           respectively.
     *
     *   @param  __x  The argument of the Airy functions.
     *   @param  __Ai  The output Airy function of the first kind.
     *   @param  __Bi  The output Airy function of the second kind.
     *   @param  __Aip  The output derivative of the Airy function
     *                  of the first kind.
     *   @param  __Bip  The output derivative of the Airy function
     *                  of the second kind.
     *//**
     *   @brief  Compute the spherical modified Bessel functions
     *           @f$ i_n(x) @f$ and @f$ k_n(x) @f$ and their first
     *           derivatives @f$ i'_n(x) @f$ and @f$ k'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the modified spherical Bessel function.
     *   @param  __x  The argument of the modified spherical Bessel function.
     *   @param  __i_n  The output regular modified spherical Bessel function.
     *   @param  __k_n  The output irregular modified spherical
     *                  Bessel function.
     *   @param  __ip_n  The output derivative of the regular modified
     *                   spherical Bessel function.
     *   @param  __kp_n  The output derivative of the irregular modified
     *                   spherical Bessel function.
     *//**
     *   @brief  Return the irregular modified Bessel function
     *           \f$ K_{\nu}(x) \f$ of order \f$ \nu \f$.
     *
     *   The irregular modified Bessel function is defined by:
     *   @f[
     *      K_{\nu}(x) = \frac{\pi}{2}
     *                   \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the irregular modified Bessel function.
     *   @param  __x   The argument of the irregular modified Bessel function.
     *   @return  The output irregular modified Bessel function.
     *//**
     *   @brief  Return the regular modified Bessel function of order
     *           \f$ \nu \f$: \f$ I_{\nu}(x) \f$.
     *
     *   The regular modified cylindrical Bessel function is:
     *   @f[
     *    I_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the regular modified Bessel function.
     *   @param  __x   The argument of the regular modified Bessel function.
     *   @return  The output regular modified Bessel function.
     *//**
     *   @brief  Compute the modified Bessel functions @f$ I_\nu(x) @f$ and
     *           @f$ K_\nu(x) @f$ and their first derivatives
     *           @f$ I'_\nu(x) @f$ and @f$ K'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Inu  The output regular modified Bessel function.
     *   @param  __Knu  The output irregular modified Bessel function.
     *   @param  __Ipnu  The output derivative of the regular
     *                   modified Bessel function.
     *   @param  __Kpnu  The output derivative of the irregular
     *                   modified Bessel function.
     *///       2nd ed, pp. 246-249./** @file tr1/modified_bessel_func.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__Ai__Bi__Aip__Bip__i_n__k_n__ip_n__kp_n__Inu__Knu__Ipnu__Kpnu__poly_hermite__H_0__H_1__H_n__H_nm1__H_nm2__poly_hermite_recursion_GLIBCXX_TR1_POLY_HERMITE_TCC// _GLIBCXX_TR1_POLY_HERMITE_TCC/**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///  Compute H_n.//  Compute H_1.//  Compute H_0./**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$ by recursion on n.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///       Dover Publications, Section 22 pp. 773-802/** @file tr1/poly_hermite.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */<tr1/riemann_zeta.tcc><tr1/poly_laguerre.tcc><tr1/poly_hermite.tcc><tr1/modified_bessel_func.tcc><tr1/legendre_function.tcc><tr1/hypergeometric.tcc><tr1/exp_integral.tcc><tr1/ell_integral.tcc><tr1/beta_function.tcc><tr1/bessel_function.tcc><tr1/gamma.tcc><limits><bits/stl_algobase.h>hyperg_Tpb_Tpchyperglhypergfconf_hypergconf_hyperglconf_hypergfairy_biairy_bilairy_bifairy_aiairy_ailairy_aifsph_neumannsph_neumannlsph_neumannfsph_legendresph_legendrelsph_legendrefsph_besselsph_bessellsph_besselfriemann_zetariemann_zetalriemann_zetaflegendrelegendrellegendreflaguerrelaguerrellaguerrefhermitehermitelhermitefexpintexpintlexpintfellint_3_Tpn_Tppellint_3lellint_3fellint_2ellint_2lellint_2fellint_1ellint_1lellint_1fcyl_neumann_Tpnucyl_neumannlcyl_neumannfcyl_bessel_kcyl_bessel_klcyl_bessel_kfcyl_bessel_jcyl_bessel_jlcyl_bessel_jfcyl_bessel_icyl_bessel_ilcyl_bessel_ifcomp_ellint_3comp_ellint_3lcomp_ellint_3fcomp_ellint_2comp_ellint_2lcomp_ellint_2fcomp_ellint_1comp_ellint_1lcomp_ellint_1fbetabetalbetafassoc_legendreassoc_legendrelassoc_legendrefassoc_laguerreassoc_laguerrelassoc_laguerref__cpp_lib_math_special_functions__STDCPP_MATH_SPEC_FUNCS__201003L_GLIBCXX_BITS_SPECFUN_HGCC visibility push(default)__cplusplus <= 201403L && __STDCPP_WANT_MATH_SPEC_FUNCS__ == 0GCC visibility pop// _GLIBCXX_BITS_SPECFUN_H// __STRICT_ANSI__/**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of real numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * The hypergeometric function is defined by
   * @f[
   *    {}_2F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n (b)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The first numeratorial parameter
   * @param __b The second numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of <tt>long double</tt> numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of @ float numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   */// Hypergeometric functions/**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of real numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * The confluent hypergeometric function is defined by
   * @f[
   *    {}_1F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of <tt>long double</tt> numeratorial parameter @c a,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see conf_hyperg for details.
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of @c float numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * @see conf_hyperg for details.
   */// Confluent hypergeometric functions/**
   * Return the Airy function @f$ Bi(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of @c float argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of @c float argument x.
   */// Airy functions/** @addtogroup mathsf
   *  @{
   *//// @} group mathsf/**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Neumann function is defined by
   * @f[
   *    n_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and <tt>long double</tt> @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   */// Spherical Neumann functions/**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and real angle @f$ \theta @f$ in radians.
   *
   * The spherical Legendre function is defined by
   * @f[
   *  Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
   *                              \frac{(l-m)!}{(l+m)!}]
   *                   P_l^m(\cos\theta) \exp^{im\phi}
   * @f]
   *
   * @tparam _Tp The floating-point type of the angle @c __theta.
   * @param __l The order <tt> __l >= 0 </tt>
   * @param __m The degree <tt> __m >= 0 </tt> and <tt> __m <= __l </tt>
   * @param __theta The radian polar angle argument
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and <tt>long double</tt> angle @f$ \theta @f$
   * in radians.
   *
   * @see sph_legendre for details.
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and float angle @f$ \theta @f$ in radians.
   *
   * @see sph_legendre for details.
   */// Spherical associated Legendre functions/**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Bessel function is defined by:
   * @f[
   *  j_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   */// Spherical Bessel functions/**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for real argument @f$ s @f$.
   *
   * The Riemann zeta function is defined by:
   * @f[
   * 	\zeta(s) = \sum_{k=1}^{\infty} k^{-s} \hbox{ for } s > 1
   * @f]
   * and
   * @f[
   * 	\zeta(s) = \frac{1}{1-2^{1-s}}\sum_{k=1}^{\infty}(-1)^{k-1}k^{-s}
   *              \hbox{ for } 0 <= s <= 1
   * @f]
   * For s < 1 use the reflection formula:
   * @f[
   * 	\zeta(s) = 2^s \pi^{s-1} \sin(\frac{\pi s}{2}) \Gamma(1-s) \zeta(1-s)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __s.
   * @param __s The argument <tt> s != 1 </tt>
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for <tt>long double</tt> argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for @c float argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   */// Riemann zeta functions/**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and real argument @f$ |x| <= 0 @f$.
   *
   * The Legendre function of order @f$ l @f$ and argument @f$ x @f$,
   * @f$ P_l(x) @f$, is defined by:
   * @f[
   *   P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __l The degree @f$ l >= 0 @f$
   * @param __x The argument @c abs(__x) <= 1
   * @throw std::domain_error if @c abs(__x) > 1
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and <tt>long double</tt> argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and @c float argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   */// Legendre polynomials/**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$
   * of nonnegative degree @c n and real argument @f$ x >= 0 @f$.
   *
   * The Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The nonnegative order
   * @param __x The argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and @c float argument  @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   */// Laguerre polynomials/**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of order n
   * and @c real argument @c x.
   *
   * The Hermite polynomial is defined by:
   * @f[
   *   H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
   * @f]
   *
   * The Hermite polynomial obeys a reflection formula:
   * @f[
   *   H_n(-x) = (-1)^n H_n(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order
   * @param __x The argument
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @c x.
   *
   * @see hermite for details.
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and float argument @c x.
   *
   * @see hermite for details.
   */// Hermite polynomials/**
   * Return the exponential integral @f$ Ei(x) @f$ for @c real argument @c x.
   *
   * The exponential integral is given by
   * \f[
   *   Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
   * \f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __x  The argument of the exponential integral function.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$
   * for <tt>long double</tt> argument @c x.
   *
   * @see expint for details.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$ for @c float argument @c x.
   *
   * @see expint for details.
   */// Exponential integrals/**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * The incomplete elliptic integral of the third kind is defined by:
   * @f[
   *   \Pi(k,\nu,\phi) = \int_0^{\phi}
   * 			 \frac{d\theta}
   * 			 {(1 - \nu \sin^2\theta)
   * 			  \sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the third kind, @f$ \Pi(k,\nu) @f$.  @see comp_ellint_3.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __nu  The second argument
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the third kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * @see ellint_3 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$ for @c float argument.
   *
   * @see ellint_3 for details.
   */// Incomplete elliptic integrals of the third kind/**
   * Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * The incomplete elliptic integral of the second kind is defined as
   * @f[
   *   E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the second kind, @f$ E(k) @f$.  @see comp_ellint_2.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the second kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * @see ellint_2 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$ for @c float argument.
   *
   * @see ellint_2 for details.
   */// Incomplete elliptic integrals of the second kind/**
   * Return the incomplete elliptic integral of the first kind @f$ F(k,\phi) @f$
   * for @c real modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * The incomplete elliptic integral of the first kind is defined as
   * @f[
   *   F(k,\phi) = \int_0^{\phi}\frac{d\theta}
   * 				     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the first kind, @f$ K(k) @f$.  @see comp_ellint_1.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for <tt>long double</tt> modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for @c float modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   */// Incomplete elliptic integrals of the first kind/**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The Neumann function is defined by:
   * @f[
   *    N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
   *                      {\sin \nu\pi}
   * @f]
   * where @f$ x >= 0 @f$ and for integral order @f$ \nu = n @f$
   * a limit is taken: @f$ lim_{\nu \to n} @f$.
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of @c float order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   */// Cylindrical Neumann functions/**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * The irregular modified Bessel function is defined by:
   * @f[
   * 	K_{\nu}(x) = \frac{\pi}{2}
   * 		     \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
   * @f]
   * where for integral @f$ \nu = n @f$ a limit is taken:
   * @f$ lim_{\nu \to n} @f$.
   * For negative argument we have simply:
   * @f[
   * 	K_{-\nu}(x) = K_{\nu}(x)
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   */// Irregular modified cylindrical Bessel functions/**
   * Return the Bessel function @f$ J_{\nu}(x) @f$ of real order @f$ \nu @f$
   * and argument @f$ x >= 0 @f$.
   *
   * The cylindrical Bessel function is:
   * @f[
   *    J_{\nu}(x) = \sum_{k=0}^{\infty}
   *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   */// Cylindrical Bessel functions (of the first kind)/**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The regular modified cylindrical Bessel function is:
   * @f[
   *  I_{\nu}(x) = i^{-\nu}J_\nu(ix) = \sum_{k=0}^{\infty}
   * 		\frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   */// Regular modified cylindrical Bessel functions/**
   * Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the third kind is defined as
   * @f[
   *   \Pi(k,\nu) = \Pi(k,\nu,\pi/2) = \int_0^{\pi/2}
   * 		     \frac{d\theta}
   * 		   {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * where @f$ \Pi(k,\nu,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_3 for details of the incomplete elliptic function
   * of the third kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @param  __nu  The argument
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for <tt>long double</tt> modulus @c k.
   *
   * @see comp_ellint_3 for details.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for @c float modulus @c k.
   *
   * @see comp_ellint_3 for details.
   */// Complete elliptic integrals of the third kind/**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for real modulus @c k.
   *
   * The complete elliptic integral of the second kind is defined as
   * @f[
   *   E(k) = E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
   * @f]
   * where @f$ E(k,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_2 for details of the incomplete elliptic function
   * of the second kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_2 for details.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_2 for details.
   */// Complete elliptic integrals of the second kind/**
   * Return the complete elliptic integral of the first kind
   * @f$ K(k) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the first kind is defined as
   * @f[
   *   K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
   * 					     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
   * first kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_1 for details of the incomplete elliptic function
   * of the first kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_1 for details.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_1 for details.
   */// Complete elliptic integrals of the first kind/**
   * Return the beta function, @f$B(a,b)@f$, for real parameters @c a, @c b.
   *
   * The beta function is defined by
   * @f[
   *   B(a,b) = \int_0^1 t^{a - 1} (1 - t)^{b - 1} dt
   *          = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}
   * @f]
   * where @f$ a > 0 @f$ and @f$ b > 0 @f$
   *
   * @tparam _Tpa The floating-point type of the parameter @c __a.
   * @tparam _Tpb The floating-point type of the parameter @c __b.
   * @param __a The first argument of the beta function, <tt> __a > 0 </tt>.
   * @param __b The second argument of the beta function, <tt> __b > 0 </tt>.
   * @throw std::domain_error if <tt> __a < 0 </tt> or <tt> __b < 0 </tt>.
   *//**
   * Return the beta function, @f$B(a,b)@f$, for long double
   * parameters @c a, @c b.
   *
   * @see beta for more details.
   *//**
   * Return the beta function, @f$ B(a,b) @f$, for @c float parameters @c a, @c b.
   *
   * @see beta for more details.
   */// Beta functions/**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * The associated Legendre function is derived from the Legendre function
   * @f$ P_l(x) @f$ by the Rodrigues formula:
   * @f[
   *   P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
   * @f]
   * @see legendre for details of the Legendre function of degree @c l
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __l  The degree <tt>__l >= 0</tt>.
   * @param  __m  The order <tt>__m <= l</tt>.
   * @param  __x  The argument, <tt>abs(__x) <= 1</tt>.
   * @throw std::domain_error if <tt>abs(__x) > 1</tt>.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * @see assoc_legendre for more details.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m
   * for @c float argument.
   *
   * @see assoc_legendre for more details.
   */// Associated Legendre functions/**
   * Return the associated Laguerre polynomial of nonnegative order @c n,
   * nonnegative degree @c m and real argument @c x: @f$ L_n^m(x) @f$.
   *
   * The associated Laguerre function of real degree @f$ \alpha @f$,
   * @f$ L_n^\alpha(x) @f$, is defined by
   * @f[
   * 	 L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
   * 			 {}_1F_1(-n; \alpha + 1; x)
   * @f]
   * where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
   * @f$ {}_1F_1(a; c; x) @f$ is the confluent hypergeometric function.
   *
   * The associated Laguerre polynomial is defined for integral
   * degree @f$ \alpha = m @f$ by:
   * @f[
   * 	 L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
   * @f]
   * where the Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   * and @f$ x >= 0 @f$.
   * @see laguerre for details of the Laguerre function of degree @c n
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order of the Laguerre function, <tt>__n >= 0</tt>.
   * @param __m The degree of the Laguerre function, <tt>__m >= 0</tt>.
   * @param __x The argument of the Laguerre function, <tt>__x >= 0</tt>.
   * @throw std::domain_error if <tt>__x < 0</tt>.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$.
   *
   * @see assoc_laguerre for more details.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$ for @c float argument.
   *
   * @see assoc_laguerre for more details.
   */// Associated Laguerre polynomials/**
   * @defgroup mathsf Mathematical Special Functions
   * @ingroup numerics
   *
   * @section mathsf_desc Mathematical Special Functions
   *
   * A collection of advanced mathematical special functions,
   * defined by ISO/IEC IS 29124 and then added to ISO C++ 2017.
   *
   *
   * @subsection mathsf_intro Introduction and History
   * The first significant library upgrade on the road to C++2011,
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">
   * TR1</a>, included a set of 23 mathematical functions that significantly
   * extended the standard transcendental functions inherited from C and declared
   * in @<cmath@>.
   *
   * Although most components from TR1 were eventually adopted for C++11 these
   * math functions were left behind out of concern for implementability.
   * The math functions were published as a separate international standard
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3060.pdf">
   * IS 29124 - Extensions to the C++ Library to Support Mathematical Special
   * Functions</a>.
   *
   * For C++17 these functions were incorporated into the main standard.
   *
   * @subsection mathsf_contents Contents
   * The following functions are implemented in namespace @c std:
   * - @ref assoc_laguerre "assoc_laguerre - Associated Laguerre functions"
   * - @ref assoc_legendre "assoc_legendre - Associated Legendre functions"
   * - @ref beta "beta - Beta functions"
   * - @ref comp_ellint_1 "comp_ellint_1 - Complete elliptic functions of the first kind"
   * - @ref comp_ellint_2 "comp_ellint_2 - Complete elliptic functions of the second kind"
   * - @ref comp_ellint_3 "comp_ellint_3 - Complete elliptic functions of the third kind"
   * - @ref cyl_bessel_i "cyl_bessel_i - Regular modified cylindrical Bessel functions"
   * - @ref cyl_bessel_j "cyl_bessel_j - Cylindrical Bessel functions of the first kind"
   * - @ref cyl_bessel_k "cyl_bessel_k - Irregular modified cylindrical Bessel functions"
   * - @ref cyl_neumann "cyl_neumann - Cylindrical Neumann functions or Cylindrical Bessel functions of the second kind"
   * - @ref ellint_1 "ellint_1 - Incomplete elliptic functions of the first kind"
   * - @ref ellint_2 "ellint_2 - Incomplete elliptic functions of the second kind"
   * - @ref ellint_3 "ellint_3 - Incomplete elliptic functions of the third kind"
   * - @ref expint "expint - The exponential integral"
   * - @ref hermite "hermite - Hermite polynomials"
   * - @ref laguerre "laguerre - Laguerre functions"
   * - @ref legendre "legendre - Legendre polynomials"
   * - @ref riemann_zeta "riemann_zeta - The Riemann zeta function"
   * - @ref sph_bessel "sph_bessel - Spherical Bessel functions"
   * - @ref sph_legendre "sph_legendre - Spherical Legendre functions"
   * - @ref sph_neumann "sph_neumann - Spherical Neumann functions"
   *
   * The hypergeometric functions were stricken from the TR29124 and C++17
   * versions of this math library because of implementation concerns.
   * However, since they were in the TR1 version and since they are popular
   * we kept them as an extension in namespace @c __gnu_cxx:
   * - @ref __gnu_cxx::conf_hyperg "conf_hyperg - Confluent hypergeometric functions"
   * - @ref __gnu_cxx::hyperg "hyperg - Hypergeometric functions"
   *
   * <!-- @subsection mathsf_general General Features -->
   *
   * @subsection mathsf_promotion Argument Promotion
   * The arguments suppled to the non-suffixed functions will be promoted
   * according to the following rules:
   * 1. If any argument intended to be floating point is given an integral value
   * That integral value is promoted to double.
   * 2. All floating point arguments are promoted up to the largest floating
   *    point precision among them.
   *
   * @subsection mathsf_NaN NaN Arguments
   * If any of the floating point arguments supplied to these functions is
   * invalid or NaN (std::numeric_limits<Tp>::quiet_NaN),
   * the value NaN is returned.
   *
   * @subsection mathsf_impl Implementation
   *
   * We strive to implement the underlying math with type generic algorithms
   * to the greatest extent possible.  In practice, the functions are thin
   * wrappers that dispatch to function templates. Type dependence is
   * controlled with std::numeric_limits and functions thereof.
   *
   * We don't promote @c float to @c double or @c double to <tt>long double</tt>
   * reflexively.  The goal is for @c float functions to operate more quickly,
   * at the cost of @c float accuracy and possibly a smaller domain of validity.
   * Similaryly, <tt>long double</tt> should give you more dynamic range
   * and slightly more pecision than @c double on many systems.
   *
   * @subsection mathsf_testing Testing
   *
   * These functions have been tested against equivalent implementations
   * from the <a href="http://www.gnu.org/software/gsl">
   * Gnu Scientific Library, GSL</a> and
   * <a href="http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/index.html">Boost</a>
   * and the ratio
   * @f[
   *   \frac{|f - f_{test}|}{|f_{test}|}
   * @f]
   * is generally found to be within 10<sup>-15</sup> for 64-bit double on
   * linux-x86_64 systems over most of the ranges of validity.
   * 
   * @todo Provide accuracy comparisons on a per-function basis for a small
   *       number of targets.
   *
   * @subsection mathsf_bibliography General Bibliography
   *
   * @see Abramowitz and Stegun: Handbook of Mathematical Functions,
   * with Formulas, Graphs, and Mathematical Tables
   * Edited by Milton Abramowitz and Irene A. Stegun,
   * National Bureau of Standards  Applied Mathematics Series - 55
   * Issued June 1964, Tenth Printing, December 1972, with corrections
   * Electronic versions of A&S abound including both pdf and navigable html.
   * @see for example  http://people.math.sfu.ca/~cbm/aands/
   *
   * @see The old A&S has been redone as the
   * NIST Digital Library of Mathematical Functions: http://dlmf.nist.gov/
   * This version is far more navigable and includes more recent work.
   *
   * @see An Atlas of Functions: with Equator, the Atlas Function Calculator
   * 2nd Edition, by Oldham, Keith B., Myland, Jan, Spanier, Jerome
   *
   * @see Asymptotics and Special Functions by Frank W. J. Olver,
   * Academic Press, 1974
   *
   * @see Numerical Recipes in C, The Art of Scientific Computing,
   * by William H. Press, Second Ed., Saul A. Teukolsky,
   * William T. Vetterling, and Brian P. Flannery,
   * Cambridge University Press, 1992
   *
   * @see The Special Functions and Their Approximations: Volumes 1 and 2,
   * by Yudell L. Luke, Academic Press, 1969
   *
   * @{
   *//** @file bits/specfun.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cmath}
 */// Mathematical Special Functions for -*- C++ -*-__phi<cmath>_GLIBCXX_MATH_H!defined __cplusplus || defined _GLIBCXX_INCLUDE_NEXT_C_HEADERS__cplusplus >= 201103L && defined(_GLIBCXX_USE_C99_MATH_TR1)__cplusplus >= 201103L && __STDCPP_WANT_MATH_SPEC_FUNCS__ != 0// __cplusplus// _GLIBCXX_MATH_H// _GLIBCXX_USE_STD_SPEC_FUNCS// by IS 29124, but not by C++17.// The mathematical special functions are only added to the global namespace// C++11 && _GLIBCXX_USE_C99_MATH_TR1/** @file math.h
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2002-2022 Free Software Foundation, Inc.// -*- C++ -*- compatibility header.max_align_t &max_align_t &&const max_align_tconst max_align_t &nullptrnullptr_tmalloc_infomalloc_statsmalloc_usable_sizemalloc_trimmalloptmallinfo2mallinfopvallocmemalignmallinfo2 &mallinfo2 &&const mallinfo2const mallinfo2 &mallinfo &mallinfo &&const mallinfoconst mallinfo &keepcostfordblksuordblksfsmblksusmblkshblkhdhblkssmblksordblksM_ARENA_MAXM_ARENA_TESTM_PERTURBM_CHECK_ACTIONM_MMAP_MAXM_MMAP_THRESHOLDM_TOP_PADM_TRIM_THRESHOLDM_KEEPM_GRAINM_NLBLKSM_MXFAST__MALLOC_DEPRECATED__MALLOC_HOOK_VOLATILEvolatile_MALLOC_H/* malloc.h *//* Output information about state of allocator to stream FP.  *//* Prints brief summary statistics on stderr. *//* Report the number of usable allocated bytes associated with allocated
   chunk __ptr. *//* Release all but __pad bytes of freed top-most memory back to the
   system. Return 1 if successful, else 0. *//* General SVID/XPG interface to tunable parameters. *//* mallopt options that actually do something *//* UNUSED in this malloc *//* maximum request size for "fastbins" *//* SVID2/XPG mallopt options *//* Returns a copy of the updated current mallinfo. *//* top-most, releasable (via malloc_trim) space *//* total free space *//* total allocated space *//* space available in freed fastbin blocks *//* always 0, preserved for backwards compatibility *//* space in mmapped regions *//* number of mmapped regions *//* number of fastbin blocks *//* number of free chunks *//* non-mmapped space allocated from system *//* SVID2/XPG mallinfo2 structure which can handle allocations
   bigger than 4GB.  *//* SVID2/XPG mallinfo structure *//* Equivalent to valloc(minimum-page-that-holds(n)), that is, round up
   __size to nearest pagesize. *//* Allocate SIZE bytes on a page boundary.  *//* Allocate SIZE bytes allocated to ALIGNMENT bytes.  *//* Re-allocate the previously allocated block in __ptr, making the new
   block SIZE bytes long.  *//* Prototypes and definition for malloc implementation.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   Copyright The GNU Toolchain Authors.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__options_MEMORY_H/* memory.h  *//*
 * SVID
 */_POSIX_UIO_MAXIOV_POSIX_HIWAT_POSIX_QLIMIT_POSIX_FD_SETSIZE<bits/uio_lim.h>LONG_BITWORD_BITNZERONL_TEXTMAXNL_SETMAXNL_NMAXNL_MSGMAXNL_LANGMAXNL_ARGMAXIOV_MAX__IOV_MAX_XOPEN_IOV_MAX_XOPEN_LIM_Hdefined __USE_GNU || !defined __USE_XOPEN2K8INT_MAX == 32767INT_MAX == 2147483647defined __INT_MAX____INT_MAX__ == 32767__INT_MAX__ == 2147483647LONG_MAX == 2147483647defined __LONG_MAX____LONG_MAX__ == 2147483647/* bits/xopen_lim.h *//* Safe assumption.  *//* Number of bits in a word of type `long int'.  *//* Number of bits in a word of type `int'.  *//* Default process priority.  *//* Maximum number of bytes in a message.  We have no limit.  *//* Maximum set number.  We have no limit.  *//* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  *//* Maximum message number.  We have no limit.  *//* Maximum number of bytes in a `LANG' name.  We have no limit.  *//* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  *//* Maximum number of `iovec' structures that may be used in a single call
   to `readv', `writev', etc.  *//* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*//* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  *//*
 * Never include this file directly; use <limits.h> instead.
 */ULONG_LONG_MAX(LONG_LONG_MAX * 2ULL + 1ULL)LONG_LONG_MAXLONG_LONG_MIN(-LONG_LONG_MAX - 1LL)initializer_listinitializer_list<_E>_Econst _Econst _E *_E *const _E &_E &size_type_M_len_M_array_INITIALIZER_LIST// _INITIALIZER_LIST/**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the initializer_list.
   *  @param  __ils  Initializer list.
   *  @relates initializer_list
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the initializer_list.
   *  @param  __ils  Initializer list.
   *  @relates initializer_list
   */// One past the last element.// First element.// Number of elements.// The compiler can call a private constructor./// initializer_list// C++0x/** @file initializer_list
 *  This is a Standard C++ Library header.
 */// GCC is distributed in the hope that it will be useful,// the Free Software Foundation; either version 3, or (at your option)// it under the terms of the GNU General Public License as published by// GCC is free software; you can redistribute it and/or modify// This file is part of GCC.// Copyright (C) 2008-2022 Free Software Foundation, Inc.// std::initializer_list support -*- C++ -*-__ils__sort_heap_Compare &__make_heap__pop_heap__adjust_heap__push_heap__is_heap__is_heap_until_STL_HEAP_H_RandomAccessIteratorConcept< _RandomAccessIterator>*(__first + __parent)*__result*(__first + (__secondChild - 1))*(__first + __secondChild)*(__last - 1)__last - 1_LessThanComparableConcept<_ValueType>/* _STL_HEAP_H *//**
   *  @brief  Determines whether a range is a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  *//**
   *  @brief  Determines whether a range is a heap.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  *//**
   *  @brief  Search the end of a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  An iterator pointing to the first element not in the heap.
   *  @ingroup heap_algorithms
   *
   *  This operation returns the last iterator i in [__first, __last) for which
   *  the range [__first, i) is a heap.  Comparisons are made using __comp.
  *//**
   *  @brief  Search the end of a heap.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  An iterator pointing to the first element not in the heap.
   *  @ingroup heap_algorithms
   *
   *  This operation returns the last iterator i in [__first, __last) for which
   *  the range [__first, i) is a heap.
  *//**
   *  @brief  Sort a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation sorts the valid heap in the range [__first,__last).
   *  Comparisons are made using __comp.
  *//**
   *  @brief  Sort a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @ingroup heap_algorithms
   *
   *  This operation sorts the valid heap in the range [__first,__last).
  *//**
   *  @brief  Construct a heap over a range using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation makes the elements in [__first,__last) into a heap.
   *  Comparisons are made using __comp.
  *//**
   *  @brief  Construct a heap over a range.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @ingroup heap_algorithms
   *
   *  This operation makes the elements in [__first,__last) into a heap.
  *//**
   *  @brief  Pop an element off a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation pops the top of the heap.  The elements __first
   *  and __last-1 are swapped and [__first,__last-1) is made into a
   *  heap.  Comparisons are made using comp.
  *//**
   *  @brief  Pop an element off a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @pre    [__first, __last) is a valid, non-empty range.
   *  @ingroup heap_algorithms
   *
   *  This operation pops the top of the heap.  The elements __first
   *  and __last-1 are swapped and [__first,__last-1) is made into a
   *  heap.
  *//**
   *  @brief  Push an element onto a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap + element.
   *  @param  __comp   Comparison functor.
   *  @ingroup heap_algorithms
   *
   *  This operation pushes the element at __last-1 onto the valid
   *  heap over the range [__first,__last-1).  After completion,
   *  [__first,__last) is a valid heap.  Compare operations are
   *  performed using comp.
  *//**
   *  @brief  Push an element onto a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap + element.
   *  @ingroup heap_algorithms
   *
   *  This operation pushes the element at last-1 onto the valid heap
   *  over the range [__first,__last-1).  After completion,
   *  [__first,__last) is a valid heap.
  */// + is_heap and is_heap_until in C++0x.// Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap,// This function is an extension, not part of the C++ standard.// __is_heap, a predicate testing whether or not a range is a heap./**
   * @defgroup heap_algorithms Heap
   * @ingroup sorting_algorithms
   *//** @file bits/stl_heap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{queue}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Heap implementation -*- C++ -*-__holeIndex__topIndexwhatexception &exception &&exceptionconst exceptionconst exception &~exceptionexception *__EXCEPTION_H/** Returns a C-style character string describing the general cause
     *  of the current error.  *//**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   *//**
   * @defgroup exceptions Exceptions
   * @ingroup diagnostics
   * @since C++98
   *
   * Classes and functions for reporting errors via exceptions.
   * @{
   *//** @file bits/exception.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly.
 */// Copyright (C) 2016-2022 Free Software Foundation, Inc.// Exception Handling support header for -*- C++ -*-<bits/exception.h>operator delete[]operator new[]const nothrow_tconst nothrow_t &nothrow_t &launderconst volatile voidconst volatile void *_NEget_new_handlerset_new_handlernothrow_t &&nothrow_tbad_array_new_length &const bad_array_new_lengthconst bad_array_new_length &bad_array_new_length~bad_array_new_lengthbad_array_new_length *~bad_allocbad_alloc &const bad_allocconst bad_alloc &bad_allocbad_alloc *new_handleralign_val_thardware_constructive_interference_sizehardware_destructive_interference_size__cpp_lib_hardware_interference_size__cpp_lib_launder_NEW__cpp_aligned_new__cpp_sized_deallocation_GLIBCXX_HAVE_BUILTIN_LAUNDER__GCC_DESTRUCTIVE_SIZE__cpp_impl_destroying_deleteexternally_visible__GCC_CONSTRUCTIVE_SIZEstd::bad_alloc// Only define the feature test macro if the compiler supports the feature:/// Tag variable of type destroying_delete_t./// invoke the destructor before deallocating the memory./// Tag type used to declare a class-specific operator delete that can// __GCC_DESTRUCTIVE_SIZE// _GLIBCXX_HAVE_BUILTIN_LAUNDER// (possibly cv-qualified) void.// The program is ill-formed if T is a function type or/// Pointer optimization barrier [ptr.launder]//@}// Default placement versions of operator delete.// Default placement versions of operator new.// __cpp_aligned_new// __cpp_sized_deallocation/** These are replaceable signatures:
 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 *  - normal array new and delete (same)
 *  - @c nothrow single new and delete (take a @c nothrow argument, return
 *    @c NULL on error)
 *  - @c nothrow array new and delete (same)
 *
 *  Placement new and delete signatures (take a memory address argument,
 *  does nothing) may not be replaced by a user's program.
*///@{/// Return the current new handler./// previous handler./// Takes a replacement handler as the argument, returns the/** If you write your own error handler to be called by @c new, it must
   *  be of this type.  */// See comment in eh_exception.cc.// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118// This declaration is not useless:/**
   *  @brief  Exception possibly thrown by @c new.
   *  @ingroup exceptions
   *
   *  @c bad_alloc (or classes derived from it) is used to report allocation
   *  errors from the throwing forms of @c new.  *//** @file new
 *  This is a Standard C++ Library header.
 *
 *  The header @c new defines several functions to manage dynamic memory and
 *  handling memory allocation errors; see
 *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
 *  for more.
 */// Copyright (C) 1994-2022 Free Software Foundation, Inc.// The -*- C++ -*- dynamic memory management header.<new>destroy_ndestroy_Destroy_n_Destroy_Construct_novalue_T1 *_Construct_Args &&destroy_at_Destroy_n_aux<true> &_Destroy_n_aux<true> &&const _Destroy_n_aux<true>const _Destroy_n_aux<true> &__destroy_n_Destroy_aux<true> &_Destroy_aux<true> &&const _Destroy_aux<true>const _Destroy_aux<true> &__destroy_Destroy_n_aux<true>_Destroy_n_aux<<unnamed>>_Destroy_aux<true>_Destroy_aux<<unnamed>>_STL_CONSTRUCT_H/* _STL_CONSTRUCT_H */// A deleted destructor is trivial, this ensures we reject such types:/**
   * Destroy a range of objects.  If the value_type of the object has
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   *//**
   * Destroy the object pointed to by a pointer type.
   */// 402. wrong new expression in [some_]allocator::construct// Allow std::_Construct to be used in constant expressions./**
   * Constructs an object in existing memory by invoking an allocated
   * object's constructor with an initializer.
   *//* This file provides the C++17 functions std::destroy_at, std::destroy, and
 * std::destroy_n, and the C++20 function std::construct_at.
 * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions
 * which are defined in all standard modes and so can be used in C++98-14 code.
 * The _Destroy functions will dispatch to destroy_at during constant
 * evaluation, because calls to that function are intercepted by the compiler
 * to allow use in constant expressions.
 */// for advance// for iterator_traits/** @file bits/stl_construct.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// nonstandard construct and destroy functions -*- C++ -*-__location<bits/stl_construct.h>__return_temporary_buffer__uninitialized_construct_bufreturn_temporary_bufferget_temporary_buffer__uninitialized_construct_buf_dispatch<true> &__uninitialized_construct_buf_dispatch<true> &&const __uninitialized_construct_buf_dispatch<true>const __uninitialized_construct_buf_dispatch<true> &__ucrconst _Temporary_buffer<_ForwardIterator, _Tp>const _Temporary_buffer<_ForwardIterator, _Tp> &_Temporary_buffer<_ForwardIterator, _Tp> &_Temporary_buffer~_Temporary_bufferrequested_size__uninitialized_construct_buf_dispatch<true>__uninitialized_construct_buf_dispatch<<unnamed>>_Temporary_buffer<_ForwardIterator, _Tp>value_type *_M_buffer_M_original_len_STL_TEMPBUF_H*__prev*__seed_ForwardIteratorConcept/* _STL_TEMPBUF_H */// Requirements: _Pointer::value_type(_Tp&&) is valid.// constructions throws.// the same value when the algorithm finishes, unless one of the// While *__seed may be altered during this algorithm, it will have// be 'moved from'.// their exact value is not defined. In particular they may// Note that while these new objects will take valid values,// Constructs objects in the range [first, last).// Disable copy constructor and assignment operator./**
       * Constructs a temporary buffer of a size somewhere between
       * zero and the given length.
       *//// As per Table mumble./// Returns the size requested by the constructor; may be >size()./**
   *  This class is used in two places: stl_algo.h and ext/memory,
   *  where it is wrapped as the temporary_buffer class.  See
   *  temporary_buffer docs for more notes.
   *//**
   *  @brief The companion to get_temporary_buffer().
   *  @param  __p  A buffer previously allocated by get_temporary_buffer.
   *  @return   None.
   *
   *  Frees the memory pointed to by __p.
   *//**
   *  @brief Allocates a temporary buffer.
   *  @param  __len  The number of objects of type Tp.
   *  @return See full description.
   *
   *  Reinventing the wheel, but this time with prettier spokes!
   *
   *  This function tries to obtain storage for @c __len adjacent Tp
   *  objects.  The objects themselves are not constructed, of course.
   *  A pair<> is returned containing <em>the buffer s address and
   *  capacity (in the units of sizeof(_Tp)), or a pair of 0 values if
   *  no storage can be obtained.</em>  Note that the capacity obtained
   *  may be less than that requested if the memory is unavailable;
   *  you should compare len with the .second return value.
   *
   * Provides the nothrow exception guarantee.
   *//** @file bits/stl_tempbuf.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Temporary buffer implementation -*- C++ -*-__original_len_S_nd_Urbg_Urbg &_Wp__generate_impl_UniformRandomBitGenerator &const param_typeconst param_type &param_type &__generateresult_type *_IntType *param_type_Power_of_2const uniform_int_distribution<_IntType>const uniform_int_distribution<_IntType> &uniform_int_distribution<_IntType> &uniform_int_distributiondistribution_typeuniform_int_distribution<_IntType>result_type_M_param_M_b_M_atemplate argument must be an integral type_GLIBCXX_BITS_UNIFORM_INT_DIST_Hdefined __UINT64_TYPE__ && defined __UINT32_TYPE____UINT64_TYPE____UINT32_TYPE____UINT32_MAX__0xffffffffU__UINT64_MAX__0xffffffffffffffffUL_M_a <= _M_b// operator!= and operator<< and operator>> are defined in <bits/random.h>// wraparound control/*
	      Note that every value in [0, urange]
	      can be written uniquely as

	      (urngrange + 1) * high + low

	      where

	      high in [0, urange / (urngrange + 1)]

	      and

	      low in [0, urngrange].
	    */// upscaling// __urange can be zero// downscaling// fallback case (2 divisions)// so use 64-bit integers to downscale to desired range.// __urng produces values that use exactly 32-bits,// so use 128-bit integers to downscale to desired range.// __urng produces values that use exactly 64-bits,// https://arxiv.org/abs/1805.10941// ACM Transactions on Modeling and Computer Simulation 29 (1), 2019// reference: Fast Random Integer Generation in an Interval// using an unsigned type _Wp twice as wide as unsigned type _Up.// Returns an unbiased random number from __g downscaled to [0,__range)// Lemire's nearly divisionless algorithm./**
       * @brief Return true if two uniform integer distributions have
       *        the same parameters.
       *//**
       * @brief Generating functions.
       *//**
       * @brief Returns the inclusive upper bound of the distribution range.
       *//**
       * @brief Returns the inclusive lower bound of the distribution range.
       *//**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       *//**
       * @brief Returns the parameter set of the distribution.
       *//**
       * @brief Resets the distribution state.
       *
       * Does nothing for the uniform integer distribution.
       *//**
       * @brief Constructs a uniform distribution object.
       *//** Parameter type. *//** The type of the range of the distribution. *//**
   * @brief Uniform discrete distribution for random numbers.
   * A discrete random distribution on the range @f$[min, max]@f$ with equal
   * probability throughout the range.
   */// to be true if n==numeric_limits<_Tp>::max() and so n+1 wraps around.// This is true for zero, which is OK because we want _Power_of_2(n+1)// Determine whether number is a power of two./// Requirements for a uniform random bit generator.// __glibcxx_function_requires/**
 * @file bits/uniform_int_dist.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{random}
 */// Copyright (C) 2009-2022 Free Software Foundation, Inc.// Class template uniform_int_distribution -*- C++ -*-__p1__p2__range__urng_GLIBCXX_CSTDLIB!_GLIBCXX_HOSTED_GLIBCXX_HAVE_AT_QUICK_EXIT_GLIBCXX_HAVE_QUICK_EXIT__cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)_GLIBCXX_HAVE_MBSTATE_T_GLIBCXX_USE_WCHAR_T__CORRECT_ISO_CPP_STDLIB_H_PROTO_GLIBCXX_USE_C99_STDLIB!_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC_GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC!_GLIBCXX_USE_C99_DYNAMIC_GLIBCXX_USE_C99_LONG_LONG_CHECK || _GLIBCXX_USE_C99_LONG_LONG_DYNAMIC// !_GLIBCXX_HOSTED// _GLIBCXX_USE_C99_STDLIB// _GLIBCXX_USE_WCHAR_T// _GLIBCXX_HAVE_MBSTATE_T// Get rid of those macros defined in <stdlib.h> in lieu of real functions.// wrapper that might already be installed later in the include search path.// Need to ensure this finds the C library's <stdlib.h> not a libstdc++// [lib.support.start.term].// <cstdlib> -- but only the functionality mentioned in// provide <stdlib.h>.  However, the C++ standard does still require// The C standard does not require a freestanding implementation to// ISO C++ 14882: 20.4.6  C library/** @file include/cstdlib
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdlib.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */// -*- C++ -*- forwarding header.is_execution_policyis_execution_policy<unsequenced_policy> &is_execution_policy<unsequenced_policy> &&const is_execution_policy<unsequenced_policy>const is_execution_policy<unsequenced_policy> &is_execution_policy<parallel_unsequenced_policy> &is_execution_policy<parallel_unsequenced_policy> &&const is_execution_policy<parallel_unsequenced_policy>const is_execution_policy<parallel_unsequenced_policy> &is_execution_policy<parallel_policy> &is_execution_policy<parallel_policy> &&const is_execution_policy<parallel_policy>const is_execution_policy<parallel_policy> &is_execution_policy<sequenced_policy> &is_execution_policy<sequenced_policy> &&const is_execution_policy<sequenced_policy>const is_execution_policy<sequenced_policy> &unsequenced_policy &unsequenced_policy &&const unsequenced_policyconst unsequenced_policy &__allow_parallel__allow_vector__allow_unsequencedparallel_unsequenced_policy &parallel_unsequenced_policy &&const parallel_unsequenced_policyconst parallel_unsequenced_policy &parallel_policy &parallel_policy &&const parallel_policyconst parallel_policy &sequenced_policy &sequenced_policy &&const sequenced_policyconst sequenced_policy &is_execution_policy<unsequenced_policy>is_execution_policy<parallel_unsequenced_policy>is_execution_policy<parallel_policy>is_execution_policy<sequenced_policy>is_execution_policy<_Tp>unsequenced_policyparallel_unsequenced_policyparallel_policysequenced_policy_ExecPolicyis_execution_policy_vunseqpar_unseqparseq_PSTL_EXECUTION_POLICY_DEFS_H__pstl__internalexecution_PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT_GLIBCXX_RELEASE >= 9/* _PSTL_EXECUTION_POLICY_DEFS_H */// namespace __pstl// namespace __internal// namespace execution// namespace v1// 2.3, Execution policy type trait// 2.8, Execution policy objects// For internal use only// 2.6, Parallel+Vector execution policy// 2.5, Parallel execution policy// 2.4, Sequential execution policy//===----------------------------------------------------------------------===//// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception// See https://llvm.org/LICENSE.txt for license information.// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.//===-- execution_defs.h --------------------------------------------------===///usr/include/c++/12/pstl"execution_defs.h"_ExecutionPolicy_ExecutionPolicy &&__exec__d_first__d_last_PSTL_GLUE_ALGORITHM_DEFS_H/* _PSTL_GLUE_ALGORITHM_DEFS_H */// [alg.lex.comparison]// [alg.min.max]// [is.heap]// [set.symmetric.difference]// [set.difference]// [set.intersection]// [set.union]// [includes]// [alg.merge]// [alg.nth.element]// [is.sorted]// [partial.sort.copy]// [partial.sort]// [alg.move]// [alg.equal]// [mismatch]// [stable.sort]// [alg.sort]// [alg.partitions]// [alg.rotate]// [alg.reverse]// [alg.unique]// [alg.remove]// [alg.generate]// [alg.fill]// [alg.replace]// [alg.transform]// [alg.swap]// [alg.copy]// [alg.search]// [alg.count]// [alg.adjacent_find]// [alg.find_first_of]// [alg.find.end]// [alg.find]// [alg.foreach]// [alg.none_of]// [alg.all_of]// [alg.any_of]//===-- glue_algorithm_defs.h ---------------------------------------------===//__op__s_first__s_last<pstl/glue_algorithm_defs.h><bits/stl_algo.h>__cpp_lib_parallel_algorithm_PSTL_ALGORITHM_FORWARD_DECLARED_GLIBCXX_ALGORITHM_PSTL_EXECUTION_POLICIES_DEFINED/* _GLIBCXX_ALGORITHM */// Feature test macro for parallel algorithms// Otherwise just pull in forward declarations// If <execution> has already been included, pull in implementations// Parallel STL algorithms/** @file include/algorithm
 *  This is a Standard C++ Library header.
 */// <algorithm> -*- C++ -*-_GLIBCXX_STDLIB_H// _GLIBCXX_STDLIB_H/** @file stdlib.h
 *  This is a Standard C++ Library header.
 */lzham_z_errorlzham_z_uncompresslzham_z_inflateEndlzham_z_inflatelzham_z_inflateResetlzham_z_inflateInit2lzham_z_inflateInitlzham_z_compressBoundlzham_z_compress2lzham_z_compresslzham_z_deflateBoundlzham_z_deflateEndlzham_z_deflatelzham_z_deflateResetlzham_z_deflateInit2lzham_z_deflateInitlzham_z_versionlzham_z_crc32lzham_z_adler32lzham_decompress_memoryconst lzham_decompress_paramsconst lzham_decompress_params *lzham_decompress_params *lzham_decompresslzham_decompress_deinitlzham_decompress_reinitlzham_decompress_initlzham_compress_memorylzham_compress2lzham_compresslzham_compress_deinitlzham_compress_reinitlzham_compress_initlzham_set_memory_callbackslzham_get_versionilzham *is_loadedunloadload~ilzhamilzhamilzham &const ilzhamconst ilzham &lzham_z_stream &lzham_z_stream &&const lzham_z_streamconst lzham_z_stream &lzham_decompress_params &lzham_decompress_params &&const lzham_decompress_params &lzham_compress_params &&const lzham_compress_params &lzham_z_error_funclzham_z_uncompress_funclzham_z_inflateEnd_funclzham_z_inflate_funclzham_z_inflateReset_funclzham_z_inflateInit2_funclzham_z_inflateInit_funclzham_z_compressBound_funclzham_z_compress2_funclzham_z_compress_funclzham_z_deflateBound_funclzham_z_deflateEnd_funclzham_z_deflate_funclzham_z_deflateReset_funclzham_z_deflateInit2_funclzham_z_deflateInit_funclzham_z_version_funclzham_decompress_memory_funclzham_decompress_funclzham_decompress_deinit_funclzham_decompress_reinit_funclzham_decompress_init_funclzham_compress_memory_funclzham_compress2_funclzham_compress_funclzham_compress_deinit_funclzham_compress_reinit_funclzham_compress_init_funclzham_set_memory_callbacks_funclzham_get_version_funclzham_z_streamplzham_z_streamlzham_z_internal_stateLZHAM_Z_NO_COMPRESSIONLZHAM_Z_BEST_SPEEDLZHAM_Z_BEST_COMPRESSIONLZHAM_Z_UBER_COMPRESSIONLZHAM_Z_NEED_DICTLZHAM_Z_ERRNOLZHAM_Z_DATA_ERRORLZHAM_Z_MEM_ERRORLZHAM_Z_VERSION_ERRORLZHAM_Z_NO_FLUSHLZHAM_Z_FULL_FLUSHLZHAM_Z_BLOCKLZHAM_Z_TABLE_FLUSHLZHAM_Z_FILTEREDLZHAM_Z_HUFFMAN_ONLYLZHAM_Z_RLELZHAM_Z_FIXEDlzham_z_realloc_funclzham_z_free_funclzham_z_alloc_funclzham_z_ulonglzham_decompress_paramslzham_decompress_flagsLZHAM_DECOMP_FLAG_OUTPUT_UNBUFFEREDLZHAM_DECOMP_FLAG_COMPUTE_ADLER32LZHAM_DECOMP_FLAG_READ_ZLIB_STREAMlzham_decompress_state_ptrlzham_decompress_status_tLZHAM_DECOMP_STATUS_NOT_FINISHEDLZHAM_DECOMP_STATUS_HAS_MORE_OUTPUTLZHAM_DECOMP_STATUS_NEEDS_MORE_INPUTLZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODELZHAM_DECOMP_STATUS_SUCCESSLZHAM_DECOMP_STATUS_FIRST_FAILURE_CODELZHAM_DECOMP_STATUS_FAILED_INITIALIZINGLZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALLLZHAM_DECOMP_STATUS_FAILED_EXPECTED_MORE_RAW_BYTESLZHAM_DECOMP_STATUS_FAILED_BAD_CODELZHAM_DECOMP_STATUS_FAILED_ADLER32LZHAM_DECOMP_STATUS_FAILED_BAD_RAW_BLOCKLZHAM_DECOMP_STATUS_FAILED_BAD_COMP_BLOCK_SYNC_CHECKLZHAM_DECOMP_STATUS_FAILED_BAD_ZLIB_HEADERLZHAM_DECOMP_STATUS_FAILED_NEED_SEED_BYTESLZHAM_DECOMP_STATUS_FAILED_BAD_SEED_BYTESLZHAM_DECOMP_STATUS_FAILED_BAD_SYNC_BLOCKLZHAM_DECOMP_STATUS_INVALID_PARAMETERlzham_compress_paramslzham_table_update_rateLZHAM_INSANELY_SLOW_TABLE_UPDATE_RATELZHAM_SLOWEST_TABLE_UPDATE_RATElzham_compress_flagslzham_compress_state_ptrlzham_compress_levelLZHAM_TOTAL_COMP_LEVELSLZHAM_COMP_LEVEL_FORCE_DWORDlzham_compress_status_tLZHAM_COMP_STATUS_FAILED_INITIALIZINGLZHAM_COMP_STATUS_FORCE_DWORDlzham_flush_tlzham_msize_funclzham_realloc_funclzham_boollzham_uint32lzham_int32lzham_uint8adlerdata_typezfreezallocavail_outm_decompress_flagsm_table_update_ratem_struct_sizem_compress_flagsm_levelLZHAM_Z_UNKNOWNLZHAM_Z_ASCIILZHAM_Z_TEXTLZHAM_Z_BINARYLZHAM_Z_VER_SUBREVISIONLZHAM_Z_VER_REVISIONLZHAM_Z_VER_MINORLZHAM_Z_VER_MAJORLZHAM_Z_VERNUM0xA810LZHAM_Z_VERSION"10.8.1"LZHAM_Z_CRC32_INITsizeof(size_t) * 2LZHAM_DLL_EXPORTLZHAM_CDECLLZHAM_64BITLZHAM_DLL_VERSION0x1010__LZHAM_H__LZHAM_EXPORTSLZHAM_DEFINE_ZLIB_API// LZHAM uses the MIT License:// Copyright (c) 2009-2012 Richard Geldreich, Jr. <richgel99@gmail.com>// #ifndef __LZHAM_H__// #ifdef __cplusplus// It allows code to always call LZHAM the same way, independent of how it was linked into the app (statically or dynamically).// This optional interface is used by the dynamic/static link helpers defined in lzham_dynamic_lib.h and lzham_static_lib.h.// Exported function typedefs, to simplify loading the LZHAM DLL dynamically.// #ifdef LZHAM_DEFINE_ZLIB_API// Define LZHAM_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.// Redefine zlib-compatible names to lzham equivalents, so lzham can be used as a more or less drop-in replacement for the subset of zlib that lzham supports.// Returns a string description of the specified error code, or NULL if the error code is invalid.// Returns LZHAM_OK on success, or one of the error codes from lzham_inflate() on failure.// Single-call decompression.// Deinitializes a decompressor.//   with more input data, or with more room in the output buffer (except when using single call decompression, described above).//   LZHAM_Z_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call lzham_inflate() again//   LZHAM_Z_PARAM_ERROR if one of the parameters is invalid.//   LZHAM_Z_DATA_ERROR if the deflate stream is invalid.//   LZHAM_Z_STREAM_ERROR if the stream is bogus.//   LZHAM_Z_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.//   LZHAM_Z_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.// Return values://   LZHAM_Z_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.//   On the first call, if flush is LZHAM_Z_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).//   flush may be LZHAM_Z_NO_FLUSH, LZHAM_Z_SYNC_FLUSH, or LZHAM_Z_FINISH.//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.// Parameters:// Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.// window_bits must be LZHAM_Z_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -LZHAM_Z_DEFAULT_WINDOW_BITS (raw stream with no zlib header/footer).// lzham_z_inflateInit2() is like lzham_z_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:// Initializes a decompressor.// lzham_z_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling lzham_z_compress().// Returns LZHAM_Z_OK on success, or one of the error codes from lzham_z_deflate() on failure.// Single-call compression functions lzham_z_compress() and lzham_z_compress2():// lzham_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by lzham_z_deflate(), assuming flush is set to only LZHAM_Z_NO_FLUSH or LZHAM_Z_FINISH.//  LZHAM_Z_STREAM_ERROR if the stream is bogus.//  LZHAM_Z_OK on success.// lzham_deflateEnd() deinitializes a compressor://   LZHAM_Z_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)//   LZHAM_Z_STREAM_END if all input has been consumed and all output bytes have been written. Don't call lzham_z_deflate() on the stream anymore.//   LZHAM_Z_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).//   flush may be LZHAM_Z_NO_FLUSH, LZHAM_Z_PARTIAL_FLUSH/LZHAM_Z_SYNC_FLUSH, LZHAM_Z_FULL_FLUSH, or LZHAM_Z_FINISH.// lzham_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.// Quickly resets a compressor without having to reallocate anything. Same as calling lzham_z_deflateEnd() followed by lzham_z_deflateInit()/lzham_z_deflateInit2().//   mem_level must be between [1, 9] (it's checked but ignored by lzham)//   window_bits must be LZHAM_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -LZHAM_Z_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)//   method must be LZHAM_Z_DEFLATED or LZHAM_Z_LZHAM (LZHAM_Z_DEFLATED will be internally converted to LZHAM_Z_LZHAM with a windowsize of LZHAM_Z_DEFAULT_WINDOW_BITS)// Additional parameters:// lzham_deflateInit2() is like lzham_deflate(), except with more control://  LZHAM_MEM_ERROR on out of memory.//  LZHAM_PARAM_ERROR if the input parameters are bogus.//  LZHAM_STREAM_ERROR if the stream is bogus.//  LZHAM_OK on success.//  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.//  level must be between [LZHAM_NO_COMPRESSION, LZHAM_BEST_COMPRESSION].//  pStream must point to an initialized lzham_stream struct.// lzham_deflateInit() initializes a compressor with default options:// not used// adler32 of the source or uncompressed data// data_type (unused)// heap alloc function user pointer// optional heap free function (defaults to free)// optional heap allocation function (defaults to malloc)// These members are ignored - they are here for backwards compatibility with zlib.// LZHAM does not support per-stream heap callbacks. Use lzham_set_memory_callbacks() instead.// internal state, allocated by zalloc/zfree// error msg (unused)// total number of bytes produced so far// number of bytes that can be written to next_out// pointer to next byte to write// total number of bytes consumed so far// number of bytes available at next_in// pointer to next byte to read// Compression/decompression stream struct.// Data types//#define LZHAM_Z_API_FORCE_WINDOW_BITS 23// TODO: Might be useful to provide an API to control this at runtime.// Define LZHAM_Z_API_FORCE_WINDOW_BITS to force the entire library to use a constant value for window_bits (helps with porting) in all zlib API's.// If changing the calling code isn't practical, unremark LZHAM_Z_API_FORCE_WINDOW_BITS.// Important note: The zlib-style API's default to 32KB dictionary for API compatibility. For improved compression, be sure to call deflateInit2/inflateInit2 and specify larger custom window_bits values!// Window bits// uber = best with extreme parsing (can be very slow)// Compression levels.// Return status codes. LZHAM_Z_PARAM_ERROR is non-standard.// compression only, resets all symbol table update rates to maximum frequency (LZHAM extension)// not supported// compression/decompression// compression/decompression, when compressing: same as LZHAM_Z_SYNC_FLUSH but also forces a full state flush (LZ dictionary, all symbol statistics)// compression/decompression, when compressing: flush current block (if any), always outputs sync block (aligns output to byte boundary, a 0xFFFF0000 marker will appear in the output stream)// compression/decompression, same as LZHAM_Z_SYNC_FLUSH// Must directly map to lzham_flush_t// See http://www.bolet.org/~pornin/deflate-flush.html// LZHAM_Z_FINISH during decompression guarantees that the output buffer is large enough to hold all remaining data to decompress.// For decompression, you typically only need to use LZHAM_Z_SYNC_FLUSH or LZHAM_Z_FINISH. // LZHAM_Z_SYNC_FLUSH and LZHAM_Z_FULL_FLUSH during compression forces compression of all buffered input.// For compression, you typically only need to use LZHAM_NO_FLUSH and LZHAM_FINISH. // Flush values. // Method// Compression strategies.// lzham_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.// lzham_adler32() returns the initial adler-32 value to use when called with ptr==NULL.// Note that lzham_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long.// Heap allocation callbacks.// Important note: LZHAM doesn't internally support the Deflate algorithm, but for API compatibility the "Deflate" and "Inflate" names are retained here.// ------------------- zlib-style API Definitions.// Single function call interface.//  error (which is recoverable in the buffered case - just call lzham_decompress() again with a non-zero size output buffer).//  decompressor. In this case, if the decompressor actually has more bytes you'll receive the LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT// In buffered mode, if the output buffer's size is 0 bytes, the caller is indicating that no more output bytes are expected from the//  LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL error (which is currently unrecoverable during unbuffered decompression).// In unbuffered mode, the output buffer MUST be large enough to hold the entire decompressed stream. Otherwise, you'll receive the// Notes:// no_more_input_bytes_flag - Set to true to indicate that no more input bytes are available to compress (EOF). Once you call this function with this param set to true, it must stay set to true in all future calls.//                         On return, *pOut_buf_size will be set to the number of bytes written to this buffer.// pOut_buf, pOut_buf_size - Pointer to the output data buffer, and a pointer to a size_t containing the max number of bytes that can be written to this buffer.//                         On return, *pIn_buf_size will be set to the number of bytes read from the buffer.// pIn_buf, pIn_buf_size - Pointer to input data buffer, and pointer to a size_t containing the number of bytes available in this buffer. // pState - Pointer to internal decompression state, originally created by lzham_decompress_init.// This method is implemented as a coroutine so it may be called as many times as needed. However, for best perf. try not to call it with tiny buffers.// Decompresses an arbitrarily sized block of compressed data, writing as much available decompressed data as possible to the output buffer. // returns adler32 of decompressed data if compute_adler32 was true, otherwise it returns the adler32 from the compressed stream.// Quickly re-initializes the decompressor to its initial state given an already allocated/initialized state (doesn't do any memory alloc unless necessary).// reuse it using by calling lzham_decompress_reinit().// Note: With large dictionaries this function could take a while (due to memory allocation). To serially decompress multiple streams, it's faster to init a compressor once and // pParams cannot be NULL. Be sure to initialize the pParams->m_struct_size member to sizeof(lzham_decompress_params) (along with the other members to reasonable values) before calling this function.// def=0, 32 or higher (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), scaled by 32, controls the slowing of the update update freq, higher=more rapid slowing (faster decode/lower ratio). Was 40 in prev. releases.// def=0, typical range 12-128 (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), controls the max interval between table updates, higher=longer max interval (faster decode/lower ratio). Was 16 in prev. releases.// If either are non-zero they will override whatever m_table_update_rate is set to. Just leave them 0 unless you are specifically customizing them for your data.// m_table_max_update_interval/m_table_update_interval_slow_rate override m_table_update_rate and allow finer control over the table update settings.// Advanced settings - set to 0 if you don't care.// for delta compression (optional) - pointer to seed bytes buffer, must be at least m_num_seed_bytes long// for delta compression (optional) - number of seed bytes pointed to by m_pSeed_bytes// optional decompression flags (see lzham_decompress_flags enum)// Controls tradeoff between ratio and decompression throughput. 0=default, or [1,LZHAM_MAX_TABLE_UPDATE_RATE], higher=faster but lower ratio.// set to the log2(dictionary_size), must range between [LZHAM_MIN_DICT_SIZE_LOG2, LZHAM_MAX_DICT_SIZE_LOG2_X86] for x86 LZHAM_MAX_DICT_SIZE_LOG2_X64 for x64// set to sizeof(lzham_decompress_params)// m_table_update_rate (or m_table_max_update_interval/m_table_update_interval_slow_rate) MUST match the values used for compression!// The seed buffer's contents and size must match the seed buffer used during compression.// If m_num_seed_bytes != 0, LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED must not be set (i.e. static "seed" dictionaries are not compatible with unbuffered decompression).// m_dict_size_log2 MUST match the value used during compression!// Notes: // Decompression parameters structure.// The remaining status codes indicate a failure of some sort. Most failures are unrecoverable. TODO: Document which codes are recoverable.// LZHAM_DECOMP_STATUS_SUCCESS indicates decompression has successfully completed.// All the following enums always (and MUST) indicate failure/success.// and the caller hasn't set no_more_input_bytes_flag to true, so it's expecting more input to proceed.// LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT indicates that the decompressor has consumed all input bytes, has not encountered an "end of stream" code, // but the caller hasn't provided any space to copy this data to the caller's output buffer. Call the lzham_decompress() again with a non-empty sized output buffer.// LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT indicates that the decompressor is trying to flush its internal buffer to the caller's output buffer, // There may be more bytes available to decompress on the next call, but there is no guarantee.// LZHAM_DECOMP_STATUS_NOT_FINISHED indicates that the decompressor is flushing its internal buffer to the caller's output buffer. // Decompression// Same return codes as lzham_compress, except this function can also return LZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALL.// Single function call compression interface.//    LZHAM_COMP_STATUS_FAILED, LZHAM_COMP_STATUS_FAILED_INITIALIZING, LZHAM_COMP_STATUS_INVALID_PARAMETER - Something went wrong.//    LZHAM_COMP_STATUS_SUCCESS - Compression has completed successfully.// Success/failure return status codes://    LZHAM_COMP_STATUS_NEEDS_MORE_INPUT - Compression can contintue, but the compressor has no more output, and has no input but we're not at EOF. Supply more input to continue.//    LZHAM_COMP_STATUS_NOT_FINISHED - Compression can continue, but the compressor needs more input, or it needs more room in the output buffer.// Normal return status codes:// pState - Pointer to internal compression state, created by lzham_compress_init.// This method may be called as many times as needed, but for best perf. try not to call it with tiny buffers.// Compresses an arbitrarily sized block of data, writing as much available compressed data as possible to the output buffer. // returns adler32 of source data (valid only on success).// Deinitializes a compressor, releasing all allocated memory.// TODO: With large dictionaries this function could take a while (due to memory allocation). I need to add a reinit() API for compression (decompression already has one).// pParams cannot be NULL. Be sure to initialize the pParams->m_struct_size member to sizeof(lzham_compress_params) (along with the other members to reasonable values) before calling this function.// Initializes a compressor. Returns a pointer to the compressor's internal state, or NULL on failure.// optional compression flags (see lzham_compress_flags enum)// max # of additional "helper" threads to create, must range between [-1,LZHAM_MAX_HELPER_THREADS], where -1=max practical// set to LZHAM_COMP_LEVEL_FASTEST, etc.// set to sizeof(lzham_compress_params)// The seed buffer's contents and size must match the seed buffer used during decompression.// decompression it will fail (usually with a LZHAM_DECOMP_STATUS_FAILED_BAD_CODE error).// match during compression and decompression. The codec does not verify these values for you, if you don't use the same settings during// IMPORTANT: The values of m_dict_size_log2, m_table_update_rate, m_table_max_update_interval, and m_table_update_interval_slow_rate MUST// Compression parameters struct.// 1=insanely slow decompression, here for reference, use 2!// as adaptively resetting the Huffman table update rate to maximum frequency, which is costly for the decompressor).// If enabled, the compressor is free to use any optimizations which could lower the decompression rate (such// Guarantees that the compressed output will always be the same given the same input and parameters (no variation between runs due to kernel threading scheduling).// Improves ratio by allowing the compressor's parse graph to grow "higher" (up to 4 parent nodes per output node), but is much slower.// Streaming compression// All the following enums must indicate failure/success.// Compression (keep in sync with g_num_lzx_position_slots[])// lzham_flush_t must map directly to the zlib-style API flush types (LZHAM_Z_NO_FLUSH, etc.)// Call this function to force LZHAM to use custom memory malloc(), realloc(), free() and msize functions.// Custom allocation function must return pointers with LZHAM_MIN_ALLOC_ALIGNMENT (or better).// User provided memory allocation// Returns DLL version (LZHAM_DLL_VERSION).// Lower byte = minor version// Upper byte = major version//   streams created by LZHAM). Internally, this API is mostly implemented via the older low-level LZHAM API.//   Note that LZHAM does not actually implement the deflate/inflate algorithm, so it cannot decompress streams created by standard zlib yet (and of course, zlib cannot decompress//   which causes this header to #define most zlib symbols to their LZHAM equivalents.//   For the most common zlib usage cases LZHAM is an almost drop-in replacement for zlib. To make switching from zlib even easier, you can define the LZHAM_DEFINE_ZLIB_API macro, //   This functionality is provided because most users of compression libraries are already very familiar with the nuts and bolts of the zlib API.// - The new API implements the most useful/popular subset of the zlib API, but doesn't expose all of the codec's functionality yet. See the lzham_z* functions. //   and is the most tested.// - The first (oldest) API directly exposes all of the codec's functionality. See lzham_compress_init(), lzham_decompress_init(), etc. This API has the lowest overhead// As of LZHAM alpha8, there are now two sets of API's:// This is the main header file, includable from C or C++ files, which defines all the publically available API's, structs, and types used by the LZHAM codec.// LZHAM uses the MIT License. See Copyright Notice and license at the end of this file.// File: lzham.h - Copyright (c) 2009-2012 Richard Geldreich, Jr. <richgel99@gmail.com>/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/includepReallocpMSizepUser_dataLZHAM_PERF_SECTIONSDEBUGdefined(_DEBUG) || defined(DEBUG)// File: lzham_config.hempty_type &empty_type &&const empty_typeconst empty_type &int_traits<unsigned short> &int_traits<unsigned short> &&const int_traits<unsigned short>const int_traits<unsigned short> &int_traits<unsigned char> &int_traits<unsigned char> &&const int_traits<unsigned char>const int_traits<unsigned char> &int_traits<unsigned int> &int_traits<unsigned int> &&const int_traits<unsigned int>const int_traits<unsigned int> &int_traits<signed int> &int_traits<signed int> &&const int_traits<signed int>const int_traits<signed int> &int_traits<signed short> &int_traits<signed short> &&const int_traits<signed short>const int_traits<signed short> &int_traits<signed char> &int_traits<signed char> &&const int_traits<signed char>const int_traits<signed char> &int_traits<unsigned short>cMincMaxcSignedint_traits<unsigned char>int_traits<unsigned int>int_traits<signed int>const int32int_traits<signed short>const int16int_traits<signed char>const int8int_traits<T>cInvalidIndexptr_bits_tsigned_size_tuint32_ptruint_ptrint64uint64int32int16uint16int8uint8uint32sizeof(uint)sizeof(uint) * CHAR_BITconst ptr_bits_tPTR_BITS_XOR157845056461938270630xDB0DD4415C87DCF7ULLconst int640x7FFFFFFFFFFFFFFFULL(int64)0x7FFFFFFFFFFFFFFFULL0x8000000000000000ULL(int64)0x8000000000000000ULL-2147483647 - 10xFFFFFFFFFFFFFFFFULLUINT64_MINUINT32_MINUINT16_MIN0xFFUUINT8_MINlzhamdefined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__)//9223372036854775807i64;//(-9223372036854775807i64 - 1);//0xFFFFFFFFFFFFFFFFui64;// TODO// File: types.hassume_failure<true> &assume_failure<true> &&const assume_failure<true>const assume_failure<true> &assume_try<x>assume_failure<true>blahassume_failure<x>LZHAM_FAIL_EXCEPTION_CODELZHAM_ASSUME(p)typedef assume_try < sizeof(assume_failure< (bool)(p) > ) > LZHAM_JOIN(assume_typedef, __COUNTER__) __attribute__((unused))LZHAM_JOIN(a,b)LZHAM_JOINER(a, b)LZHAM_JOINER(a,b)LZHAM_JOINER_FINAL(a, b)LZHAM_JOINER_FINAL(a,b)LZHAM_ASSERT_CLOSED_RANGE(x,l,h)LZHAM_ASSERT((x >= l) && (x <= h))LZHAM_ASSERT_OPEN_RANGE(x,l,h)LZHAM_ASSERT((x >= l) && (x < h))LZHAM_FAIL(msg)do { lzham_fail(#msg, __FILE__, __LINE__); } while(0)LZHAM_VERIFY(_exp)(void)( (!!(_exp)) || (lzham_assert(#_exp, __FILE__, __LINE__), 0) )LZHAM_ASSERTS_ENABLEDLZHAM_ASSERT(_exp)// Borrowed from boost libraries.// File: lzham_assert.hconst char[85]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_huffman_codes.hcHuffmanMaxSupportedSymsgenerate_huffman_codesget_generate_huffman_codes_table_size//const uint cHuffmanMaxSupportedSyms = 600;// File: lzham_huffman_codes.hnum_symspFreqpCodesizesmax_code_sizetotal_freq_ret/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_huffman_codes.cpp"lzham_huffman_codes.h"huffman_work_tables &huffman_work_tables *max_freqtotal_freqnum_used_symssym_freq &sym_freq[2049]1025cHuffmanMaxSupportedSyms + 1cMaxInternalNodescHuffmanMaxSupportedSyms + 1 + cMaxInternalNodessym_freq *symscalculate_minimum_redundancyrootavbluseddpth34832sizeof(huffman_work_tables)radix_sort_symscMaxPassesuint[512]unsigned int[512]256 * cMaxPasseshistsizeof(hist[0])sizeof(hist[0]) * 256sizeof(hist[0]) * 256 * cMaxPassesfreq0freq1pCur_symspNew_symstotal_passespasspHistuint[256]offsetspass_shiftdst_offset0dst_offset1dst_offsetprev_freq!(pCur_syms[i].m_freq < prev_freq)syms0syms1huffman_work_tables &&const huffman_work_tablesconst huffman_work_tables &sym_freq &&const sym_freqconst sym_freq &const sym_freq *huffman_work_tablessym_frequint16[1024]unsigned short[1024]m_freq!USE_CALCULATE_MINIMUM_REDUNDANCY/* third pass, right to left, setting leaf depths *//* second pass, right to left, setting internal depths *//* add on the second item *//* select first item for a pairing *//* first pass, left to right, setting parent pointers *//* check for pathological cases *//* current depth of leaves *//* number of internal nodes *//* number of available nodes *//* next value to be assigned *//* next leaf to be used *//* next root node to be used */// calculate_minimum_redundancy() written by Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk November 1996.// File: huffman_codes.cpppair<_IntType, _IntType>pair<const _Tp &, const _Tp &>pair<_OutputIterator1, _OutputIterator2>__enable_if<__value, int>__enable_if<__value, bool>__enable_if<<expression>, bool>__promote_3__enable_if<__value, long long>__enable_if<__value, long>__promoted_t__promote<_Tp, __value>__is_char<_CharT>ostreambuf_iterator<_CharT, char_traits<_CharT>>__enable_if<__value, _CharT *>__enable_if<__value, _Deque_iterator<_CharT, _CharT &, _CharT *>>istreambuf_iterator<_CharT, char_traits<_CharT>>_Deque_iterator<_CharT, _CharT &, _CharT *>_CharT &_Safe_iterator<_IIte, _ISeq, _ICat>_Safe_iterator<_OIte, _OSeq, _OCat>__enable_if<<expression>, void>__normal_iterator<_Ite, _Cont>_Deque_iterator<_Tp, _Tp &, _Tp *>__enable_if<<expression>, _OutputIterator>__enable_if<__value, _OutputIterator>_Deque_iterator<_Tp1, _Ref1, _Ptr1>_Deque_iterator<_Tp2, _Ref2, _Ptr2>__is_random_access_iter<_II, __iterator_category_t<_II>>_Safe_iterator<_II1, _Seq1, _Cat1>_Safe_iterator<_II2, _Seq2, _Cat2>_Safe_iterator<_Iter1, _Seq1, _Cat1>_Safe_iterator<_Iter2, _Seq2, _Cat2>pair<_InputIterator1, _InputIterator2>_Iter_comp_to_iter<_Compare, _Iterator>iterator<iterator_category, value_type, difference_type, pointer, reference>reverse_iterator<_Iter>move_iterator<_Iter>__move_if_noexcept_cond<value_type>move_iterator<_Tp *>__replace_first_arg<_Tp, _Up>__difference<_Ptr, void>__rebind<_Tp, _Up, __void_t<rebind<_Up>>>__difference<_Tp, __void_t<difference_type>>__ptr_traits_impl<_Ptr, type>pointer_traits<_Ptr>_List_iterator<_Tp>integral_constant<unsigned long, 2UL>integral_constant<unsigned long, 2UL> &integral_constant<unsigned long, 2UL> &&const integral_constant<unsigned long, 2UL>const integral_constant<unsigned long, 2UL> &_Index_tuple<_Indexes2...>_Indexes2__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>_Nth_type<<expression>, _Rest...>_Np_Restintegral_constant<bool, <expression>>__and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>__is_constructible_impl<_Tp, const _Tp &>__is_constructible_impl<_Tp, _Tp &&>__is_move_constructible_impl<_Tp, value>__and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>>__and_<__is_copy_constructible_impl<_Tp, value>, integral_constant<bool, <expression>>>__is_trivially_copy_constructible_impl<_Tp, value>__and_<__is_move_constructible_impl<_Tp, value>, integral_constant<bool, <expression>>>__is_trivially_move_constructible_impl<_Tp, value>__is_trivially_copy_assignable_impl<_Tp, value>integral_constant<unsigned long, 0UL>integral_constant<unsigned long, 0UL> &integral_constant<unsigned long, 0UL> &&const integral_constant<unsigned long, 0UL>const integral_constant<unsigned long, 0UL> &integral_constant<unsigned long, <expression>>is_void<_To>__add_lvalue_reference_helper<_Tp, value>__select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select__select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &&const __select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>const __select<2UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true>__select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true> &__select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true> &&const __select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true>const __select<4UL, _List<unsigned int, unsigned long, unsigned long long>, true> &__select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> &&const __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false>const __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>__select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &&const __select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false>const __select<4UL, _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> &__select<sizeof(_Tp), _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, <expression>>_List<>_List<> &_List<> &&const _List<>const _List<> &_List<unsigned long long>_List<unsigned long long> &_List<unsigned long long> &&const _List<unsigned long long>const _List<unsigned long long> &_List<unsigned int, unsigned long, unsigned long long>_List<unsigned int, unsigned long, unsigned long long> &_List<unsigned int, unsigned long, unsigned long long> &&const _List<unsigned int, unsigned long, unsigned long long>const _List<unsigned int, unsigned long, unsigned long long> &_List<unsigned short, unsigned int, unsigned long, unsigned long long>_List<unsigned short, unsigned int, unsigned long, unsigned long long> &_List<unsigned short, unsigned int, unsigned long, unsigned long long> &&const _List<unsigned short, unsigned int, unsigned long, unsigned long long>const _List<unsigned short, unsigned int, unsigned long, unsigned long long> &__select<_Sz, _List<_UInts...>, <expression>>_List<_UInts...>_List<_Up...>__add_pointer_helper<_Tp, value>common_type<_Tp0, _Tp0>__common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>, void>common_type<type, _Rp...>__or_<is_void<_Ret>, __is_nothrow_convertible<type, _Ret>>integral_constant<bool, true>integral_constant<bool, true> &integral_constant<bool, true> &&const integral_constant<bool, true>const integral_constant<bool, true> &integral_constant<bool, false>integral_constant<bool, false> &integral_constant<bool, false> &&const integral_constant<bool, false>const integral_constant<bool, false> &__is_array_unknown_bounds<_NestedType>__or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>__or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>__or_<is_reference<_Tp>, is_scalar<_Tp>>is_volatile<_Qualified>__make_unsigned_selector<char16_t, false, true>__make_unsigned_selector<char16_t, false, true> &__make_unsigned_selector<char16_t, false, true> &&const __make_unsigned_selector<char16_t, false, true>const __make_unsigned_selector<char16_t, false, true> &__make_unsigned_selector<char32_t, false, true>__make_unsigned_selector<char32_t, false, true> &__make_unsigned_selector<char32_t, false, true> &&const __make_unsigned_selector<char32_t, false, true>const __make_unsigned_selector<char32_t, false, true> &__make_signed_selector<wchar_t, false, true>__make_signed_selector<wchar_t, false, true> &__make_signed_selector<wchar_t, false, true> &&const __make_signed_selector<wchar_t, false, true>const __make_signed_selector<wchar_t, false, true> &__make_signed_selector<char16_t, false, true>__make_signed_selector<char16_t, false, true> &__make_signed_selector<char16_t, false, true> &&const __make_signed_selector<char16_t, false, true>const __make_signed_selector<char16_t, false, true> &__make_signed_selector<char32_t, false, true>__make_signed_selector<char32_t, false, true> &__make_signed_selector<char32_t, false, true> &&const __make_signed_selector<char32_t, false, true>const __make_signed_selector<char32_t, false, true> &__or_<__is_referenceable<_Tp, void>, is_void<_Tp>>is_array<_Up>is_function<_Up>__result_of_success<decltype((<expression>)), __invoke_memfun_deref>__result_of_success<decltype((<expression>)), __invoke_memobj_deref>reference_wrapper<_Up>__result_of_success<decltype((<expression>)), __invoke_other>_Op<_Args...>__numeric_traits_floating<double>__numeric_traits_floating<double> &__numeric_traits_floating<double> &&const __numeric_traits_floating<double>const __numeric_traits_floating<double> &__numeric_traits_floating<long double>__numeric_traits_floating<long double> &__numeric_traits_floating<long double> &&const __numeric_traits_floating<long double>const __numeric_traits_floating<long double> &__is_integer<double>__is_integer<double> &__is_integer<double> &&const __is_integer<double>const __is_integer<double> &__is_integer<float>__is_integer<float> &__is_integer<float> &&const __is_integer<float>const __is_integer<float> &__traitor<__is_integer<_Tp>, __is_floating<_Tp>>__int_traits__iter_to_alloc_t__ptr_rebind__is_in_place_typeindex_sequence_formake_index_sequenceindex_sequencemake_integer_sequence__detected_orvalue_t__is_array_convertible__is_standard_integer__is_unsigned_integer__is_signed_integer__is_one_offalse_typetrue_type_PCCFP_Tp(+1)std::numeric_limits<_Tp>::quiet_NaN()__beta__comp_ellint_1__comp_ellint_2"Bad argument in __comp_ellint_2."Bad argument in __comp_ellint_2.__N("Bad argument in __comp_ellint_2.")__kk_Tp(3)__comp_ellint_3"Bad argument in __comp_ellint_3."Bad argument in __comp_ellint_3.__N("Bad argument in __comp_ellint_3.")_Tp(10)+_Tp(1)__ellint_1"Bad argument in __ellint_1."Bad argument in __ellint_1.const char[28]__N("Bad argument in __ellint_1.")__phi_red__ellint_2"Bad argument in __ellint_2."Bad argument in __ellint_2.__N("Bad argument in __ellint_2.")__ss__sss__cc__ellint_3"Bad argument in __ellint_3."Bad argument in __ellint_3.__N("Bad argument in __ellint_3.")__Pi__expint19.0_Tp(19)-19.0-_Tp(19)_Tp(20)4.0_Tp(4)-0.25-_Tp(0.25L)0.3333333433_Tp(1) / _Tp(3)0.6666666865_Tp(2) / _Tp(3)0.3550280631_Tp(0.35502805388781723926L)0.2588194013_Tp(0.25881940379280679840L)-0.2588194013-_Tp(0.25881940379280679840L)0.333333333333333333340.66666666666666666668-0.258819403792806798390.0001192092896_Tp(1000) * std::numeric_limits<_Tp>::epsilon()0.9950000048_Tp(0.995L)sizeof(_Tp)__numeric_constants<long double>__numeric_constants<long double> &__numeric_constants<long double> &&const __numeric_constants<long double>const __numeric_constants<long double> &__numeric_constants<float>__numeric_constants<float> &__numeric_constants<float> &&const __numeric_constants<float>const __numeric_constants<float> &integral_constant<bool, __v>type<_If, _Else>__or_<is_same<type, signed char>, is_same<type, signed short>, is_same<type, signed int>, is_same<type, signed long>, is_same<type, signed long long>, is_same<type, signed __int128_t>>__or_<is_same<type, unsigned char>, is_same<type, unsigned short>, is_same<type, unsigned int>, is_same<type, unsigned long>, is_same<type, unsigned long long>, is_same<type, __uint128_t>>__or_<__or_<is_same<type, signed char>, is_same<type, signed short>, is_same<type, signed int>, is_same<type, signed long>, is_same<type, signed long long>, is_same<type, signed __int128_t>>, __or_<is_same<type, unsigned char>, is_same<type, unsigned short>, is_same<type, unsigned int>, is_same<type, unsigned long>, is_same<type, unsigned long long>, is_same<type, __uint128_t>>>is_convertible<_FromElementType(*)[], _ToElementType(*)[]>_FromElementType[]_FromElementType(*)[]_ToElementType[]_ToElementType(*)[]_SomeTemplate<_Up, _Types...>pair<type, second_type>__enable_if<__value, _Tp>__promote<decltype((<expression>)), __value>__numeric_traits_integer<_Tp>__is_nothrow_convertible<type, _Ret>extent<_Tp, <expression>>__is_copy_constructible_impl<_Tp, value>__is_constructible_impl<_Tp>__not_<is_signed<_Tp>>__not_<extent<_Tp, 0U>>type<__and_<_B2, _B3, _Bn...>, _B1>type<const _Tp &, _Tp &&>__is_nothrow_swappable<_T2>__is_nothrow_swappable<_T1>type<const pair<_T1, _T2> &, const __nonesuch &>const pair<_T1, _T2>const pair<_T1, _T2> &pair<_T1, _T2> &type<const _Tp *, move_iterator<_Tp *>>type<_Iterator, move_iterator<_Iterator>>_Tp(0.16L)_Tp(6)_Tp(8)0.15999999641.73205080756887729361.7320508075688772935274463415058723Lstatic_cast<_Tp>(1.7320508075688772935274463415058723L)1.7320507761.14472988584940017421.1447298858494001741434273513530587Lstatic_cast<_Tp>(1.1447298858494001741434273513530587L)1.1447298534932.0std::numeric_limits<_Tp>::max_exponent10const long double[]long double[]const long double[29]long double[29]464sizeof(__prime)sizeof(__prime) / sizeof(_Tp)_Tp(5)_Tp(7)11.0_Tp(11)_Tp(13)17.0_Tp(17)23.0_Tp(23)29.0_Tp(29)31.0_Tp(31)_Tp(37)41.0_Tp(41)_Tp(43)47.0_Tp(47)53.0_Tp(53)59.0_Tp(59)61.0_Tp(61)67.0_Tp(67)71.0_Tp(71)73.0_Tp(73)79.0_Tp(79)83.0_Tp(83)89.0_Tp(89)97.0_Tp(97)101.0_Tp(101)103.0_Tp(103)107.0_Tp(107)109.0_Tp(109)38.01.57079632679489661931.5707963267948966192313216916397514L1.570796371static_cast<_Tp>(1.5707963267948966192313216916397514L)__expint_Ei1.084202172485504434e-18_Tp(10) * std::numeric_limits<_Tp>::epsilon()1.192092896e-06__ellint_rj__lolim1.6810515715560467531e-4931_Tp(5) * __min_Tp(1)/_Tp(3)"Argument less than zero " "in __ellint_rj.""Argument too small " "in __ellint_rj"Argument less than zero in __ellint_rj.__N("Argument less than zero "
                                      "in __ellint_rj.")Argument too small in __ellint_rj__N("Argument too small "
                                      "in __ellint_rj")__c0_Tp(1) / _Tp(4)__c114.0_Tp(14)0.21428571428571428572_Tp(3) / _Tp(14)__c2__c322.0_Tp(22)0.13636363636363636364_Tp(3) / _Tp(22)__c426.0_Tp(26)0.11538461538461538462_Tp(3) / _Tp(26)__xn__zn__pn__sigma__power4__errtol1.3552527156068805425e-20__eps / _Tp(8)_Tp(1) / _Tp(6)__xndev__yndev__zndev__pndev__ea__eb__ec__e3-0.21428571428571428572-__c10.40909090909090909093_Tp(3) * __c30.34615384615384615384_Tp(3) * __c4__c2 / _Tp(2)-0.13636363636363636364-__c3-0.27272727272727272728-__c3 - __c3__s3__iter__epsilon__xnroot__ynroot__znroot__lambda__alpha25.877471754e-380.21428571640.13636364040.1153846161.490116119e-080.1666666716-0.21428571640.40909093620.3461538553-0.1363636404-0.2727272809__ellint_rd"Argument less than zero " "in __ellint_rd.""Argument too small " "in __ellint_rd."Argument less than zero in __ellint_rd.__N("Argument less than zero "
                                      "in __ellint_rd.")Argument too small in __ellint_rd.__N("Argument too small "
                                      "in __ellint_rd.")9.0_Tp(9)0.40909090909090909091_Tp(9) / _Tp(22)__ed__ef-0.409090909090909090910.4090909064-0.4090909064__ellint_rf"Argument less than zero " "in __ellint_rf.""Argument too small in __ellint_rf"Argument less than zero in __ellint_rf.__N("Argument less than zero "
                                      "in __ellint_rf.")Argument too small in __ellint_rf__N("Argument too small in __ellint_rf")24.0_Tp(24)0.041666666666666666668_Tp(1) / _Tp(24)0.1_Tp(1) / _Tp(10)44.0_Tp(44)0.06818181818181818182_Tp(3) / _Tp(44)0.07142857142857142857_Tp(1) / _Tp(14)0.041666667910.10000000150.068181820210.07142857462__is_in_place_type_v__is_integer<decltype((<expression>))>is_same<_T2, _U2>is_same<_T1, _U1>__or_<_B2, _B3, _Bn...>__and_<_B2, _B3, _Bn...>extent<_Tp, 0U>__match_cv_qualifiers<wchar_t, unsigned int, false, false>__match_cv_qualifiers<wchar_t, unsigned int, false, false> &__match_cv_qualifiers<wchar_t, unsigned int, false, false> &&const __match_cv_qualifiers<wchar_t, unsigned int, false, false>const __match_cv_qualifiers<wchar_t, unsigned int, false, false> &__match_cv_qualifiers<char16_t, unsigned short, false, false>__match_cv_qualifiers<char16_t, unsigned short, false, false> &__match_cv_qualifiers<char16_t, unsigned short, false, false> &&const __match_cv_qualifiers<char16_t, unsigned short, false, false>const __match_cv_qualifiers<char16_t, unsigned short, false, false> &__make_signed_selector<unsigned int, true, false>__make_signed_selector<unsigned int, true, false> &__make_signed_selector<unsigned int, true, false> &&const __make_signed_selector<unsigned int, true, false>const __make_signed_selector<unsigned int, true, false> &__invoke_result<_Fn, _Args...>is_same<type, __uint128_t>is_same<type, unsigned long long>is_same<type, unsigned long>is_same<type, unsigned int>is_same<type, signed long>is_same<type, signed int>is_same<type, signed short>is_same<type, signed char>is_same<_Tp, _Types>__ellint_rc"Argument less than zero " "in __ellint_rc."Argument less than zero in __ellint_rc.__N("Argument less than zero "
                                      "in __ellint_rc.")0.1428571492_Tp(1) / _Tp(7)0.3000000119_Tp(3) / _Tp(10)0.375_Tp(3) / _Tp(8)_Tp(30)3.973643192e-09__eps / _Tp(30)__sn0.577215664901532860620.5772156649015328606065120900824024L0.5772156715static_cast<_Tp>(0.5772156649015328606065120900824024L)__match_cv_qualifiers<unsigned short, signed short, false, false>__match_cv_qualifiers<unsigned short, signed short, false, false> &__match_cv_qualifiers<unsigned short, signed short, false, false> &&const __match_cv_qualifiers<unsigned short, signed short, false, false>const __match_cv_qualifiers<unsigned short, signed short, false, false> &is_enum<unsigned short>is_enumis_enum<unsigned short> &is_enum<unsigned short> &&const is_enum<unsigned short>const is_enum<unsigned short> &__make_unsigned_selector<char16_t, true, false>__make_unsigned_selector<char16_t, true, false> &__make_unsigned_selector<char16_t, true, false> &&const __make_unsigned_selector<char16_t, true, false>const __make_unsigned_selector<char16_t, true, false> &__match_cv_qualifiers<unsigned int, signed int, false, false>__match_cv_qualifiers<unsigned int, signed int, false, false> &__match_cv_qualifiers<unsigned int, signed int, false, false> &&const __match_cv_qualifiers<unsigned int, signed int, false, false>const __match_cv_qualifiers<unsigned int, signed int, false, false> &is_integral<unsigned int>is_integralis_integral<unsigned int> &is_integral<unsigned int> &&const is_integral<unsigned int>const is_integral<unsigned int> &__make_unsigned_selector<wchar_t, true, false>__make_unsigned_selector<wchar_t, true, false> &__make_unsigned_selector<wchar_t, true, false> &&const __make_unsigned_selector<wchar_t, true, false>const __make_unsigned_selector<wchar_t, true, false> &__cv_selector<unsigned int, false, false>__cv_selector<unsigned int, false, false> &__cv_selector<unsigned int, false, false> &&const __cv_selector<unsigned int, false, false>const __cv_selector<unsigned int, false, false> &is_volatile<char32_t>is_volatileis_volatile<char32_t> &is_volatile<char32_t> &&const is_volatile<char32_t>const is_volatile<char32_t> &is_const<char32_t>is_constis_const<char32_t> &is_const<char32_t> &&const is_const<char32_t>const is_const<char32_t> &is_const<char16_t>is_const<char16_t> &is_const<char16_t> &&const is_const<char16_t>const is_const<char16_t> &is_volatile<wchar_t>is_volatile<wchar_t> &is_volatile<wchar_t> &&const is_volatile<wchar_t>const is_volatile<wchar_t> &is_const<wchar_t>is_const<wchar_t> &is_const<wchar_t> &&const is_const<wchar_t>const is_const<wchar_t> &const long double[9]long double[9]_Tp(7.5L)_Tp(0.9189385332046727417803297364056176L)_Tp( 0.99999999999980993227684700473478L)_Tp( 676.520368121885098567009190444019L)_Tp(-1259.13921672240287047156078755283L)_Tp( 771.3234287776530788486528258894L)_Tp(-176.61502916214059906584551354L)_Tp( 12.507343278686904814458936853L)_Tp(-0.13857109526572011689554707L)_Tp( 9.984369578019570859563e-6L)_Tp( 1.50563273514931155834e-7L)__expint_E1_asymp__esum__osum__expint_En_cont_frac__nm12.9743287383930794127e+4931_Tp(1) / __fp_min__ans"Continued fraction failed " "in __expint_En_cont_frac."Continued fraction failed in __expint_En_cont_frac.__N("Continued fraction failed "
                                     "in __expint_En_cont_frac.")__expint_E1_series8.507059173e+37is_volatile<unsigned int>is_volatile<unsigned int> &is_volatile<unsigned int> &&const is_volatile<unsigned int>const is_volatile<unsigned int> &is_volatile<unsigned short>is_volatile<unsigned short> &is_volatile<unsigned short> &&const is_volatile<unsigned short>const is_volatile<unsigned short> &const char[83]char[83]/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_decomp.hlzham_lib_set_memory_callbackslzham_lib_z_crc32lzham_lib_z_adler32lzham_lib_z_errorlzham_lib_z_uncompresslzham_lib_z_inflateEndlzham_lib_z_inflatelzham_lib_z_inflateResetlzham_lib_z_inflateInitlzham_lib_z_inflateInit2lzham_lib_decompress_memorylzham_lib_decompresslzham_lib_decompress_deinitlzham_lib_decompress_reinitlzham_lib_decompress_init// File: lzham_decomp.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_lzdecomp.cpp"lzham_decomp.h"const struct <unnamed>const struct <unnamed> &struct <unnamed> &struct <unnamed> &&struct <unnamed>[]s_error_descsstruct <unnamed>[10]sizeof(s_error_descs)sizeof(s_error_descs[0])sizeof(s_error_descs) / sizeof(s_error_descs[0])stream end"stream end"need dictionary"need dictionary"file error"file error"stream error"stream error"data error"data error"out of memory"out of memory"buf error"buf error"version error"version error"parameter error"parameter error"orig_avail_inlzham_decompressor *pDecomp-LZHAM_MIN_DICT_SIZE_LOG2sizeof(lzham_decompress_params)new_dict_sizepNew_dictCLZDecompBase::cMinDictSizeLog2 == LZHAM_MIN_DICT_SIZE_LOG2CLZDecompBase::cMinDictSizeLog2 == 15CLZDecompBase::cMaxDictSizeLog2 == LZHAM_MAX_DICT_SIZE_LOG2_X64CLZDecompBase::cMaxDictSizeLog2 == 29decomp_buf_sizecheck_paramsCLZDecompBase::cMinDictSizeLog2CLZDecompBase::cMaxDictSizeLog2lzham_decompressor &lzham_decompressor &&const lzham_decompressorconst lzham_decompressor &~lzham_decompressorlzham_decompressorCLZDecompBase::cNumStatesreset_huffman_table_update_ratesreset_all_tablesreset_arith_tablesreset_huff_tablesdict_size_maskunbufferedmatch_hist0match_hist1match_hist2match_hist3dst_ofsout_buf_sizepDst_endarith_valuearith_lengthbit_bufpDecode_buf_nextm_z_cmfbit_count < (int)(8)pDecode_buf_next == codec.m_pDecode_buf_end!codec.m_decode_buf_eofpDecode_buf_next < codec.m_pDecode_buf_endm_z_flgm_block_typeCLZDecompBase::cBlockHeaderBitsbit_count < (int)(CLZDecompBase::cBlockHeaderBits)m_tmpCLZDecompBase::cBlockFlushTypeBitsbit_count < (int)(CLZDecompBase::cBlockFlushTypeBits)dummy_resultbit_count & 7bit_count < (int)(bit_count & 7)bit_count < (int)(16)m_flush_num_bytes_remaining*m_pOut_buf_size(size_t)(m_flush_n - copy_ofs)cBytesToMemCpyPerIterationm_flush_n ? LZHAM_DECOMP_STATUS_NOT_FINISHED : LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUTdst_ofs >= m_dst_highwater_ofs!m_dst_highwater_ofsnum_raw_bytes_remainingbit_count < (int)(24)num_raw_bytes_check_bitsin_buf_remainingdict_size - dst_ofsdst_ofs == dict_sizeblock_flush_typematch_model_index < LZHAM_ARRAY_SIZE(m_is_match_model)match_model_index < (sizeof(m_is_match_model) / sizeof(decay_array_to_subtype(m_is_match_model)))is_match_bitm_is_match_model[match_model_index]arith_length < cSymbolCodecArithMinLen!is_match_bitdst_ofs >= out_buf_sizecur_state < CLZDecompBase::cNumLitStatesbit_count < 24pDecode_buf_next >= codec.m_pDecode_buf_endpDecode_buf_next - sizeof(uint32)k <= pTables->m_table_max_codek <= pTables->m_max_codes[len - 1]freq <= UINT16_MAX--pModel->m_symbols_until_update == 0dst_ofs > dict_size_maskm_is_rep_model[cur_state]m_is_rep0_model[cur_state]is_rep0_len1m_is_rep0_single_byte_model[cur_state]m_rep_len_table[cur_state >= CLZDecompBase::cNumLitStates]bit_count < (int)(1)s_huge_match_code_len[match_len]bit_count < (int)(s_huge_match_code_len[match_len])is_rep1m_is_rep1_model[cur_state]is_rep2m_is_rep2_model[cur_state]static_cast<int>(sym) < 0match_len == 9m_large_len_table[cur_state >= CLZDecompBase::cNumLitStates]num_extra_bits < 3bit_count < (int)(num_extra_bits)num_extra_bits > 4num_extra_bits - 4bit_count < (int)(num_extra_bits - 4)(((size_t)match_hist0 > dst_ofs) || ((dst_ofs + match_len) > out_buf_size))((LZHAM_MAX(src_ofs, dst_ofs) + match_len) > dict_size_mask)(((((src_ofs) < (dst_ofs)) ? (dst_ofs) : (src_ofs)) + match_len) > dict_size_mask)src_ofspCopy_src == pDst_endmatch_len > 0match_hist0 == 1match_len < 8((match_len < 8) || ((int)match_len > match_hist0))m_file_src_file_adler32update_interval_slow_rate370381CLZDecompBase::cLZXNumSpecialLengthsCLZDecompBase::cLZXLowestUsableMatchSlotCLZDecompBase::cNumHugeMatchCodesCLZDecompBase::cMaxMatchLenCLZDecompBase::cMinMatchLenCLZDecompBase::cMaxMatchLen - CLZDecompBase::cMinMatchLenCLZDecompBase::cMaxMatchLen - CLZDecompBase::cMinMatchLen + 1(CLZDecompBase::cMaxMatchLen - CLZDecompBase::cMinMatchLen + 1)CLZDecompBase::cNumHugeMatchCodes + (CLZDecompBase::cMaxMatchLen - CLZDecompBase::cMinMatchLen + 1)CLZDecompBase::cLZXNumSecondaryLengthsCLZDecompBase::cNumHugeMatchCodes + CLZDecompBase::cLZXNumSecondaryLengths431CLZDecompBase::cSyncBlock437445447453462copy_ofsbytes_to_copy473479483496CLZDecompBase::cRawBlockraw_bytes_remaining0raw_bytes_remaining1raw_bytes_remaining2517520536551559in_buf_ofs584588608623625CLZDecompBase::cCompBlock640651match_model_indexconst char[55]680pModel682705const decoder_tablesconst decoder_tables *pTables711const uint32 *val_ptrint[17]uint[17]uint16 *match_hist0_ofs737const uint8[24]unsigned char[24]pCopy_src774777780CLZDecompBase::cNumLitStates787CLZDecompBase::cMaxMatchLen + 1(CLZDecompBase::cMaxMatchLen + 1)796const uint8[4]801const uint[4]810819824828837CLZDecompBase::cLZXSpecialCodeEndOfBlockCodeCLZDecompBase::cLZXSpecialCodeEndOfBlockCode - CLZDecompBase::cLZXNumSpecialLengths(CLZDecompBase::cLZXSpecialCodeEndOfBlockCode - CLZDecompBase::cLZXNumSpecialLengths)898912929945CLZDecompBase::cNumLitStates + 3976pCopy_dst1054CLZDecompBase::cEOFBlock1074108010821083LZHAM_CR_INITIAL_STATEm_pDescm_errm_z_dict_adler32m_z_has_flushedm_z_first_callm_z_last_statusm_debug_litm_debug_match_distm_debug_match_lenm_debug_is_matchm_num_raw_bytes_remainingm_pCopy_srcm_src_ofsm_num_extra_bitsm_extra_bitsm_match_slotm_match_lenm_rep_lit0m_seed_bytes_to_ignore_when_flushingm_flush_nm_pFlush_srcm_start_block_dst_ofsm_match_hist3m_match_hist2m_match_hist1m_match_hist0m_initial_stepm_block_stepm_dst_highwater_ofsm_dst_ofsm_orig_out_buf_sizem_pOrig_out_bufm_no_more_input_bytes_flagm_decomp_adler32m_pDecomp_bufm_pRaw_decomp_bufm_raw_decomp_buf_sizem_lzBases_huge_match_code_lens_huge_match_base_lenCLZDecompBase::cMaxMatchLen + 1 + 2561538CLZDecompBase::cMaxMatchLen + 1 + 256 + 10245634CLZDecompBase::cMaxMatchLen + 1 + 256 + 1024 + 4096s_literal_next_stateLZHAM_RESTORE_LOCAL_STATELZHAM_SAVE_LOCAL_STATEmatch_len = m_match_len; src_ofs = m_src_ofs; pCopy_src = m_pCopy_src;m_match_len = match_len; m_src_ofs = src_ofs; m_pCopy_src = pCopy_src;match_len = m_match_len;m_match_len = match_len;match_len = m_match_len; match_slot = m_match_slot; extra_bits = m_extra_bits;m_match_len = match_len; m_match_slot = match_slot; m_extra_bits = extra_bits;match_len = m_match_len; match_slot = m_match_slot; num_extra_bits = m_num_extra_bits;m_match_len = match_len; m_match_slot = match_slot; m_num_extra_bits = num_extra_bits;match_len = m_match_len; match_slot = m_match_slot;m_match_len = match_len; m_match_slot = match_slot;rep_lit0 = m_rep_lit0;m_rep_lit0 = rep_lit0;num_raw_bytes_remaining = m_num_raw_bytes_remaining;m_num_raw_bytes_remaining = num_raw_bytes_remaining;LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec,result,model)LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_HUFFMAN(codec, result, model)LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_ofs)LZHAM_SAVE_STATE m_pFlush_src = m_pDecomp_buf + m_seed_bytes_to_ignore_when_flushing + m_dst_highwater_ofs; m_flush_num_bytes_remaining = dict_ofs - m_seed_bytes_to_ignore_when_flushing - m_dst_highwater_ofs; m_seed_bytes_to_ignore_when_flushing = 0; m_dst_highwater_ofs = dict_ofs & dict_size_mask; while (m_flush_num_bytes_remaining) { m_flush_n = LZHAM_MIN(m_flush_num_bytes_remaining, *m_pOut_buf_size); if (0 == (m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_COMPUTE_ADLER32)) { LZHAM_BULK_MEMCPY(m_pOut_buf, m_pFlush_src, m_flush_n); } else { size_t copy_ofs = 0; while (copy_ofs < m_flush_n) { const uint cBytesToMemCpyPerIteration = 8192U; size_t bytes_to_copy = LZHAM_MIN((size_t)(m_flush_n - copy_ofs), cBytesToMemCpyPerIteration); LZHAM_MEMCPY(m_pOut_buf + copy_ofs, m_pFlush_src + copy_ofs, bytes_to_copy); m_decomp_adler32 = adler32(m_pFlush_src + copy_ofs, bytes_to_copy, m_decomp_adler32); copy_ofs += bytes_to_copy; } } *m_pIn_buf_size = static_cast<size_t>(m_codec.decode_get_bytes_consumed()); *m_pOut_buf_size = m_flush_n; LZHAM_CR_RETURN(m_state, m_flush_n ? LZHAM_DECOMP_STATUS_NOT_FINISHED : LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT); m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag); m_pFlush_src += m_flush_n; m_flush_num_bytes_remaining -= m_flush_n; } LZHAM_RESTORE_STATELZHAM_MEMCPYLZHAM_BULK_MEMCPYLZHAM_DECODE_NEEDS_BYTESLZHAM_SAVE_STATE for ( ; ; ) { *m_pIn_buf_size = static_cast<size_t>(m_codec.decode_get_bytes_consumed()); *m_pOut_buf_size = 0; LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT); m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag); if ((m_codec.m_decode_buf_eof) || (m_codec.m_decode_buf_size)) break; } LZHAM_RESTORE_STATELZHAM_SAVE_STATELZHAM_SAVE_LOCAL_STATE m_match_hist0 = match_hist0; m_match_hist1 = match_hist1; m_match_hist2 = match_hist2; m_match_hist3 = match_hist3; m_cur_state = cur_state; m_dst_ofs = dst_ofs;LZHAM_RESTORE_STATELZHAM_RESTORE_LOCAL_STATE match_hist0 = m_match_hist0; match_hist1 = m_match_hist1; match_hist2 = m_match_hist2; match_hist3 = m_match_hist3; cur_state = m_cur_state; dst_ofs = m_dst_ofs;LZHAM_CR_FINISH}LZHAM_CR_RETURN(state,result)do { state = __LINE__; return (result); case __LINE__:; } while (0)LZHAM_CR_BEGIN(state)switch( state ) { case LZHAM_CR_INITIAL_STATE:// Something is wrong because the caller's output buffer should be large enough to hold the entire decompressed stream when flush==LZHAM_Z_FINISH.// If status is LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT, there must be at least 1 more byte on the way but the caller to lzham_decompress() supplied an empty output buffer.// (The output buffer at next_out MUST be large to hold the remaining uncompressed data when flush==LZHAM_Z_FINISH).// Caller has indicated that all remaining input was at next_in, and all remaining output will fit entirely in next_out.// Signal caller that we can't make forward progress without supplying more input, or by setting flush to LZHAM_Z_FINISH.// Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).// flushes it'll report how many bytes it has written since the call. // Also, the output buffer size must indicate the full size of the output buffer. The decompressor will track the current output offset, and during partial/sync// In unbuffered mode, the caller is not allowed to move the output buffer and the output pointer MUST always point to the beginning of the output buffer.// This block type is currently undefined.// Received EOF.// for ( ; ; )// lit or match// Handle matches of length 2 or higher.// Handle byte runs.// Match source or destination wraps around the end of the dictionary to the beginning, so handle the copy one byte at a time.// We have the match's length and distance, now do the copy.// Decode "huge" match length.// Match is >= 9 bytes, decode the actual length.// Low 3 bits of symbol = match length category, higher bits = distance category.// Must be cLZXSpecialCodePartialStateReset.// Handle special symbols.// Handle normal/full match.// Determine if match is a rep_match, and if so what type.// Handle match.// Determine delta literal's partial context.// Delta literal// Regular literal// Handle literal.// Read "is match" bit.// Copy the raw bytes.// Output buffer is not large enough.// Determine how many bytes we can safely memcpy() in a single call.// We need more bytes from the caller.// Now handle the bulk of the raw data with memcpy().// Flush any full bytes from the bit buffer.// Discard any partial bytes from the bit buffer (align up to the next byte).// Get and verify raw block length check bits.// Determine how large this raw block is.// Raw block handling is complex because we ultimately want to (safely) handle as many bytes as possible using a small number of memcpy()'s.// it *always* points to the beginning of the decompressed stream). The caller will need to track the current output buffer offset.// We assume the caller doesn't move the output buffer between calls AND the pointer to the output buffer input parameter won't change between calls (i.e.// Partial/sync flushes in unbuffered mode details:// unbuffered, or dst_ofs==0// It's a sync or full flush, so immediately give caller whatever output we have. Also gives the caller a chance to reposition the input stream ptr somewhere else before continuing.// See lzcompressor::send_sync_block() (TODO: make these an enum)            // See lzcompressor::send_sync_block() (TODO: make these an enum)// Reset either the symbol table update rates, or all statistics, then force a coroutine return to give the caller a chance to handle the output right now.// Sync block// Decode block type.// Output block loop.//LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, tmp, 2);//uint tmp;// Was written by lzcompressor::send_configuration().// Important: Do not use any switch() statements below here.// The most often used variables are in locals so the compiler hopefully puts them into CPU registers.// the right times. (This makes this function difficult to follow and freaking ugly due to the macros of doom - but hey it works.)// returns must be either be a member variable, or a local which is saved/restored to a member variable at// Important: This function is a coroutine. ANY locals variables that need to be preserved across coroutine//------------------------------------------------------------------------------------------------------------------// Decompression method. Implemented as a coroutine so it can be paused and resumed to support streaming.// Buffered mode only.// Flush the output buffer/dictionary by doing a coroutine return to the caller.// Helper that coroutine returns to the caller with a request for more input bytes.// Helpers to save/restore local variables (hopefully CPU registers) to memory.// Coroutine helpers.// Ordinarily I dislike macros like this, but in this case I think using them makes the decompression function easier to follow.// 12-23: unused// 7-11: match states// 0-6: literal states// http://www.sics.se/~adam/pt/// Also see "Protothreads - Lightweight, Stackless Threads in C":// http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html// See "Coroutines in C":// File: lzham_lzdecomp.cpp1656!unbuffered(!unbuffered)(unbuffered)(unbuffered) && (dst_ofs >= out_buf_size)(unbuffered) && ((dst_ofs + num_bytes_to_copy) > out_buf_size)(unbuffered) && (LZHAM_BUILTIN_EXPECT(dst_ofs >= out_buf_size, 0))(unbuffered) && LZHAM_BUILTIN_EXPECT((((size_t)match_hist0 > dst_ofs) || ((dst_ofs + match_len) > out_buf_size)), 0)unbuffered ? (dst_ofs - m_dst_highwater_ofs) : 0unbuffered ? UINT_MAX : (dict_size - 1)(!unbuffered) && (m_params.m_num_seed_bytes)(!unbuffered) && (dst_ofs)(!unbuffered) && (dst_ofs > dict_size_mask)(!unbuffered) && (LZHAM_BUILTIN_EXPECT(dst_ofs > dict_size_mask, 0))(!unbuffered) && LZHAM_BUILTIN_EXPECT( ((LZHAM_MAX(src_ofs, dst_ofs) + match_len) > dict_size_mask), 0)vector<output_symbol> *output_symbol *scalar_type<lzham_decompressor>scalar_type<lzham_decompressor> &scalar_type<lzham_decompressor> &&const scalar_type<lzham_decompressor>const scalar_type<lzham_decompressor> &CLZDecompBase &CLZDecompBase &&const CLZDecompBaseconst CLZDecompBase &table_update_settings &table_update_settings &&const table_update_settingsconst table_update_settings &CLZDecompBasecNumStatescNumLitStatescBlockCheckBitscLZHAMDebugSyncMarkerValue666cLZHAMDebugSyncMarkerBitscLZXSpecialCodeEndOfBlockCodecLZXSpecialCodePartialStateResetcLZXNumSecondaryLengthscNumHugeMatchCodescMaxHugeMatchCodeBitscLZXNumSpecialLengthscLZXLowestUsableMatchSlotcLZXMaxPositionSlotscMinMatchLen257UcMaxHugeMatchLencMaxLen2MatchDisttable_update_settingsm_num_lzx_slotsm_dict_sizem_slow_rateLZHAM_IS_MATCH_MODEL_INDEX(cur_state)(cur_state)init_position_slotsm_lzx_position_extra_bitsm_lzx_position_extra_maskm_lzx_position_baseg_table_update_settings//#define LZHAM_LZDEBUG// File: lzham_lzdecompbase.hdict_size_log2/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_lzdecompbase.cppdict_size_log2 >= LZHAM_MIN_DICT_SIZE_LOG2dict_size_log2 >= 15const char[94]dict_size_log2 <= LZHAM_MAX_DICT_SIZE_LOG2_X64dict_size_log2 <= 29(sizeof(g_table_update_settings) / sizeof(g_table_update_settings[0])) == LZHAM_FASTEST_TABLE_UPDATE_RATEtable_update_settings[20]const char[106]char[106]const uint8[15]unsigned char[15]const uint8[]g_num_lzx_position_slots16*2128+16*216*4128+16*416*6128+16*616*8128+16*816*10128+16*1016*12128+16*1216*14128+16*1416*16128+16*16CLZDecompBase::cLZXMaxPositionSlots//printf("%u, ", m_num_lzx_slots); }//for (dict_size_log2 = LZHAM_MIN_DICT_SIZE_LOG2; dict_size_log2 <= LZHAM_MAX_DICT_SIZE_LOG2_X64; dict_size_log2++) {// codec's internal default// crazy slow!// Keep in sync with LZHAM_DEFAULT_ADAPT_RATE, and LZHAM_DEFAULT_TABLE_UPDATE_RATE, etc.// File: lzham_lzdecompbase.cpp__ptr_traits_ptr_to<_Ptr, _Elt, value>_SomeTemplate<_Tp, _Types...>is_base_of<random_access_iterator_tag, _Cat>iterator_traits<_Iter>__or_<_Bn...>__result_of_memfun<type, type, _Args...>is_function<_To>__success_type<__decay_t<__cond_t<_Tp, _Up>>>__result_of_success<decltype((<expression>)), __invoke_memobj_ref>rebind<_Up>name proto __THROWNL __asm__ (__ASMNAME (#alias))name proto __THROW __asm__ (__ASMNAME (#alias))extern "C" {fct __THROW__LEAF_ATTR fct __THROWnoexcept (true)__GXX_EXPERIMENTAL_CXX0X___GLIBCXX_GTHREAD_USE_WEAK_GLIBCXX_NATIVE_THREAD_IDpthread_self()_GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC__GLIBC_PREREQ(2,23)_GLIBCXX_HAVE_GETS__NO_CTYPE_GLIBCXX_OS_DEFINES__GLIBC_PREREQ(2,15) && defined(_GNU_SOURCE)__GLIBC_PREREQ(2, 27)__GLIBC_PREREQ(2, 34)// libpthread.// Since glibc 2.34 all pthreads functions are usable without linking to// Otherwise use (__gthread_t)1 as the ID of the main (and only) thread.// So only use it if we know the libpthread version is available.// which breaks the invariant this_thread::get_id() != thread::id{}.// Before then it was in libc.so.6 but not libc.a, and always returns 0,// Since glibc 2.27 pthread_self() is usable without linking to libpthread.// version dynamically in case it has changed since libstdc++ was configured.// Glibc 2.23 removed the obsolete isinf and isnan declarations. Check the// __GNU_SOURCE is defined.// glibc 2.15 and later does not declare gets for ISO C11 when// Provide a declaration for the possibly deprecated gets function, as// This keeps isalnum, et al from being propagated as macros.// file will come before all others.// System-specific #define, typedefs, corrections, etc, go here.  This/** @file bits/os_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */// Specific definitions for GNU/Linux  -*- C++ -*-/usr/include/c++/12/x86_64-redhat-linux/bits/usr/include/c++/12/x86_64-redhat-linux_GLIBCXX_CPU_DEFINES/** @file bits/cpu_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */// Copyright (C) 2005-2022 Free Software Foundation, Inc.// Specific definitions for generic platforms  -*- C++ -*-_PSTL_ICC_18_OMP_SIMD_BROKEN(__INTEL_COMPILER == 1800)_PSTL_CPP11_STD_ROTATE_BROKEN((__GLIBCXX__ && __GLIBCXX__ < 20150716) || (_MSC_VER && _MSC_VER < 1800))_PSTL_PRAGMA_MESSAGE_POLICIES(x)_PSTL_PRAGMA_MESSAGE(x)_PSTL_PRAGMA_MESSAGE_IMPL(x)_PSTL_PRAGMA(message(_PSTL_STRING_CONCAT(_PSTL_PRAGMA_LOCATION, x)))_PSTL_PRAGMA_LOCATION" [Parallel STL message]: "_PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED_PSTL_PRAGMA_VECTOR_UNALIGNED_PSTL_PRAGMA_DECLARE_REDUCTION(NAME,OP)_PSTL_PRAGMA(omp declare reduction(NAME:OP : omp_out(omp_in)) initializer(omp_priv = omp_orig))_PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1,PRM2)_PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM)_PSTL_PRAGMA_SIMD_EARLYEXIT_PSTL_UDS_PRESENT(__INTEL_COMPILER >= 1900 && __INTEL_COMPILER_BUILD_DATE >= 20180626)_PSTL_UDR_PRESENT_PSTL_MONOTONIC_PRESENT_PSTL_EARLYEXIT_PRESENT(!__INTEL_COMPILER || __INTEL_COMPILER >= 1700) && (_MSC_FULL_VER >= 190023918 || __cplusplus >= 201402L)_PSTL_CPP14_INTEGER_SEQUENCE_PRESENT(_MSC_VER >= 1900 || __cplusplus >= 201402L)_PSTL_CPP14_MAKE_REVERSE_ITERATOR_PRESENT(_MSC_VER >= 1900 || __cplusplus >= 201402L || __cpp_lib_make_reverse_iterator == 201402)_PSTL_CPP14_2RANGE_MISMATCH_EQUAL_PRESENT(_MSC_VER >= 1900 || __cplusplus >= 201300L || __cpp_lib_robust_nonmodifying_seq_ops == 201304)_PSTL_CPP17_EXECUTION_POLICIES_PRESENT(_MSC_VER >= 1912)_PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM)_PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM)_PSTL_PRAGMA_SIMD_SCAN(PRM)_PSTL_PRAGMA_FORCEINLINE_PSTL_PRAGMA_SIMD_REDUCTION(PRM)_PSTL_PRAGMA(omp simd reduction(PRM))_PSTL_PRAGMA_DECLARE_SIMD_PSTL_PRAGMA(omp declare simd)_PSTL_PRAGMA_SIMD_PSTL_PRAGMA(omp simd)_PSTL_GCC_VERSION(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)_PSTL_HIDE_FROM_ABI_POP_PSTL_HIDE_FROM_ABI_PUSH_PSTL_STRING_CONCAT(x,y)x #y_PSTL_STRING(x)_PSTL_STRING_AUX(x)_PSTL_PRAGMA(x)_Pragma(#x)_PSTL_USAGE_WARNINGS_PSTL_VERSION_PATCH(_PSTL_VERSION % 10)_PSTL_VERSION_MINOR((_PSTL_VERSION % 1000) / 10)_PSTL_VERSION_MAJOR(_PSTL_VERSION / 1000)_PSTL_VERSION12000_PSTL_CONFIG_H!defined(_PSTL_PAR_BACKEND_SERIAL) && !defined(_PSTL_PAR_BACKEND_TBB)defined(PSTL_USAGE_WARNINGS)!defined(_PSTL_USAGE_WARNINGS)_PSTL_HIDE_FROM_ABI_PER_TU(_OPENMP >= 201307) || (__INTEL_COMPILER >= 1600) || (!defined(__INTEL_COMPILER) && _PSTL_GCC_VERSION >= 40900) || \(__INTEL_COMPILER)(__INTEL_COMPILER >= 1900 || !defined(__INTEL_COMPILER) && _PSTL_GCC_VERSION >= 40900 || _OPENMP >= 201307)(__INTEL_COMPILER >= 1600)defined(PSTL_USE_NONTEMPORAL_STORES) && (__INTEL_COMPILER >= 1600)_MSC_VER || __INTEL_COMPILER/* _PSTL_CONFIG_H */// broken macros//the preprocessors don't type a message location// Check the user-defined macro to use non-temporal stores// omp_orig - refers to the original variable to be reduced// omp_priv - refers to the private copy of the initial value// omp_out - refers to the final value of the combiner operator// omp_in - refers to the local partial result// OP - type of the callable object with the reduction operation// NAME - the name of the functor// Declaration of reduction functor, where// Should be defined to 1 for environments with a vendor implementation of C++17 execution policies//Enable SIMD//no simd//#pragma simd// Enable SIMD for compilers that support OpenMP 4.0// according to clang documentation, version can be vendor specific// the actual GCC version on the system.// note that when ICC or Clang is in use, _PSTL_GCC_VERSION might not fully match/* nothing */// Portability "#pragma" definition// Check the internal macro for warnings// Check the user-defined macro for warnings// The version is XYYZ, where X is major, YY is minor, and Z is patch (i.e. X.YY.Z)//===-- pstl_config.h -----------------------------------------------------===//<pstl/pstl_config.h><bits/cpu_defines.h><bits/os_defines.h>__is_constant_evaluated__builtin_is_constant_evaluatedterminate__terminate_GTHREAD_USE_MUTEX_TIMEDLOCK_GLIBCXX_X86_RDSEED_GLIBCXX_X86_RDRAND_GLIBCXX_VERBOSE_GLIBCXX_USE_UTIMENSAT_GLIBCXX_USE_UTIME_GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_FCHAR8_T_GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_CXX20_GLIBCXX_USE_TMPNAM_GLIBCXX_USE_ST_MTIM_GLIBCXX_USE_SENDFILE_GLIBCXX_USE_SC_NPROCESSORS_ONLN_GLIBCXX_USE_SCHED_YIELD_GLIBCXX_USE_REALPATH_GLIBCXX_USE_RANDOM_TR1_GLIBCXX_USE_PTHREAD_RWLOCK_T_GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK_GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT_GLIBCXX_USE_NLS_GLIBCXX_USE_NANOSLEEP_GLIBCXX_USE_LSTAT_GLIBCXX_USE_LONG_LONG_GLIBCXX_USE_LFS_GLIBCXX_USE_GET_NPROCS_GLIBCXX_USE_GETTIMEOFDAY_GLIBCXX_USE_FCHMODAT_GLIBCXX_USE_FCHMOD_GLIBCXX_USE_DEV_RANDOM_GLIBCXX_USE_DECIMAL_FLOAT_GLIBCXX_USE_CLOCK_REALTIME_GLIBCXX_USE_CLOCK_MONOTONIC_GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1_GLIBCXX_USE_C99_INTTYPES_TR1_GLIBCXX_USE_C99_FENV_TR1_GLIBCXX_USE_C99_CTYPE_TR1_GLIBCXX_USE_C99_COMPLEX_TR1_GLIBCXX_USE_C99_GLIBCXX_USE_C11_UCHAR_CXX11_GLIBCXX_SYMVER_GNU_GLIBCXX_SYMVER_GLIBCXX_STDIO_SEEK_END_GLIBCXX_STDIO_SEEK_CUR_GLIBCXX_STDIO_EOF_GLIBCXX_RES_LIMITS_GLIBCXX_MANGLE_SIZE_T_GLIBCXX_HAS_GTHREADS_GLIBCXX_FULLY_DYNAMIC_STRING_GLIBCXX_ATOMIC_BUILTINS_GLIBCXX98_USE_C99_WCHAR_GLIBCXX98_USE_C99_STDLIB_GLIBCXX98_USE_C99_STDIO_GLIBCXX98_USE_C99_MATH_GLIBCXX98_USE_C99_COMPLEX_GLIBCXX11_USE_C99_WCHAR_GLIBCXX11_USE_C99_STDLIB_GLIBCXX11_USE_C99_STDIO_GLIBCXX11_USE_C99_MATH_GLIBCXX11_USE_C99_COMPLEX_GLIBCXX_DARWIN_USE_64_BIT_INODE_GLIBCXX_STDC_HEADERS_GLIBCXX_PACKAGE__GLIBCXX_VERSION"version-unused"_GLIBCXX_PACKAGE_URL_GLIBCXX_PACKAGE_TARNAME"libstdc++"_GLIBCXX_PACKAGE_STRING"package-unused version-unused"_GLIBCXX_PACKAGE_NAME"package-unused"_GLIBCXX_PACKAGE_BUGREPORT_GLIBCXX_LT_OBJDIR".libs/"_GLIBCXX_ICONV_CONST_GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL_GLIBCXX_HAVE_WRITEV_GLIBCXX_HAVE_WCTYPE_H_GLIBCXX_HAVE_WCSTOF_GLIBCXX_HAVE_WCHAR_H_GLIBCXX_HAVE_VWSCANF_GLIBCXX_HAVE_VSWSCANF_GLIBCXX_HAVE_VFWSCANF_GLIBCXX_HAVE_UTIME_H_GLIBCXX_HAVE_USELOCALE_GLIBCXX_HAVE_UNLINKAT_GLIBCXX_HAVE_UNISTD_H_GLIBCXX_HAVE_UCHAR_H_GLIBCXX_HAVE_TRUNCATE_GLIBCXX_HAVE_TLS_GLIBCXX_HAVE_TIMESPEC_GET_GLIBCXX_HAVE_TGMATH_H_GLIBCXX_HAVE_TANL_GLIBCXX_HAVE_TANHL_GLIBCXX_HAVE_TANHF_GLIBCXX_HAVE_TANF_GLIBCXX_HAVE_S_ISREG_GLIBCXX_HAVE_SYS_UIO_H_GLIBCXX_HAVE_SYS_TYPES_H_GLIBCXX_HAVE_SYS_TIME_H_GLIBCXX_HAVE_SYS_SYSINFO_H_GLIBCXX_HAVE_SYS_STAT_H_GLIBCXX_HAVE_SYS_STATVFS_H_GLIBCXX_HAVE_SYS_SOCKET_H_GLIBCXX_HAVE_SYS_SEM_H_GLIBCXX_HAVE_SYS_SDT_H_GLIBCXX_HAVE_SYS_RESOURCE_H_GLIBCXX_HAVE_SYS_PARAM_H_GLIBCXX_HAVE_SYS_MMAN_H_GLIBCXX_HAVE_SYS_IPC_H_GLIBCXX_HAVE_SYS_IOCTL_H_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT_GLIBCXX_HAVE_SYMLINK_GLIBCXX_HAVE_STRXFRM_L_GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE_GLIBCXX_HAVE_STRTOLD_GLIBCXX_HAVE_STRTOF_GLIBCXX_HAVE_STRING_H_GLIBCXX_HAVE_STRINGS_H_GLIBCXX_HAVE_STRERROR_R_GLIBCXX_HAVE_STRERROR_L_GLIBCXX_HAVE_STDLIB_H_GLIBCXX_HAVE_STDINT_H_GLIBCXX_HAVE_STDBOOL_H_GLIBCXX_HAVE_STDALIGN_H_GLIBCXX_HAVE_STACKTRACE_GLIBCXX_HAVE_SQRTL_GLIBCXX_HAVE_SQRTF_GLIBCXX_HAVE_SOCKATMARK_GLIBCXX_HAVE_SINL_GLIBCXX_HAVE_SINHL_GLIBCXX_HAVE_SINHF_GLIBCXX_HAVE_SINF_GLIBCXX_HAVE_SINCOSL_GLIBCXX_HAVE_SINCOSF_GLIBCXX_HAVE_SINCOS_GLIBCXX_HAVE_SETENV_GLIBCXX_HAVE_SECURE_GETENV_GLIBCXX_HAVE_READLINK_GLIBCXX_HAVE_POWL_GLIBCXX_HAVE_POWF_GLIBCXX_HAVE_POSIX_SEMAPHORE_GLIBCXX_HAVE_POSIX_MEMALIGN_GLIBCXX_HAVE_POLL_H_GLIBCXX_HAVE_POLL_GLIBCXX_HAVE_OPENAT_GLIBCXX_HAVE_NETINET_TCP_H_GLIBCXX_HAVE_NETINET_IN_H_GLIBCXX_HAVE_NETDB_H_GLIBCXX_HAVE_MODFL_GLIBCXX_HAVE_MODFF_GLIBCXX_HAVE_MODF_GLIBCXX_HAVE_MEMORY_H_GLIBCXX_HAVE_MEMALIGN_GLIBCXX_HAVE_LOGL_GLIBCXX_HAVE_LOGF_GLIBCXX_HAVE_LOG10L_GLIBCXX_HAVE_LOG10F_GLIBCXX_HAVE_LOCALE_H_GLIBCXX_HAVE_LINUX_TYPES_H_GLIBCXX_HAVE_LINUX_RANDOM_H_GLIBCXX_HAVE_LINUX_FUTEX_GLIBCXX_HAVE_LINK_H_GLIBCXX_HAVE_LINK_GLIBCXX_HAVE_LIMIT_VMEM_GLIBCXX_HAVE_LIMIT_RSS_GLIBCXX_HAVE_LIMIT_FSIZE_GLIBCXX_HAVE_LIMIT_DATA_GLIBCXX_HAVE_LIMIT_AS_GLIBCXX_HAVE_LIBINTL_H_GLIBCXX_HAVE_LDEXPL_GLIBCXX_HAVE_LDEXPF_GLIBCXX_HAVE_LC_MESSAGES_GLIBCXX_HAVE_ISWBLANK_GLIBCXX_HAVE_ISNANL_GLIBCXX_HAVE_ISNANF_GLIBCXX_HAVE_ISINFL_GLIBCXX_HAVE_ISINFF_GLIBCXX_HAVE_INTTYPES_H_GLIBCXX_HAVE_ICONV_GLIBCXX_HAVE_HYPOTL_GLIBCXX_HAVE_HYPOTF_GLIBCXX_HAVE_HYPOT_GLIBCXX_HAVE_GETIPINFO_GLIBCXX_HAVE_GETENTROPY_GLIBCXX_HAVE_FREXPL_GLIBCXX_HAVE_FREXPF_GLIBCXX_HAVE_FMODL_GLIBCXX_HAVE_FMODF_GLIBCXX_HAVE_FLOORL_GLIBCXX_HAVE_FLOORF_GLIBCXX_HAVE_FLOAT_H_GLIBCXX_HAVE_FINITEL_GLIBCXX_HAVE_FINITEF_GLIBCXX_HAVE_FINITE_GLIBCXX_HAVE_FENV_H_GLIBCXX_HAVE_FDOPENDIR_GLIBCXX_HAVE_FCNTL_H_GLIBCXX_HAVE_FABSL_GLIBCXX_HAVE_FABSF_GLIBCXX_HAVE_EXPL_GLIBCXX_HAVE_EXPF_GLIBCXX_HAVE_EXECINFO_H_GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46_GLIBCXX_HAVE_ENDIAN_H_GLIBCXX_HAVE_DLFCN_H_GLIBCXX_HAVE_DIRFD_GLIBCXX_HAVE_DIRENT_H_GLIBCXX_HAVE_DECL_STRNLEN_GLIBCXX_HAVE_COSL_GLIBCXX_HAVE_COSHL_GLIBCXX_HAVE_COSHF_GLIBCXX_HAVE_COSF_GLIBCXX_HAVE_COMPLEX_H_GLIBCXX_HAVE_CEILL_GLIBCXX_HAVE_CEILF_GLIBCXX_HAVE_ATOMIC_LOCK_POLICY_GLIBCXX_HAVE_ATANL_GLIBCXX_HAVE_ATANF_GLIBCXX_HAVE_ATAN2L_GLIBCXX_HAVE_ATAN2F_GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE_GLIBCXX_HAVE_ASINL_GLIBCXX_HAVE_ASINF_GLIBCXX_HAVE_ARPA_INET_H_GLIBCXX_HAVE_ARC4RANDOM_GLIBCXX_HAVE_ALIGNED_ALLOC_GLIBCXX_HAVE_ACOSL_GLIBCXX_HAVE_ACOSF_PSTL_ASSERT_MSG(_Condition,_Message)__glibcxx_assert(_Condition)_PSTL_ASSERT(_Condition)_PSTL_PAR_BACKEND_SERIAL_GLIBCXX_USE_TBB_PAR_BACKEND__has_include(<tbb/tbb.h>)_GLIBCXX_HAS_BUILTIN_GLIBCXX_HAS_BUILTIN(B)__has_builtin(B) || ! __is_identifier(B)_GLIBCXX_DOUBLE_IS_IEEE_BINARY64_GLIBCXX_FLOAT_IS_IEEE_BINARY32_GLIBCXX_USE_FLOAT128_GLIBCXX_USE_C99_WCHAR_GLIBCXX_USE_C99_STDIO_GLIBCXX_USE_C99_COMPLEX__N(msgid)(msgid)_GLIBCXX_FAST_MATH_GLIBCXX_TXN_SAFE_DYN_GLIBCXX_TXN_SAFE_GLIBCXX_USE_WEAK_REF__GXX_WEAK___GLIBCXX_WEAK_DEFINITION_GLIBCXX_PSEUDO_VISIBILITY(V)_GLIBCXX_USE_ALLOCATOR_NEW_GLIBCXX_END_EXTERN_C_GLIBCXX_BEGIN_EXTERN_C_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)__glibcxx_assert(cond)do { __glibcxx_constexpr_assert(cond); } while (false)_GLIBCXX_VERBOSE_ASSERT__glibcxx_constexpr_assert(cond)if (std::__is_constant_evaluated() && !bool(cond)) __builtin_unreachable()_GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11_GLIBCXX_END_NAMESPACE_CXX11_GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11_GLIBCXX_BEGIN_NAMESPACE_CXX11_GLIBCXX_NAMESPACE_LDBL_OR_CXX11_GLIBCXX_NAMESPACE_CXX11_GLIBCXX_END_NAMESPACE_LDBL_GLIBCXX_BEGIN_NAMESPACE_LDBL_GLIBCXX_NAMESPACE_LDBL_GLIBCXX_LONG_DOUBLE_COMPAT_GLIBCXX_END_NAMESPACE_ALGO_GLIBCXX_BEGIN_NAMESPACE_ALGO_GLIBCXX_STD_A_GLIBCXX_END_NAMESPACE_CONTAINER_GLIBCXX_BEGIN_NAMESPACE_CONTAINER_GLIBCXX_STD_C_GLIBCXX_END_NAMESPACE_VERSION_GLIBCXX_BEGIN_NAMESPACE_VERSION_GLIBCXX_INLINE_VERSION_GLIBCXX_DEFAULT_ABI_TAG_GLIBCXX_ABI_TAG_CXX11namespace __cxx11 {__cxx11::_GLIBCXX_USE_CXX11_ABI_GLIBCXX_USE_DUAL_ABI_GLIBCXX_EXTERN_TEMPLATE_GLIBCXX_NOEXCEPT_QUALnoexcept (_NE)_GLIBCXX_NOEXCEPT_PARM, bool _NE_GLIBCXX_THROW_OR_ABORT(_EXC)(throw (_EXC))_GLIBCXX_NOTHROW_GLIBCXX_USE_NOEXCEPT_GLIBCXX_THROW(_EXC)noexcept_GLIBCXX_NOEXCEPT_IF(__VA_ARGS__...)noexcept(__VA_ARGS__)_GLIBCXX_NOEXCEPT_GLIBCXX17_INLINE_GLIBCXX23_CONSTEXPR_GLIBCXX20_CONSTEXPR_GLIBCXX17_CONSTEXPRconstexpr_GLIBCXX14_CONSTEXPR_GLIBCXX_USE_CONSTEXPR_GLIBCXX_CONSTEXPR_GLIBCXX_NODISCARD[[__nodiscard__]]__attribute ((__abi_tag__ ("cxx11")))_GLIBCXX20_DEPRECATED_SUGGEST(ALT)_GLIBCXX20_DEPRECATED(MSG)_GLIBCXX17_DEPRECATED_SUGGEST(ALT)_GLIBCXX_DEPRECATED_SUGGEST(ALT)_GLIBCXX17_DEPRECATED[[__deprecated__]]_GLIBCXX14_DEPRECATED_SUGGEST(ALT)_GLIBCXX14_DEPRECATED_GLIBCXX_DEPRECATED_GLIBCXX11_DEPRECATED_SUGGEST(ALT)_GLIBCXX11_DEPRECATED__attribute__ ((__deprecated__ ("use '" ALT "' instead")))_GLIBCXX_USE_DEPRECATED_GLIBCXX_VISIBILITY(V)__attribute__ ((__visibility__ (#V)))_GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY_GLIBCXX_NORETURN__attribute__ ((__noreturn__))_GLIBCXX_CONST_GLIBCXX_PURE__GLIBCXX__20221121_GLIBCXX_RELEASE_GLIBCXX_CXX_CONFIG_H_CPP_CPPCONFIG_WRAPPER__gnu_cxx__cxx11defined(__DEPRECATED)defined(__DEPRECATED) && (__cplusplus >= 201103L)defined(__DEPRECATED) && (__cplusplus >= 201402L)defined(__DEPRECATED) && (__cplusplus >= 201703L)defined(__DEPRECATED) && (__cplusplus >= 202002L)__cplusplus >= 202100L_GLIBCXX_THROW_OR_ABORT__cpp_exceptions__cpp_noexcept_function_type! _GLIBCXX_USE_DUAL_ABIdefined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL)defined(_GLIBCXX_DEBUG) && defined(_GLIBCXX_PARALLEL)__NO_INLINE__ && !__GXX_WEAK__defined(_GLIBCXX_DEBUG)defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128____cplusplus >= 201103L && __has_builtin(__builtin_is_constant_evaluated)defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_ASSERTIONS)_GLIBCXX_ASSERTIONSdefined(_GLIBCXX_ASSERTIONS) \defined(_GLIBCXX_ASSERTIONS)__SANITIZE_THREAD__defined __has_feature__has_feature(thread_sanitizer)_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER! defined __GLIBCXX_TYPE_INT_N_0 && ! defined __STRICT_ANSI___GLIBCXX_PSEUDO_VISIBILITY__cplusplus >= 201103L && _GLIBCXX_USE_CXX11_ABI			\__cpp_char8_tdefined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__)!(defined(_GLIBCXX_LONG_DOUBLE_ALT128_COMPAT) && defined(__LONG_DOUBLE_IEEE128__))__FLT_MANT_DIG__ == 24 \__DBL_MANT_DIG__ == 53 \__is_identifier_GLIBCXX_HAS_BUILTIN(__has_unique_object_representations)_GLIBCXX_HAS_BUILTIN(__is_aggregate)_GLIBCXX_HAS_BUILTIN(__is_same)_GLIBCXX_HAS_BUILTIN(__builtin_launder)__has_include(<pstl/pstl_config.h>)defined (_GLIBCXX_HAVE__ACOSF) && ! defined (_GLIBCXX_HAVE_ACOSF)defined (_GLIBCXX_HAVE__ACOSL) && ! defined (_GLIBCXX_HAVE_ACOSL)defined (_GLIBCXX_HAVE__ASINF) && ! defined (_GLIBCXX_HAVE_ASINF)defined (_GLIBCXX_HAVE__ASINL) && ! defined (_GLIBCXX_HAVE_ASINL)defined (_GLIBCXX_HAVE__ATAN2F) && ! defined (_GLIBCXX_HAVE_ATAN2F)defined (_GLIBCXX_HAVE__ATAN2L) && ! defined (_GLIBCXX_HAVE_ATAN2L)defined (_GLIBCXX_HAVE__ATANF) && ! defined (_GLIBCXX_HAVE_ATANF)defined (_GLIBCXX_HAVE__ATANL) && ! defined (_GLIBCXX_HAVE_ATANL)defined (_GLIBCXX_HAVE__CEILF) && ! defined (_GLIBCXX_HAVE_CEILF)defined (_GLIBCXX_HAVE__CEILL) && ! defined (_GLIBCXX_HAVE_CEILL)defined (_GLIBCXX_HAVE__COSF) && ! defined (_GLIBCXX_HAVE_COSF)defined (_GLIBCXX_HAVE__COSHF) && ! defined (_GLIBCXX_HAVE_COSHF)defined (_GLIBCXX_HAVE__COSHL) && ! defined (_GLIBCXX_HAVE_COSHL)defined (_GLIBCXX_HAVE__COSL) && ! defined (_GLIBCXX_HAVE_COSL)defined (_GLIBCXX_HAVE__EXPF) && ! defined (_GLIBCXX_HAVE_EXPF)defined (_GLIBCXX_HAVE__EXPL) && ! defined (_GLIBCXX_HAVE_EXPL)defined (_GLIBCXX_HAVE__FABSF) && ! defined (_GLIBCXX_HAVE_FABSF)defined (_GLIBCXX_HAVE__FABSL) && ! defined (_GLIBCXX_HAVE_FABSL)defined (_GLIBCXX_HAVE__FINITE) && ! defined (_GLIBCXX_HAVE_FINITE)defined (_GLIBCXX_HAVE__FINITEF) && ! defined (_GLIBCXX_HAVE_FINITEF)defined (_GLIBCXX_HAVE__FINITEL) && ! defined (_GLIBCXX_HAVE_FINITEL)defined (_GLIBCXX_HAVE__FLOORF) && ! defined (_GLIBCXX_HAVE_FLOORF)defined (_GLIBCXX_HAVE__FLOORL) && ! defined (_GLIBCXX_HAVE_FLOORL)defined (_GLIBCXX_HAVE__FMODF) && ! defined (_GLIBCXX_HAVE_FMODF)defined (_GLIBCXX_HAVE__FMODL) && ! defined (_GLIBCXX_HAVE_FMODL)defined (_GLIBCXX_HAVE__FPCLASS) && ! defined (_GLIBCXX_HAVE_FPCLASS)defined (_GLIBCXX_HAVE__FREXPF) && ! defined (_GLIBCXX_HAVE_FREXPF)defined (_GLIBCXX_HAVE__FREXPL) && ! defined (_GLIBCXX_HAVE_FREXPL)defined (_GLIBCXX_HAVE__HYPOT) && ! defined (_GLIBCXX_HAVE_HYPOT)defined (_GLIBCXX_HAVE__HYPOTF) && ! defined (_GLIBCXX_HAVE_HYPOTF)defined (_GLIBCXX_HAVE__HYPOTL) && ! defined (_GLIBCXX_HAVE_HYPOTL)defined (_GLIBCXX_HAVE__ISINF) && ! defined (_GLIBCXX_HAVE_ISINF)defined (_GLIBCXX_HAVE__ISINFF) && ! defined (_GLIBCXX_HAVE_ISINFF)defined (_GLIBCXX_HAVE__ISINFL) && ! defined (_GLIBCXX_HAVE_ISINFL)defined (_GLIBCXX_HAVE__ISNAN) && ! defined (_GLIBCXX_HAVE_ISNAN)defined (_GLIBCXX_HAVE__ISNANF) && ! defined (_GLIBCXX_HAVE_ISNANF)defined (_GLIBCXX_HAVE__ISNANL) && ! defined (_GLIBCXX_HAVE_ISNANL)defined (_GLIBCXX_HAVE__LDEXPF) && ! defined (_GLIBCXX_HAVE_LDEXPF)defined (_GLIBCXX_HAVE__LDEXPL) && ! defined (_GLIBCXX_HAVE_LDEXPL)defined (_GLIBCXX_HAVE__LOG10F) && ! defined (_GLIBCXX_HAVE_LOG10F)defined (_GLIBCXX_HAVE__LOG10L) && ! defined (_GLIBCXX_HAVE_LOG10L)defined (_GLIBCXX_HAVE__LOGF) && ! defined (_GLIBCXX_HAVE_LOGF)defined (_GLIBCXX_HAVE__LOGL) && ! defined (_GLIBCXX_HAVE_LOGL)defined (_GLIBCXX_HAVE__MODF) && ! defined (_GLIBCXX_HAVE_MODF)defined (_GLIBCXX_HAVE__MODFF) && ! defined (_GLIBCXX_HAVE_MODFF)defined (_GLIBCXX_HAVE__MODFL) && ! defined (_GLIBCXX_HAVE_MODFL)defined (_GLIBCXX_HAVE__POWF) && ! defined (_GLIBCXX_HAVE_POWF)defined (_GLIBCXX_HAVE__POWL) && ! defined (_GLIBCXX_HAVE_POWL)defined (_GLIBCXX_HAVE__QFPCLASS) && ! defined (_GLIBCXX_HAVE_QFPCLASS)defined (_GLIBCXX_HAVE__SINCOS) && ! defined (_GLIBCXX_HAVE_SINCOS)defined (_GLIBCXX_HAVE__SINCOSF) && ! defined (_GLIBCXX_HAVE_SINCOSF)defined (_GLIBCXX_HAVE__SINCOSL) && ! defined (_GLIBCXX_HAVE_SINCOSL)defined (_GLIBCXX_HAVE__SINF) && ! defined (_GLIBCXX_HAVE_SINF)defined (_GLIBCXX_HAVE__SINHF) && ! defined (_GLIBCXX_HAVE_SINHF)defined (_GLIBCXX_HAVE__SINHL) && ! defined (_GLIBCXX_HAVE_SINHL)defined (_GLIBCXX_HAVE__SINL) && ! defined (_GLIBCXX_HAVE_SINL)defined (_GLIBCXX_HAVE__SQRTF) && ! defined (_GLIBCXX_HAVE_SQRTF)defined (_GLIBCXX_HAVE__SQRTL) && ! defined (_GLIBCXX_HAVE_SQRTL)defined (_GLIBCXX_HAVE__STRTOF) && ! defined (_GLIBCXX_HAVE_STRTOF)defined (_GLIBCXX_HAVE__STRTOLD) && ! defined (_GLIBCXX_HAVE_STRTOLD)defined (_GLIBCXX_HAVE__TANF) && ! defined (_GLIBCXX_HAVE_TANF)defined (_GLIBCXX_HAVE__TANHF) && ! defined (_GLIBCXX_HAVE_TANHF)defined (_GLIBCXX_HAVE__TANHL) && ! defined (_GLIBCXX_HAVE_TANHL)defined (_GLIBCXX_HAVE__TANL) && ! defined (_GLIBCXX_HAVE_TANL)__builtin_launder__is_same__is_aggregate__has_unique_object_representations__SIZEOF_FLOAT128__199711L__DEPRECATED// _GLIBCXX_CXX_CONFIG_H/* #undef __CORRECT_ISO_CPP11_MATH_H_PROTO_INT *//* Define if all C++11 integral type overloads are available in <math.h>.  *//* #undef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP *//* Define if all C++11 floating point overloads are available in <math.h>.  *//* #undef _GLIBCXX_LARGE_FILES *//* Define for large files, on AIX-style hosts. *//* Define to 1 if mutex_timedlock is available. *//* Defined if as can handle rdseed. *//* Defined if as can handle rdrand. *//* Define to 1 if a verbose library is built, or 0 otherwise. *//* Define if code specialized for wchar_t should be used. *//* Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and
   AT_FDCWD in <fcntl.h>. *//* Define if utime is available in <utime.h>. *//* Define if c8rtomb and mbrtoc8 functions in <uchar.h> should be imported
   into namespace std in <cuchar> for -fchar8_t. *//* Define if c8rtomb and mbrtoc8 functions in <uchar.h> should be imported
   into namespace std in <cuchar> for C++20. *//* Define if obsolescent tmpnam is available in <stdio.h>. *//* #undef _GLIBCXX_USE_SYSCTL_HW_NCPU *//* Define if sysctl(), CTL_HW and HW_NCPU are available in <sys/sysctl.h>. *//* Define if struct stat has timespec members. *//* #undef _GLIBCXX_USE_STDIO_PURE *//* Define to restrict std::__basic_file<> to stdio APIs. *//* Define if sendfile is available in <sys/sendfile.h>. *//* #undef _GLIBCXX_USE_SC_NPROC_ONLN *//* Define if _SC_NPROC_ONLN is available in <unistd.h>. *//* Define if _SC_NPROCESSORS_ONLN is available in <unistd.h>. *//* Defined if sched_yield is available. *//* Define if usable realpath is available in <stdlib.h>. *//* Define if /dev/random and /dev/urandom are available for the random_device
   of TR1 (Chapter 5.1). *//* Define if POSIX read/write locks are available in <gthr.h>. *//* Define if pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock are
   available in <pthread.h>. *//* Define if pthread_mutex_clocklock is available in <pthread.h>. *//* Define if pthread_cond_clockwait is available in <pthread.h>. *//* #undef _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP *//* Define if pthreads_num_processors_np is available in <pthread.h>. *//* Define if NLS translations are to be used. *//* Defined if nanosleep is available. *//* Define if lstat is available in <sys/stat.h>. *//* Define if code specialized for long long should be used. *//* Define if LFS support is available. *//* Define if get_nprocs is available in <sys/sysinfo.h>. *//* Defined if gettimeofday is available. *//* Define if fchmodat is available in <sys/stat.h>. *//* Define if fchmod is available in <sys/stat.h>. *//* Define if /dev/random and /dev/urandom are available for
   std::random_device. *//* Define if ISO/IEC TR 24733 decimal floating point types are supported on
   this host. *//* Defined if clock_gettime has realtime clock support. *//* Defined if clock_gettime has monotonic clock support. *//* #undef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL *//* Defined if clock_gettime syscall has monotonic and realtime clock support.
   *//* Define if C99 types in <stdint.h> should be imported in <tr1/cstdint> in
   namespace std::tr1. *//* Define if C99 functions or macros in <math.h> should be imported in
   <tr1/cmath> in namespace std::tr1. *//* Define if wchar_t C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. *//* Define if C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. *//* Define if C99 functions in <fenv.h> should be imported in <tr1/cfenv> in
   namespace std::tr1. *//* Define if C99 functions in <ctype.h> should be imported in <tr1/cctype> in
   namespace std::tr1. *//* Define if C99 functions in <complex.h> should be used in <tr1/complex>.
   Using compiler builtins for these functions requires corresponding C99
   library functions to be present. *//* Define if C99 functions or macros from <wchar.h>, <math.h>, <complex.h>,
   <stdio.h>, and <stdlib.h> can be used or exposed. *//* Define if C11 functions in <uchar.h> should be imported into namespace std
   in <cuchar>. *//* #undef _GLIBCXX_SYMVER_SUN *//* Define to use Sun versioning in the shared library. *//* #undef _GLIBCXX_SYMVER_GNU_NAMESPACE *//* Define to use GNU namespace versioning in the shared library. *//* Define to use GNU versioning in the shared library. *//* #undef _GLIBCXX_SYMVER_DARWIN *//* Define to use darwin versioning in the shared library. *//* Define to use symbol versioning in the shared library. *//* Define to the value of the SEEK_END integer constant. *//* Define to the value of the SEEK_CUR integer constant. *//* Define to the value of the EOF integer constant. *//* #undef _GLIBCXX_SIZE_T_IS_UINT *//* Define if size_t is unsigned int. *//* Define if using setrlimit to set resource limits during "make check" *//* #undef _GLIBCXX_PTRDIFF_T_IS_INT *//* Define if ptrdiff_t is int. *//* #undef _GLIBCXX_NO_SLEEP *//* Defined if no way to sleep is available. *//* #undef _GLIBCXX_NO_C99_ROUNDING_FUNCS *//* Define if C99 llrint and llround functions are missing from <math.h>. *//* Define to the letter to which size_t is mangled. *//* Define if compatibility should be provided for -mlong-double-64. *//* Define if compatibility should be provided for alternative 128-bit long
   double formats. *//* Define to 1 if a full hosted library is built, or 0 if freestanding. *//* Define if gthreads library is available. *//* Define to 1 if a fully dynamic basic_string is wanted, 0 to disable,
   undefined for platform defaults *//* #undef _GLIBCXX_CONCEPT_CHECKS *//* Define to use concept checking code from the boost libraries. *//* Define if the compiler supports C++11 atomics. *//* Define if C99 functions or macros in <wchar.h> should be imported in
   <cwchar> in namespace std for C++98. *//* Define if C99 functions or macros in <stdlib.h> should be imported in
   <cstdlib> in namespace std for C++98. *//* Define if C99 functions or macros in <stdio.h> should be imported in
   <cstdio> in namespace std for C++98. *//* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std for C++98. *//* Define if C99 functions in <complex.h> should be used in <complex> for
   C++98. Using compiler builtins for these functions requires corresponding
   C99 library functions to be present. *//* Define if C99 functions or macros in <wchar.h> should be imported in
   <cwchar> in namespace std for C++11. *//* Define if C99 functions or macros in <stdlib.h> should be imported in
   <cstdlib> in namespace std for C++11. *//* Define if C99 functions or macros in <stdio.h> should be imported in
   <cstdio> in namespace std for C++11. *//* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std for C++11. *//* Define if C99 functions in <complex.h> should be used in <complex> for
   C++11. Using compiler builtins for these functions requires corresponding
   C99 library functions to be present. *//* #undef _GLIBCXX_FILE_OFFSET_BITS *//* Number of bits in a file offset, on hosts where this is settable. *//* Enable large inode numbers on Mac OS X 10.5.  *//* #undef _GLIBCXX_VERSION *//* Version number of package *//* Define to 1 if you have the ANSI C header files. *//* #undef SIZEOF_VOID_P *//* The size of `void *', as computed by sizeof. *//* #undef SIZEOF_SHORT *//* The size of `short', as computed by sizeof. *//* #undef SIZEOF_LONG *//* The size of `long', as computed by sizeof. *//* #undef SIZEOF_INT *//* The size of `int', as computed by sizeof. *//* #undef SIZEOF_CHAR *//* The size of `char', as computed by sizeof. *//* Define to the version of this package. *//* Define to the home page for this package. *//* Define to the one symbol short name of this package. *//* Define to the full name and version of this package. *//* Define to the full name of this package. *//* Define to the address where bug reports for this package should be sent. *//* #undef _GLIBCXX_PACKAGE *//* Name of package *//* Define to the sub-directory in which libtool stores uninstalled libraries.
   *//* Define as const if the declaration of iconv() needs const. *//* Define to 1 if you have the `__cxa_thread_atexit_impl' function. *//* #undef _GLIBCXX_HAVE___CXA_THREAD_ATEXIT *//* Define to 1 if you have the `__cxa_thread_atexit' function. *//* #undef _GLIBCXX_HAVE__WFOPEN *//* Define to 1 if you have the `_wfopen' function. *//* #undef _GLIBCXX_HAVE__TANL *//* Define to 1 if you have the `_tanl' function. *//* #undef _GLIBCXX_HAVE__TANHL *//* Define to 1 if you have the `_tanhl' function. *//* #undef _GLIBCXX_HAVE__TANHF *//* Define to 1 if you have the `_tanhf' function. *//* #undef _GLIBCXX_HAVE__TANF *//* Define to 1 if you have the `_tanf' function. *//* #undef _GLIBCXX_HAVE__SQRTL *//* Define to 1 if you have the `_sqrtl' function. *//* #undef _GLIBCXX_HAVE__SQRTF *//* Define to 1 if you have the `_sqrtf' function. *//* #undef _GLIBCXX_HAVE__SINL *//* Define to 1 if you have the `_sinl' function. *//* #undef _GLIBCXX_HAVE__SINHL *//* Define to 1 if you have the `_sinhl' function. *//* #undef _GLIBCXX_HAVE__SINHF *//* Define to 1 if you have the `_sinhf' function. *//* #undef _GLIBCXX_HAVE__SINF *//* Define to 1 if you have the `_sinf' function. *//* #undef _GLIBCXX_HAVE__SINCOSL *//* Define to 1 if you have the `_sincosl' function. *//* #undef _GLIBCXX_HAVE__SINCOSF *//* Define to 1 if you have the `_sincosf' function. *//* #undef _GLIBCXX_HAVE__SINCOS *//* Define to 1 if you have the `_sincos' function. *//* #undef _GLIBCXX_HAVE__QFPCLASS *//* Define to 1 if you have the `_qfpclass' function. *//* #undef _GLIBCXX_HAVE__POWL *//* Define to 1 if you have the `_powl' function. *//* #undef _GLIBCXX_HAVE__POWF *//* Define to 1 if you have the `_powf' function. *//* #undef _GLIBCXX_HAVE__MODFL *//* Define to 1 if you have the `_modfl' function. *//* #undef _GLIBCXX_HAVE__MODFF *//* Define to 1 if you have the `_modff' function. *//* #undef _GLIBCXX_HAVE__MODF *//* Define to 1 if you have the `_modf' function. *//* #undef _GLIBCXX_HAVE__LOGL *//* Define to 1 if you have the `_logl' function. *//* #undef _GLIBCXX_HAVE__LOGF *//* Define to 1 if you have the `_logf' function. *//* #undef _GLIBCXX_HAVE__LOG10L *//* Define to 1 if you have the `_log10l' function. *//* #undef _GLIBCXX_HAVE__LOG10F *//* Define to 1 if you have the `_log10f' function. *//* #undef _GLIBCXX_HAVE__LDEXPL *//* Define to 1 if you have the `_ldexpl' function. *//* #undef _GLIBCXX_HAVE__LDEXPF *//* Define to 1 if you have the `_ldexpf' function. *//* #undef _GLIBCXX_HAVE__ISNANL *//* Define to 1 if you have the `_isnanl' function. *//* #undef _GLIBCXX_HAVE__ISNANF *//* Define to 1 if you have the `_isnanf' function. *//* #undef _GLIBCXX_HAVE__ISNAN *//* Define to 1 if you have the `_isnan' function. *//* #undef _GLIBCXX_HAVE__ISINFL *//* Define to 1 if you have the `_isinfl' function. *//* #undef _GLIBCXX_HAVE__ISINFF *//* Define to 1 if you have the `_isinff' function. *//* #undef _GLIBCXX_HAVE__ISINF *//* Define to 1 if you have the `_isinf' function. *//* #undef _GLIBCXX_HAVE__HYPOTL *//* Define to 1 if you have the `_hypotl' function. *//* #undef _GLIBCXX_HAVE__HYPOTF *//* Define to 1 if you have the `_hypotf' function. *//* #undef _GLIBCXX_HAVE__HYPOT *//* Define to 1 if you have the `_hypot' function. *//* #undef _GLIBCXX_HAVE__FREXPL *//* Define to 1 if you have the `_frexpl' function. *//* #undef _GLIBCXX_HAVE__FREXPF *//* Define to 1 if you have the `_frexpf' function. *//* #undef _GLIBCXX_HAVE__FPCLASS *//* Define to 1 if you have the `_fpclass' function. *//* #undef _GLIBCXX_HAVE__FMODL *//* Define to 1 if you have the `_fmodl' function. *//* #undef _GLIBCXX_HAVE__FMODF *//* Define to 1 if you have the `_fmodf' function. *//* #undef _GLIBCXX_HAVE__FLOORL *//* Define to 1 if you have the `_floorl' function. *//* #undef _GLIBCXX_HAVE__FLOORF *//* Define to 1 if you have the `_floorf' function. *//* #undef _GLIBCXX_HAVE__FINITEL *//* Define to 1 if you have the `_finitel' function. *//* #undef _GLIBCXX_HAVE__FINITEF *//* Define to 1 if you have the `_finitef' function. *//* #undef _GLIBCXX_HAVE__FINITE *//* Define to 1 if you have the `_finite' function. *//* #undef _GLIBCXX_HAVE__FABSL *//* Define to 1 if you have the `_fabsl' function. *//* #undef _GLIBCXX_HAVE__FABSF *//* Define to 1 if you have the `_fabsf' function. *//* #undef _GLIBCXX_HAVE__EXPL *//* Define to 1 if you have the `_expl' function. *//* #undef _GLIBCXX_HAVE__EXPF *//* Define to 1 if you have the `_expf' function. *//* #undef _GLIBCXX_HAVE__COSL *//* Define to 1 if you have the `_cosl' function. *//* #undef _GLIBCXX_HAVE__COSHL *//* Define to 1 if you have the `_coshl' function. *//* #undef _GLIBCXX_HAVE__COSHF *//* Define to 1 if you have the `_coshf' function. *//* #undef _GLIBCXX_HAVE__COSF *//* Define to 1 if you have the `_cosf' function. *//* #undef _GLIBCXX_HAVE__CEILL *//* Define to 1 if you have the `_ceill' function. *//* #undef _GLIBCXX_HAVE__CEILF *//* Define to 1 if you have the `_ceilf' function. *//* #undef _GLIBCXX_HAVE__ATANL *//* Define to 1 if you have the `_atanl' function. *//* #undef _GLIBCXX_HAVE__ATANF *//* Define to 1 if you have the `_atanf' function. *//* #undef _GLIBCXX_HAVE__ATAN2L *//* Define to 1 if you have the `_atan2l' function. *//* #undef _GLIBCXX_HAVE__ATAN2F *//* Define to 1 if you have the `_atan2f' function. *//* #undef _GLIBCXX_HAVE__ASINL *//* Define to 1 if you have the `_asinl' function. *//* #undef _GLIBCXX_HAVE__ASINF *//* Define to 1 if you have the `_asinf' function. *//* #undef _GLIBCXX_HAVE__ALIGNED_MALLOC *//* Define to 1 if you have the `_aligned_malloc' function. *//* #undef _GLIBCXX_HAVE__ACOSL *//* Define to 1 if you have the `_acosl' function. *//* #undef _GLIBCXX_HAVE__ACOSF *//* Define to 1 if you have the `_acosf' function. *//* #undef _GLIBCXX_HAVE_XLOCALE_H *//* Define to 1 if you have the <xlocale.h> header file. *//* Define if writev is available in <sys/uio.h>. *//* #undef _GLIBCXX_HAVE_WIN32_SLEEP *//* Defined if Sleep exists. *//* Define to 1 if you have the <wctype.h> header file. *//* Defined if wcstof exists. *//* Define to 1 if you have the <wchar.h> header file. *//* Defined if vwscanf exists. *//* Defined if vswscanf exists. *//* Defined if vfwscanf exists. *//* Define to 1 if you have the <utime.h> header file. *//* #undef _GLIBCXX_HAVE_USLEEP *//* Defined if usleep exists. *//* Define to 1 if you have the `uselocale' function. *//* Define if unlinkat is available in <fcntl.h>. *//* Define to 1 if you have the <unistd.h> header file. *//* Define to 1 if you have the <uchar.h> header file. *//* Define if truncate is available in <unistd.h>. *//* Define to 1 if the target supports thread-local storage. *//* Define to 1 if you have the `timespec_get' function. *//* Define to 1 if you have the <tgmath.h> header file. *//* Define to 1 if you have the `tanl' function. *//* Define to 1 if you have the `tanhl' function. *//* Define to 1 if you have the `tanhf' function. *//* Define to 1 if you have the `tanf' function. *//* Define if S_ISREG is available in <sys/stat.h>. *//* #undef _GLIBCXX_HAVE_S_IFREG *//* Define if S_IFREG is available in <sys/stat.h>. *//* Define to 1 if you have the <sys/uio.h> header file. *//* Define to 1 if you have the <sys/types.h> header file. *//* Define to 1 if you have the <sys/time.h> header file. *//* Define to 1 if you have the <sys/sysinfo.h> header file. *//* Define to 1 if you have the <sys/stat.h> header file. *//* Define to 1 if you have the <sys/statvfs.h> header file. *//* Define to 1 if you have the <sys/socket.h> header file. *//* Define to 1 if you have the <sys/sem.h> header file. *//* Define to 1 if you have a suitable <sys/sdt.h> header file *//* Define to 1 if you have the <sys/resource.h> header file. *//* Define to 1 if you have the <sys/param.h> header file. *//* Define to 1 if you have the <sys/mman.h> header file. *//* #undef _GLIBCXX_HAVE_SYS_MACHINE_H *//* Define to 1 if you have the <sys/machine.h> header file. *//* #undef _GLIBCXX_HAVE_SYS_ISA_DEFS_H *//* Define to 1 if you have the <sys/isa_defs.h> header file. *//* Define to 1 if you have the <sys/ipc.h> header file. *//* Define to 1 if you have the <sys/ioctl.h> header file. *//* #undef _GLIBCXX_HAVE_SYS_FILIO_H *//* Define to 1 if you have the <sys/filio.h> header file. *//* Define to 1 if the target runtime linker supports binding the same symbol
   to different versions. *//* Define if symlink is available in <unistd.h>. *//* Define if strxfrm_l is available in <string.h>. *//* Define to 1 if `d_type' is a member of `struct dirent'. *//* Define to 1 if you have the `strtold' function. *//* Define to 1 if you have the `strtof' function. *//* Define to 1 if you have the <string.h> header file. *//* Define to 1 if you have the <strings.h> header file. *//* Define if strerror_r is available in <string.h>. *//* Define if strerror_l is available in <string.h>. *//* Define to 1 if you have the <stdlib.h> header file. *//* Define to 1 if you have the <stdint.h> header file. *//* Define to 1 if you have the <stdbool.h> header file. *//* Define to 1 if you have the <stdalign.h> header file. *//* Define if the <stacktrace> header is supported. *//* Define to 1 if you have the `sqrtl' function. *//* Define to 1 if you have the `sqrtf' function. *//* Define to 1 if you have the `sockatmark' function. *//* #undef _GLIBCXX_HAVE_SLEEP *//* Defined if sleep exists. *//* Define to 1 if you have the `sinl' function. *//* Define to 1 if you have the `sinhl' function. *//* Define to 1 if you have the `sinhf' function. *//* Define to 1 if you have the `sinf' function. *//* Define to 1 if you have the `sincosl' function. *//* Define to 1 if you have the `sincosf' function. *//* Define to 1 if you have the `sincos' function. *//* Define to 1 if you have the `setenv' function. *//* Define to 1 if you have the `secure_getenv' function. *//* Define if readlink is available in <unistd.h>. *//* Define to 1 if you have the `quick_exit' function. *//* #undef _GLIBCXX_HAVE_QFPCLASS *//* Define to 1 if you have the `qfpclass' function. *//* Define to 1 if you have the `powl' function. *//* Define to 1 if you have the `powf' function. *//* Define to 1 if POSIX Semaphores with sem_timedwait are available in
   <semaphore.h>. *//* Define to 1 if you have the `posix_memalign' function. *//* Define to 1 if you have the <poll.h> header file. *//* Define if poll is available in <poll.h>. *//* Define if openat is available in <fcntl.h>. *//* #undef _GLIBCXX_HAVE_OBSOLETE_ISNAN *//* Define if <math.h> defines obsolete isnan function. *//* #undef _GLIBCXX_HAVE_OBSOLETE_ISINF *//* Define if <math.h> defines obsolete isinf function. *//* Define to 1 if you have the <netinet/tcp.h> header file. *//* Define to 1 if you have the <netinet/in.h> header file. *//* Define to 1 if you have the <netdb.h> header file. *//* #undef _GLIBCXX_HAVE_NAN_H *//* Define to 1 if you have the <nan.h> header file. *//* Define to 1 if you have the `modfl' function. *//* Define to 1 if you have the `modff' function. *//* Define to 1 if you have the `modf' function. *//* Define to 1 if you have the <memory.h> header file. *//* Define to 1 if you have the `memalign' function. *//* Define if mbstate_t exists in wchar.h. *//* #undef _GLIBCXX_HAVE_MACHINE_PARAM_H *//* Define to 1 if you have the <machine/param.h> header file. *//* #undef _GLIBCXX_HAVE_MACHINE_ENDIAN_H *//* Define to 1 if you have the <machine/endian.h> header file. *//* Define to 1 if you have the `logl' function. *//* Define to 1 if you have the `logf' function. *//* Define to 1 if you have the `log10l' function. *//* Define to 1 if you have the `log10f' function. *//* Define to 1 if you have the <locale.h> header file. *//* Define to 1 if you have the <linux/types.h> header file. *//* Define to 1 if you have the <linux/random.h> header file. *//* Define if futex syscall is available. *//* Define to 1 if you have the <link.h> header file. *//* Define if link is available in <unistd.h>. *//* Only used in build directory testsuite_hooks.h. *//* Define to 1 if you have the <libintl.h> header file. *//* Define to 1 if you have the `ldexpl' function. *//* Define to 1 if you have the `ldexpf' function. *//* Define if LC_MESSAGES is available in <locale.h>. *//* Defined if iswblank exists. *//* Define to 1 if you have the `isnanl' function. *//* Define to 1 if you have the `isnanf' function. *//* #undef _GLIBCXX_HAVE_ISNAN *//* Define to 1 if you have the `isnan' function. *//* Define to 1 if you have the `isinfl' function. *//* Define to 1 if you have the `isinff' function. *//* #undef _GLIBCXX_HAVE_ISINF *//* Define to 1 if you have the `isinf' function. *//* Define to 1 if you have the <inttypes.h> header file. *//* #undef _GLIBCXX_HAVE_IEEEFP_H *//* Define to 1 if you have the <ieeefp.h> header file. *//* Define if you have the iconv() function. *//* Define to 1 if you have the `hypotl' function. *//* Define to 1 if you have the `hypotf' function. *//* Define to 1 if you have the `hypot' function. *//* Define if gets is available in <stdio.h> before C++14. *//* Define if _Unwind_GetIPInfo is available. *//* Define if getentropy is available in <unistd.h>. *//* Define to 1 if you have the `frexpl' function. *//* Define to 1 if you have the `frexpf' function. *//* #undef _GLIBCXX_HAVE_FP_H *//* Define to 1 if you have the <fp.h> header file. *//* #undef _GLIBCXX_HAVE_FPCLASS *//* Define to 1 if you have the `fpclass' function. *//* Define to 1 if you have the `fmodl' function. *//* Define to 1 if you have the `fmodf' function. *//* Define to 1 if you have the `floorl' function. *//* Define to 1 if you have the `floorf' function. *//* Define to 1 if you have the <float.h> header file. *//* Define to 1 if you have the `finitel' function. *//* Define to 1 if you have the `finitef' function. *//* Define to 1 if you have the `finite' function. *//* Define to 1 if you have the <fenv.h> header file. *//* Define if fdopendir is available in <dirent.h>. *//* Define to 1 if you have the <fcntl.h> header file. *//* Define to 1 if you have the `fabsl' function. *//* Define to 1 if you have the `fabsf' function. *//* Define to 1 if you have the `expl' function. *//* Define to 1 if you have the `expf' function. *//* Define to 1 if you have the <execinfo.h> header file. *//* Define to 1 if GCC 4.6 supported std::exception_ptr for the target *//* Define to 1 if you have the <endian.h> header file. *//* Define to 1 if you have the <dlfcn.h> header file. *//* Define if dirfd is available in <dirent.h>. *//* Define to 1 if you have the <dirent.h> header file. *//* Define to 1 if you have the declaration of `strnlen', and to 0 if you
   don't. *//* Define to 1 if you have the `cosl' function. *//* Define to 1 if you have the `coshl' function. *//* Define to 1 if you have the `coshf' function. *//* Define to 1 if you have the `cosf' function. *//* Define to 1 if you have the <complex.h> header file. *//* Define to 1 if you have the `ceill' function. *//* Define to 1 if you have the `ceilf' function. *//* #undef _GLIBCXX_HAVE_CC_TLS *//* Define to 1 if the target assembler supports thread-local storage. *//* Define to 1 if you have the `at_quick_exit' function. *//* Defined if shared_ptr reference counting should use atomic operations. *//* Define to 1 if you have the `atanl' function. *//* Define to 1 if you have the `atanf' function. *//* Define to 1 if you have the `atan2l' function. *//* Define to 1 if you have the `atan2f' function. *//* Define to 1 if the target assembler supports .symver directive. *//* Define to 1 if you have the `asinl' function. *//* Define to 1 if you have the `asinf' function. *//* Define to 1 if you have the <arpa/inet.h> header file. *//* Define if arc4random is available in <stdlib.h>. *//* Define to 1 if you have the `aligned_alloc' function. *//* Define to 1 if you have the `acosl' function. *//* Define to 1 if you have the `acosf' function. *//* config.h.in.  Generated from configure.ac by autoheader.  *//* config.h.  Generated from config.h.in by configure.  */// End of prewritten config; the settings discovered at configure time follow.// __has_include// This section will need some rework when a new (default) backend type is added// For now this defaults to being based on the presence of Thread Building Blocks// #define PSTL_VERSION 9000// Preserved here so we have some idea which version of upstream we've pulled in// This header is not installed for freestanding:// PSTL configuration// Intel and older Clang require !__is_identifier for some built-ins:// Define if double has the IEEE binary64 format.// Define if float has the IEEE binary32 format./* For powerpc64 don't use __float128 when it's the same type as long double. *//* Define if __float128 is supported on this host.  */// language char8_t feature macro is defined.// Unless explicitly specified, enable char8_t extensions only if the core// so they should be tested with #if not with #ifdef.// N.B. these _GLIBCXX_USE_C99_XXX macros are defined unconditionally// For example, <windows.h> is known to #define min and max as macros...// for something else under certain OSes (see BADNAMES).// src/functexcept.cc.  We use __N because the more traditional _N is used// translation.  It is primarily used for messages in thrown exceptions; see// This marks string literals in header files to be extracted for eventual// Create a boolean flag to be used to determine if --fast-math is set.// user hooks are listed above.// The remainder of the prewritten config is automatic; all the// For C++11 and C++14 they are in namespace std when requested.// In C++17 mathematical special functions are in namespace std.// implementation.// Most of the following conditions are due to limitations in the current// Conditionally enable annotations for the Transactional Memory TS on C++11.// libitm) without depending on them if the respective features are not used.// allows for referring to functions provided by other libraries (e.g.,// for declaring functions as weak while not defining such functions.  This// By default, we assume that __GXX_WEAK__ also means that there is support// macro causes these definitions to be weak.// user code are decorated with this macro.  For some targets, this// Certain function definitions that are meant to be overridable from// specify empty default for namespace annotation macros.// If platform uses neither visibility nor psuedo-visibility,// Pick up any CPU-specific definitions.// Pick up any OS-specific definitions.// First includes.// !__cplusplus// macro is not defined, something is wrong.// unless the compiler is in strict mode. If it's not defined and the strict// If __int128 is supported, we expect __GLIBCXX_TYPE_INT_N_0 to be defined// Macros for C linkage: define extern "C" linkage only when using C++.// memory accesses which occurred after the refcount became zero.// accesses occurred when the refcount was positive do not race with// The annotations in this example tell the race detector that all memory//   }//       }//         _M_destroy(__a);//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);//       {//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);//   {//   void _M_remove_reference()// current implementation of the library) is atomic reference counting:// The most frequent use case for these macros (and the only case in the// latter when they share the same argument pointer.// the race detector will infer a happens-before arc from the former to the// atomic (lock-free) synchronization to race detectors:// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and// Macros for race detectors.// Macro indicating that TSAN is in use.// ! VERBOSE_ASSERT// include out of the mix.// Avoid the use of assert, because we're trying to keep the <cassert>// Assert./* precondition violation detected! */// Disable std::string explicit instantiation declarations in order to assert.// Debug Mode implies checking assertions.// the compiler support is present to make this function work as expected.// The macro _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED can be used to check if// This can be used without checking if the compiler supports the feature.// Internal version of std::is_constant_evaluated().// _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT && IEEE128// Namespaces for 128-bit IEEE long double format on 64-bit POWER LE.// Inline namespaces for long double 128 modes.// double formats. Not possible for Clang until __ibm128 is supported.// Define if compatibility should be provided for alternative 128-bit long// Define if compatibility should be provided for -mlong-double-64.// GLIBCXX_ABI Deprecated// _GLIBCXX_END_NAMESPACE_CONTAINER// _GLIBCXX_BEGIN_NAMESPACE_CONTAINER// _GLIBCXX_END_NAMESPACE_ALGO// _GLIBCXX_BEGIN_NAMESPACE_ALGO// Macros for opening/closing conditional namespaces.// _GLIBCXX_STD_C// _GLIBCXX_STD_A// of some nested namespace within it corresponding to the active mode.// Macros for namespace scope. Either namespace std:: or the name// Check for invalid use due to lack for weak symbols.// Check for invalid usage and unsupported mixed-mode use.// Inline namespaces for parallel mode.// Inline namespace for debug mode.// Non-inline namespace for components replaced by alternates in active mode.// Inline namespaces for special modes: debug, parallel.// Inline namespace for symbol versioning.// Defined if inline namespaces are used for versioning.// Ignore any pre-defined value of _GLIBCXX_USE_CXX11_ABI// and without making the declaration of std::terminate visible to users.// This allows the library to terminate without including all of <exception>/*
  Outline of libstdc++ namespaces.

  namespace std
  {
    namespace __debug { }
    namespace __parallel { }
    namespace __cxx1998 { }

    namespace __detail {
      namespace __variant { }				// C++17
    }

    namespace rel_ops { }

    namespace tr1
    {
      namespace placeholders { }
      namespace regex_constants { }
      namespace __detail { }
    }

    namespace tr2 { }
    
    namespace decimal { }

    namespace chrono { }				// C++11
    namespace placeholders { }				// C++11
    namespace regex_constants { }			// C++11
    namespace this_thread { }				// C++11
    inline namespace literals {				// C++14
      inline namespace chrono_literals { }		// C++14
      inline namespace complex_literals { }		// C++14
      inline namespace string_literals { }		// C++14
      inline namespace string_view_literals { }		// C++17
    }
  }

  namespace abi { }

  namespace __gnu_cxx
  {
    namespace __detail { }
  }

  For full details see:
  http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html
*/// checks even at -O0.// templates only in basic_string, thus activating its debug-mode// Special case: _GLIBCXX_EXTERN_TEMPLATE == -1 disallows extern// resulting executables.// library binary. This substantially reduces the binary size of// required types that are already explicitly instantiated in the// throughout the library to avoid multiple weak definitions for// manual, it inhibits all implicit instantiations and is used// of extern keyword on template declaration. As documented in the g++// Macro for extern template, ie controlling template linkage via use// Macro for noexcept, to support in mixed 03/0x mode.// Macro for constexpr, to support in mixed 03/0x mode.// Macro to warn about unused results.// Macros for ABI tag attributes.//   _GLIBCXX20_DEPRECATED_SUGGEST( string-literal )//   _GLIBCXX20_DEPRECATED( string-literal )//   _GLIBCXX17_DEPRECATED_SUGGEST( string-literal )//   _GLIBCXX17_DEPRECATED//   _GLIBCXX14_DEPRECATED_SUGGEST( string-literal )//   _GLIBCXX14_DEPRECATED//   _GLIBCXX11_DEPRECATED_SUGGEST( string-literal )//   _GLIBCXX11_DEPRECATED//   _GLIBCXX_DEPRECATED_SUGGEST( string-literal )//   _GLIBCXX_DEPRECATED//   _GLIBCXX_USE_DEPRECATED// Macros for deprecated attributes.// headers included below, it will be defined to an empty default.// If this is not supplied by the OS-specific or CPU-specific//   _GLIBCXX_VISIBILITY//   _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY// Macros for visibility attributes.// See below for C++//   _GLIBCXX_NOTHROW//   _GLIBCXX_NORETURN//   _GLIBCXX_CONST//   _GLIBCXX_PURE// Macros for various attributes.// The datestamp of the C++ library in compressed ISO date format.// The major release number for the GCC release the C++ library belongs to./** @file bits/c++config.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{version}
 */// Predefined symbols and macros -*- C++ -*-/* #undef _GLIBCXX_HAVE_ARC4RANDOM */_Complex long double_Complex double_Complex floatx ## lx ## f__cfloat128__TC__x ## q__locale_struct &__locale_struct &&const __locale_structconst __locale_struct &__fsid_t &__fsid_t &&const __fsid_tconst __fsid_t &__sigset_t &__sigset_t &&const __sigset_t &timeval &timeval &&const timeval &timespec &timespec &&const timespec &fd_set &fd_set &&const fd_setconst fd_set &__atomic_wide_counter &__atomic_wide_counter &&const __atomic_wide_counterconst __atomic_wide_counter &__pthread_mutex_s &__pthread_mutex_s &&const __pthread_mutex_sconst __pthread_mutex_s &__pthread_rwlock_arch_t &__pthread_rwlock_arch_t &&const __pthread_rwlock_arch_tconst __pthread_rwlock_arch_t &__once_flag &__once_flag &&const __once_flagconst __once_flag &__pthread_cond_s &__pthread_cond_s &&const __pthread_cond_sconst __pthread_cond_s &__pthread_internal_slist &__pthread_internal_slist &&const __pthread_internal_slistconst __pthread_internal_slist &__pthread_internal_list &__pthread_internal_list &&const __pthread_internal_listconst __pthread_internal_list &pthread_barrierattr_t &pthread_barrierattr_t &&const pthread_barrierattr_t &pthread_barrier_t &pthread_barrier_t &&const pthread_barrier_tconst pthread_barrier_t &pthread_rwlockattr_t &pthread_rwlockattr_t &&const pthread_rwlockattr_t &pthread_rwlock_t &pthread_rwlock_t &&const pthread_rwlock_tconst pthread_rwlock_t &pthread_cond_t &pthread_cond_t &&const pthread_cond_tconst pthread_cond_t &pthread_mutex_t &pthread_mutex_t &&const pthread_mutex_t &pthread_attr_t &pthread_attr_t &&const pthread_attr_t &pthread_condattr_t &pthread_condattr_t &&const pthread_condattr_t &pthread_mutexattr_t &pthread_mutexattr_t &&const pthread_mutexattr_t &drand48_data &drand48_data &&const drand48_dataconst drand48_data &random_data &random_data &&const random_dataconst random_data &lldiv_t &lldiv_t &&const lldiv_tconst lldiv_t &ldiv_t &ldiv_t &&const ldiv_tconst ldiv_t &div_t &div_t &&const div_tconst div_t &__builtin_fabs__builtin_llabs__builtin_labs_GLIBCXX_BITS_STD_ABS_H// _GLIBCXX_BITS_STD_ABS_H// extern "C"++"// 2735. std::abs(short), std::abs(signed char) and others should return int// 2294. <cstdlib> should declare abs(double)// 2192. Validity and return type of std::abs(0u) is unclear/** @file include/bits/std_abs.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cmath, cstdlib}
 */// -*- C++ -*- C library enhancements header.__mbstate_t &__mbstate_t &&const __mbstate_tconst __mbstate_t &_G_fpos64_t &_G_fpos64_t &&const _G_fpos64_tconst _G_fpos64_t &L_cuserid__is_null_pointer_Type *__promote<float, false> &__promote<float, false> &&const __promote<float, false>const __promote<float, false> &__promote<double, false> &__promote<double, false> &&const __promote<double, false>const __promote<double, false> &__promote<long double, false> &__promote<long double, false> &&const __promote<long double, false>const __promote<long double, false> &__remove_unsigned<unsigned long long> &__remove_unsigned<unsigned long long> &&const __remove_unsigned<unsigned long long>const __remove_unsigned<unsigned long long> &__remove_unsigned<unsigned long> &__remove_unsigned<unsigned long> &&const __remove_unsigned<unsigned long>const __remove_unsigned<unsigned long> &__remove_unsigned<unsigned int> &__remove_unsigned<unsigned int> &&const __remove_unsigned<unsigned int>const __remove_unsigned<unsigned int> &__remove_unsigned<unsigned short> &__remove_unsigned<unsigned short> &&const __remove_unsigned<unsigned short>const __remove_unsigned<unsigned short> &__remove_unsigned<unsigned char> &__remove_unsigned<unsigned char> &&const __remove_unsigned<unsigned char>const __remove_unsigned<unsigned char> &__remove_unsigned<char> &__remove_unsigned<char> &&const __remove_unsigned<char>const __remove_unsigned<char> &__add_unsigned<long long> &__add_unsigned<long long> &&const __add_unsigned<long long>const __add_unsigned<long long> &__add_unsigned<long> &__add_unsigned<long> &&const __add_unsigned<long>const __add_unsigned<long> &__add_unsigned<int> &__add_unsigned<int> &&const __add_unsigned<int>const __add_unsigned<int> &__add_unsigned<short> &__add_unsigned<short> &&const __add_unsigned<short>const __add_unsigned<short> &__add_unsigned<signed char> &__add_unsigned<signed char> &&const __add_unsigned<signed char>const __add_unsigned<signed char> &__add_unsigned<char> &__add_unsigned<char> &&const __add_unsigned<char>const __add_unsigned<char> &__promote<float, false>std::__is_integer<_Tp>::__value__promote<double, false>__promote<long double, false>__promote<_Tp, false>__promote<_Tp, <unnamed>>__remove_unsigned<wchar_t>__remove_unsigned<bool>__remove_unsigned<unsigned long long>__remove_unsigned<unsigned long>__remove_unsigned<unsigned int>__remove_unsigned<unsigned short>__remove_unsigned<unsigned char>__remove_unsigned<char>__remove_unsigned<_Tp>__add_unsigned<wchar_t>__add_unsigned<bool>__add_unsigned<long long>__add_unsigned<long>__add_unsigned<int>__add_unsigned<short>__add_unsigned<signed char>__add_unsigned<char>__add_unsigned<_Tp>__conditional_type<false, _Iftrue, _Iffalse>__conditional_type<_Cond, _Iftrue, _Iffalse>__enable_if<true, _Tp>__enable_if<<unnamed>, <unnamed>>_EXT_TYPE_TRAITS__cpp_fold_expressions// then __promote is used to provide the nested __type member.// Deducing the promoted type is done by __promoted_t<_Tp...>,// <cmath> and <complex> to only the intended types.// allows this type to be used for SFINAE to constrain overloads in// No nested __type member for non-integer non-floating point types,// For arithmetic promotions in <complex> and <cmath>// For use in string and vstring.// Declare but don't define.// Given an integral builtin type, return the corresponding signed type.// Given an integral builtin type, return the corresponding unsigned type.// Conditional expression for types. If true, first, if false, second.// Define a nested type if some predicate holds./** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_mem.cpp(LZHAM_MIN_ALLOC_ALIGNMENT - 1)lzham_msize: bad ptr"lzham_msize: bad ptr"lzham_free: bad ptr"lzham_free: bad ptr"lzham_realloc: bad ptr"lzham_realloc: bad ptr"17179869184MAX_POSSIBLE_BLOCK_SIZElzham_malloc: size too big"lzham_malloc: size too big"actual_sizep_new(reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0(reinterpret_cast<ptr_bits_t>(p_new) & (sizeof(size_t) * 2 - 1)) == 0const char[77]char[77]sizeof(uint32) - 1U(sizeof(uint32) - 1U)~(sizeof(uint32) - 1U)lzham_malloc: out of memory"lzham_malloc: out of memory"lzham_mem_errorlzham_default_msizelzham_default_reallocp_final_blockg_pUser_datag_pMSizeg_pRealloc0x400000000ULL_msizeLZHAM_MEM_STATS// LZHAM_MEM_STATS// File: lzham_mem.cppp_msg<bits/utility.h>getconst pair<_Up, _Tp>const pair<_Up, _Tp> &&pair<_Up, _Tp> &&const pair<_Up, _Tp> &pair<_Up, _Tp> &const pair<_Tp, _Up>const pair<_Tp, _Up> &&pair<_Tp, _Up> &&const pair<_Tp, _Up> &pair<_Tp, _Up> &const typeconst type &&const pair<_Tp1, _Tp2>const pair<_Tp1, _Tp2> &&pair<_Tp1, _Tp2> &&const type &const pair<_Tp1, _Tp2> &pair<_Tp1, _Tp2> &make_pair_T1 &&_T2 &&__pair_get<1UL> &__pair_get<1UL> &&const __pair_get<1UL>const __pair_get<1UL> &const _Tp2const _Tp2 &&_Tp2 &&__const_move_getconst _Tp2 &_Tp2 &__const_get__move_get__get__pair_get<0UL> &__pair_get<0UL> &&const __pair_get<0UL>const __pair_get<0UL> &const _Tp1const _Tp1 &&_Tp1 &&const _Tp1 &_Tp1 &__pair_base<_U1, _U2> &const __pair_base<_U1, _U2>const __pair_base<_U1, _U2> &__pair_base~__pair_base_ImplicitlyMoveConvertiblePair_MoveConstructiblePair_ImplicitlyConvertiblePair_ConstructiblePairpiecewise_construct_t &piecewise_construct_t &&const piecewise_construct_tconst piecewise_construct_t &piecewise_construct_tconst pair<_U1, _U2>const pair<_U1, _U2> &pair<_U1, _U2> &pair<_U1, _U2> &&pair<_T1, _T2> &&tuple<_Args1...> &tuple<_Args2...> &const _T1const _T1 &_T1 &const _T2const _T2 &_T2 &use 'nullptr' instead of '0' to initialize std::pair of move-only type and pointer_U1 &&_U2 &&__zero_as_null_pointer_constant__pair_get<1UL>__pair_get<0UL>__pair_get<_Int>tuple_element<1UL, pair<_Tp1, _Tp2>>tuple_element<0UL, pair<_Tp1, _Tp2>>tuple_size<pair<_Tp1, _Tp2>>__is_tuple_like_impl<pair<_T1, _T2>>__pair_base<_U1, _U2>_PCC<false, _T1, _T2>_PCC<<unnamed>, _T1, _T2>tuple<<unnamed>...>first_type__is_pairtuple_size_v_Index_tuple<_Indexes...>secondpiecewise_construct__cpp_lib_tuples_by_type_GLIBCXX_DEPRECATED_PAIR_CTOR__attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))_STL_PAIR_H__cplusplus >= 201103L && ! __cpp_lib_concepts__cpp_lib_three_way_comparison && __cpp_lib_concepts/* _STL_PAIR_H *//** @{
   * std::get overloads for accessing members of std::pair
   *//// Partial specialization for std::pair// Various functions which give std::pair a tuple-like interface.// NB: DR 706.// 181.  make_pair() unintended behavior/**
   *  @brief A convenience wrapper for creating a pair from two objects.
   *  @param  __x  The first object.
   *  @param  __y  The second object.
   *  @return   A newly-constructed pair<> object of the appropriate type.
   *
   *  The C++98 standard says the objects are passed by reference-to-const,
   *  but C++03 says they are passed by value (this was LWG issue #181).
   *
   *  Since C++11 they have been passed by forwarding reference and then
   *  forwarded to the new members of the pair. To create a pair with a
   *  member of reference type, pass a `reference_wrapper` to this function.
   *//// @} relates pair// __cplusplus >= 201103L// Constrained free swap overload, see p0185r1/** Swap overload for pairs. Calls std::pair::swap().
   *
   * @note This std::swap overload is not declared in C++03 mode,
   * which has performance implications, e.g. see https://gcc.gnu.org/PR38466
  */// !(three_way_comparison && concepts)/// Uses @c operator< to find the result./// Uses @c operator== to find the result./** Defines a lexicographical order for pairs.
   *
   * For two pairs of the same type, `P` is ordered before `Q` if
   * `P.first` is less than `Q.first`, or if `P.first` and `Q.first`
   * are equivalent (neither is less than the other) and `P.second` is less
   * than `Q.second`.
  *//// Two pairs of the same type are equal iff their members are equal./// @relates pair @{/// Templated constructor to convert from other pairs./// Two objects may be passed to a `pair` constructor to be copied./** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */// 265.  std::pair::pair() effects overly restrictive// C++03 implementation// lib concepts// in cases where the standard says the zero should be deduced as int// These allow construction from an rvalue and a literal zero,// Deprecated extensions to DR 811.// A type which can be constructed from literal zero, but not nullptr// Shortcut for constraining the templates that take pairs./// Construct from two const lvalues, disallowing implicit conversions./// Construct from two const lvalues, allowing implicit conversions.// Shortcut for constraining the templates that don't take pairs.// C++11/14/17 implementation using enable_if, partially constexpr./// Converting assignment from a `pair<U1, U2>` rvalue/// Converting assignment from a `pair<U1, U2>` lvalue/// Move assignment operator/// Copy assignment operator/// Converting constructor from a `pair<U1, U2>` rvalue/// Converting constructor from a `pair<U1, U2>` lvalue/// Constructor accepting two values of arbitrary types/// Constructor accepting lvalues of `first_type` and `second_type`/// Default constructor// C++20 implementation using concepts, explicit(bool), fully constexpr./// Swap the first members and then the second members.///< Move constructor///< Copy constructor///< The second member///< The first member///< The type of the `second` member///< The type of the `first` member/**
   *  @brief Struct holding two objects of arbitrary type.
   *
   *  @tparam _T1  Type of first object.
   *  @tparam _T2  Type of second object.
   *
   *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
   */// avoid querying those properties for incomplete types.// is_convertible if the types are the same to// See PR 70437, don't look at is_constructible or// constructors.// Concept utility functions, reused in conditionally-explicit// Forward declarations./// Tag for piecewise construction of std::pair objects./// Tag type for piecewise construction of std::pair objects.// for std::tuple_element, std::tuple_size// for std::move / std::forward, and std::swap// for std::__decay_and_strip/** @file bits/stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */// Pair implementation -*- C++ -*-__in__pairscoped_perf_section &scoped_perf_section &&const scoped_perf_sectionconst scoped_perf_section &scoped_perf_sectionscoped_perf_section *lzham_timer &lzham_timer &&const lzham_timerconst lzham_timer &lzham_timerget_msget_secsticks_to_ms1000.0fticks_to_secsget_ticksget_init_ticksget_ticks_per_secget_elapsed_usget_elapsed_msconst lzham_timer *lzham_timer *get_elapsed_secsvar_args_ttimer_ticksm_stoppedm_startedm_stop_timem_start_timeg_inv_freqg_freqg_init_ticks// LZHAM_PERF_SECTIONS   // File: lzham_timer.hticksstart_ticksassert_perror(errnum)(!(errnum) ? __ASSERT_VOID_CAST (0) : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))(static_cast <bool> (expr) ? void (0) : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))static_cast<void>/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_platform.cppvoid lzham_debug_break()(int)sizeOfBuffer - 1LZHAM_FORCE_DEBUGGER_PRESENT(TARGET_OS_MAC == 1) && (TARGET_IPHONE_SIMULATOR == 0) && (TARGET_OS_IPHONE == 0)// This stuff was a quick hack only intended for debugging/development.// __GNUC__// File: platform.cpp__underlying_type_impl<_Tp, value>integral_constant<bool, __is_in_place_type_v>setpayloadsigf64x_Float64x *setpayloadf64x__getpayloadf64xconst _Float64xconst _Float64x *getpayloadf64xtotalordermagf64xtotalorderf64x__fminimum_mag_numf64xfminimum_mag_numf64x__fmaximum_mag_numf64xfmaximum_mag_numf64x__fminimum_magf64xfminimum_magf64x__fmaximum_magf64xfmaximum_magf64x__fminimum_numf64xfminimum_numf64x__fmaximum_numf64xfmaximum_numf64x__fminimumf64xfminimumf64x__fmaximumf64xfmaximumf64x__fminmagf64xfminmagf64x__fmaxmagf64xfmaxmagf64xcanonicalizef64x__ufromfpxf64xufromfpxf64x__fromfpxf64xfromfpxf64x__ufromfpf64xufromfpf64x__fromfpf64xfromfpf64x__roundevenf64xroundevenf64x__fmaf64xfmaf64x__fminf64xfminf64x__fmaxf64xfmaxf64x__fdimf64xfdimf64x__llroundf64xllroundf64x__lroundf64xlroundf64x__llrintf64xllrintf64x__lrintf64xlrintf64x__remquof64xremquof64x__truncf64xtruncf64x__roundf64xroundf64x__nearbyintf64xnearbyintf64x__scalblnf64xscalblnf64x__llogbf64xllogbf64x__ilogbf64xilogbf64x__scalbnf64xscalbnf64x__remainderf64xremainderf64x__nextupf64xnextupf64x__nextdownf64xnextdownf64x__nextafterf64xnextafterf64x__rintf64xrintf64x__lgammaf64x_rlgammaf64x_r__tgammaf64xtgammaf64x__lgammaf64xlgammaf64x__erfcf64xerfcf64x__erff64xerff64x__ynf64xynf64x__y1f64xy1f64x__y0f64xy0f64x__jnf64xjnf64x__j1f64xj1f64x__j0f64xj0f64x__nanf64xnanf64x__copysignf64xcopysignf64x__fmodf64xfmodf64x__floorf64xfloorf64x__fabsf64xfabsf64x__ceilf64xceilf64x__cbrtf64xcbrtf64x__hypotf64xhypotf64x__sqrtf64xsqrtf64x__powf64xpowf64x__log2f64xlog2f64x__exp2f64xexp2f64x__logbf64xlogbf64x__log1pf64xlog1pf64x__expm1f64xexpm1f64x__exp10f64xexp10f64x__modff64xmodff64x__log10f64xlog10f64x__logf64xlogf64x__ldexpf64xldexpf64x__frexpf64xfrexpf64x__expf64xexpf64x__atanhf64xatanhf64x__asinhf64xasinhf64x__acoshf64xacoshf64x__sincosf64xsincosf64x__tanhf64xtanhf64x__sinhf64xsinhf64x__coshf64xcoshf64x__tanf64xtanf64x__sinf64xsinf64x__cosf64xcosf64x__atan2f64xatan2f64x__atanf64xatanf64x__asinf64xasinf64x__acosf64xacosf64x(_Float64x *__x, _Float64x __payload)(const _Float64x *__x)(const _Float64x *__x, const _Float64x *__y)(_Float64x __x, _Float64x __y)(_Float64x *__cx, const _Float64x *__x)(_Float64x __x, int __round, unsigned int __width)(_Float64x __x)(_Float64x __x, _Float64x __y, _Float64x __z)(_Float64x __x, _Float64x __y, int *__quo)(_Float64x __x, long int __n)(_Float64x __x, int __n)(_Float64x, int *__signgamp)(_Float64x)(int, _Float64x)(_Float64x __x, _Float64x *__iptr)(_Float64x __x, int __exponent)(_Float64x __x, int *__exponent)(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx)(_Float64x __y, _Float64x __x)f64subf64xf64sqrtf64xf64mulf64xf64fmaf64xf64divf64xf64addf64x<debug/assertions.h>_InputIterator &__advance_OutputIterator &_RandomAccessIterator &_BidirectionalIterator &__distance_List_const_iterator<<unnamed>>_List_iterator<<unnamed>>_STL_ITERATOR_BASE_FUNCS_H__n >= 0/* _STL_ITERATOR_BASE_FUNCS_H */// concept requirements -- taken care of in __advance/**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __i  An input iterator.
   *  @param  __n  The @a delta by which to change @p __i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p __n may be negative, in which case @p __i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */// Give better error if std::advance called with a non-Cpp17InputIterator.// concept requirements -- taken care of in __distance/**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __first  An input iterator.
   *  @param  __last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that __first + n == __last.  This requires
   *  that @p __last must be reachable from @p __first.  Note that @c
   *  n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */// Give better error if std::distance called with a non-Cpp17InputIterator.// Forward declaration because of the qualified call in distance.// Forward declaration for the overloads of __distance./** @file bits/stl_iterator_base_funcs.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility
 *  functions, such as distance() and advance().
 */// Functions used by iterators -*- C++ -*-element_typeelement_type *const _Ptrconst _Ptr &_Ptr &pointer_toelement_type &_Elt &pointer_traits<_Tp *>rebind__ptr_traits_impl<_Ptr, __undefined>__ptr_traits_impl<_Ptr, _Elt>__rebind<_Tp, _Up, <unnamed>>__difference<_Tp, <unnamed>>__ptr_traits_ptr_to<_Tp *, _Tp, false>__ptr_traits_ptr_to<_Ptr, _Elt, true>__ptr_traits_ptr_to<_Ptr, _Elt, <unnamed>>__ptr_traits_elem_t__ptr_traits_elem<_Ptr, __void_t<element_type>>__ptr_traits_elem<_Ptr, <unnamed>>__replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>__get_first_arg<_SomeTemplate<_Tp, _Types...>>__get_first_arg<_Tp>__undefined_SomeTemplate_PTR_TRAITS_H__cpp_lib_constexpr_memory__cpp_concepts/**
   * @brief Obtain address referenced by a pointer to an object
   * @param __ptr A pointer to an object
   * @return @c pointer_traits<_Ptr>::to_address(__ptr) if that expression is
             well-formed, otherwise @c to_address(__ptr.operator->())
   * @ingroup pointer_abstractions
  *//**
   * @brief Obtain address referenced by a pointer to an object
   * @param __ptr A pointer to an object
   * @return @c __ptr
   * @ingroup pointer_abstractions
  *//// Convenience alias for rebinding pointers./// A pointer to a different type./// Type used to represent the difference between two pointers/// The type pointed to/// The pointer type/**
   * @brief  Partial specialization for built-in pointers.
   * @ingroup pointer_abstractions
   * @since C++11
  *//**
   * @brief  Uniform interface to all pointer-like types
   * @ingroup pointer_abstractions
   * @since C++11
  */// 3545. std::pointer_traits should be SFINAE-friendly/// The type used to represent the difference between two pointers./// The type pointed to./// The pointer type./**
       *  @brief  Obtain a pointer to an object
       *  @param  __r  A reference to an object of type `element_type`
       *  @return `addressof(__r)`
      */// Partial specialization defining pointer_traits<T*>::pointer_to(T&).// Do not define pointer_traits<P>::pointer_to if element type is void./**
       *  @brief  Obtain a pointer to an object
       *  @param  __r  A reference to an object of type `element_type`
       *  @return `pointer::pointer_to(__e)`
       *  @pre `pointer::pointer_to(__e)` is a valid expression.
      */// Define pointer_traits<P>::pointer_to.// Use _Ptr::element_type if is a valid type.// Detect the element type of a pointer-like type.// by a requires-clause, so __ptr_traits_elem_t only needs to do this:// When concepts are supported detection of _Ptr::element_type is done// `type` is `SomeTemplate<U, Args...>`, otherwise there is no member `type`.// For a specialization `SomeTemplate<T, Args...>` and a type `U` the member// otherwise `type` is `__undefined`.// For a specialization `SomeTemplate<T, Types...>` the member `type` is T,// Defined to a newer value in bits/unique_ptr.h for C++23/** @file bits/ptr_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Copyright (C) 2011-2022 Free Software Foundation, Inc.// Pointer Traits -*- C++ -*-2.7182818284590452353602874713526625L__sqrt1_21.25331413731550025121.2533141373155002512078826424055226L__sqrt2__2_sqrtpi__1_pi0.785398163397448309630.7853981633974483096156608458198757L__pi_33.14159265358979323853.1415926535897932384626433832795029L__floating_point_constant<_Tp>_GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC// _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H/// std::isnan./// out of intrinsics, this will disappear completely in favor of/// all comparisons result in false. If/when we build a std::isnan/// This is a wrapper for the isnan function. Otherwise, for NaN,///  Constant Euler-Mascheroni @f$ e @f$///  Constant Euler's constant @f$ \gamma_E @f$.///  Constant @f$ \log(\pi) @f$.///  Constant @f$ 1 / sqrt(2) @f$.///  Constant @f$ \sqrt(\pi/2) @f$.///  Constant @f$ \sqrt(3) @f$.///  Constant @f$ \sqrt(2) @f$.///  Constant @f$ 2 / \sqrt(\pi) @f$.///  Constant @f$ 1 / \pi @f$.///  Constant @f$ \pi / 4 @f$.///  Constant @f$ \pi / 3 @f$.///  Constant @f$ \pi / 2 @f$.///  Constant @f$ \pi @f$./// A structure for numeric constants./// type logic./// constants.  Not everything will be able to be expressed as/// A class to encapsulate type dependent floating point// Written by Edward Smith-Rowland based on numerous mathematics books./** @file tr1/special_function_util.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__comp_ellint_2_series__comp_ellint_1_series_GLIBCXX_TR1_ELL_INTEGRAL_TCC// _GLIBCXX_TR1_ELL_INTEGRAL_TCC//  Reduce phi to -pi/2 < phi < +pi/2./**
     *   @brief Return the incomplete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu,\phi) = \int_0^{\phi}
     *                       \frac{d\theta}
     *                            {(1 - \nu \sin^2\theta)
     *                             \sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the third kind.
     *//**
     *   @brief Return the complete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ using the
     *          Carlson formulation.
     * 
     *   The complete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu) = \int_0^{\pi/2}
     *                   \frac{d\theta}
     *                 {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @return  The complete elliptic function of the third kind.
     *//**
     *   @brief  Return the Carlson elliptic function @f$ R_J(x,y,z,p) @f$
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the third kind is defined by:
     *   @f[
     *       R_J(x,y,z,p) = \frac{3}{2} \int_0^\infty
     *       \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}(t + p)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @param  __p  The fourth argument.
     *   @return  The Carlson elliptic function of the fourth kind.
     *//**
     *   @brief  Return the Carlson elliptic function
     *           @f$ R_C(x,y) = R_F(x,y,y) @f$ where @f$ R_F(x,y,z) @f$
     *           is the Carlson elliptic function of the first kind.
     * 
     *   The Carlson elliptic function is defined by:
     *   @f[
     *       R_C(x,y) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first argument.
     *   @param  __y  The second argument.
     *   @return  The Carlson elliptic function.
     *//**
     *   @brief  Return the incomplete elliptic integral of the second kind
     *           @f$ E(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the second kind.
     *//**
     *   @brief  Return the complete elliptic integral of the second kind
     *           @f$ E(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the Carlson elliptic function of the second kind
     *           @f$ R_D(x,y,z) = R_J(x,y,z,z) @f$ where
     *           @f$ R_J(x,y,z,p) @f$ is the Carlson elliptic function
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the second kind is defined by:
     *   @f[
     *       R_D(x,y,z) = \frac{3}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{3/2}}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of two symmetric arguments.
     *   @param  __y  The second of two symmetric arguments.
     *   @param  __z  The third argument.
     *   @return  The Carlson elliptic function of the second kind.
     *//**
     *   @brief Return the complete elliptic integral of the second kind
     *          @f$ E(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the incomplete elliptic integral of the first kind
     *           @f$ F(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the first kind is defined as
     *   @f[
     *     F(k,\phi) = \int_0^{\phi}\frac{d\theta}
     *                                   {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the first kind.
     *//**
     *   @brief  Return the complete elliptic integral of the first kind
     *           @f$ K(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                                           {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     *   where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
     *   first kind.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the complete elliptic integral of the first kind
     *          @f$ K(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                              {\sqrt{1 - k^2sin^2\theta}}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the Carlson elliptic function @f$ R_F(x,y,z) @f$
     *          of the first kind.
     * 
     *   The Carlson elliptic function of the first kind is defined by:
     *   @f[
     *       R_F(x,y,z) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}}
     *   @f]
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @return  The Carlson elliptic function of the first kind.
     *///        (1992), pp. 261-269//        W. T. Vetterling, B. P. Flannery, Cambridge University Press//   (4)  Numerical Recipes in C, 2nd ed, by W. H. Press, S. A. Teukolsky,//   (3)  The Gnu Scientific Library, http://www.gnu.org/software/gsl//   (2)  B. C. Carlson, Special Functions of Applied Mathematics (1977)//   (1)  B. C. Carlson Numer. Math. 33, 1 (1979)/** @file tr1/ell_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__va_copy(d,s)__builtin_va_copy(d,s)va_copy(d,s)va_arg(v,l)__builtin_va_arg(v,l)va_end(v)__builtin_va_end(v)va_start(v,l)__builtin_va_start(v,l)_BITS_UIO_LIM_H/* Maximum length of the 'struct iovec' array in a single call to
   readv or writev.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  *//* Implementation limits related to sys/uio.h - Linux version.
   Copyright (C) 2017-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */get_unshifted_max_code(len >= 1) && (len <= cMaxExpectedCodeSize)const char[93]char[93]cMaxExpectedCodeSizecMaxExpectedCodeSize + 1~decoder_tablesconst decoder_tables &decoder_tables &pCur_lookuppCur_sorted_symbol_ordersizeof(*this)sizeof(m_lookup[0])sizeof(m_sorted_symbol_order[0])decoder_tablesm_sorted_symbol_orderm_cur_sorted_symbol_order_sizem_lookupm_cur_lookup_sizem_val_ptrsm_max_codesm_max_code_sizem_min_code_sizem_decode_start_code_sizem_table_max_codem_table_shiftm_table_bitsm_total_used_symsm_num_symscMaxTableBitscMaxSupportedSymsprefix_codinggenerate_decoder_tablesgenerate_codeslimit_max_code_size// namespace prefix_coding// DO NOT use any complex classes here - it is bitwise copied.// This value can be tuned for a specific CPU.// File: lzham_prefix_coding.hpCodes/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_prefix_coding.cppuint[16]min_codesunsigned int(&)[17]uint(&)[17]sorted_positionstotal_used_symsmin_code_sizenum_codes[c]sorted_pos < total_used_symssorted_pospCodesizes[sym_index] == codesizet < (1U << table_bits)pTables->m_lookup[t] == UINT32_MAXstatic_cast<uint>(sizeof(pTables->m_lookup[0]))codesizefillsizefillnummin_codemax_codesym_index291297299c <= cMaxExpectedCodeSize(cMaxExpectedCodeSize + 1)1 << (cMaxExpectedCodeSize + 1)(1 << (cMaxExpectedCodeSize + 1))!c || (next_code[c] <= UINT16_MAX)!c || (math::total_bits(pCodes[i]) <= pCodesizes[i])cMaxEverCodeSizeuint[35]unsigned int[35]cMaxEverCodeSize + 1unsigned int(&)[35]uint(&)[35]should_limitc <= cMaxEverCodeSizenext_sorted_ofsuint8[1024]new_codesizesnext_ofs// namespace prefix_codig// sentinels//UINT_MAX;// (If you remember what LHArc was, you've been doing this for a LONG time.)// Technique of adjusting tree to enforce maximum code size from LHArc. //#define TEST_DECODER_TABLES// File: lzham_prefix_coding.cpp_Deque_iterator<_OTp, _OTp &, _OTp *>_OTp &_OTp *__enable_if<__value, _Deque_iterator<_Tp, _Tp &, _Tp *>>__enable_if<__value, void>__normal_iterator<_Iter, _Container>__ptr_traits_ptr_to<_Tp *, _Tp, value>__and_<_Bn...>__is_nt_copy_assignable_impl<_Tp, value>__is_nt_move_assignable_impl<_Tp, value>__is_trivially_move_assignable_impl<_Tp, value>__and_<__is_destructible_safe<_Tp, value, value>, integral_constant<bool, <expression>>>integral_constant<unsigned long, __alignof__(_Tp)>__add_rvalue_reference_helper<_Tp, value>__select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true>__select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> &__select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> &&const __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true>const __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> &is_reference<_NestedType>is_function<_NestedType>is_void<_NestedType>is_const<_Qualified>__is_integer_nonstrict<_Value>__is_integer<long double>__is_integer<long double> &__is_integer<long double> &&const __is_integer<long double>const __is_integer<long double> &__traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>>unsigned int(*)[35]unsigned int(*)[17]_PCC<true, _T1, _T2>_PCC<<expression>, _T1, _T2>__or_<is_same<_Tp, _Types>...>__strip_reference_wrapper<type>common_type<_Dp1, _Dp2>__detector<_Default, void, _Op, _Args...>__call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>_Index_tuple<__integer_pack(_Num)...>integer_sequence<_Tp, __integer_pack(_Num)...>integer_sequence<unsigned long, _Idx...>integer_sequence<unsigned long, __integer_pack(_Num)...>integer_sequence<unsigned long, __integer_pack(<expression>)...>rebind<_Tp>type<type &&, reference>type<_B1, __or_<_B2, _B3, _Bn...>>type<_B1, _B2>3.141592741static_cast<_Tp>(3.1415926535897932384626433832795029L)__beta_lgamma__bet(_Tp(2))__expint_Ei_asymp__expint_Ei_series4.768371582e-07_Tp(4) * std::numeric_limits<_Tp>::epsilon()_Tp(100)4.336808689942017736e-19is_integral<unsigned short>is_integral<unsigned short> &is_integral<unsigned short> &&const is_integral<unsigned short>const is_integral<unsigned short> &is_volatile<char16_t>is_volatile<char16_t> &is_volatile<char16_t> &&const is_volatile<char16_t>const is_volatile<char16_t> &const float[9]float[9]0.9189385176676.5203857-1259.13916771.3234253-176.61503612.50734329-0.13857109849.984369171e-061.505632667e-07is_enum<wchar_t>is_enum<wchar_t> &is_enum<wchar_t> &&const is_enum<wchar_t>const is_enum<wchar_t> &is_integral<wchar_t>is_integral<wchar_t> &is_integral<wchar_t> &&const is_integral<wchar_t>const is_integral<wchar_t> &__cv_selector<signed int, false, false>__cv_selector<signed int, false, false> &__cv_selector<signed int, false, false> &&const __cv_selector<signed int, false, false>const __cv_selector<signed int, false, false> &is_const<unsigned int>is_const<unsigned int> &is_const<unsigned int> &&const is_const<unsigned int>const is_const<unsigned int> &is_enum<char16_t>is_enum<char16_t> &is_enum<char16_t> &&const is_enum<char16_t>const is_enum<char16_t> &is_integral<char16_t>is_integral<char16_t> &is_integral<char16_t> &&const is_integral<char16_t>const is_integral<char16_t> &__cv_selector<signed short, false, false>__cv_selector<signed short, false, false> &__cv_selector<signed short, false, false> &&const __cv_selector<signed short, false, false>const __cv_selector<signed short, false, false> &is_const<unsigned short>is_const<unsigned short> &is_const<unsigned short> &&const is_const<unsigned short>const is_const<unsigned short> &is_enum<char32_t>is_enum<char32_t> &is_enum<char32_t> &&const is_enum<char32_t>const is_enum<char32_t> &is_integral<char32_t>is_integral<char32_t> &is_integral<char32_t> &&const is_integral<char32_t>const is_integral<char32_t> &2.718281746static_cast<_Tp>(2.7182818284590452353602874713526625L)fsubfsqrtfmulffmafdivfaddfsublfsqrtlfmullffmalfdivlfaddldsubldsqrtldmulldfmalddivldaddlf32subf32xf32sqrtf32xf32mulf32xf32fmaf32xf32divf32xf32addf32xf32subf64f32sqrtf64f32mulf64f32fmaf64f32divf64f32addf64f32subf64xf32sqrtf64xf32mulf64xf32fmaf64xf32divf64xf32addf64xf32subf128f32sqrtf128f32mulf128f32fmaf128f32divf128f32addf128f32xsubf64xf32xsqrtf64xf32xmulf64xf32xfmaf64xf32xdivf64xf32xaddf64xf32xsubf128f32xsqrtf128f32xmulf128f32xfmaf128f32xdivf128f32xaddf128f64subf128f64sqrtf128f64mulf128f64fmaf128f64divf128f64addf128__throw_exception_againthrow__catch(X)catch(X)__trytry_EXCEPTION_DEFINES_H! __cpp_exceptions// Else proceed normally.// Iff -fno-exceptions, transform error handling code to work without it./** @file bits/exception_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 */// -fno-exceptions Support -*- C++ -*-__find_uniq_type_in_packin_place_index_tin_place_type_tin_place_t &in_place_t &&const in_place_tconst in_place_t &in_place_t_Nth_type<1UL, _Tp0, _Tp1, _Tp2, _Rest...>_Nth_type<0UL, _Tp0, _Tp1, _Tp2, _Rest...>_Nth_type<0UL, _Tp0, _Tp1, _Rest...>_Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>_Nth_type<2UL, _Tp0, _Tp1, _Tp2, _Rest...>_Nth_type<1UL, _Tp0, _Tp1, _Rest...>_Nth_type<0UL, _Tp0, _Rest...>_Nth_type<_Np, _Types...>integer_sequence<_Tp, _Idx...>_Build_index_tuple<_Num>_Num_Indexestuple_element_ttuple_element<__i, const volatile _Tp>tuple_element<__i, volatile _Tp>tuple_element<__i, const _Tp>__tuple_element_ttuple_element<__i, _Tp>tuple_size<const volatile __enable_if_has_tuple_size<_Tp, type, type, value>>const volatile __enable_if_has_tuple_size<_Tp, type, type, value>tuple_size<volatile __enable_if_has_tuple_size<_Tp, type, type, value>>volatile __enable_if_has_tuple_size<_Tp, type, type, value>tuple_size<const __enable_if_has_tuple_size<_Tp, type, type, value>>const __enable_if_has_tuple_size<_Tp, type, type, value>in_place_indexin_place_typein_place__cpp_lib_integer_sequence__cpp_lib_tuple_element_t_GLIBCXX_UTILITY_H__has_builtin(__make_integer_seq)! __cpp_concepts/* _GLIBCXX_UTILITY_H */// Need additional specializations to avoid ambiguities./// Alias template index_sequence_for/// Alias template make_index_sequence/// Alias template index_sequence/// Alias template make_integer_sequence/// Class template integer_sequence// For GCC and other compilers, use __integer_pack instead.// Clang defines __make_integer_seq for this purpose.// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.// extract the elements in a tuple.// Stores a tuple of indices.  Used by tuple and pair, and by bind() to//       tuple_size/tuple_element are// 3378. tuple_size_v/tuple_element_t should be available when// define them here, to be available in <array>, <utility> and <ranges> too.// The standard says this macro and alias template should be in <tuple> but we// more than one _Tp found// Otherwise, return sizeof...(_Types).// Return the index of _Tp in _Types, if it occurs exactly once.// Duplicate of C++14's tuple_element_t for internal use in C++11 mode/// Gives the type of the ith element of a given tuple type.// 2770. tuple_size<const T> specialization is not SFINAE compatible// 2313. tuple_size should always derive from integral_constant<size_t, N>/// Finds the size of a given tuple type./** @file include/bits/utility.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 *
 *  This file contains the parts of `<utility>` needed by other headers,
 *  so they don't need to include the whole of `<utility>`.
 */// Copyright (C) 2004-2022 Free Software Foundation, Inc.// Utilities used throughout the library -*- C++ -*-__iterator_categoryconst _Iterconst _Iter &_Iter &output_iterator_tag &output_iterator_tag &&const output_iterator_tagconst output_iterator_tag &random_access_iterator_tagrandom_access_iterator_tag &random_access_iterator_tag &&const random_access_iterator_tagconst random_access_iterator_tag &bidirectional_iterator_tagbidirectional_iterator_tag &bidirectional_iterator_tag &&const bidirectional_iterator_tagconst bidirectional_iterator_tag &forward_iterator_tagforward_iterator_tag &forward_iterator_tag &&const forward_iterator_tagconst forward_iterator_tag &input_iterator_tag &input_iterator_tag &&const input_iterator_tagconst input_iterator_tag &__is_random_access_iter<_It, _Cat>_It_RequireInputIteriterator_traits<const _Tp *>iterator_traits<_Tp *>__iterator_traits<_Iterator, __void_t<iterator_category, value_type, difference_type, pointer, reference>>__iterator_traits<_Iterator, <unnamed>>iterator<_Category, _Tp, _Distance, _Pointer, _Reference>_Referenceoutput_iterator_taginput_iterator_tag_InIter_STL_ITERATOR_BASE_TYPES_H__cpp_concepts >= 201907L/* _STL_ITERATOR_BASE_TYPES_H *//**
   *  This function is not a part of the C++ standard but is syntactic
   *  sugar for internal library use only.
  *//// Partial specialization for const pointer types./// Partial specialization for pointer types./// Partial specialization for object pointer types.// ! C++11// ! concepts// 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14/**
   *  @brief  Traits class for iterators.
   *
   *  This class does nothing but define nested typedefs.  The general
   *  version simply @a forwards the nested typedefs from the Iterator
   *  argument.  Specialized versions for pointers and pointers-to-const
   *  provide tighter, more correct semantics.
  *//// This type represents a reference-to-value_type./// This type represents a pointer-to-value_type./// Distance between iterators is represented as this type./// The type "pointed to" by the iterator./// One of the @link iterator_tags tag types@endlink./**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
  *//// Contiguous iterators point to objects stored contiguously in memory./// iterator operations./// Random-access iterators support a superset of bidirectional/// operations./// Bidirectional iterators support a superset of forward iterator/// Forward iterators support a superset of input iterator operations.///  Marking output iterators.///  Marking input iterators./**
   *  @defgroup iterator_tags Iterator Tags
   *  These are empty types, used to distinguish different iterators.  The
   *  distinction is not made by what they contain, but simply by what they
   *  are.  Different underlying algorithms can then be used based on the
   *  different operations supported by different iterator types.
  *//**
   *  @defgroup iterators Iterators
   *  Abstractions for uniform iterating through various underlying types.
  */// For __void_t, is_convertible/** @file bits/stl_iterator_base_types.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility types,
 *  such as iterator_traits and struct iterator.
 */// Types used in iterator implementation -*- C++ -*-__glibcxx_class_requires4(_a,_b,_c,_d,_e)__glibcxx_class_requires3(_a,_b,_c,_d)__glibcxx_class_requires2(_a,_b,_c)__glibcxx_class_requires(_a,_b)__glibcxx_function_requires(__VA_ARGS__...)_CONCEPT_CHECK_H!defined(_GLIBCXX_CONCEPT_CHECKS) || !_GLIBCXX_HOSTED// _GLIBCXX_CONCEPT_CHECK// enable/disable// a valid instantiation pattern.  Thus, we steal a feature from C99.// parenthesis to hide the commas, because "debug::(Temp<Foo,Bar>)" isn't// the commas in the template argument list.  We can't use an inner pair of// BinaryPredicateConcept.  The preprocessor tries to split things up on// won't work due to concept templates with more than one parameter, e.g.,//#define glibcxx_function_requires(C) debug::function_requires< debug::C >()// Note that the obvious and elegant approach of// the checks are on// It is not supported for freestanding implementations.// configure options or editing c++config.h.// Concept-checking code is off by default unless users turn it on via// if you're looking for additional places to use these.// "concept requirements" (and maybe some more text).  So grep like crazy// don't need to be used, or perhaps /should/ be used, are commented with// All places in libstdc++-v3 where these are used, or /might/ be used, or/** @file bits/concept_check.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */// Concept-checking control -*- C++ -*-__glibcxx_requires_subscript(_N)__glibcxx_requires_nonempty()__glibcxx_requires_non_empty_range(_First,_Last)_GLIBCXX_DEBUG_ONLY(_Statement)_GLIBCXX_DEBUG_PEDASSERT(_Condition)_GLIBCXX_DEBUG_ASSERT(_Condition)_GLIBCXX_DEBUG_ASSERTIONS_H_GLIBCXX_DEBUG_PEDANTIC// _GLIBCXX_DEBUG_ASSERTIONS// Verify that the container is nonempty// Verify that [_First, _Last) forms a non-empty iterator range./** @file debug/assertions.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */// Copyright (C) 2003-2022 Free Software Foundation, Inc.// Debugging support implementation -*- C++ -*-/usr/include/c++/12/debug__glibcxx_requires_irreflexive_pred2(_First,_Last,_Pred)__glibcxx_requires_irreflexive_pred(_First,_Last,_Pred)__glibcxx_requires_irreflexive2(_First,_Last)__glibcxx_requires_irreflexive(_First,_Last)__glibcxx_requires_string_len(_String,_Len)__glibcxx_requires_string(_String)__glibcxx_requires_heap_pred(_First,_Last,_Pred)__glibcxx_requires_heap(_First,_Last)__glibcxx_requires_partitioned_upper_pred(_First,_Last,_Value,_Pred)__glibcxx_requires_partitioned_lower_pred(_First,_Last,_Value,_Pred)__glibcxx_requires_partitioned_upper(_First,_Last,_Value)__glibcxx_requires_partitioned_lower(_First,_Last,_Value)__glibcxx_requires_sorted_set_pred(_First1,_Last1,_First2,_Pred)__glibcxx_requires_sorted_set(_First1,_Last1,_First2)__glibcxx_requires_sorted_pred(_First,_Last,_Pred)__glibcxx_requires_sorted(_First,_Last)__glibcxx_requires_can_decrement_range(_First1,_Last1,_First2)__glibcxx_requires_can_increment_range(_First1,_Last1,_First2)__glibcxx_requires_can_increment(_First,_Size)__glibcxx_requires_valid_range(_First,_Last)__glibcxx_requires_cond(_Cond,_Msg)_GLIBCXX_DEBUG_MACRO_SWITCH_H__gnu_debug__debug// _GLIBCXX_DEBUG_MACRO_SWITCH_H/** @namespace __gnu_debug
 *  @brief GNU debug classes for public use.
*//**
 * @namespace std::__debug
 * @brief GNU debug code, replaces standard behavior with debug behavior.
 */// Debug mode namespaces./** Macros and namespaces used by the implementation outside of debug
 *  wrappers to verify certain properties. The __glibcxx_requires_xxx
 *  macros are merely wrappers around the __glibcxx_check_xxx wrappers
 *  when we are compiling with debug mode, but disappear when we are
 *  in release mode so that there is no checking performed in, e.g.,
 *  the standard library algorithms.
*//** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */__beta_product__beta_gamma_GLIBCXX_TR1_BETA_FUNCTION_TCC// _GLIBCXX_TR1_BETA_FUNCTION_TCC/**
     *   @brief  Return the beta function \f$ B(x,y) \f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the product form.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the log gamma functions.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function: \f$B(x,y)\f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//** @file tr1/beta_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__expint_large_n__expint_asymp__expint_En_recursion__expint_En_series__expint_E1_GLIBCXX_TR1_EXP_INTEGRAL_TCC"Series summation failed " "in __expint_En_series."// _GLIBCXX_TR1_EXP_INTEGRAL_TCC/**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *   \f[
     *     Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *   \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large order.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *        
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large argument.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Find a good asymptotic switch point./**
     *   @brief Return the exponential integral @f$ E_1(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Check this starting number.//  Backward recursion is stable only for n >= x.//  Forward recursion is stable only for n < x./**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by recursion.  Use upward recursion for @f$ x < n @f$
     *          and downward recursion (Miller's algorithm) otherwise.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by continued fractions.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by series summation.  This should be good
     *          for @f$ x < 1 @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^{\infty} \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///       2nd ed, pp. 222-225.//       Dover Publications, New-York, Section 5, pp. 228-251.//  Written by Edward Smith-Rowland based on:/** @file tr1/exp_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_symbol_codec.cppnum_bits <= 251365m_bit_count <= cBitBufSize138713281350arith_buf_ofsm_arith_output_buf.size()bit == sym.m_bitsoutput_symbol::cAlignToByteSymoutput_symbol::cArithInit1087output_symbol::cArithSymnum_bits_in1029m_bit_count >= 25cBitBufSize - 8(cBitBufSize - 8)orig_base2 * cSymbolCodecArithMinLencSymbolCodecArithMinLen >> 1(cSymbolCodecArithMinLen >> 1)cSymbolCodecArithMinLen >> 9(cSymbolCodecArithMinLen >> 9)m_mode == cEncoding995997998m_mode == cDecoding13171236!model.m_encoding1237cBitBufSize - 16(cBitBufSize - 16)t != UINT32_MAXmodel.m_code_sizes[sym] == len12681272129013041398119012031204122611721463bitmask886821model.m_encoding822831807793769(num_bits == 32) || (bits <= ((1U << num_bits) - 1))const adaptive_bit_model_vectorconst adaptive_bit_model_vector &2048.0cSymbolCodecArithProbScale - 1!m_symbols_until_updateconst char[24]498m_total_count <= 65535base_code_sizenum_lefttotal_freq == m_total_count__builtin_alloca531prefix_coding::cMaxExpectedCodeSize538(m_adapt_rate ? m_adapt_rate : LZHAM_DEFAULT_ADAPT_RATE)(m_adapt_rate ? m_adapt_rate : 64U)actual_table_bitscost_to_use_tablecost_to_not_use_table571actual_totalactual_total == m_total_count487max_update_interval <= 0xFFFF355adapt_rate <= 0xFFFF356max_table_bitsprefix_coding::cMaxTableBitsLZHAM_DEFAULT_MAX_UPDATE_INTERVALm_encoding(false)LZHAM_CREATE_PROB_COST_TABLELZHAM_DEFAULT_ADAPT_RATE// corrupted stream, or a bug// Huffman or plain bits// This renorm logic must match the logic used in the arithmetic decoder.// All bits from each source must be output in exactly the same order that the decompressor will read them.// Intermix the final Arithmetic, Huffman, or plain bits to a single combined bitstream.// to ensure the last bits are flushed// Try to see if using the accel table is actually worth the trouble of constructing it.// Shortcut building the Huffman codes if we know all the sym freqs are 1.// this was 8 in the alphas// Slam m_update_cycle to a specific value so update_tables() sets m_total_count to the proper value// 1.0/ln(2)// Using a fixed table to convert from scaled probability to scaled bits for determinism across compilers/run-time libs/platforms.// Keep in sync with default setting in g_table_update_settings[]// Was 40 in previous versions// Was 16 in previous versions.// File: lzham_symbol_codec.cppis_vector<T>vector<unsigned short>vector<unsigned char>vector<adaptive_bit_model>vector<output_symbol>adaptive_bit_model_vector_PCCPvector<unsigned short> *const vector<unsigned short> *vector<adaptive_bit_model> *const vector<adaptive_bit_model> *const output_symbol *const vector<output_symbol> *scalar_type<output_symbol>scalar_type<output_symbol> &scalar_type<output_symbol> &&const scalar_type<output_symbol>const scalar_type<output_symbol> &bitwise_copyable<adaptive_bit_model>bitwise_copyable<adaptive_bit_model> &bitwise_copyable<adaptive_bit_model> &&const bitwise_copyable<adaptive_bit_model>const bitwise_copyable<adaptive_bit_model> &scalar_type<adaptive_bit_model>scalar_type<adaptive_bit_model> &scalar_type<adaptive_bit_model> &&const scalar_type<adaptive_bit_model>const scalar_type<adaptive_bit_model> &scalar_type<decoder_tables>scalar_type<decoder_tables> &scalar_type<decoder_tables> &&const scalar_type<decoder_tables>const scalar_type<decoder_tables> &bitwise_copyable<unsigned short>bitwise_copyable<unsigned short> &bitwise_copyable<unsigned short> &&const bitwise_copyable<unsigned short>const bitwise_copyable<unsigned short> &bitwise_copyable<unsigned char>bitwise_copyable<unsigned char> &bitwise_copyable<unsigned char> &&const bitwise_copyable<unsigned char>const bitwise_copyable<unsigned char> &is_array<_Tp>type<_B2, _B1>type<pair<_T1, _T2> &&, __nonesuch &&>__nonesuch &&is_nothrow_move_assignable<_T2>is_nothrow_move_assignable<_T1>rel_ops<vector<output_symbol>>rel_ops<vector<output_symbol>> &rel_ops<vector<output_symbol>> &&const rel_ops<vector<output_symbol>>const rel_ops<vector<output_symbol>> &is_vector<output_symbol>is_vector<output_symbol> &is_vector<output_symbol> &&const is_vector<output_symbol>const is_vector<output_symbol> &rel_ops<vector<adaptive_bit_model>>rel_ops<vector<adaptive_bit_model>> &rel_ops<vector<adaptive_bit_model>> &&const rel_ops<vector<adaptive_bit_model>>const rel_ops<vector<adaptive_bit_model>> &is_vector<adaptive_bit_model>is_vector<adaptive_bit_model> &is_vector<adaptive_bit_model> &&const is_vector<adaptive_bit_model>const is_vector<adaptive_bit_model> &rel_ops<vector<unsigned char>>rel_ops<vector<unsigned char>> &rel_ops<vector<unsigned char>> &&const rel_ops<vector<unsigned char>>const rel_ops<vector<unsigned char>> &is_vector<unsigned char>is_vector<unsigned char> &is_vector<unsigned char> &&const is_vector<unsigned char>const is_vector<unsigned char> &rel_ops<vector<unsigned short>>rel_ops<vector<unsigned short>> &rel_ops<vector<unsigned short>> &&const rel_ops<vector<unsigned short>>const rel_ops<vector<unsigned short>> &is_vector<unsigned short>is_vector<unsigned short> &is_vector<unsigned short> &&const is_vector<unsigned short>const is_vector<unsigned short> &const float[]float[]const float[29]float[29]bitwise_movable<unsigned char>bitwise_movable<unsigned char> &bitwise_movable<unsigned char> &&const bitwise_movable<unsigned char>const bitwise_movable<unsigned char> &bitwise_movable<unsigned short>bitwise_movable<unsigned short> &bitwise_movable<unsigned short> &&const bitwise_movable<unsigned short>const bitwise_movable<unsigned short> &bitwise_movable<adaptive_bit_model>bitwise_movable<adaptive_bit_model> &bitwise_movable<adaptive_bit_model> &&const bitwise_movable<adaptive_bit_model>const bitwise_movable<adaptive_bit_model> &bitwise_movable<output_symbol>bitwise_movable<output_symbol> &bitwise_movable<output_symbol> &&const bitwise_movable<output_symbol>const bitwise_movable<output_symbol> &bitwise_copyable<output_symbol>bitwise_copyable<output_symbol> &bitwise_copyable<output_symbol> &&const bitwise_copyable<output_symbol>const bitwise_copyable<output_symbol> &unsigned char *constunsigned short *constadaptive_bit_model *constoutput_symbol *consttimex &timex &&const timexconst timex &tm &tm &&const tm &itimerspec &itimerspec &&const itimerspec &/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_timer.cppquery_counter_frequencytimer_ticks *query_counterconst char[87]char[87]stop_timem_started(false)m_stopped(false)// File: lzham_timer.cpppTicks/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdecomp/lzham_vector.cppm_size <= m_capacitysizeof(void*) == sizeof(uint64)min_new_capacity < (0x400000000ULL / element_size)new_capacity && (new_capacity > m_capacity)desired_sizenew_pvector: lzham_realloc() failed allocating %u bytes"vector: lzham_realloc() failed allocating %u bytes"const char[4]vector: lzham_malloc() failed allocating %u bytes"vector: lzham_malloc() failed allocating %u bytes"// new_capacity must be 64-bit when compiling on x64.// File: lzham_vector.cpppMoverassume_try<1>is_integral<_IntType>__match_cv_qualifiers<char32_t, unsigned int, false, false>__match_cv_qualifiers<char32_t, unsigned int, false, false> &__match_cv_qualifiers<char32_t, unsigned int, false, false> &&const __match_cv_qualifiers<char32_t, unsigned int, false, false>const __match_cv_qualifiers<char32_t, unsigned int, false, false> &__make_signed_selector<unsigned short, true, false>__make_signed_selector<unsigned short, true, false> &__make_signed_selector<unsigned short, true, false> &&const __make_signed_selector<unsigned short, true, false>const __make_signed_selector<unsigned short, true, false> &is_same<type, unsigned short>is_same<type, unsigned char>is_same<type, signed __int128_t>is_same<type, signed long long>0.142857142857142857140.300000000000000000013.6140072416183481135e-211.253314137static_cast<_Tp>(1.2533141373155002512078826424055226L)__make_unsigned_selector<char32_t, true, false>__make_unsigned_selector<char32_t, true, false> &__make_unsigned_selector<char32_t, true, false> &&const __make_unsigned_selector<char32_t, true, false>const __make_unsigned_selector<char32_t, true, false> &is_enum<unsigned int>is_enum<unsigned int> &is_enum<unsigned int> &&const is_enum<unsigned int>const is_enum<unsigned int> &__cv_selector<unsigned short, false, false>__cv_selector<unsigned short, false, false> &__cv_selector<unsigned short, false, false> &&const __cv_selector<unsigned short, false, false>const __cv_selector<unsigned short, false, false> &static_cast<_Tp>(0.7853981633974483096156608458198757L)0.7853981853const float[28]float[28]-0.033333335070.023809524250.07575757802-0.25311356781.166666627-7.09215688754.97117615-529.12426766192.123047236364096.0-236364096.0-86580.257811425517.125/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdll/lzham_api.cpp10.8.14112// File: lzham_api.cpp - Dynamic DLL entrypoints./home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamdllconst __normal_iterator<_Iterator, _Container> *__normal_iterator<_Iterator, _Container> *fill_n must pass integral size/usr/include/c++/12/bits/new_allocator.hconst __new_allocator<file_stats>const __new_allocator<file_stats> &__new_allocator<file_stats> &const __new_allocator<_Up>const __new_allocator<_Up> &__new_allocator<_Up> &const __new_allocator<basic_string<char, char_traits<char>, allocator<char>>>const __new_allocator<basic_string<char, char_traits<char>, allocator<char>>> &__new_allocator<basic_string<char, char_traits<char>, allocator<char>>> &const __new_allocator<unsigned char>const __new_allocator<unsigned char> &__new_allocator<unsigned char> &const __new_allocator<char32_t>const __new_allocator<char32_t> &__new_allocator<char32_t> &const __new_allocator<char16_t>const __new_allocator<char16_t> &__new_allocator<char16_t> &const __new_allocator<wchar_t>const __new_allocator<wchar_t> &__new_allocator<wchar_t> &const __new_allocator<char>const __new_allocator<char> &__new_allocator<char> &const __new_allocator<_Tp>const __new_allocator<_Tp> &__new_allocator<_Tp> &_M_max_sizeconst __new_allocator<_Tp> *__new_allocator<_Tp> *max_sizedeallocateallocate__alcannot allocate incomplete types~__new_allocator__new_allocatorconst __new_allocator<_Tp1>const __new_allocator<_Tp1> &__new_allocator<_Tp1> &__new_allocator<_Tp>rebind<_Tp1>_GLIBCXX_OPERATOR_NEW_GLIBCXX_OPERATOR_DELETE_GLIBCXX_SIZED_DEALLOC_GLIBCXX_SIZED_DEALLOC(p,n)(p), (n) * sizeof(_Tp)::operator delete::operator new_STD_NEW_ALLOCATOR_H__has_builtin(__builtin_operator_new) >= 201802L__cpp_impl_three_way_comparison < 201907L__PTRDIFF_MAX__ < __SIZE_MAX____PTRDIFF_MAX____SIZE_MAX____STDCPP_DEFAULT_NEW_ALIGNMENT__// 402. wrong new expression in [some_] allocator::construct// __p is not permitted to be a null pointer.// 3190. allocator::allocate sometimes returns too little storage// 3308. std::allocator<void>().allocate(n)// about what the return value is when __n == 0.// NB: __n is permitted to be 0.  The C++ standard says nothing// 2103. propagate_on_container_move_assignment/**
   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].
   *  @ingroup allocators
   *
   *  This is precisely the allocator defined in the C++ Standard.
   *    - all allocation calls operator new
   *    - all deallocation calls operator delete
   *
   *  @tparam  _Tp  Type of allocated object.
   *//** @file bits/new_allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Allocator that wraps operator new -*- C++ -*-/usr/include/c++/12/x86_64-redhat-linux/bits/c++allocator.h<bits/new_allocator.h>_GLIBCXX_CXX_ALLOCATOR_H_GLIBCXX_SANITIZE_STD_ALLOCATORdefined(__SANITIZE_ADDRESS__)__has_feature(address_sanitizer)// Define __new_allocator as the base class to std::allocator./**
   *  @brief  An alias to the base class for std::allocator.
   *
   *  Used to set the std::allocator base class to std::__new_allocator.
   *
   *  @ingroup allocators
   *  @tparam  _Tp  Type of allocated object.
    *//** @file bits/c++allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Base to std::allocator -*- C++ -*-/usr/include/c++/12/bits/memoryfwd.huses_allocator<<unnamed>, <unnamed>>allocator_traits<_Alloc>allocator<_Tp>_MEMORYFWD_Hallocator<void>/// @} group memory/// Declare uses_allocator so it can be specialized in `<queue>` etc./**
   * @defgroup allocators Allocators
   * @ingroup memory
   *
   * Classes encapsulating memory operations.
   *
   * @{
   *//** @file bits/memoryfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 *//*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// <memory> Forward declarations -*- C++ -*-/usr/include/c++/12/bits/allocator.h<bits/memoryfwd.h><bits/c++allocator.h>const allocator<file_stats>const allocator<file_stats> &allocator<file_stats> &const allocator<basic_string<char, char_traits<char>, allocator<char>>>const allocator<basic_string<char, char_traits<char>, allocator<char>>> &allocator<basic_string<char, char_traits<char>, allocator<char>>> &const allocator<unsigned char>const allocator<unsigned char> &allocator<unsigned char> &const allocator<char32_t>const allocator<char32_t> &allocator<char32_t> &const allocator<char16_t>const allocator<char16_t> &allocator<char16_t> &const allocator<wchar_t>const allocator<wchar_t> &allocator<wchar_t> &const allocator<char>const allocator<char> &allocator<char> &const allocator<_T1>const allocator<_T1> &allocator<_T1> &const allocator<_T2>const allocator<_T2> &allocator<_T2> &const allocator<_Tp>const allocator<_Tp> &allocator<_Tp> &_S_do_it_Allocconst _Allocconst _Alloc &_Alloc &allocatorconst allocator<_Up>const allocator<_Up> &allocator<_Up> &allocator<void> &allocator<void> &&const allocator<void>const allocator<void> &~allocatorallocator<_Tp> *const allocator<_Tp1>const allocator<_Tp1> &allocator<_Tp1> &__shrink_to_fit_aux<_Tp, true>__shrink_to_fit_aux<_Tp, <unnamed>>__alloc_neq<_Alloc, false>__alloc_neq<_Alloc, <unnamed>>__alloc_swap<_Alloc, false>__alloc_swap<_Alloc, <unnamed>>allocator<const volatile _Tp>allocator<volatile _Tp>allocator<const _Tp>__allocator_base__cpp_lib_incomplete_container_elements_ALLOCATOR_H__cpp_constexpr_dynamic_alloc"std::allocator_traits::is_always_equal"// Optimize for stateless allocators.// Precondition: swappable allocators.// To implement Option 3 of DR 431.// Undefine.// which are defined via explicit instantiations elsewhere.// Inhibit implicit instantiations for required instantiations,/// @} group allocator// allocator_traits::rebind_alloc can be used to form a valid allocator type.// Invalid allocator<cv T> partial specializations.// Inherit everything else.// Avoid implicit deprecation.// 3035. std::allocator's constructors should be constexpr// 2103. std::allocator propagate_on_container_move_assignment// These were removed for C++20./**
   * @brief  The @a standard allocator, as per C++03 [20.4.1].
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
   *  for further details.
   *
   *  @tparam  _Tp  Type of allocated object.
   */// with any pointer which wasn't obtained from allocate.// No deallocate member because it would be undefined to call it// No allocate member because it's ill-formed by LWG 3307.// same API as the primary template, but still trivial as in pre-C++20.// As noted above, these members are present for C++20 to provide the// These were removed for C++20, allocator_traits does the right thing./// allocator<void> specialization.// the same members that are present in the primary template.// explicit specialization, with the historical ABI properties, but with// different standard dialects. So C++20 still uses the allocator<void>// but trivial for C++98-17, which would be an ABI incompatibiliy between// but then it would have a non-trivial default ctor and dtor for C++20,// Since C++20 the primary template should be used for allocator<void>,/**
   *  @addtogroup allocators
   *  @{
   */// Define the base class to std::allocator./** @file bits/allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Allocators -*- C++ -*-__one__two_Value_typevalue type is destructible/usr/include/c++/12/bits/alloc_traits.h<bits/allocator.h>_Allocator_Allocator &__alloc_on_swap__traitspropagate_on_container_move_assignment__pocma__alloc_on_move__alloc_on_copypropagate_on_container_copy_assignment__poccaallocator_traits<allocator<void>> &allocator_traits<allocator<void>> &&const allocator_traits<allocator<void>>const allocator_traits<allocator<void>> &select_on_container_copy_constructionconst allocator_typeconst allocator_type &allocator_type &_Alloc2_S_select_Alloc2 &_S_max_size_S_destroy_S_construct_S_allocate__allocator_traits_base &__allocator_traits_base &&const __allocator_traits_baseconst __allocator_traits_base &_RequireNotAllocator_RequireAllocator__is_allocator<_Alloc, __void_t<value_type, decltype((<expression>))>>__is_allocator<_Alloc, <unnamed>>__is_move_insertable<allocator<_Tp>>__is_move_insertable<_Alloc>__is_copy_insertable<allocator<_Tp>>__is_copy_insertable<_Alloc>__is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype((<expression>))>>_ValueT__is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, <unnamed>>allocator_traits<allocator<void>>const_void_pointervoid_pointerallocator_typeallocator_traits<allocator<_Tp>>__alloc_rebind__has_construct__construct_helper<_Tp, _Args...>rebind_allocis_always_equalpropagate_on_container_swap_Size<_A2, _DiffT, __void_t<size_type>>_A2_DiffT_Size<_A2, _DiffT, <unnamed>>_Diff<_A2, _PtrT, __void_t<difference_type>>_PtrT_Diff<_A2, _PtrT, <unnamed>>_Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>_Ptr<_Func, _Tp, <unnamed>>__allocator_traits_base__equal__pocs__cv_pointer__v_pointer__c_pointer__rebind<_Tp, _Up, __void_t<other>>_Func__cpp_lib_allocator_traits_is_always_equal_ALLOC_TRAITS_H__cplusplus < 201703L// _ALLOC_TRAITS_H/**
   * Destroy a range of objects using the supplied allocator.  For
   * non-default allocators we do not optimize away invocation of
   * destroy() even if _Tp has a trivial destructor.
   */// Trait to detect Allocator-like types.// std::allocator<_Tp> just requires MoveConstructible// i.e. actually trying to use it would still be invalid. Use with caution.)// (might be wrong if _Alloc::construct exists but is not constrained,// true if _Alloc::value_type is MoveInsertable into containers using _Alloc// std::allocator<_Tp> just requires CopyConstructible// true if _Alloc::value_type is CopyInsertable into containers using _Alloc/**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return `__rhs`
      *//// max_size is ill-formed for allocator<void>/**
       *  @brief  Destroy an object of type `_Up`
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Invokes the destructor for `*__p`.
      *//**
       *  @brief  Construct an object of type `_Up`
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to memory of suitable size and alignment for
       *	       an object of type `_Up`.
       *  @param  __args Constructor arguments.
       *
       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
       *  in C++11, C++14 and C++17. Changed in C++20 to call
       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
      *//// deallocate is ill-formed for allocator<void>/// allocate is ill-formed for allocator<void>/// Whether all instances of the allocator type compare equal./// How the allocator is propagated on swap/// How the allocator is propagated on move assignment/// How the allocator is propagated on copy assignment/// The allocator's size type/// The allocator's difference type/// The allocator's const void pointer type./// The allocator's void pointer type./// The allocator's const pointer type./// The allocator's pointer type./// The allocated type/// The allocator type/// Explicit specialization for std::allocator<void>./**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs
      *//**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size()
      *//**
       *  @brief  Destroy an object of type @a _Up
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Calls @c __a.destroy(__p).
      *//**
       *  @brief  Deallocate memory.
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the memory to deallocate.
       *  @param  __n  The number of objects space was allocated for.
       *
       *  Calls <tt> a.deallocate(p, n) </tt>
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *  @param  __hint Aid to locality.
       *  @return Memory of suitable size and alignment for @a n objects
       *          of type @c value_type
       *
       *  Returns <tt> a.allocate(n, hint) </tt>
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *
       *  Calls @c a.allocate(n)
      *//// Partial specialization for std::allocator./**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
       *
       *  Returns @c __rhs.select_on_container_copy_construction() if that
       *  expression is well-formed, otherwise returns @a __rhs
      *//**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
       *
       *  Returns @c __a.max_size() if that expression is well-formed,
       *  otherwise returns @c numeric_limits<size_type>::max()
      *//**
       *  @brief  Destroy an object of type @a _Tp
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Calls @c __a.destroy(__p) if that expression is well-formed,
       *  otherwise calls @c __p->~_Tp()
      *//**
       *  @brief  Construct an object of type `_Tp`
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
       *  @param  __args Constructor arguments.
       *
       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
       *  if that expression is well-formed, otherwise uses placement-new
       *  to construct an object of type @a _Tp at location @a __p from the
       *  arguments @a __args...
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *  @param  __hint Aid to locality.
       *  @return Memory of suitable size and alignment for @a n objects
       *          of type @c value_type
       *
       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
       *  well-formed, otherwise returns @c a.allocate(n)
      */// 2466. allocator_traits::max_size() default behavior is incorrect/**
       * @brief   Whether all instances of the allocator type compare equal.
       *
       * @c Alloc::is_always_equal if that type exists,
       * otherwise @c is_empty<Alloc>::type
      *//**
       * @brief   How the allocator is propagated on swap
       *
       * @c Alloc::propagate_on_container_swap if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   How the allocator is propagated on move assignment
       *
       * @c Alloc::propagate_on_container_move_assignment if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   How the allocator is propagated on copy assignment
       *
       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   The allocator's size type
       *
       * @c Alloc::size_type if that type exists, otherwise
       * <tt> make_unsigned<difference_type>::type </tt>
      *//**
       * @brief   The allocator's difference type
       *
       * @c Alloc::difference_type if that type exists, otherwise
       * <tt> pointer_traits<pointer>::difference_type </tt>
      *//**
       * @brief   The allocator's const void pointer type.
       *
       * @c Alloc::const_void_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
      *//**
       * @brief   The allocator's void pointer type.
       *
       * @c Alloc::void_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<void> </tt>
      *//**
       * @brief   The allocator's const pointer type.
       *
       * @c Alloc::const_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
      */// Select _A2::size_type or make_unsigned<_DiffT>::type// Select _A2::difference_type or pointer_traits<_Ptr>::difference_type// Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>/**
       * @brief   The allocator's pointer type.
       *
       * @c Alloc::pointer if that type exists, otherwise @c value_type*
      *//**
   * @brief  Uniform interface to all allocator types.
   * @headerfile memory
   * @ingroup allocators
   * @since C++11
  *//** @file bits/alloc_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Allocator traits -*- C++ -*-__alloc/usr/include/c++/12/ext/alloc_traits.h<bits/alloc_traits.h>_S_nothrow_move_S_always_equal_S_propagate_on_swap_S_propagate_on_move_assign_S_propagate_on_copy_assign_S_on_swap_S_select_on_copy__alloc_traits<_Alloc, <unnamed>>_EXT_ALLOC_TRAITS_H// 431. Swapping containers with unequal allocators.// overload destroy for non-standard pointer types// overload construct for non-standard pointer types// C++11 allocators do not define reference or const_reference/**
 * @brief  Uniform interface to C++98 and C++11 allocators.
 * @ingroup allocators
*/// for __alloc_swap/** @file ext/alloc_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 *//usr/include/c++/12/bits/stl_uninitialized.h<ext/alloc_traits.h>__relocate_a__relocate_a_1maybe_unused_ValueType_ValueType2__currelocation is only possible for values of the same type_Tp *__restrict____relocate_object_a_Up *__restrict__uninitialized_move_nuninitialized_moveuninitialized_value_construct_nuninitialized_value_constructuninitialized_default_construct_nuninitialized_default_construct__uninitialized_copy_n_pairuninitialized_copy_n__uninitialized_copy_n__uninitialized_default_novalue_n__uninitialized_default_novalue__uninitialized_default_n_a__uninitialized_default_a__can_fill__uninit_default_n__uninitialized_default_n__uninitialized_default__uninitialized_move_fill__uninitialized_fill_move__uninitialized_move_copy__uninitialized_copy_move__uninitialized_fill_n_aallocator<_Tp2> &__uninitialized_fill_a__uninitialized_move_if_noexcept_a__uninitialized_move_a__uninitialized_copy_auninitialized_fill_n__do_uninit_fill_nuninitialized_fill__do_uninit_fill_ValueType1__can_memmove__assignable_ValueType2 &__uninit_copyuninitialized_copy__do_uninit_copy__check_constructibleresult type must be constructible from input type__uninitialized_default_novalue_n_1<true> &__uninitialized_default_novalue_n_1<true> &&const __uninitialized_default_novalue_n_1<true>const __uninitialized_default_novalue_n_1<true> &__uninit_default_novalue_n__uninitialized_default_novalue_1<true> &__uninitialized_default_novalue_1<true> &&const __uninitialized_default_novalue_1<true>const __uninitialized_default_novalue_1<true> &__uninit_default_novalue__uninitialized_default_n_1<true> &__uninitialized_default_n_1<true> &&const __uninitialized_default_n_1<true>const __uninitialized_default_n_1<true> &__uninitialized_default_1<true> &__uninitialized_default_1<true> &&const __uninitialized_default_1<true>const __uninitialized_default_1<true> &__uninit_default__uninitialized_fill_n<true> &__uninitialized_fill_n<true> &&const __uninitialized_fill_n<true>const __uninitialized_fill_n<true> &__uninit_fill_n__uninitialized_fill<true> &__uninitialized_fill<true> &&const __uninitialized_fill<true>const __uninitialized_fill<true> &__uninit_fill__uninitialized_copy<true> &__uninitialized_copy<true> &&const __uninitialized_copy<true>const __uninitialized_copy<true> &__is_bitwise_relocatable<_Tp, <unnamed>>__uninitialized_default_novalue_n_1<true>__uninitialized_default_novalue_n_1<_TrivialValueType>_TrivialValueType__uninitialized_default_novalue_1<true>__uninitialized_default_novalue_1<_TrivialValueType>__uninitialized_default_n_1<true>__uninitialized_default_n_1<_TrivialValueType>__uninitialized_default_1<true>__uninitialized_default_1<_TrivialValueType>__uninitialized_fill_n<true>__uninitialized_fill_n<_TrivialValueType>__uninitialized_fill<true>__uninitialized_fill<_TrivialValueType>__uninitialized_copy<true>__uninitialized_copy<_TrivialValueTypes>_TrivialValueTypes__orig__mid__cpp_lib_raw_memory_algorithms_GLIBCXX_USE_ASSIGN_FOR_INIT_GLIBCXX_USE_ASSIGN_FOR_INIT(T,U)__is_trivial(T) && __is_assignable(T&, U) && std::__check_constructible<T, U>()_STL_UNINITIALIZED_Hconst _Tp&/* _STL_UNINITIALIZED_H */// resolves to the non-trivial overload above.// Can't use memmove. Wrap the pointer so that __relocate_a_1// Also known as is_trivially_relocatable.// This class may be specialized for specific types./**
   *  @brief Move-construct from the range [first,first+count) into result.
   *  @param  __first  An input iterator.
   *  @param  __count  The number of objects to initialize.
   *  @param  __result An output iterator.
   *  @return  __result + __count
   *  @since C++17
  *//**
   *  @brief Move-construct from the range [first,last) into result.
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   __result + (__first - __last)
   *  @since C++17
  *//**
   *  @brief Value-initializes objects in the range [first,first+count).
   *  @param  __first  A forward iterator.
   *  @param  __count  The number of objects to construct.
   *  @return   __result + __count
   *  @since C++17
  *//**
   *  @brief Value-initializes objects in the range [first,last).
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @since C++17
  *//**
   *  @brief Default-initializes objects in the range [first,first+count).
   *  @param  __first  A forward iterator.
   *  @param  __count  The number of objects to construct.
   *  @return   __first + __count
   *  @since C++17
  *//**
   *  @brief Default-initializes objects in the range [first,last).
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @since C++17
  *//**
   *  @brief Copies the range [first,first+n) into result.
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  __result + __n
   *  @since C++11
   *
   *  Like copy_n(), but does not require an initialized output range.
  */// Fills [first, first + n) with default-initialized value_types.// __uninitialized_default_novalue_n// Fills [first, last) with default-initialized value_types.// __uninitialized_default_novalue// which ignores the allocator and value-initializes the elements.// __uninitialized_default_n_a specialization for std::allocator,// alloc, with no arguments passed to the construct call.// Fills [first, first + n) with value_types constructed by the allocator// __uninitialized_default_n_a// Fills [first, last) with value_types constructed by the allocator// __uninitialized_default_a// See uninitialized_fill_n for the conditions for using std::fill_n.// Fills [first, first + n) with value-initialized value_types.// __uninitialized_default_n// Fills [first, last) with value-initialized value_types.// __uninitialized_default// __uninitialized_default_a, __uninitialized_default_n_a.// Extensions: __uninitialized_default, __uninitialized_default_n,//  fills [first2 + (last1 - first1), last2) with x.// Moves [first1, last1) into [first2, first2 + (last1 - first1)), and// __uninitialized_move_fill//  [mid, mid + (last - first)).// Fills [result, mid) with x, and moves [first, last) into// __uninitialized_fill_move//  [result, result + (last1 - first1) + (last2 - first2)).//  copies [first2, last2) into// Moves [first1, last1) into [result, result + (last1 - first1)), and// __uninitialized_move_copy//  move [first2, last2) into// Copies [first1, last1) into [result, result + (last1 - first1)), and// __uninitialized_copy_move// for construction and destruction.// All of these algorithms take a user-supplied allocator, which is used// __uninitialized_fill_move, __uninitialized_move_fill.// Extensions: __uninitialized_copy_move, __uninitialized_move_copy,//  any of the POD optimizations.//  default allocator.  For nondefault allocators we do not use//  We dispatch back to the standard versions when we're given the//  and uninitialized_fill_n that take an allocator parameter.// Extensions: versions of uninitialized_copy, uninitialized_fill,// so only use std::fill_n when _Size is already an integral type.// that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,// For arbitrary class types and floating point types we can't assume// so try to use std::fill_n to benefit from its optimizations.// Trivial types do not need a constructor to begin their lifetime,/**
   *  @brief Copies the value x into the range [first,first+n).
   *  @param  __first  An input iterator.
   *  @param  __n      The number of copies to make.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill_n(), but does not require an initialized output range.
  */// DR 1339. uninitialized_fill_n should return the end of its range// so try to use std::fill to benefit from its memset optimization./**
   *  @brief Copies the value x into the range [first,last).
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill(), but does not require an initialized output range.
  */// XXX Unnecessary because std::copy would check it anyway?// bother optimizing to std::copy if it isn't.// _ValueType1 must be trivially-copyable to use memmove, so don't/**
   *  @brief Copies the range [first,last) into result.
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   __result + (__first - __last)
   *
   *  Like copy(), but does not require an initialized output range.
  */// should be too.// no user-declared constructors, so if the assignment is valid, construction// No need to check if is_constructible<T, U> for C++98. Trivial types have// so don't try to use std::copy or std::fill etc. if we can't assign.// But trivial types can still have deleted or inaccessible assignment,// If the type is trivial we don't need to construct it, just assign to it.// compile without errors. This gives a nice clear error message.// otherwise some ill-formed uses of std::uninitialized_xxx would// explicit check that construction from _Tp is actually valid,// only use assignment (or memmove) not construction, so we need an// Trivial types can have deleted constructors, but std::copy etc./** @addtogroup memory
   *  @{
   */// __alloc_traits// copy/** @file bits/stl_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Raw memory manipulators -*- C++ -*-/usr/include/c++/12/bits/stl_vector.h_M_data_ptr_M_move_assignvector<_Tp, _Alloc> &&_M_erase_at_endconst _Tp_alloc_type_Tp_alloc_typeconst _Tp_alloc_type &_Tp_alloc_type &__diffmax__gnu_cxx::__numeric_traits<ptrdiff_t>::__max__allocmaxconst size_t &_S_check_init_len"cannot create std::vector larger than max_size()"cannot create std::vector larger than max_size()__N("cannot create std::vector larger than max_size()")_M_check_lenconst vector<_Tp, _Alloc>const vector<_Tp, _Alloc> *vector<_Tp, _Alloc> *const size_type_M_emplace_aux_M_insert_dispatch_M_assign_dispatch_M_default_initialize_M_impl_M_finish_M_start_M_get_Tp_allocator_M_fill_initialize_M_range_initialize_M_allocate_and_copyvector<_Tp, _Alloc> &emplacepush_back_M_end_of_storage_M_range_checkshrink_to_fitresizecrendcrbegincendcbeginrendrbegin_S_relocate_S_do_relocate_S_use_relocate_S_nothrow_relocateconst vector<_Tp, _Alloc> &_ValT_M_ptr_M_val~_Temporary_value_Temporary_value_Storage &const _Storageconst _Storage &~_Storage_Storageconst __type_identity_t<allocator_type>const __type_identity_t<allocator_type> &_M_create_storage_Vector_base<_Tp, _Alloc> *_M_deallocate_Tr_M_allocate~_Vector_base_Vector_base_Vector_base<_Tp, _Alloc> &&_Tp_alloc_type &&other &&get_allocatorother &const _Vector_base<_Tp, _Alloc>const _Vector_base<_Tp, _Alloc> *_Vector_impl_Vector_impl &&_Vector_impl *is_nothrow_default_constructible<_Tp_alloc_type>::value_M_swap_data_Vector_impl_data &_M_copy_dataconst _Vector_impl_dataconst _Vector_impl_data &_Vector_impl_data_Vector_impl_data &&_Vector_impl_data *_Never_valueless_alt<vector<_Tp, _Alloc>>_Never_valueless_alt<<unnamed>>vector<_Tp, _Alloc>_Vector_base<_Tp, _Alloc>__position__new_size__rv_M_realloc_insert_M_insert_aux_Arg &&_M_range_insert_M_assign_auxemplace_back_M_storage_M_byte_M_thisstd::vector must have a non-const, non-volatile value_type_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC_GLIBCXX_ASAN_ANNOTATE_SHRINK(n)_GLIBCXX_ASAN_ANNOTATE_GREW(n)_GLIBCXX_ASAN_ANNOTATE_GROW(n)_GLIBCXX_ASAN_ANNOTATE_REINIT_STL_VECTOR_H__variant_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR!_GLIBCXX_INLINE_VERSION__cplusplus > 201703L || defined __STRICT_ANSI____cpp_if_constexpr_M_erase_M_insert_rval_M_shrink_to_fit_M_default_append_M_fill_insert_M_fill_assignnoexcept(__x.swap(__y))_Alloc_traits::propagate_on_container_swap::value || _M_get_Tp_allocator() == __x._M_get_Tp_allocator()"vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"/* _STL_VECTOR_H */// namespace __detail::__variant// vector into a variant, but only if move assignment cannot throw.// Provide the strong exception-safety guarantee when emplacing a// see <variant>/// See std::vector::swap()./// Based on operator</// Based on operator==/**
   *  @brief  Vector ordering relation.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  vectors.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Vector ordering relation.
   *  @param  __x  A `vector`.
   *  @param  __y  A `vector` of the same type as `__x`.
   *  @return  A value indicating whether `__x` is less than, equal to,
   *           greater than, or incomparable with `__y`.
   *
   *  See `std::lexicographical_compare_three_way()` for how the determination
   *  is made. This operator is used to synthesize relational operators like
   *  `<` and `>=` etc.
  *//**
   *  @brief  Vector equality comparison.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff the size and elements of the vectors are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  vectors.  Vectors are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */// so we need to individually move each element.// The rvalue's allocator cannot be moved and is not equal,// object's memory, resulting in a linear-time operation.// Do move assignment when it might not be possible to move source// or because the allocators are equal.// moved, either because the source's allocator will move too// Constant-time move assignment when source object's memory can be// _M_assign_aux.// Called by erase(q1,q2), clear(), resize(), _M_fill_assign,// Internal erase functions follow.// (even if std::allocator_traits::max_size says we can).// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,// Called by constructors to check initial size.// Called by _M_fill_insert, _M_insert_aux etc.// Emplacing an rvalue of the correct type can use _M_insert_rval.// Try to emplace at the end, otherwise forward to _M_insert_aux.// Either move-construct at the end, or forward to _M_insert_aux.// reallocate or move existing elements. _Arg is either _Tp& or _Tp.// Called by insert(p,x) and other functions when insertion needs to// and destroyed with _Alloc_traits::destroy().// A value_type object constructed with _Alloc_traits::construct()// Called by insert(p,x)// Called by resize(n).// the same thing.// Called by insert(p,n,x), and the range insert when it turns out to be// Called by the second insert_dispatch above// Called by the range insert to implement [23.1.1]/9// 438. Ambiguity in the "do the right thing" clause// Internal insert functions follow.// to be the same thing.// Called by assign(n,t), and the range assign when it turns out// Called by the second assign_dispatch above// Called by the range assign to implement [23.1.1]/9// assignment work for the range versions.// Internal assign functions follow.  The *_aux functions do the actual// Called by the vector(n) constructor.// vector(n,value,a) constructor.// Called by the first initialize_dispatch above and by the// Called by the second initialize_dispatch above// Called by the range constructor to implement [23.1.1]/9// Internal constructor functions follow./**
       *  Memory expansion handler.  Uses the member allocation function to
       *  obtain @a n bytes of memory, and then copies [first,last) into it.
       *//**
       *  Erases all the elements.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       *//**
       *  @brief  Swaps data with another %vector.
       *  @param  __x  A %vector of the same element and allocator types.
       *
       *  This exchanges the elements between two vectors in constant time.
       *  (Three pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(v1,v2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                  erased.
       *  @return  An iterator pointing to the element pointed to by @a __last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range
       *  [__first,__last) and shorten the %vector accordingly.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %vector by one.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */// Check whether it's an integral type.  If so, it's not an iterator./**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts an initializer_list into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a l into the %vector before the location
       *  specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts given rvalue into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  An iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts an object in %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified location.
       *  Note that this kind of operation could be expensive for a %vector
       *  and if it is frequently used the user should consider using
       *  std::list.
       *//**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation. It shrinks the %vector by one.
       *
       *  Note that no data is returned, and if the last element's
       *  data is needed, it should be retrieved before pop_back() is
       *  called.
       *//**
       *  @brief  Add data to the end of the %vector.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %vector and assigns the given data
       *  to it.  Due to the nature of a %vector this operation can be
       *  done in constant time if the %vector has preallocated space
       *  available.
       */// [23.2.4.3] modifiers/**
       *   Returns a pointer such that [data(), data() + size()) is a valid
       *   range.  For a non-empty %vector, data() == &front().
       */// data access// DR 464. Suggestion for new member functions in standard containers./**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %vector.
       *//**
       *  Returns a read/write reference to the data at the last
       *  element of the %vector.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %vector.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       *//**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       *//**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       *//// Safety check used only from at()./**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       *//**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */// element access/**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          elements.
       *  @param  __n  Number of elements required.
       *  @throw  std::length_error  If @a n exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %vector to hold the specified number of elements.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the number of elements
       *  that will be required, the user can reserve the memory in
       *  %advance, and thus prevent a possible reallocation of memory
       *  and copying of %vector data.
       *//**
       *  Returns true if the %vector is empty.  (Thus begin() would
       *  equal end().)
       *//**
       *  Returns the total number of elements that the %vector can
       *  hold before needing to allocate more memory.
       *//**  A non-binding request to reduce capacity() to size().  *//**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  the %vector is extended and new elements are populated with
       *  given data.
       *//**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  default constructed elements are appended.
       *//**  Returns the size() of the largest possible %vector.  *//**  Returns the number of elements in the %vector.  */// [23.2.4.2] capacity/**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %vector.  Iteration
       *  is done in reverse element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %vector.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       *//**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %vector.  Iteration is done
       *  in reverse element order.
       *//**
       *  Returns a read/write reverse iterator that points to the
       *  last element in the %vector.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */// iterators/// Get a copy of the memory allocation object./**
       *  @brief  Assigns an initializer list to a %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Assigns a range to a %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %vector with copies of the elements in the
       *  range [__first,__last).
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Assigns a given value to a %vector.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %vector with @a __n copies of the given
       *  value.  Note that the assignment completely changes the
       *  %vector and that the resulting %vector's size is the same as
       *  the number of elements assigned.
       *//**
       *  @brief  %Vector list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %Vector move assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %vector (without copying,
       *  if the allocators permit it).
       *  Afterwards @a __x is a valid, but unspecified %vector.
       *
       *  Whether the allocator is moved depends on the allocator traits.
       *//**
       *  @brief  %Vector assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but any unused capacity in
       *  @a __x will not be copied.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Builds a %vector from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements from
       *  [first,last).
       *
       *  If the iterators are forward, bidirectional, or
       *  random-access, then this will call the elements' copy
       *  constructor N times (where N is distance(first,last)) and do
       *  no memory reallocation.  But if only input iterators are
       *  used, then this will do at most 2N calls to the copy
       *  constructor, and logN memory reallocations.
       *//**
       *  @brief  Builds a %vector from an initializer list.
       *  @param  __l  An initializer_list.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements in the
       *  initializer_list @a __l.
       *
       *  This will call the element type's copy constructor N times
       *  (where N is @a __l.size()) and do no memory reallocation.
       *//// Move constructor with alternative allocator/// Copy constructor with alternative allocator/**
       *  @brief  %Vector move constructor.
       *
       *  The newly-created %vector contains the exact contents of the
       *  moved instance.
       *  The contents of the moved instance are a valid, but unspecified
       *  %vector.
       *//**
       *  @brief  %Vector copy constructor.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but any unused capacity in
       *  @a __x  will not be copied
       *  (i.e. capacity() == size() in the new %vector).
       *
       *  The newly-created %vector uses a copy of the allocator object used
       *  by @a __x (unless the allocator traits dictate a different object).
       *//**
       *  @brief  Creates a %vector with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n copies of @a __value.
       *//**
       *  @brief  Creates a %vector with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n default
       *  constructed elements.
       *//**
       *  @brief  Creates a %vector with no elements.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Creates a %vector with no elements.
       */// (assign() and get_allocator() are also listed in this section)// [23.2.4.1] construct/copy/destroy// All callers have already checked _S_use_relocate() so just do it.// so only do it if we know the type can be move-inserted into *this.// immediate context (in __relocate_object_a's noexcept-specifier),// Instantiating std::__relocate_a might cause an error outside the// Concept requirements./**
   *  @brief A standard container which offers fixed time access to
   *  individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c push_front and @c pop_front.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */// Kept for ABI compatibility.// _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR// ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)// Tell ASan when unused capacity is initialized to be valid.// Mark unused capacity as invalid after reallocation.// Mark unused capacity as valid again before deallocating it.// Used on reallocation to tell ASan unused capacity is invalid.// mark end of valid region as __curr instead of __prev.// Adjust ASan annotation for [_M_start, _M_end_of_storage) to// Enable ASan annotations for memory obtained from std::allocator.// !is_nothrow_move_constructible<_Tp_alloc_type>.// Not defaulted, to enforce noexcept(true) even when// information used by TBAA.// Do not use std::swap(_M_start, __x._M_start), etc as it loses/// See bits/stl_deque.h's _Deque_base for an explanation./** @file bits/stl_vector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this  software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Vector implementation -*- C++ -*-__vec/usr/include/c++/12/bits/hash_bytes.h_Fnv_hash_bytes_Hash_bytes_HASH_BYTES_H// machines.)// (although it might not produce the same values on different// algorithm is guaranteed to stay the same from release to release.// A similar hash primitive, using the FNV hash algorithm. This// improve hash quality or speed.// the same from release to release -- it may be updated or tuned to// byte array. The actual hash algorithm is not guaranteed to stay// All of them are based on a primitive that hashes a pointer to a// Hash function implementation for the nontrivial specialization./** @file bits/hash_bytes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Copyright (C) 2010-2022 Free Software Foundation, Inc.// Declarations for hash functions. -*- C++ -*-/usr/include/c++/12/bits/functional_hash.h<bits/hash_bytes.h>__is_fast_hash__is_fast_hash<hash<long double>> &__is_fast_hash<hash<long double>> &&const __is_fast_hash<hash<long double>>const __is_fast_hash<hash<long double>> &hash<std::nullptr_t> &hash<std::nullptr_t> &&const hash<std::nullptr_t>const hash<std::nullptr_t> &const hash<std::nullptr_t> *hash<std::nullptr_t> *hash<long double> &hash<long double> &&const hash<long double>const hash<long double> &hash<double> &hash<double> &&const hash<double>const hash<double> &const hash<double> *hash<double> *hash<float> &hash<float> &&const hash<float>const hash<float> &const hash<float> *hash<float> *_Fnv_hash_impl &_Fnv_hash_impl &&const _Fnv_hash_implconst _Fnv_hash_impl &__hash_combine21661362612166136261ULstatic_cast<size_t>(2166136261UL)_Hash_impl &_Hash_impl &&const _Hash_implconst _Hash_impl &33396759110xc70f6907ULstatic_cast<size_t>(0xc70f6907UL)hash<__uint128_t> &hash<__uint128_t> &&const hash<__uint128_t>const hash<__uint128_t> &const hash<__uint128_t> *hash<__uint128_t> *__GLIBCXX_TYPE_INT_N_0 unsigned__int128 unsignedhash<__int128_t> &hash<__int128_t> &&const hash<__int128_t>const hash<__int128_t> &const hash<__int128_t> *hash<__int128_t> *hash<unsigned long long> &hash<unsigned long long> &&const hash<unsigned long long>const hash<unsigned long long> &const hash<unsigned long long> *hash<unsigned long long> *hash<unsigned long> &hash<unsigned long> &&const hash<unsigned long>const hash<unsigned long> &const hash<unsigned long> *hash<unsigned long> *hash<unsigned int> &hash<unsigned int> &&const hash<unsigned int>const hash<unsigned int> &const hash<unsigned int> *hash<unsigned int> *hash<unsigned short> &hash<unsigned short> &&const hash<unsigned short>const hash<unsigned short> &const hash<unsigned short> *hash<unsigned short> *hash<long long> &hash<long long> &&const hash<long long>const hash<long long> &const hash<long long> *hash<long long> *hash<long> &hash<long> &&const hash<long>const hash<long> &const hash<long> *hash<long> *hash<int> &hash<int> &&const hash<int>const hash<int> &const hash<int> *hash<int> *hash<short> &hash<short> &&const hash<short>const hash<short> &const hash<short> *hash<short> *hash<char32_t> &hash<char32_t> &&const hash<char32_t>const hash<char32_t> &const hash<char32_t> *hash<char32_t> *hash<char16_t> &hash<char16_t> &&const hash<char16_t>const hash<char16_t> &const hash<char16_t> *hash<char16_t> *hash<wchar_t> &hash<wchar_t> &&const hash<wchar_t>const hash<wchar_t> &const hash<wchar_t> *hash<wchar_t> *hash<unsigned char> &hash<unsigned char> &&const hash<unsigned char>const hash<unsigned char> &const hash<unsigned char> *hash<unsigned char> *hash<signed char> &hash<signed char> &&const hash<signed char>const hash<signed char> &const hash<signed char> *hash<signed char> *hash<char> &hash<char> &&const hash<char>const hash<char> &const hash<char> *hash<char> *hash<bool> &hash<bool> &&const hash<bool>const hash<bool> &const hash<bool> *hash<bool> *~__hash_enum__hash_enum__hash_enum<_Tp, <unnamed>> &&~__poison_hash__poison_hash__poison_hash<_Tp, <unnamed>> &&__is_fast_hash<hash<long double>>__is_fast_hash<_Hash>_Hashhash<std::nullptr_t>hash<long double>hash<double>hash<float>_Fnv_hash_impl_Hash_implhash<__uint128_t>hash<__int128_t>hash<unsigned long long>hash<unsigned long>hash<unsigned int>hash<unsigned short>hash<long long>hash<long>hash<int>hash<short>hash<char32_t>hash<char16_t>hash<wchar_t>hash<unsigned char>hash<signed char>hash<char>hash<bool>hash<_Tp *>__hash_enum<_Tp, true>__hash_enum<_Tp, <unnamed>>__poison_hash<_Tp, __void_t<decltype((<expression>))>>__poison_hash<_Tp, <unnamed>>hash<_Tp>__hash_base<_Result, _Arg>argument_type__enable_hash_call_Cxx_hashtable_define_trivial_hash_Cxx_hashtable_define_trivial_hash(_Tp)template<> struct hash<_Tp> : public __hash_base<size_t, _Tp> { size_t operator()(_Tp __val) const noexcept { return static_cast<size_t>(__val); } };_FUNCTIONAL_HASH_H// _FUNCTIONAL_HASH_H// otherwise.// Default behavior is to consider that hashers are fast unless specified// containers will cache the hash code.// Hint about performance of hash functor. If not fast the hash-based/// @} group hashes/// Specialization for long double.// 0 and -0 both hash to zero./// Specialization for double./// Specialization for float.// A hash function similar to FNV-1a (see PR59406 for how it differs)./// Explicit specialization for unsigned long long./// Explicit specialization for unsigned long./// Explicit specialization for unsigned int./// Explicit specialization for unsigned short./// Explicit specialization for long long./// Explicit specialization for long./// Explicit specialization for int./// Explicit specialization for short./// Explicit specialization for char32_t./// Explicit specialization for char16_t./// Explicit specialization for char8_t./// Explicit specialization for wchar_t./// Explicit specialization for unsigned char./// Explicit specialization for signed char./// Explicit specialization for char./// Explicit specialization for bool.// Explicit specializations for integer types./// Partial specializations for pointer types.// Use with non-enum types still SFINAES./// Primary class template hash, usable for enum types only.// Helper struct for hash with enum types.// Private rather than deleted to be non-trivially-copyable.// Helper struct for SFINAE-poisoning non-enum types./// Primary class template hash./** @defgroup hashes Hashes
   *  @ingroup functors
   *
   *   Hashing functors taking a variable type and returning a @c std::size_t.
   *
   *  @{
   *//** @file bits/functional_hash.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// functional_hash.h header -*- C++ -*-__clength__hash/usr/include/c++/12/bits/stl_bvector.h<bits/functional_hash.h>_Bit_type *__first_p_S_word_bit__fill_bvector_nsizeof(_Bit_type)__fill_bvectorconst _Bit_type__fmask0ul~0ul__lmaskconst const_iteratorconst const_iterator &_Bit_const_iterator &const_iterator &const iteratorconst iterator &_Bit_iterator &iterator &const _Bit_iterator_baseconst _Bit_iterator_base &_Bit_iterator_base &int(_S_word_bit)const _Bit_reference_Bit_reference &const _Bit_reference &_M_insert_range_M_initialize_range_M_initialize_value_M_initialize_M_copy_alignedflip"insert(position, false)"use 'insert(position, false)' insteadvector<bool, _Alloc> &vector<bool, _Alloc> &&const vector<bool, _Alloc>const vector<bool, _Alloc> &_S_nword_M_move_data_Bvector_base<_Alloc> &&~_Bvector_base_Bvector_baseconst _Bit_alloc_typeconst _Bit_alloc_type &_M_get_Bit_allocator_Bit_alloc_type &_M_end_addr_Bvector_impl_Bit_alloc_type &&_Bvector_impl &&is_nothrow_default_constructible<_Bit_alloc_type>::value_Bvector_impl_data &_M_reset_Bvector_impl_data &&_Bvector_impl_dataconst _Bvector_impl_dataconst _Bvector_impl_data &_Bit_const_iterator &&const _Bit_const_iteratorconst _Bit_const_iterator &_Bit_const_iterator_Bit_const_iterator *const _Bit_const_iterator *_Bit_iterator_base *const _Bit_iterator_base *_M_const_castconst _Bit_iteratorconst _Bit_iterator &_Bit_iterator &&_Bit_iterator *const _Bit_iterator *_Bit_iterator_base &&_Bit_iterator_base_M_incr_M_bump_downint(_S_word_bit) - 1_M_bump_up_Bit_reference *const _Bit_reference *operator bool_Bit_referencehash<vector<bool, _Alloc>>vector<bool, _Alloc>_Bit_alloc_traits_Bit_pointer_Bvector_base<_Alloc>_Bit_alloc_typeint(__CHAR_BIT__ * sizeof(_Bit_type))_Bit_type_M_offset_M_p_M_mask_STL_BVECTOR_H_M_reallocate_Bit_alloc_traits::propagate_on_container_swap::value || _M_get_Bit_allocator() == __x._M_get_Bit_allocator()"vector::reserve""vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"/// std::hash specialization for vector<bool>.// DR 1182.// Fill N full words, as if using memset, but usable in constant expressions.// Fill a partial word.// vector class.// here due to the using-declaration in __gnu_debug::vector.// N.B. DR 464 says nothing about vector<bool> but we need something// Precondition: __first._M_offset == 0 && __result._M_offset == 0.// Check whether it's an integral type. If so, it's not an iterator.// [23.2.5]/1, third-to-last entry in synopsis listing// or not the type is an integer.// The range version is a member template, so we dispatch on whether// versions: one that takes a count, and one that takes a range.// assign(), a generalized assignment member function.  Two/**
   *  @brief  A specialization of vector for booleans which offers fixed time
   *  access to individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Alloc  Allocator type.
   *
   *  Note that vector<bool> does not actually meet the requirements for being
   *  a container.  This is because the reference and pointer types are not
   *  really references and pointers to bool.  See DR96 for details.  @see
   *  vector for function documentation.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */// !is_nothrow_move_constructible<_Bit_alloc_type>.// Allow assignment from iterators (assume offset is zero):// We don't need the offset field for the start, it's always zero./** @file bits/stl_bvector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// vector<bool> specialization -*- C++ -*-/usr/include/c++/12/bits/invoke.h__invoke_r_Callable_Callable &&__invoke__invoke_impl_MemPtr &&_MemFun_MemFun &&_Fn &&__invfwd_GLIBCXX_INVOKE_H// _GLIBCXX_INVOKE_H// INVOKE<R> when R is cv void// INVOKE<R>: Invoke a callable object and convert the result to R./// Invoke a callable object.// reference_wrapper is converted to an lvalue-reference.// Used by __invoke_impl instead of std::forward<_Tp> so that a// forward/** @file include/bits/invoke.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Implementation of INVOKE -*- C++ -*-/usr/include/c++/12/backward/binders.hbind2nd"std::bind"use 'std::bind' instead_Operationconst _Operationconst _Operation &_Operation &bind1stfirst_argument_typefirst_argument_type &const first_argument_typeconst first_argument_type &binder2ndsecond_argument_typeconst second_argument_typeconst second_argument_type &second_argument_type &binder1stbinder2nd<_Operation>binder1st<_Operation>_BACKWARD_BINDERS_H/* _BACKWARD_BINDERS_H *//** @}  *//// One of the @link binders binder functors@endlink.// 109.  Missing binders for non-const sequence elements/** @defgroup binders Binder Classes
   * @ingroup functors
   *
   *  Binders turn functions/functors with two arguments into functors
   *  with a single argument, storing an argument to be applied later.
   *  For example, a variable @c B of type @c binder1st is constructed
   *  from a functor @c f and an argument @c x. Later, B's @c
   *  operator() is called with a single argument @c y. The return
   *  value is the value of @c f(x,y). @c B can be @a called with
   *  various arguments (y1, y2, ...) and will in turn call @c
   *  f(x,y1), @c f(x,y2), ...
   *
   *  The function @c bind1st is provided to save some typing. It takes the
   *  function and an argument as parameters, and returns an instance of
   *  @c binder1st.
   *
   *  The type @c binder2nd and its creator function @c bind2nd do the same
   *  thing, but the stored argument is passed as the second parameter instead
   *  of the first, e.g., @c bind2nd(std::minus<float>(),1.3) will create a
   *  functor whose @c operator() accepts a floating-point number, subtracts
   *  1.3 from it, and returns the result. (If @c bind1st had been used,
   *  the functor would perform <em>1.3 - x</em> instead.
   *
   *  Creator-wrapper functions like @c bind1st are intended to be used in
   *  calling algorithms. Their return values will be temporary objects.
   *  (The goal is to not require you to type names like
   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the
   *  return value from @c bind1st(std::plus<int>(),5).
   *
   *  These become more useful when combined with the composition functions.
   *
   *  These functions are deprecated in C++11 and can be replaced by
   *  @c std::bind (or @c std::tr1::bind) which is more powerful and flexible,
   *  supporting functions with any number of arguments.  Uses of @c bind1st
   *  can be replaced by @c std::bind(f, x, std::placeholders::_1) and
   *  @c bind2nd by @c std::bind(f, std::placeholders::_1, x).
   *  @{
   */// 20.3.6 binders// Suppress deprecated warning for this file./** @file backward/binders.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Functor implementations -*- C++ -*-/usr/include/c++/12/backward/usr/include/c++/12/bits/stl_function.h<backward/binders.h>mem_fun_ref"std::mem_fn"use 'std::mem_fn' insteadmem_funptr_fun"std::function"use 'std::function' instead_Arg1_Arg2not2"std::not_fn"use 'std::not_fn' insteadconst _Predicateconst _Predicate &_Predicate &not1const_mem_fun1_ref_tmem_fun1_ref_tconst_mem_fun1_tmem_fun1_tconst_mem_fun_ref_tmem_fun_ref_tconst_mem_fun_tmem_fun_tconst second_typeconst second_type &second_type &_Pairconst _Pairconst _Pair &_Pair &const first_typeconst first_type &first_type &_Pair2const _Pair2const _Pair2 &_Pair2 &pointer_to_binary_functionpointer_to_unary_functionbinary_negateconst argument_typeconst argument_type &argument_type &unary_negatebit_not<void> &bit_not<void> &&const bit_not<void>const bit_not<void> &bit_xor<void> &bit_xor<void> &&const bit_xor<void>const bit_xor<void> &bit_or<void> &bit_or<void> &&const bit_or<void>const bit_or<void> &bit_and<void> &bit_and<void> &&const bit_and<void>const bit_and<void> &logical_not<void> &logical_not<void> &&const logical_not<void>const logical_not<void> &logical_or<void> &logical_or<void> &&const logical_or<void>const logical_or<void> &logical_and<void> &logical_and<void> &&const logical_and<void>const logical_and<void> &less_equal<void> &less_equal<void> &&const less_equal<void>const less_equal<void> &_S_cmpgreater_equal<void> &greater_equal<void> &&const greater_equal<void>const greater_equal<void> &less<void> &less<void> &&const less<void>const less<void> &greater<void> &greater<void> &&const greater<void>const greater<void> &not_equal_to<void> &not_equal_to<void> &&const not_equal_to<void>const not_equal_to<void> &equal_to<void> &equal_to<void> &&const equal_to<void>__pfconst equal_to<void> &negate<void> &negate<void> &&const negate<void>const negate<void> &modulus<void> &modulus<void> &&const modulus<void>const modulus<void> &divides<void> &divides<void> &&const divides<void>const divides<void> &multiplies<void> &multiplies<void> &&const multiplies<void>const multiplies<void> &minus<void> &minus<void> &&const minus<void>const minus<void> &plus<void> &plus<void> &&const plus<void>const plus<void> &__has_is_transparent_t__has_is_transparent<_Func, _SfinaeType, __void_t<is_transparent>>_SfinaeType__has_is_transparent<_Func, _SfinaeType, <unnamed>>const_mem_fun1_ref_t<_Ret, _Tp, _Arg>mem_fun1_ref_t<_Ret, _Tp, _Arg>const_mem_fun1_t<_Ret, _Tp, _Arg>mem_fun1_t<_Ret, _Tp, _Arg>const_mem_fun_ref_t<_Ret, _Tp>mem_fun_ref_t<_Ret, _Tp>const_mem_fun_t<_Ret, _Tp>mem_fun_t<_Ret, _Tp>_Select2nd<_Pair>_Select1st<_Pair>_Identity<const _Tp>_Identity<_Tp>pointer_to_binary_function<_Arg1, _Arg2, _Result>pointer_to_unary_function<_Arg, _Result>binary_negate<_Predicate>unary_negate<_Predicate>bit_not<void>is_transparentbit_xor<void>bit_or<void>bit_and<void>bit_not<_Tp>bit_xor<_Tp>bit_or<_Tp>bit_and<_Tp>logical_not<void>logical_or<void>logical_and<void>logical_not<_Tp>logical_or<_Tp>logical_and<_Tp>less_equal<void>__not_overloaded<_Tp, _Up, __void_t<decltype((<expression>))>>__not_overloaded<_Tp, _Up, <unnamed>>__not_overloaded2<_Tp, _Up, __void_t<decltype((<expression>))>>__not_overloaded2<_Tp, _Up, <unnamed>>greater_equal<void>less<void>greater<void>not_equal_to<void>equal_to<void>less_equal<_Tp *>greater_equal<_Tp *>less<_Tp *>greater<_Tp *>less_equal<_Tp>greater_equal<_Tp>less<_Tp>greater<_Tp>not_equal_to<_Tp>equal_to<_Tp>negate<void>modulus<void>divides<void>multiplies<void>minus<void>plus<void>negate<_Tp>modulus<_Tp>divides<_Tp>multiplies<_Tp>minus<_Tp>plus<_Tp>__is_transparentbinary_function<_Arg1, _Arg2, _Result>unary_function<_Arg, _Result>_M_f__cpp_lib_transparent_operators_STL_FUNCTION_H(__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED__UINTPTR_TYPE__/* _STL_FUNCTION_H */// mem_fun and mem_fun_ref.// Mem_fun adaptor helper functions.  There are only two:/// One of the @link ptrmem_adaptors adaptors for member pointers@endlink./** @defgroup ptrmem_adaptors Adaptors for pointers to members
   *  @ingroup functors
   *
   *  There are a total of 8 = 2^3 function objects in this family.
   *   (1) Member functions taking no arguments vs member functions taking
   *        one argument.
   *   (2) Call through pointer vs call through reference.
   *   (3) Const vs non-const member function.
   *
   *  All of this complexity is in the function objects themselves.  You can
   *   ignore it by using the helper function `mem_fun` and `mem_fun_ref`,
   *   which create whichever type of adaptor is appropriate.
   *
   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.
   *  Use `mem_fn` instead.
   *
   *  @{
   */// 20.3.8 adaptors pointers members// Partial specialization, avoids confusing errors in e.g. std::set<const T>./// One of the @link pointer_adaptors adaptors for function pointers@endlink./** @defgroup pointer_adaptors Adaptors for pointers to functions
   *  @ingroup functors
   *
   *  The advantage of function objects over pointers to functions is that
   *  the objects in the standard library declare nested typedefs describing
   *  their argument and result types with uniform names (e.g., `result_type`
   *  from the base classes `unary_function` and `binary_function`).
   *  Sometimes those typedefs are required, not just optional.
   *
   *  Adaptors are provided to turn pointers to unary (single-argument) and
   *  binary (double-argument) functions into function objects.  The
   *  long-winded functor `pointer_to_unary_function` is constructed with a
   *  function pointer `f`, and its `operator()` called with argument `x`
   *  returns `f(x)`.  The functor `pointer_to_binary_function` does the same
   *  thing, but with a double-argument `f` and `operator()`.
   *
   *  The function `ptr_fun` takes a pointer-to-function `f` and constructs
   *  an instance of the appropriate functor.
   *
   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.
   *
   *  @{
   */// 20.3.7 adaptors pointers functions/// One of the @link negators negation functors@endlink./** @defgroup negators Negators
   *  @ingroup functors
   *
   *  The function templates `not1` and `not2` are function object adaptors,
   *  which each take a predicate functor and wrap it in an instance of
   *  `unary_negate` or `binary_negate`, respectively.  Those classes are
   *  functors whose `operator()` evaluates the wrapped predicate function
   *  and then returns the negation of the result.
   *
   *  For example, given a vector of integers and a trivial predicate,
   *  \code
   *  struct IntGreaterThanThree
   *    : public std::unary_function<int, bool>
   *  {
   *      bool operator() (int x) const { return x > 3; }
   *  };
   *
   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
   *  \endcode
   *  The call to `find_if` will locate the first index (i) of `v` for which
   *  `!(v[i] > 3)` is true.
   *
   *  The not1/unary_negate combination works on predicates taking a single
   *  argument.  The not2/binary_negate combination works on predicates taking
   *  two arguments.
   *
   *  @deprecated Deprecated in C++17, no longer in the standard since C++20.
   *  Use `not_fn` instead.
   *
   *  @{
   */// 20.3.5 negators// DR 660. Missing Bitwise Operations./// One of the @link logical_functors Boolean operations functors@endlink./** @defgroup logical_functors Boolean Operations Classes
   *  @ingroup functors
   *
   *  The library provides function objects for the logical operations:
   *  `&&`, `||`, and `!`.
   *
   *  @{
   */// 20.3.4 logical operations// False if we can call operator<=(T,U)// True if there is no overloaded operator<= for these operands.// False if we can call T.operator<=(U)// True if there is no viable operator<= member function./// One of the @link comparison_functors comparison functors@endlink.// False if we can call operator>=(T,U)// True if there is no overloaded operator>= for these operands.// False if we can call T.operator>=(U)// True if there is no viable operator>= member function.// False if we can call operator<(T,U)// True if there is no overloaded operator< for these operands.// False if we can call T.operator<(U)// True if there is no viable operator< member function.// False if we can call operator>(T,U)// True if there is no overloaded operator> for these operands.// False if we can call T.operator>(U)// True if there is no viable operator> member function.// Partial specialization of std::less_equal for pointers.// Partial specialization of std::greater_equal for pointers.// Partial specialization of std::less for pointers.// Partial specialization of std::greater for pointers./** @defgroup comparison_functors Comparison Classes
   *  @ingroup functors
   *
   *  The library provides six wrapper functors for all the basic comparisons
   *  in C++, like @c <.
   *
   *  @{
   */// 20.3.3 comparisons/// One of the @link arithmetic_functors math functors@endlink./// Returns the sum// Ignore warnings about unary_function and binary_function.// undefined/** @defgroup arithmetic_functors Arithmetic Function Object Classes
   *  @ingroup functors
   *
   *  The library provides function objects for basic arithmetic operations.
   *  See the documentation for @link functors function objects @endlink
   *  for examples of their use.
   *
   *  @{
   */// 20.3.2 arithmetic/// @c result_type is the return type/// @c second_argument_type is the type of the second argument/// @c first_argument_type is the type of the first argument/**
   *  Helper for defining adaptable binary function objects.
   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.
   *//// @c argument_type is the type of the argument/**
   *  Helper for defining adaptable unary function objects.
   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.
   *//** @defgroup functors Function Objects
   *  @ingroup utilities
   *
   *  Function objects, or _functors_, are objects with an `operator()`
   *  defined and accessible.  They can be passed as arguments to algorithm
   *  templates and used in place of a function pointer.  Not only is the
   *  resulting expressiveness of the library increased, but the generated
   *  code can be more efficient than what you might write by hand.  When we
   *  refer to _functors_, then, generally we include function pointers in
   *  the description as well.
   *
   *  Often, functors are only created as temporaries passed to algorithm
   *  calls, rather than being created as named variables.
   *
   *  Two examples taken from the standard itself follow.  To perform a
   *  by-element addition of two vectors `a` and `b` containing `double`,
   *  and put the result in `a`, use
   *  \code
   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
   *  \endcode
   *  To negate every element in `a`, use
   *  \code
   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
   *  \endcode
   *  The addition and negation functions will usually be inlined directly.
   *
   *  An _adaptable function object_ is one which provides nested typedefs
   *  `result_type` and either `argument_type` (for a unary function) or
   *  `first_argument_type` and `second_argument_type` (for a binary function).
   *  Those typedefs are used by function object adaptors such as `bind2nd`.
   *  The standard library provides two class templates, `unary_function` and
   *  `binary_function`, which define those typedefs and so can be used as
   *  base classes of adaptable function objects.
   *
   *  Since C++11 the use of function object adaptors has been superseded by
   *  more powerful tools such as lambda expressions, `function<>`, and more
   *  powerful type deduction (using `auto` and `decltype`). The helpers for
   *  defining adaptable function objects are deprecated since C++11, and no
   *  longer part of the standard library since C++17. However, they are still
   *  defined and used by libstdc++ after C++17, as a conforming extension.
   *
   *  @{
   */// 20.3.1 base classes/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 *//usr/include/c++/12/bits/refwrap.h<bits/stl_function.h><bits/invoke.h>crefreference_wrapperoperator _Tp &reference_wrapper<_Tp> &const reference_wrapper<_Tp>const reference_wrapper<_Tp> &_S_fun_Reference_wrapper_base_memfun<_MemFunPtr, true>__maybe_type_MemFunPtr__result_type_Reference_wrapper_base_memfun<_Tp, <unnamed>>_Reference_wrapper_base<..(*)(..)>_Reference_wrapper_base<..(..)>_Reference_wrapper_base<_Tp>_Refwrap_base_arg2<_Tp, __void_t<first_argument_type, second_argument_type>>_Refwrap_base_arg2<_Tp, <unnamed>>_Refwrap_base_arg1<_Tp, __void_t<argument_type>>_Refwrap_base_arg1<_Tp, <unnamed>>_Weak_result_type<_Functor>_Weak_result_type_memfun<_Func _Class::*, false>_Weak_result_type_memfun<_MemFunPtr, true>_Weak_result_type_memfun<_Functor, <unnamed>>_Weak_result_type_impl<..(*)(..)>_Weak_result_type_impl<..(..)>_Weak_result_type_impl<_Functor>_Maybe_get_result_type<_Functor, __void_t<result_type>>_Maybe_get_result_type<_Functor, <unnamed>>_Mem_fn_traits<..(*)(..)>_Mem_fn_traits_base<_Res, _Class, _ArgTypes...>_Mem_fn_traits<_Signature>_Maybe_unary_or_binary_function<_Res, _T1, _T2>_Maybe_unary_or_binary_function<_Res, _T1>_Maybe_unary_or_binary_function<_Res, _ArgTypes...>__not_same&& noexceptconst volatile& noexcept_Up2_M_data_GLIBCXX_MEM_FN_TRAITS2_GLIBCXX_MEM_FN_TRAITS_GLIBCXX_MEM_FN_TRAITS(_REF,_LVAL,_RVAL)_GLIBCXX_MEM_FN_TRAITS2( , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(const , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(volatile , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)_GLIBCXX_MEM_FN_TRAITS2(_CV,_REF,_LVAL,_RVAL)template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF> : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF> : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...> { using __vararg = true_type; };_GLIBCXX_REFWRAP_H// _GLIBCXX_REFWRAP_H/// std::cref overload to prevent wrapping a reference_wrapper/// std::ref overload to prevent wrapping a reference_wrapper/// Denotes a const reference should be taken to a variable./// Denotes a reference should be taken to a variable./// @relates reference_wrapper @{// 3041. Unnecessary decay in reference_wrapper// 2993. reference_wrapper<T> conversion from T&&// so checking for nested types could result in ODR violations.// In C++20 std::reference_wrapper<T> allows T to be incomplete,/**
   *  @brief Primary class template for reference_wrapper.
   *  @ingroup functors
   */// - a function pointer type (binary)// - a function pointer type (unary)// - a function type (binary)// - a function type (unary)/**
   *  Derives from unary_function or binary_function when it
   *  can. Specializations handle all of the easy cases. The primary
   *  template determines what to do with a class type, which may
   *  derive from both unary_function and binary_function.
  */// Nested first_argument_type and second_argument_type.// Detect nested first_argument_type and second_argument_type.// Nested argument_type.// Detect nested argument_type./**
   *  Strip top-level cv-qualifiers from the function object and let
   *  _Weak_result_type_memfun perform the real work.
  */// A pointer to data member doesn't have a weak result type.// A pointer to member function has a weak result type.// Let _Weak_result_type_impl perform the real work./// Retrieve the result type for a varargs function pointer./// Retrieve the result type for a function pointer./// Retrieve the result type for a varargs function type./// Retrieve the result type for a function type./**
   *  Base class for any function object that has a weak result type, as
   *  defined in 20.8.2 [func.require] of C++11.
  *//// If we have found a result_type, extract it./// Derives from @c binary_function, as appropriate./// Derives from @c unary_function, as appropriate./**
   * Derives from @c unary_function or @c binary_function, or perhaps
   * nothing, depending on the number of arguments provided. The
   * primary template is the basis case, which derives nothing.
   */// for unary_function and binary_function/** @file include/bits/refwrap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Implementation of std::reference_wrapper -*- C++ -*-__uref/usr/include/c++/12/bits/range_access.hconst _Containerconst _Container &const _Tp(&)[]const valarray<_Tp>const valarray<_Tp> &valarray<_Tp> &valarray<_Tp>__cpp_lib_nonmember_container_access_GLIBCXX_RANGE_ACCESS_H// _GLIBCXX_RANGE_ACCESS_H/**
   *  @brief  Return the data pointer of an initializer list.
   *  @param  __il  Initializer list.
   *//**
   *  @brief  Return the data pointer of an array.
   *  @param  __array  Array.
   *//**
   *  @brief  Return the data pointer of a const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return the data pointer of a container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return whether an initializer_list is empty.
   *  @param  __il  Initializer list.
   *//**
   *  @brief  Return whether an array is empty (always false).
   *//**
   *  @brief  Return whether a container is empty.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return the size of an array.
   *//**
   *  @brief  Return the size of a container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the const container.
   *  @param  __cont  Container.
   */// These overloads must be declared for cbegin and cend to use them./**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return an iterator pointing to the first element of the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the container.
   *  @param  __cont  Container.
   */// reverse_iterator// common_type_t, make_signed_t/** @file bits/range_access.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */// Range access functions for containers -*- C++ -*-__il__array__cont__arr/usr/include/c++/12/bits/vector.tcc__position + 1end()vector::_M_realloc_insert"vector::_M_realloc_insert"__old_start__old_finish__elems_before__new_start__new_finish_GLIBCXX_ASAN_ANNOTATE_SHRINK_GLIBCXX_ASAN_ANNOTATE_GREW_GLIBCXX_ASAN_ANNOTATE_GROW_VECTOR_TCC__elems_after__n - __elems_after__position.base()__old_finish - __n__tmp.end()__tmp.begin()this->_M_impl._M_finish - 2this->_M_impl._M_finish - 1*(this->_M_impl._M_finish - 1)__addthis->_M_impl._M_finishthis->_M_impl._M_start/* _VECTOR_TCC */// vector<bool>// See _M_realloc_insert above.// [res.on.arguments]).// taking the element by lvalue ref (see last bullet of C++11// to the existing vector.  This is an issue only for callers// case, where the moves could alter a new element belonging// The order of the three operations is dictated by the C++11// need to use it before _M_insert_aux moves elements around.// could alias one of the elements of the container and so we// We need to construct a temporary because something in __args...// replacement allocator cannot free existing storage// copy of it before _M_insert_aux moves elements around.// __x could be an existing element of this vector, so make a/** @file bits/vector.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 */// Vector implementation (out of line) -*- C++ -*-/usr/include/c++/12/vector<bits/vector.tcc><bits/range_access.h><bits/refwrap.h><bits/stl_bvector.h><bits/stl_vector.h><bits/stl_uninitialized.h>polymorphic_allocator<_Tp>_GLIBCXX_VECTORpmr_GLIBCXX_EXPORT_TEMPLATE/* _GLIBCXX_VECTOR */// namespace _GLIBCXX_STD_C::pmr// namespace pmr/** @file include/vector
 *  This is a Standard C++ Library header.
 */// <vector> -*- C++ -*-/usr/include/c++/12/bits/stringfwd.hbasic_string<_CharT, _Traits, _Alloc>_STRINGFWD_Hchar_traits<char32_t>char_traits<char16_t>char_traits<wchar_t>char_traits<char>// _STRINGFWD_H/// A string of @c char32_t/// A string of @c char16_t/// A string of @c char8_t/// A string of @c wchar_t/// A string of @c char/**
   *  @defgroup strings Strings
   *
   *  @{
  */// ISO C++ 14882: 21 Strings library/** @file bits/stringfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */// <string> Forward declarations -*- C++ -*-/usr/include/bits/types/wint_t.hwint_t__wint_t_defined/* bits/types/wint_t.h *//* _WINT_T *//* Some versions of stddef.h provide wint_t, even though neither the
   C nor C++ standards, nor POSIX, specifies this.  We assume that
   stddef.h will define the macro _WINT_T if and only if it provides
   wint_t, and conversely, that it will avoid providing wint_t if
   _WINT_T is already defined.  *//usr/include/bits/types/mbstate_t.hmbstate_t__mbstate_t_defined/usr/include/wchar.h<bits/types/mbstate_t.h><bits/types/wint_t.h>wcsftime_lfputws_unlocked__FILE *__FILE *__restrict__fgetws_unlockedputwchar_unlockedputwc_unlockedfputwc_unlockedfgetwc_unlockedgetwchar_unlockedgetwc_unlockedopen_wmemstreamwchar_t **wcpncpywcpcpywcstof64x_lwchar_t **__restrict__wcstof32x_lwcstof128_lwcstof64_lwcstof32_lwcstold_lwcstof_lwcstod_lwcstoull_lwcstoll_lwcstoul_lwcstol_lwcstouqwcstoqwcstof64xwcstof32xwcstof128wcstof64wcstof32wcswidthwcwidthwcsnrtombsconst wchar_t **const wchar_t **__restrict__mbstate_t *__mbstate_t *mbstate_t *__restrict__mbsnrtowcsconst char **__restrict____mbrlenwmempcpywcsnlenwcswcswcschrnulwcsdupwcsxfrm_lwcscoll_lwcsncasecmp_lwcscasecmp_lwcsncasecmpwcscasecmpwcstoullwcstollwcstoldwmemchrwcsstrwcsrchrwcspbrkwcschrwscanfwprintfwmemsetwmemmovewmemcpywmemcmpwctobwcsxfrmwcstoulwcstolwcstokwcstofwcstodwcsspnwcsrtombswcsncpywcsncmpwcsncatwcslenwcsftimewcscspnwcscpywcscollwcscmpwcscatwcrtombvwscanfvwprintfvswscanfvswprintfvfwscanfvfwprintfungetwcswscanfswprintfputwcharputwcmbsrtowcsmbsinitconst mbstate_tconst mbstate_t *mbrtowcmbrlengetwchargetwcfwscanffwprintffwidefputwsfputwcfgetwsfgetwcbtowcWEOF(0xffffffffu)__CORRECT_ISO_CPP_WCHAR_H_PROTO(defined __USE_XOPEN && !defined __USE_GNU \defined __has_builtin__has_builtin (__builtin_fclose)defined __USE_ISOC95 || defined __USE_UNIX98!__GLIBC_USE (DEPRECATED_SCANF) \(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vswscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vfwscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...)__isoc99_swscanf(const wchar_t *__restrict __format, ...)__isoc99_wscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...)__isoc99_fwscanf"__isoc99_vswscanf""__isoc99_vwscanf""__isoc99_vfwscanf""__isoc99_swscanf""__isoc99_wscanf""__isoc99_fwscanf"/* wchar.h  *//* The following headers provide asm redirections.  These redirections must
   appear before the first usage of these functions, e.g. in bits/wchar.h.  *//* Declare all functions from bits/wchar2-decl.h first.  *//* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  *//* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  *//* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  *//* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  *//* Use ISO C99. *//* __attribute__ ((__format__ (__wscanf__, 2, 0))) *//* __attribute__ ((__format__ (__wscanf__, 1, 0))) *//* Same redirection as above for the v*wscanf family.  *//* Use ISO C95, C99 and Unix98. *//* __attribute__ ((__format__ (__wscanf__, 2, 3))) *//* __attribute__ ((__format__ (__wscanf__, 1, 2))) *//* For historical reasons, the C99-compliant versions of the scanf
   functions are at alternative names.  When __LDBL_COMPAT or
   __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI are in effect, this is handled in
   bits/wchar-ldbl.h.  *//* __attribute__ ((__format__ (__wprintf__, 3, 0))) *//* Write formatted output of at most N character to S from argument
   list ARG.  *//* __attribute__ ((__format__ (__wprintf__, 1, 0))) *//* __attribute__ ((__format__ (__wprintf__, 2, 0))) *//* __attribute__ ((__format__ (__wprintf__, 3, 4))) *//* Write formatted output of at most N characters to S.  *//* __attribute__ ((__format__ (__wprintf__, 1, 2))) *//* __attribute__ ((__format__ (__wprintf__, 2, 3))) *//* Select orientation for stream.  *//* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  *//* If the attribute macro hasn't been defined yet (by <stdio.h>) and
   fclose is a built-in, use it.  *//* Wide character I/O functions.  *//* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  *//* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  *//* Convert initial portion of wide string NPTR to `long long int'
   representation.  *//* ISO C99.  *//* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  *//* Convert initial portion of wide string NPTR to `long int'
   representation.  *//* Likewise for `_FloatN' and `_FloatNx' when support is enabled.  *//* Convert initial portion of the wide string NPTR to `double'
   representation.  *//* Use X/Open.  *//* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  *//* Determine number of column positions required for C.  *//* The following functions are extensions found in X/Open CAE.  *//* use POSIX 2008 *//* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  *//* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  *//* Write multibyte character representation of wide character string
   SRC to DST.  *//* Write wide character representation of multibyte character string
   SRC to DST.  *//* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  *//* Define inline function as optimization.  *//* Return number of bytes in multibyte character pointed to by S.  *//* Write multibyte representation of wide character WC to S.  *//* Write wide character representation of multibyte character pointed
   to by S to PWC.  *//* Determine whether PS points to an object representing the initial
   state.  *//* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  *//* Determine whether C constitutes a valid (one-byte) multibyte
   character.  *//* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  *//* Set N wide characters of S to C.  *//* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  *//* Copy N wide characters of SRC to DEST.  *//* Compare N wide characters of S1 and S2.  *//* Search N wide characters of S for C.  *//* Return the number of wide characters in S, but at most MAXLEN.  *//* Another name for `wcsstr' from XPG4.  *//* Return the number of wide characters in S.  *//* Divide WCS into tokens separated by characters in DELIM.  *//* Find the first occurrence in WCS of any character in ACCEPT.  *//* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  *//* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  *//* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  *//* Find the last occurrence of WC in WCS.  *//* Find the first occurrence of WC in WCS.  *//* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  *//* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  *//* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  *//* Compare N wide-characters of S1 and S2.  *//* Append no more than N wide-characters of SRC onto DEST.  *//* Copy no more than N wide-characters of SRC to DEST.  *//* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  *//* All versions of XPG prior to the publication of ISO C99 required
   the bulk of <wctype.h>'s declarations to appear in this header
   (because <wctype.h> did not exist prior to C99).  In POSIX.1-2001
   those declarations were marked as XSI extensions; in -2008 they
   were additionally marked as obsolescent.  _GNU_SOURCE mode
   anticipates the removal of these declarations in the next revision
   of POSIX.  *//* These constants might also be defined in <inttypes.h>.  *//*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */__ws__wc__dst__nwc__ps__nmc__wcs/usr/include/c++/12/cwchar<wchar.h>_GLIBCXX_CWCHAR_GLIBCXX_HAVE_BROKEN_VSWPRINTF//_GLIBCXX_USE_WCHAR_T// Get rid of those macros defined in <wchar.h> in lieu of real functions.// assumes it is in wchar.h, regardless of wchar_t specializations.// Need to do a bit of trickery here with mbstate_t as char_traits// ISO C++ 14882: 21.4/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/c++/12/bits/postypes.h<cwchar>const fpos<_StateT>const fpos<_StateT> &fpos<_StateT> &_StateToperator std::streamoff~fposfposfpos<_StateT>streamsizestreamoff_M_state_M_off_GLIBCXX_POSTYPES_H__INT64_TYPE__/// File position for char32_t streams./// File position for char16_t streams./// File position for char8_t streams./// File position for wchar_t streams./// File position for char streams.// they must both be typedefs for fpos<mbstate_t>// as implementation defined types, but clause 27.2 requires that// Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos/// Test if equivalent to another position.// offsets compare equal.// objects belong to the same equivalence class if the contained// equivalence relation. In this implementation two fpos<StateT>// The standard only requires that operator== must be an/// Subtract position to return offset.// stored in *this and in the argument.// implementation it returns the difference between the offset// defines its semantics only in terms of operator+. In this// The standard requires that this operator must be defined, but/// Subtract offset from position.// copy.// argument from that copy using operator-= and then returns the// implementation it constructs a copy of *this, subtracts the/// Add position and offset.// argument to that copy using operator+= and then returns the// implementation it constructs a copy of *this, adds the// defines its semantics only in terms of operator-. In this/// Subtract offset from this position.// its argument from the stored offset and returns *this.// gives no semantics. In this implementation it just subtracts/// Add offset to this position.// argument to the stored offset and returns *this.// gives no semantics. In this implementation it just adds its/// Return the last set value of @a st./// Remember the value of @a st./// Convert to streamoff./// Construct position from offset.// constructs the state.// constructor stores the streamoff as the offset and default// implementation implicit conversion is also allowed, and this// fails to give any meaningful semantics. In this// from streamoff objects using the constructor syntax, and// The standard requires that fpos objects can be constructed// constructor that initializes the offset to 0 and default// constructed. This implementation provides a default// The standard doesn't require that fpos objects can be default/**
   *  @brief  Class representing stream positions.
   *
   *  The standard places no requirements upon the template parameter StateT.
   *  In this implementation StateT must be DefaultConstructible,
   *  CopyConstructible and Assignable.  The standard only requires that fpos
   *  should contain a member of type StateT. In this implementation it also
   *  contains an offset stored as a signed integer.
   *
   *  @param  StateT  Type passed to and returned from state().
   */// Signed integral type/// Integral type for I/O operation counts and buffer sizes./**
   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.
   *
   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an
   *  implementation defined type.
   *  Note: In versions of GCC up to and including GCC 3.3, streamoff
   *  was typedef long.
  */// below.// unspecified. The behaviour in this implementation is as noted// behaviour of these types is mostly implementation defined or// 27.2, 27.4.1, 27.4.3 and D.6. Despite all this verbiage, the// template fpos<> are described in clauses 21.1.2, 21.1.3, 27.1.2,// The types streamoff, streampos and wstreampos and the class// For mbstate_t// ISO C++ 14882: 27.4.3 - Template class fpos// ISO C++ 14882: 27.4.1 - Types/** @file bits/postypes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */// Position types -*- C++ -*-__other__stWINT_WIDTHWCHAR_WIDTHSIZE_WIDTHSIG_ATOMIC_WIDTHPTRDIFF_WIDTHUINTMAX_WIDTHINTMAX_WIDTHUINTPTR_WIDTHINTPTR_WIDTHUINT_FAST64_WIDTHINT_FAST64_WIDTHUINT_FAST32_WIDTHINT_FAST32_WIDTHUINT_FAST16_WIDTHINT_FAST16_WIDTHUINT_FAST8_WIDTHINT_FAST8_WIDTHUINT_LEAST64_WIDTHINT_LEAST64_WIDTHUINT_LEAST32_WIDTHINT_LEAST32_WIDTHUINT_LEAST16_WIDTHINT_LEAST16_WIDTHUINT_LEAST8_WIDTHINT_LEAST8_WIDTHUINT64_WIDTHINT64_WIDTHUINT32_WIDTHINT32_WIDTHUINT16_WIDTHINT16_WIDTHUINT8_WIDTHINT8_WIDTH__STDC_CONSTANT_MACROS__STDC_LIMIT_MACROS/usr/include/c++/12/cstdint_GLIBCXX_CSTDINT// _GLIBCXX_CSTDINT// _GLIBCXX_USE_C99_STDINT_TR1// Define the minimum needed for <ratio>, <chrono> etc.// !_GLIBCXX_USE_C99_STDINT_TR1/** @file include/cstdint
 *  This is a Standard C++ Library header.
 */// <cstdint> -*- C++ -*-/usr/include/c++/12/bits/char_traits.h<cstdint><bits/postypes.h>not_eofconst int_typeint_typeconst int_type &int_type &eofeq_int_typeto_int_typeconst char_typeconst char_type &to_char_typechar_type *const char_type *comparelteqchar_type &char_traits<char32_t> &char_traits<char32_t> &&const char_traits<char32_t>const char_traits<char32_t> &eof()static_cast<int_type>(-1)char32_t &char32_t *sizeof(char_type)char_type()char_traits<char16_t> &char_traits<char16_t> &&const char_traits<char16_t>const char_traits<char16_t> &char16_t &655330xfffdint_type(0xfffd)char16_t *char_traits<wchar_t> &char_traits<wchar_t> &&const char_traits<wchar_t>const char_traits<wchar_t> &static_cast<int_type>(WEOF)wchar_t &char_traits<char> &char_traits<char> &&const char_traits<char>const char_traits<char> &static_cast<int_type>(_GLIBCXX_STDIO_EOF)__builtin_memchr__builtin_strlen__builtin_memcmpstate_typeoff_typepos_typechar_type_Char_types<_CharT>__cpp_lib_constexpr_char_traits201611L_GLIBCXX_ALWAYS_INLINEinline __attribute__((__always_inline__))_CHAR_TRAITS_HGCC diagnostic ignored "-Wstringop-overflow"GCC diagnostic ignored "-Wstringop-overread"GCC diagnostic ignored "-Warray-bounds"__cplusplus >= 201703L && _GLIBCXX_HAVE_IS_CONSTANT_EVALUATEDdefined __UINT_LEAST16_TYPE__defined __UINT_LEAST32_TYPE__// _CHAR_TRAITS_H//_GLIBCXX_USE_CHAR8_T/// 21.1.3.2  char_traits specializations// from ending up as 0xffffffff.// To keep both the byte 0xff and the eof symbol 0xffffffff// LWG 467./// 21.1.3.1  char_traits specializations/**
   *  @brief  Basis for explicit traits specializations.
   *
   *  @note  For any given actual character type, this definition is
   *  probably wrong.  Since this is just a thin wrapper around
   *  __gnu_cxx::char_traits, it is possible to achieve a more
   *  appropriate definition by specializing __gnu_cxx::char_traits.
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.
  */// 21.1// Unofficial macro indicating P0426R1 support in C++17// Unofficial macro indicating P1032R1 support in C++20// so use a temporary buffer instead.// The overlap detection below fails due to PR c++/89074,// unlikely, but saves a lot of work/**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamental types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   *//**
   *  @brief  Mapping from character type to associated types.
   *
   *  @note This is an implementation class for the generic version
   *  of char_traits.  It defines int_type, off_type, pos_type, and
   *  state_type.  By default these are unsigned long, streamoff,
   *  streampos, and mbstate_t.  Users who need a different set of
   *  types, but who don't need to change the definitions of any function
   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
   *  while leaving __gnu_cxx::char_traits alone. */// For WEOF, wmemmove, wmemset, etc.// For streampos// ISO C++ 14882: 21  Strings library/** @file bits/char_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */// Character Traits for use by standard string and iostream -*- C++ -*-/usr/include/bits/locale.h__LC_IDENTIFICATION__LC_MEASUREMENT__LC_TELEPHONE__LC_ADDRESS__LC_NAME__LC_PAPER__LC_ALL__LC_MESSAGES__LC_MONETARY__LC_COLLATE__LC_TIME__LC_NUMERIC__LC_CTYPE_BITS_LOCALE_H!defined _LOCALE_H && !defined _LANGINFO_H/* bits/locale.h *//* Definition of locale category symbol values.
   Copyright (C) 2001-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/locale.h<bits/locale.h>uselocalefreelocaleduplocalenewlocalelconv *localeconvsetlocalelconv &lconv &&const lconvconst lconv &lconvint_n_sign_posnint_p_sign_posnint_n_sep_by_spaceint_n_cs_precedesint_p_sep_by_spaceint_p_cs_precedesn_sign_posnp_sign_posnn_sep_by_spacen_cs_precedesp_sep_by_spacep_cs_precedesfrac_digitsint_frac_digitsnegative_signpositive_signmon_groupingmon_thousands_sepmon_decimal_pointcurrency_symbolint_curr_symbolgroupingthousands_sepdecimal_pointLC_GLOBAL_LOCALE((locale_t) -1L)LC_ALL_MASK(LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK | LC_PAPER_MASK | LC_NAME_MASK | LC_ADDRESS_MASK | LC_TELEPHONE_MASK | LC_MEASUREMENT_MASK | LC_IDENTIFICATION_MASK )LC_IDENTIFICATION_MASK(1 << __LC_IDENTIFICATION)LC_MEASUREMENT_MASK(1 << __LC_MEASUREMENT)LC_TELEPHONE_MASK(1 << __LC_TELEPHONE)LC_ADDRESS_MASK(1 << __LC_ADDRESS)LC_NAME_MASK(1 << __LC_NAME)LC_PAPER_MASK(1 << __LC_PAPER)LC_MESSAGES_MASK(1 << __LC_MESSAGES)LC_MONETARY_MASK(1 << __LC_MONETARY)LC_COLLATE_MASK(1 << __LC_COLLATE)LC_TIME_MASK(1 << __LC_TIME)LC_NUMERIC_MASK(1 << __LC_NUMERIC)LC_CTYPE_MASK(1 << __LC_CTYPE)LC_IDENTIFICATIONLC_MEASUREMENTLC_TELEPHONELC_ADDRESSLC_NAMELC_PAPERLC_ALLLC_MESSAGESLC_MONETARYLC_COLLATELC_TIMELC_NUMERICLC_CTYPE_LOCALE_H/* locale.h  *//* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  *//* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  *//* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  *//* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  *//* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  *//* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  *//* POSIX.1-2008 extends the locale interface with functions for
   explicit creation and manipulation of 'locale_t' objects
   representing locale contexts, and a set of parallel
   locale-sensitive text processing functions that take a locale_t
   argument.  This enables applications to work with data from
   multiple locales simultaneously and thread-safely.  *//* Return the numeric/monetary information for the current locale.  *//* Set and/or return the current locale.  *//* Positive and negative sign positions:
     0 Parentheses surround the quantity and int_curr_symbol.
     1 The sign string precedes the quantity and int_curr_symbol.
     2 The sign string follows the quantity and int_curr_symbol.
     3 The sign string immediately precedes the int_curr_symbol.
     4 The sign string immediately follows the int_curr_symbol.  *//* 1 iff a space separates int_curr_symbol from a negative value.  *//* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  *//* 1 iff a space separates int_curr_symbol from a positive value.  *//* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  *//* Positive and negative sign positions:
     0 Parentheses surround the quantity and currency_symbol.
     1 The sign string precedes the quantity and currency_symbol.
     2 The sign string follows the quantity and currency_symbol.
     3 The sign string immediately precedes the currency_symbol.
     4 The sign string immediately follows the currency_symbol.  *//* 1 iff a space separates currency_symbol from a negative value.  *//* 1 if currency_symbol precedes a negative value, 0 if succeeds.  *//* 1 iff a space separates currency_symbol from a positive value.  *//* 1 if currency_symbol precedes a positive value, 0 if succeeds.  *//* Local fractional digits.  *//* Int'l fractional digits.  *//* Sign for negative values.  *//* Sign for positive values.  *//* Like `grouping' element (above).  *//* Thousands separator.  *//* Decimal point character.  *//* Local currency symbol.  *//* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  *//* Monetary information.  *//* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  *//* Numeric (non-monetary) information.  *//* Structure giving information about numeric and monetary notation.  *//* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  *//*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */__dataset__category_mask__locale__category/usr/include/c++/12/clocale<locale.h>_GLIBCXX_CLOCALE// Get rid of those macros defined in <locale.h> in lieu of real functions.// ISO C++ 14882: 18.2.2  Implementation properties: C library/** @file clocale
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c locale.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/c++/12/x86_64-redhat-linux/bits/c++locale.h<clocale>__uselocale__convert_from_vconst __c_localeconst __c_locale &__locale_struct *&__ret__builtin_vsnprintf__c_locale_GLIBCXX_NUM_CATEGORIES_GLIBCXX_C_LOCALE_GNU_GLIBCXX_CXX_LOCALE_H__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)// namespace __gnu_cxx_ieee128// and should be avoided.// fall back to the unsafe vsprintf which, in general, can be dangerous// return length of string.  If vsnprintf is available use it, otherwise// Convert numeric value of type double and long double to string and// Written by Benjamin Kosnik <bkoz@redhat.com>// ISO C++ 14882: 22.8  Standard locale categories./** @file bits/c++locale.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// Wrapper for underlying C-language localization -*- C++ -*-__cloc/usr/include/c++/12/iosfwd<bits/stringfwd.h>basic_stringstream<_CharT, _Traits, _Alloc>basic_ostringstream<_CharT, _Traits, _Alloc>basic_istringstream<_CharT, _Traits, _Alloc>basic_stringbuf<_CharT, _Traits, _Alloc>basic_fstream<_CharT, _Traits>basic_ofstream<_CharT, _Traits>basic_ifstream<_CharT, _Traits>basic_filebuf<_CharT, _Traits>basic_iostream<_CharT, _Traits>basic_ostream<_CharT, _Traits>basic_istream<_CharT, _Traits>basic_streambuf<_CharT, _Traits>basic_ios<_CharT, _Traits>ios_base_GLIBCXX_IOSFWD__cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI/* _GLIBCXX_IOSFWD */// C++20 && CXX11_ABI/// Class for @c wchar_t mixed input and output file streams./// Class for @c wchar_t output file streams./// Class for @c wchar_t input file streams./// Class for @c wchar_t file buffers./// Class for @c wchar_t mixed input and output memory streams./// Class for @c wchar_t output memory streams./// Class for @c wchar_t input memory streams./// Class for @c wchar_t memory buffers./// Base class for @c wchar_t mixed input and output streams./// Base class for @c wchar_t output streams./// Base class for @c wchar_t input streams./// Base class for @c wchar_t buffers./// Base class for @c wchar_t streams./// Class for @c char mixed input and output file streams./// Class for @c char output file streams./// Class for @c char input file streams./// Class for @c char file buffers./// Class for @c char mixed input and output memory streams./// Class for @c char output memory streams./// Class for @c char input memory streams./// Class for @c char memory buffers./// Base class for @c char mixed input and output streams./// Base class for @c char output streams./// Base class for @c char input streams./// Base class for @c char buffers./// Base class for @c char streams./**
   *  @defgroup io I/O
   *
   *  Nearly all of the I/O classes are parameterized on the type of
   *  characters they read and write.  (The major exception is ios_base at
   *  the top of the hierarchy.)  This is a change from pre-Standard
   *  streams, which were not templates.
   *
   *  For ease of use and compatibility, all of the basic_* I/O-related
   *  classes are given typedef names for both of the builtin character
   *  widths (wide and narrow).  The typedefs are the same as the
   *  pre-Standard names, for example:
   *
   *  @code
   *     typedef basic_ifstream<char>  ifstream;
   *  @endcode
   *
   *  Because properly forward-declaring these classes can be difficult, you
   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;
   *  header, which contains only declarations of all the I/O classes as
   *  well as the typedefs.  Trying to forward-declare the typedefs
   *  themselves (e.g., <code>class ostream;</code>) is not valid ISO C++.
   *
   *  For more specific declarations, see
   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/io.html#std.io.objects
   *
   *  @{
  */// For string forward declarations.// ISO C++ 14882: 27.2  Forward declarations/** @file include/iosfwd
 *  This is a Standard C++ Library header.
 */// <iosfwd> Forward declarations -*- C++ -*-/usr/include/ctype.htoupper_l__toupper_ltolower_l__tolower_lisblank_lisxdigit_lisupper_lisspace_lispunct_lisprint_lisgraph_lislower_lisdigit_liscntrl_lisalpha_lisalnum_l_tolower_touppertoasciiisasciiisctypeconst __int32_tconst __int32_t *const __int32_t **signed int **__ctype_toupper_loc__ctype_tolower_locconst unsigned short **unsigned short **__ctype_b_locisblanktouppertolowerisxdigitisupperisspaceispunctisprintislowerisgraphisdigitiscntrlisalphaisalnum_ISupper_ISbit (0)_ISlower_ISbit (1)_ISalpha_ISbit (2)_ISdigit_ISbit (3)_ISxdigit_ISbit (4)_ISspace_ISbit (5)_ISprint_ISbit (6)_ISgraph_ISbit (7)_ISblank_ISbit (8)_IScntrl_ISbit (9)_ISpunct_ISbit (10)_ISalnum_ISbit (11)__exctype_l(name)extern int name (int, locale_t) __THROW__isctype_l(c,type,locale)((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)__tobody(c,f,a,args)(__extension__ ({ int __res; if (sizeof (c) > 1) { if (__builtin_constant_p (c)) { int __c = (c); __res = __c < -128 || __c > 255 ? __c : (a)[__c]; } else __res = f args; } else __res = (a)[(int) (c)]; __res; }))__exctype(name)extern int name (int) __THROW__toascii(c)((c) & 0x7f)__isascii(c)(((c) & ~0x7f) == 0)_ISbit(bit)((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))_CTYPE_H_ISbitdefined __USE_EXTERN_INLINES!defined __NO_CTYPE__isctype_fdefined __isctype__GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus/* ctype.h  *//* Use POSIX 2008.  *//* Not __NO_CTYPE.  *//* Optimizing gcc *//* Return the uppercase version of C.  *//* Return the lowercase version of C in locale L.  *//* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  *//* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  *//* This code is needed for the optimized mapping functions.  *//* Use X/Open or use misc.  *//* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  *//* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  *//* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  *//* Test C for a set of character classes according to MASK.  *//* ISO C99 introduced one new function.  *//* Return the lowercase version of C.  *//* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  *//* Mask off high bits.  *//* If C is a 7 bit value.  *//* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  *//* ! _ISbit  *//* Alphanumeric.  *//* Punctuation.  *//* Control character.  *//* Blank (usually SPC and TAB).  *//* Graphical.  *//* Printing.  *//* Whitespace.  *//* Hexadecimal numeric.  *//* Numeric.  *//* Alphabetic.  *//* lowercase.  *//* UPPERCASE.  *//* __BYTE_ORDER == __LITTLE_ENDIAN *//* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  *//*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 *//usr/include/c++/12/cctype<ctype.h>_GLIBCXX_CCTYPE// _GLIBCXX_USE_C99_CTYPE_TR1// Get rid of those macros defined in <ctype.h> in lieu of real functions.// ISO C++ 14882: <ccytpe>/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/c++/12/bits/localefwd.h<cctype><iosfwd><bits/c++locale.h>const localeconst locale &locale &_Facetconst _Facetconst _Facet &_Facet &use_facethas_facetmessages_byname<_CharT>messages<_CharT>moneypunct_byname<_CharT, _Intl>_Intlmoneypunct<_CharT, _Intl>money_put<_CharT, _OutIter>_OutItermoney_get<_CharT, _InIter>time_get_byname<_CharT, _InIter>time_get<_CharT, _InIter>collate_byname<_CharT>collate<_CharT>numpunct_byname<_CharT>numpunct<_CharT>messages_basemoney_basetime_put_byname<_CharT, _OutIter>time_put<_CharT, _OutIter>time_basenum_put<_CharT, _OutIter>num_get<_CharT, _InIter>codecvt_byname<_InternT, _ExternT, _StateT>_InternT_ExternTcodecvt<char32_t, char, __mbstate_t>codecvt<char16_t, char, __mbstate_t>codecvt<wchar_t, char, __mbstate_t>codecvt<char, char, __mbstate_t>codecvt<_InternT, _ExternT, _StateT>codecvt_basectype_byname<_CharT>ctype<wchar_t>ctype<char>ctype<_CharT>ctype_baselocale_LOCALE_FWD_H// 22.2.7 message retrieval// 22.2.6 money// 22.2.5 date and time// 22.2.4 collation// 22.2.2 and 22.2.3 numeric// NB: Specialized for char and wchar_t in locale_facets.h.// 22.2.1 and 22.2.1.3 ctype// 22.1.3 Convenience interfaces// 22.1.1 Locale/** 
   *  @defgroup locales Locales
   *
   *  Classes and functions for internationalization and localization.
   */// For ostreambuf_iterator, istreambuf_iterator// Defines __c_locale, config-specific include// ISO C++ 14882: 22.1  Locales/** @file bits/localefwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// <locale> Forward declarations -*- C++ -*-/usr/include/c++/12/bits/cxxabi_forced.h__forced_unwind &const __forced_unwindconst __forced_unwind &__forced_unwind__pure_dummy~__forced_unwind__cxxabiv1_CXXABI_FORCED_H// __CXXABI_FORCED_H // Prevent catch by value./** 
   *  @brief Thrown as part of forced unwinding.
   *  @ingroup exceptions
   *
   *  A magic placeholder class that can be caught by reference to
   *  recognize forced unwinding.
   *//** @file bits/cxxabi_forced.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cxxabi.h}
 */// cxxabi.h subset for cancellation -*- C++ -*-/usr/include/c++/12/bits/ostream_insert.h<bits/cxxabi_forced.h>basic_ostream<_CharT, _Traits> &__ostream_insert__ostream_fill__ostream_write_OSTREAM_INSERT_H__cxxabiv1::__forced_unwind&/* _OSTREAM_INSERT_H *//** @file bits/ostream_insert.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */// Helpers for ostream inserters -*- C++ -*-/usr/include/c++/12/bits/string_view.tccfind_last_not_offind_first_not_offind_last_ofrfind_GLIBCXX_STRING_VIEW_TCC__str// _GLIBCXX_STRING_VIEW_TCC// __cplusplus <= 201402L// anyway because __s is probably aligned, which helps memcmp.// We already know that __first[0] == __s[0] but compare them again// Compare the full strings from the first occurrence of __elem0.// Find the first occurrence of __elem0:// N3762 basic_string_view library/** @file include/bits/string_view.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string_view}
 */// Components for manipulating non-owning sequences of characters -*- C++ -*-/usr/include/c++/12/string_view<bits/string_view.tcc><bits/ostream_insert.h><bits/char_traits.h>operator ""svconst char32_tconst char32_t *const char16_tconst char16_t *operator<<__sv_limit__testoff__sv_check"%s: __pos (which is %zu) > __size " "(which is %zu)"%s: __pos (which is %zu) > __size (which is %zu)__N("%s: __pos (which is %zu) > __size "
				   "(which is %zu)")__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &&const __is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>>const __is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &hash<basic_string_view<char32_t, char_traits<char32_t>>> &hash<basic_string_view<char32_t, char_traits<char32_t>>> &&const hash<basic_string_view<char32_t, char_traits<char32_t>>>const hash<basic_string_view<char32_t, char_traits<char32_t>>> &const u32string_viewconst u32string_view &basic_string_view<char32_t, char_traits<char32_t>> &const hash<basic_string_view<char32_t, char_traits<char32_t>>> *hash<basic_string_view<char32_t, char_traits<char32_t>>> *sizeof(char32_t)__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &&const __is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>>const __is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &hash<basic_string_view<char16_t, char_traits<char16_t>>> &hash<basic_string_view<char16_t, char_traits<char16_t>>> &&const hash<basic_string_view<char16_t, char_traits<char16_t>>>const hash<basic_string_view<char16_t, char_traits<char16_t>>> &const u16string_viewconst u16string_view &basic_string_view<char16_t, char_traits<char16_t>> &const hash<basic_string_view<char16_t, char_traits<char16_t>>> *hash<basic_string_view<char16_t, char_traits<char16_t>>> *sizeof(char16_t)__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &&const __is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>>const __is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &&const hash<basic_string_view<wchar_t, char_traits<wchar_t>>>const hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &const wstring_viewconst wstring_view &basic_string_view<wchar_t, char_traits<wchar_t>> &const hash<basic_string_view<wchar_t, char_traits<wchar_t>>> *hash<basic_string_view<wchar_t, char_traits<wchar_t>>> *sizeof(wchar_t)__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &&const __is_fast_hash<hash<basic_string_view<char, char_traits<char>>>>const __is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &hash<basic_string_view<char, char_traits<char>>> &hash<basic_string_view<char, char_traits<char>>> &&const hash<basic_string_view<char, char_traits<char>>>const hash<basic_string_view<char, char_traits<char>>> &const string_viewconst string_view &basic_string_view<char, char_traits<char>> &const hash<basic_string_view<char, char_traits<char>>> *hash<basic_string_view<char, char_traits<char>>> *_S_comparesubstrbasic_string_view<_CharT, _Traits> &remove_suffixremove_prefixconst basic_string_view<_CharT, _Traits>const basic_string_view<_CharT, _Traits> *basic_string_view<_CharT, _Traits> *const basic_string_view<_CharT, _Traits> &basic_string_view__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>>hash<basic_string_view<char32_t, char_traits<char32_t>>>__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>>hash<basic_string_view<char16_t, char_traits<char16_t>>>__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>>hash<basic_string_view<wchar_t, char_traits<wchar_t>>>__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>>hash<basic_string_view<char, char_traits<char>>>basic_string_view<_CharT, _Traits>const value_type *traits_typenpos_M_strsize_type(-1)__cpp_lib_string_view_GLIBCXX_STRING_VIEWstring_view_literals__cplusplus >= 202002L && __cpp_lib_concepts__cplusplus > 201703L && __cpp_lib_concepts && __cpp_deduction_guidesGCC diagnostic ignored "-Wliteral-suffix"__n1__pos1__pos2__sv__osthis->_M_len >= __nthis->_M_len > 0"basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)"__pos < this->_M_len// _GLIBCXX_EXPERIMENTAL_STRING_VIEW// Opt-in to view concept// Opt-in to borrowed_range concept// namespace literals// namespace string_literals// [string.view.hash], hash support:// basic_string_view typedef names// [string.view.io], Inserters and extractors// type (see N3766).// deduction and the other argument gets implicitly converted to the deduced// context, so that only one argument participates in template argument// Several of these functions use type_identity_t to create a non-deduced// [string.view.comparison], non-member basic_string_view comparison function// [string.view.find], searching// 2777. basic_string_view::copy should use char_traits::copy// [string.view.ops], string operations:// [string.view.modifiers], modifiers:// [string.view.access], element access// [string.view.capacity], capacity// [string.view.iterators], iterator support// [string.view.cons], construction and assignment/**
   *  @class basic_string_view <string_view>
   *  @brief  A non-owning reference to a string.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  A basic_string_view looks like this:
   *
   *  @code
   *    _CharT*    _M_str
   *    size_t     _M_len
   *  @endcode
   */// NB: __sv_limit doesn't check for a bad __pos value.// Helper for basic_string members.// Helper for basic_string and basic_string_view members./** @file include/string_view
 *  This is a Standard C++ Library header.
 *//usr/include/c++/12/cstdio_GLIBCXX_CSTDIO__cplusplus <= 201103L && !defined(_GLIBCXX_HAVE_GETS)__cplusplus <= 201103L// _GLIBCXX_USE_C99_STDIO// LWG 2249// Get rid of those macros defined in <stdio.h> in lieu of real functions.// ISO C++ 14882: 27.8.2  C Library files/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 *//usr/include/c++/12/cerrno_GLIBCXX_CERRNO// Adhere to section 17.4.1.2 clause 5 of ISO 14882:1998// ISO C++ 14882: 19.3  Error numbers/** @file cerrno
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c errno.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */// The -*- C++ -*- forwarding header./usr/include/c++/12/ext/string_conversions.h<cerrno><cstdio>_S_chk_Range_chk_TRet~_Save_errno_Save_errno_Save_errno *_String__to_xstringconst _Save_errno__save_errnoconst _TRet_CharT **__stoa_M_errno_STRING_CONVERSIONS_H// _STRING_CONVERSIONS_H// the __cxx11 string, likely with the help of internal hooks.// XXX Eventually the result should be constructed in-place in// Helper for the to_string / to_wstring functions.// only called when _Ret is int// Helper for all the sto* functions./** @file ext/string_conversions.h
 *  This file is a GNU extension to the Standard C++ Library.
 */// String Conversions -*- C++ -*-__convf/usr/include/c++/12/bits/charconv.hchar[201]00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899"0001020304050607080910111213141516171819"
	"2021222324252627282930313233343536373839"
	"4041424344454647484950515253545556575859"
	"6061626364656667686970717273747576777879"
	"8081828384858687888990919293949596979899"const char[201]const auto__to_chars_10_implimplementation bug__to_chars_len_GLIBCXX_CHARCONV_H// _GLIBCXX_CHARCONV_H// (which can be determined by the __to_chars_len function).// The caller is required to provide a buffer of exactly the right size// Write an unsigned integer value to the range [first,first+len).// Generic implementation for arbitrary bases./** @file bits/charconv.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{charconv}
 */// Copyright (C) 2017-2022 Free Software Foundation, Inc.// Numeric conversions (to_string, to_chars) -*- C++ -*-/usr/include/c++/12/bits/basic_string.h<bits/charconv.h><ext/string_conversions.h><string_view>operator ""scxx11abi_tagto_wstring__gnu_cxx::__numeric_traits<long double>::__max_exponent104952__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20%LfL"%Lf"const wchar_t[4]wchar_t[4]__gnu_cxx::__numeric_traits<double>::__max_exponent10328__gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20%fL"%f"const wchar_t[3]wchar_t[3]__gnu_cxx::__numeric_traits<float>::__max_exponent10__gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20sizeof(unsigned long long)4 * sizeof(unsigned long long)%lluL"%llu"const wchar_t[5]wchar_t[5]sizeof(long long)4 * sizeof(long long)%lldL"%lld"sizeof(unsigned long)4 * sizeof(unsigned long)%luL"%lu"4 * sizeof(long)%ldL"%ld"4 * sizeof(unsigned)%uL"%u"sizeof(int)4 * sizeof(int)%dL"%d"stoldconst wstringconst wstring &basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &"stold"stod"stod"stof"stof"stoull"stoull"stoll"stoll"stoul"stoul"stol"stol"stoi"stoi"to_string"%Lf""%f"const basic_string<char, char_traits<char>, allocator<char>>string &basic_string<char, char_traits<char>, allocator<char>> &__neg__uval1ull1ulconst stringconst string &basic_stringconst _Allocatorconst _Allocator &basic_istream<wchar_t, char_traits<wchar_t>> &basic_istream<char, char_traits<char>> &basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits> &&basic_string<_CharT, _Traits, _Alloc> &const basic_string<_CharT, _Traits, _Alloc>const basic_string<_CharT, _Traits, _Alloc> &operator>>const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> &basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> &basic_string<_CharT, _Traits, _Alloc> &&__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &&const __is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>const __is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &&const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &const u32stringconst u32string &basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> *hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> *__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &&const __is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>const __is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &&const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &const u16stringconst u16string &basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> *hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> *__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &&const __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>const __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &&const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> *hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> *__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &&const __is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>>const __is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &hash<basic_string<char, char_traits<char>, allocator<char>>> &hash<basic_string<char, char_traits<char>, allocator<char>>> &&const hash<basic_string<char, char_traits<char>, allocator<char>>>const hash<basic_string<char, char_traits<char>, allocator<char>>> &const hash<basic_string<char, char_traits<char>, allocator<char>>> *hash<basic_string<char, char_traits<char>, allocator<char>>> *const basic_string<_CharT, _Traits, _Alloc> *basic_string<_CharT, _Traits, _Alloc> *c_str_M_replace_dispatch__i2__k1__k2basic_string::append"basic_string::append"__pos <= size()__builtin_unreachable__cplusplus >= 201103L || __pos < size()operator std::basic_string_view<_CharT, _Traits>__capacity_CharT[]~basic_string"basic_string: " "construction from null is not valid"basic_string: construction from null is not valid__N("basic_string: "
				       "construction from null is not valid")__endis_nothrow_default_constructible<_Alloc>::value_S_copy_chars_S_assign_S_move_S_copy_M_disjunct_M_limit_M_check_length_M_check_M_use_local_data_M_get_allocator_M_destroy_M_dispose_M_is_local_M_set_length_M_capacity_M_local_data_M_length_S_to_string_view_Alloc_hider_Alloc &&_Alloc_hider *__sv_wrapper_Never_valueless_alt<basic_string<_Tp, _Traits, _Alloc>>__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>>hash<basic_string<char, char_traits<char>, allocator<char>>>basic_stringbuf<<unnamed>, <unnamed>, <unnamed>>_S_local_capacity_If_sv_Char_alloc_type_M_construct_FwdIterator_InIterator_M_dataplus_M_string_length_M_allocated_capacity_M_local_buf_M_sv_GLIBCXX_STRING_CONSTEXPR__cpp_lib_string_udls__cpp_lib_constexpr_string_BASIC_STRING_Hstring_literals! _GLIBCXX_USE_CXX11_ABI__cpp_lib_constexpr_string < 201907L__cplusplus < 201103L || defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS_GLIBCXX_DISAMBIGUATE_REPLACE_INST__cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS_GLIBCXX_DEFINING_STRING_INSTANTIATIONS_GLIBCXX_USE_CXX11_ABI && (__CHAR_BIT__ * __SIZEOF_INT__) <= 32_GLIBCXX_USE_CXX11_ABI && (__CHAR_BIT__ * __SIZEOF_LONG__) <= 32defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR_GLIBCXX_COMPATIBILITY_CXX0X__cpp_lib_constexpr_string >= 201907L_M_append_M_replace_M_replace_aux_M_mutate_M_assign_M_createsize_type &"%s: __pos (which is %zu) > " "this->size() (which is %zu)"begin() <= __i1 && __i1 <= __i2 && __i2 <= end()__SIZEOF_LONG____SIZEOF_INT__noexcept(__lhs.swap(__rhs))!empty()__first >= begin() && __first <= __last && __last <= end()__position >= begin() && __position < end()__p >= begin() && __p <= end()"basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"/* _BASIC_STRING_H */// basic_string into a variant, but only if moving the string cannot throw.// inline namespace literals// inline namespace string_literals/// std::hash specialization for u32string./// std::hash specialization for u16string./// std::hash specialization for u8string./* _GLIBCXX_COMPATIBILITY_CXX0X *//// std::hash specialization for wstring./// std::hash specialization for string./* C++11 */// _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR// _GLIBCXX_HAVE_BROKEN_VSWPRINTF// DR 1261.// NB: wcstof vs wcstod.// NB: (v)snprintf vs sprintf.// any 32-bit value fits in the SSO buffer// DR 1261. Insufficent overloads for to_string / to_wstring// NB: strtof vs strtod.// 21.4 Numeric Conversions [string.conversions]./// Read a line from an rvalue stream into a string./**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a __str until &apos;\n&apos; is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  end of line is encountered, it is extracted but not stored into
   *  @a __str.
   *//**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @param __delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until @a __delim is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  @a __delim is encountered, it is extracted but not stored into
   *  @a __str.
   */// 586. string inserter not a formatted function/**
   *  @brief  Write string to a stream.
   *  @param __os  Output stream.
   *  @param __str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a __str into os following the same rules as for
   *  writing a C string.
   *//**
   *  @brief  Read stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until whitespace is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  If is.width() is non-zero, that is the limit on the
   *  number of characters stored into @a __str.  Any previous
   *  contents of @a __str are erased.
   *//**
   *  @brief  Swap contents of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *
   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
   *//**
   *  @brief  Test if C string doesn't precede string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't precede C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't precede string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   */// operator >=/**
   *  @brief  Test if C string doesn't follow string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't follow C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't follow string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   */// operator <=/**
   *  @brief  Test if C string follows string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string follows C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string follows string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   */// operator >/**
   *  @brief  Test if C string precedes string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string precedes C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string precedes string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   */// operator </**
   *  @brief  Test difference of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   *//**
   *  @brief  Test difference of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
   *//**
   *  @brief  Test difference of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   */// operator !=/**
   *  @brief  Test equivalence of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
   *//**
   *  @brief  Three-way comparison of a string and a C string.
   *  @param __lhs  A string.
   *  @param __rhs  A null-terminated string.
   *  @return  A value indicating whether `__lhs` is less than, equal to,
   *	       greater than, or incomparable with `__rhs`.
   *//**
   *  @brief  Test equivalence of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   *//**
   *  @brief  Test equivalence of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   */// operator ==/**
   *  @brief  Concatenate string and character.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate string and C string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate character and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate C string and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   */// operator+// 3075. basic_string needs deduction guides from basic_string_view// _GLIBCXX_USE_CXX11_ABI// Allow basic_stringbuf::__xfer_bufptrs to call _M_length:/**
       *  @brief  Compare substring against a character %array.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  character %array to compare against.
       *  @param __n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos.  Form a string from the
       *  first @a __n2 characters of @a __s.  Returns an integer < 0
       *  if this substring is ordered before the string from @a __s,
       *  0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a __s.  Determines the
       *  effective length rlen of the strings to compare as the
       *  smallest of the length of the substring and @a __n2.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
       *  no special meaning.
      *//**
       *  @brief  Compare substring to a C string.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a pos.  Returns an integer < 0 if
       *  the substring is ordered before @a __s, 0 if their values
       *  are equivalent, or > 0 if the substring is ordered after @a
       *  __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of the length of the substring and
       *  the length of a string constructed from @a __s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),__s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
      */// 5 String::compare specification questionable/**
       *  @brief  Compare to a C string.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a __s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      *//**
       *  @brief  Compare substring to a substring.
       *  @param __pos1  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @param __pos2  Index of first character of substring of str.
       *  @param __n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos1.  Form the substring of @a
       *  __str from the @a __n2 characters starting at @a __pos2.
       *  Returns an integer < 0 if this substring is ordered before
       *  the substring of @a __str, 0 if their values are equivalent,
       *  or > 0 if this substring is ordered after the substring of
       *  @a __str.  Determines the effective length rlen of the
       *  strings to compare as the smallest of the lengths of the
       *  substrings.  The function then compares the two strings by
       *  calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      *//**
       *  @brief  Compare substring to a string.
       *  @param __pos  Index of first character of substring.
       *  @param __n  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n characters
       *  starting at @a __pos.  Returns an integer < 0 if the
       *  substring is ordered before @a __str, 0 if their values are
       *  equivalent, or > 0 if the substring is ordered after @a
       *  __str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the length of the substring
       *  and @a __str.size().  The function then compares the two
       *  strings by calling
       *  traits::compare(substring.data(),str.data(),rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise
       *  the shorter one is ordered first.
      *//**
       *  @brief  Compare to a string_view.
       *  @param __pos1  A position in the string to start comparing from.
       *  @param __n1  The number of characters to compare.
       *  @param __svt  An object convertible to string_view to compare
       *                against.
       *  @param __pos2  A position in the string_view to start comparing from.
       *  @param __n2  The number of characters to compare.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string_view.
       *  @param __pos  A position in the string to start comparing from.
       *  @param __n  The number of characters to compare.
       *  @param __svt  An object convertible to string_view to compare
       *                against.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string_view.
       *  @param __svt An object convertible to string_view to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      *//**
       *  @brief  Get a substring.
       *  @param __pos  Index of first character (default 0).
       *  @param __n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Construct and return a new string using the @a __n
       *  characters starting at @a __pos.  If the string is too
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      *//**
       *  @brief  Find last position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character other than
       *  @a __c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __s within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to consider.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character not
       *  contained in the first @a __n characters of @a __s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find last position of a character not in a string_view.
       *  @param __svt  An object convertible to string_view containing
       *                characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *//**
       *  @brief  Find last position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character
       *  other than @a __c within this string.  If found, returns the
       *  index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from __s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in the first @a __n characters of @a __s within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in a string_view.
       *  @param __svt  A object convertible to string_view containing
       *                characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *//**
       *  @brief  Find position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not contained
       *  in @a __str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
       *
       *  Note: equivalent to rfind(__c, __pos).
      *//**
       *  @brief  Find last position of a character of C string.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character of C substring.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find last position of a character of string.
       *  @param __svt  An object convertible to string_view containing
       *                characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
      *//**
       *  @brief  Find last position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the character
       *  @a __c within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
       *
       *  Note: equivalent to find(__c, __pos).
      *//**
       *  @brief  Find position of a character of C string.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character of C substring.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find position of a character of a string_view.
       *  @param __svt  An object convertible to string_view containing
       *                characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
      *//**
       *  @brief  Find position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a __pos, searches backward for the value of
       *  @a __s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a string_view.
       *  @param __svt  The object convertible to string_view to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
      *//**
       *  @brief  Find last position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for value of @a
       *  __str within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the value of @a
       *  __s within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      *//**
       *  @brief  Find position of a string_view.
       *  @param __svt  The object convertible to string_view to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
      *//**
       *  @brief  Find position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for value of @a __str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      *//**
       *  @brief  Find position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      *//**
       *  @brief  Return copy of allocator used to construct this string.
      *//**
       *  @brief  Return non-const pointer to contents.
       *
       *  This is a pointer to the character sequence held by the string.
       *  Modifying the characters in the sequence is allowed.
      *//**
       *  @brief  Return const pointer to contents.
       *
       *  This is a pointer to internal data.  It is undefined to modify
       *  the contents through the returned pointer. To get a pointer that
       *  allows modifying the contents use @c &str[0] instead,
       *  (or in C++17 the non-const @c str.data() overload).
      *//**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */// String operations:/**
       *  @brief  Swap contents with another string.
       *  @param __s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a __s in constant
       *  time.
      *//**
       *  @brief  Copy substring into C string.
       *  @param __s  C string to copy value into.
       *  @param __n  Number of characters to copy.
       *  @param __pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Copies up to @a __n characters starting at @a __pos into the
       *  C string @a __s.  If @a __pos is %greater than size(),
       *  out_of_range is thrown.
      *//**
       *  @brief  Replace range of characters with string_view.
       *  @param __i1    An iterator referencing the start position
          to replace at.
       *  @param __i2    An iterator referencing the end position
          for the replace.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with string_view.
       *  @param __pos1  The position to replace at.
       *  @param __n1    The number of characters to replace.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @param __pos2  The position in the string_view to insert from.
       *  @param __n2    The number of characters to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with string_view.
       *  @param __pos  The position to replace at.
       *  @param __n    The number of characters to replace.
       *  @param __svt  The object convertible to string_view to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with initializer_list.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __l  The initializer_list of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */// useful to avoid the overhead of temporary buffering in _M_replace.// Specializations for the common case of pointer and iterator:/**
       *  @brief  Replace range of characters with range.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __k1  Iterator referencing start of range to insert.
       *  @param __k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Replace range of characters with multiple characters
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __n  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  @a __n copies of @a __c are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace range of characters with C string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the characters of @a __s are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace range of characters with C substring.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @param __n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the first @a __n characters of @a __s are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Replace range of characters with string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the value of @a __str is inserted.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace characters with multiple characters.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __n2  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this
       *  string.  In place, @a __n2 copies of @a __c are inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Replace characters with value of a C string.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the characters of @a __s are
       *  inserted.  If @a __pos is beyond end of string, out_of_range
       *  is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Replace characters with value of a C substring.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @param __n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the first @a __n2 characters of
       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
       *  @a __pos is beyond end of string, out_of_range is thrown.  If
       *  the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Replace characters with value from another string.
       *  @param __pos1  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @param __pos2  Index of first character of str to use.
       *  @param __n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
       *  __str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos1,__pos1 + n) from this
       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace characters with value from another string.
       *  @param __pos  Index of first character to replace.
       *  @param __n  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos+__n) from
       *  this string.  In place, the value of @a __str is inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of the result exceeds max_size(), length_error
       *  is thrown.  The value of the string doesn't change if an
       *  error is thrown.
      *//**
       *  @brief  Remove the last character.
       *
       *  The string must be non-empty.
       *//**
       *  @brief  Remove a range of characters.
       *  @param __first  Iterator referencing the first character to remove.
       *  @param __last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Remove one character.
       *  @param __position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a __position from this string. The value
       *  of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Remove characters.
       *  @param __pos  Index of first character to remove (default 0).
       *  @param __n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a __n characters from this string starting at @a
       *  __pos.  The length of the string is reduced by @a __n.  If
       *  there are < @a __n characters to remove, the remainder of
       *  the string is truncated.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert a string_view.
       *  @param __pos1  Position in string to insert at.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @param __pos2  Start of characters in str to insert.
       *  @param __n    The number of characters to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Insert a string_view.
       *  @param __pos  Position in string to insert at.
       *  @param __svt  The object convertible to string_view to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Insert one character.
       *  @param __p  Iterator referencing position in string to insert at.
       *  @param __c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a __c at position referenced by @a __p.
       *  If adding character causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __pos  Index in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts @a __n copies of character @a __c starting at index
       *  @a __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos > length(),
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert a C string.
       *  @param __pos  Position in string to insert at.
       *  @param __s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Insert a C substring.
       *  @param __pos  Position in string to insert at.
       *  @param __s  The C string to insert.
       *  @param __n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a __n characters of @a __s starting at @a
       *  __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos is beyond
       *  end(), out_of_range is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      *//**
       *  @brief  Insert a substring.
       *  @param __pos1  Position in string to insert at.
       *  @param __str   The string to insert.
       *  @param __pos2  Start of characters in str to insert.
       *  @param __n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a __pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a __n character of @a __str
       *  beginning with @a __pos2.  If adding characters causes the
       *  length to exceed max_size(), length_error is thrown.  If @a
       *  __pos1 is beyond the end of this string or @a __pos2 is
       *  beyond the end of @a __str, out_of_range is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Insert value of a string.
       *  @param __pos1 Position in string to insert at.
       *  @param __str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a __str starting at @a __pos1.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */// See PR libstdc++/83328/**
       *  @brief  Insert an initializer_list of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __l  The initializer_list of characters to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *//**
       *  @brief  Insert a range of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [__beg,__end).  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert a range of characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [beg,end).  If adding characters
       *  causes the length to exceed max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Set value from a range of characters in a string_view.
       *  @param __svt  The source object convertible to string_view.
       *  @param __pos  The position in the string_view to assign from.
       *  @param __n  The number of characters to assign.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value from a string_view.
       *  @param __svt  The source object convertible to string_view.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value to an initializer_list of characters.
       *  @param __l  The initializer_list of characters to assign.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value to a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [__first,__last).
      *//**
       *  @brief  Set value to multiple characters.
       *  @param __n  Length of the resulting string.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a __n copies of
       *  character @a __c.
       *//**
       *  @brief  Set value to contents of a C string.
       *  @param __s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a __s.
       *  The data is copied, so there is no dependence on @a __s once the
       *  function returns.
       *//**
       *  @brief  Set value to a C substring.
       *  @param __s  The C string to use.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a __n
       *  characters of @a __s.  If @a __n is is larger than the number of
       *  available characters in @a __s, the remainder of @a __s is used.
       *//**
       *  @brief  Set value to a substring of a string.
       *  @param __str  The string to use.
       *  @param __pos  Index of the first character of str.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a __str
       *  consisting of @a __n characters at @a __pos.  If @a __n is
       *  is larger than the number of available characters in @a
       *  __str, the remainder of @a __str is used.
       */// 2063. Contradictory requirements for string move assignment/**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *
       *  This function sets this string to the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       */// If this allocation throws there are no effects:// deallocate it before replacing current allocator.// Propagating allocator cannot free existing storage so must/**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a single character.
       *  @param __c  Character to append.
       *//**
       *  @brief  Append a range of characters from a string_view.
       *  @param __svt  An object convertible to string_view to be appended from.
       *  @param __pos The position in the string_view to append from.
       *  @param __n   The number of characters to append from the string_view.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a string_view.
       *  @param __svt  An object convertible to string_view to be appended.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [__first,__last) to this string.
       *//**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append multiple characters.
       *  @param __n  The number of characters to append.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends __n copies of __c to this string.
       *//**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a C substring.
       *  @param __s  The C string to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a substring.
       *  @param __str  The string to append.
       *  @param __pos  Index of the first character of str to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a __pos is not a valid index.
       *
       *  This function appends @a __n characters from @a __str
       *  starting at @a __pos to this string.  If @a __n is is larger
       *  than the number of available characters in @a __str, the
       *  remainder of @a __str is appended.
       *//**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to be appended.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a character.
       *  @param __c  The character to append.
       *  @return  Reference to this string.
       */// Modifiers:/**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %string.
       *//**
       *  Returns a read/write reference to the data at the last
       *  element of the %string.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %string.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %string.
       *//**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       *//**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */// In pedantic mode be strict in C++98 mode.// and in C++11 mode.// Allow pos == size() both in C++98 mode, as v3 extension,/**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       *//**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */// Element access:/**
       *  Returns true if the %string is empty.  Equivalent to 
       *  <code>*this == ""</code>.
       *//**
       *  Erases the string, making it empty.
       *//**
       *  Equivalent to shrink_to_fit().
       *//**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  __res_arg  Number of characters required.
       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       *//**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       *////  A non-binding request to reduce capacity() to size()./**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       *//**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *  @param  __c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a __c.
       *////  Returns the size() of the largest possible %string.///  null-termination.///  Returns the number of characters in the string, not including any// Capacity:/**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.
       *//**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.
       */// Iterators:/**
       *  @brief  Convert to a string_view.
       *  @return A string_view.
       *//**
       *  @brief  Set value to string constructed from a string_view.
       *  @param  __svt  An object convertible to string_view.
       *//**
       *  @brief  Set value to string constructed from initializer %list.
       *  @param  __l  std::initializer_list.
       */// Need to do a deep copy// __str can't use it, so free it.// __str can reuse our existing storage.// Just move the allocated pointer, our allocator can free it.// char_traits::copy precondition that the ranges don't overlap).// (unless this is a self-move, because that would violate the// We've always got room for a short string, just copy it// Replace allocator if POCMA is true.// Destroy existing storage before replacing allocator./**
       *  @brief  Move assign the value of @a str to this string.
       *  @param  __str  Source string.
       *
       *  The contents of @a str are moved into this string (without copying).
       *  @a str is a valid, but unspecified string.
       *//**
       *  @brief  Set value to string of length 1.
       *  @param  __c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       *//**
       *  @brief  Copy contents of @a s into this string.
       *  @param  __s  Source null-terminated string.
       *//**
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       *//**
       *  @brief  Destroy the string instance.
       *//**
       *  @brief  Construct string from a string_view.
       *  @param  __t  Source object convertible to string view.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string from a substring of a string_view.
       *  @param  __t   Source object convertible to string view.
       *  @param  __pos The index of the first character to copy from __t.
       *  @param  __n   The number of characters to copy from __t.
       *  @param  __a   Allocator to use.
       *//**
       *  @brief  Construct string as copy of a range.
       *  @param  __beg  Start of range.
       *  @param  __end  End of range.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string from an initializer %list.
       *  @param  __l  std::initializer_list of characters.
       *  @param  __a  Allocator to use (default is default allocator).
       */// we mess up the contents if we put a '\0' in the string.// basic_stringbuf relies on writing into unallocated capacity so// Must use _M_length() here not _M_set_length() because/**
       *  @brief  Move construct string.
       *  @param  __str  Source string.
       *
       *  The newly-created string contains the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       */// 3076. basic_string CTAD ambiguity/**
       *  @brief  Construct string as multiple characters.
       *  @param  __n  Number of characters.
       *  @param  __c  Character to use.
       *  @param  __a  Allocator to use (default is default allocator).
       */// NB: Not required, but considered best practice./**
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string initialized by a character %array.
       *  @param  __s  Source character %array.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use (default is default allocator).
       *
       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
       *  has no special meaning.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __a  Allocator to use.
       */// 2583. no way to supply an allocator for basic_string(str, pos)/**
       *  @brief  Construct string with copy of value of @a __str.
       *  @param  __str  Source string.
       *//**
       *  @brief  Construct an empty string using allocator @a a.
       *//**
       *  @brief  Default constructor creates an empty string.
       */// arguments, per 17.4.4.4 para. 2 item 2.// NB: We overload ctors in some cases instead of using default// Construct/copy/destroy:// These types are off.// to optimize for the common case of pointers as iterators.// _S_copy_chars is a separate template to permit specialization// traits_type::copy/move/assign.// When __n = 1 way faster than the general multichar// True if _Rep and source do not overlap.// NB: _M_limit doesn't check for a bad __pos value.// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063// The explicit instantiations in misc-inst.cc require this due to// Ensure that _M_local_buf is the active member of the union.// string::iterator, _CharT*, etc.// For forward_iterators up to random_access_iterators, used for// For Input Iterators, used in istreambuf_iterators, etc.// requires special behaviour if _InIterator is an integral type// _M_construct_aux is used to implement the 21.3.1 para 15 which// Create & Destroy// The actual data.// TODO check __is_final// Use empty-base optimization: http://www.cantrip.org/emptyopt.html/**
       *  @brief  Only internally used: Construct string from a string view
       *          wrapper.
       *  @param  __svw  string view wrapper.
       *  @param  __a  Allocator to use.
       */// is provided.// participate in overload resolution when a string_view// allows to add an internal constructor that does not// Wraps a string_view by explicit conversion and thus// Allows an implicit conversion to __sv_type.// A helper type for avoiding boiler-plate.// type used for positions in insert, erase etc.///  Value returned by various member functions when they fail.// Types:// std::char_traits begins the lifetime of characters.// Begin the lifetime of characters in allocated storage./**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   */// Support P0426R1 changes to char_traits in C++17.// Support P0980R1 in C++20./** @file bits/basic_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */// Components for manipulating sequences of characters -*- C++ -*-__svw__svt__dat__is__beg__res_arg/usr/include/c++/12/bits/basic_string.tcc~_Guard_Guard_Guard *__dnew__guard"basic_string::_M_create"basic_string::_M_create__N("basic_string::_M_create")_M_guarded_BASIC_STRING_TCC__cplusplus <= 201703L && _GLIBCXX_EXTERN_TEMPLATE > 0// _GLIBCXX_EXTERN_TEMPLATE// to ensure the definition in libstdc++.so is unique (PR 86138).// Still need to prevent implicit instantiation of the COW empty rep,// code will implicitly instantiate std::string and std::wstring as needed.// Suppress the explicit instantiation declarations for C++20, so C++20// and earlier standards (so not C++20's starts_with and ends_with).// src/c++17/string-inst.cc only instantiate the members required for C++17// The explicit instantiation definitions in src/c++11/string-inst.cc and// might cause endless loop// 91. Description of operator>> and getline() for string<>// 211.  operator>>(istream&, string&) doesn't set failbit// Avoid reallocation for common case.// 21.3.7.9 basic_string::getline and operators// exclude trailing null// 21.3.5.7 par 3: do not append null.  (good.)// (PR 98465).// Hint to middle end that __p and __s overlap// Work in-place.// 2788. unintentionally require a default constructible allocator/* swallow the exception */// P0966 reserve should not shrink// vector/unordered_map/unordered_set reserve functions// 2968. Inconsistencies between basic_string reserve and// Check for out_of_range and length_error exceptions.// Allocate more space.// pointers, calling for a different coding style.// Input Iterators have a cost structure very different from// istreambuf_iterators, etc.// NB: This is the special case for Input Iterators, used in// null char_type() element.// NB: Need an array of char_type[__capacity], plus a terminating// Never allocate a string bigger than max_size.// http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.// meet amortized linear time requirements of the library: see// The below implements an exponential growth policy, necessary to// 83.  String::npos vs. string::max_size()// updated by Jonathan Wakely for ISO-14882-2011.// Non-reference-counted implementation written by Paolo Carlini and// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.// Written by Jason Merrill based upon the specification by Takanori Adachi/** @file bits/basic_string.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */__old_capacity/usr/include/c++/12/string<bits/basic_string.tcc><bits/basic_string.h><bits/localefwd.h>hash<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &hash<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &&const hash<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>const hash<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &hash<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &hash<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &&const hash<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>const hash<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &hash<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &hash<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &&const hash<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>const hash<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &hash<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &hash<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &&const hash<basic_string<char, char_traits<char>, polymorphic_allocator<char>>>const hash<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &_Strconst _Strconst _Str &_Str &hash<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>hash<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>hash<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>hash<basic_string<char, char_traits<char>, polymorphic_allocator<char>>>__hash_string_base<_Str>_GLIBCXX_STRING__cplusplus >= 201703L && _GLIBCXX_USE_CXX11_ABI/* _GLIBCXX_STRING */// For less// For operators >>, <<, and getline.// NB: In turn includes stl_algobase.h/** @file include/string
 *  This is a Standard C++ Library header.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/include/lzham_static_lib.hlzham_static_lib *~lzham_static_liblzham_static_liblzham_static_lib &const lzham_static_libconst lzham_static_lib &LZHAM_STATIC_LIB// Like lzham_dynamic_lib, except it sets the function pointer members to point directly to the C functions in lzhamlibdirent64 &dirent64 &&const dirent64const dirent64 &dirent &dirent &&const dirent &dirent64getdents64versionsort64const dirent64 *dirent64 *const dirent64 **dirent64 **versionsortgetdirentries64__off64_t *__restrict__alphasort64scandirat64dirent64 ***dirent64 ***__restrict__scandiratscandir64readdir64_rdirent64 *__restrict__dirent64 **__restrict__readdir64(const struct dirent **__e1, const struct dirent **__e2)(int __fd, char *__restrict __buf, size_t __nbytes, __off64_t *__restrict __basep)(int __dfd, const char *__restrict __dir, struct dirent ***__restrict __namelist, int (*__selector) (const struct dirent *), int (*__cmp) (const struct dirent **, const struct dirent **))(const char *__restrict __dir, struct dirent ***__restrict __namelist, int (*__selector) (const struct dirent *), int (*__cmp) (const struct dirent **, const struct dirent **))(DIR *__restrict __dirp, struct dirent *__restrict __entry, struct dirent **__restrict __result)(DIR *__dirp)"readdir64_r""readdir64""versionsort64""getdirentries64""alphasort64""scandirat64""scandir64"__dfd/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamtest/timer.h/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamtest/lzhamtest.cpp"lzham_static_lib.h""timer.h"<string><vector>op_mode_tOP_MODE_INVALIDOP_MODE_COMPRESSOP_MODE_DECOMPRESSOP_MODE_ALLLZHAM Codec - x64 Command Line Test App - Compiled %s %s
"LZHAM Codec - x64 Command Line Test App - Compiled %s %s\n"Apr 20 202316:20:49const char[9]Expecting LZHAM DLL Version 0x%04X
"Expecting LZHAM DLL Version 0x%04X\n"lzham_libUsing static libraries.
"Using static libraries.\n"num_helper_threadsLoaded LZHAM DLL version 0x%04X

"Loaded LZHAM DLL version 0x%04X\n\n"cmd_linebasic_string<char, char_traits<char>, allocator<char>> &&exit_statusconst vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &main_internalconst comp_optionsconst comp_options &comp_options &op_modeseed_filenamestrInvalid option: %s
"Invalid option: %s\n"Invalid dictionary size: %s
"Invalid dictionary size: %s\n"comp_level(int)LZHAM_COMP_LEVEL_UBERInvalid compression level: %s
"Invalid compression level: %s\n"Invalid number of helper threads: %s
"Invalid number of helper threads: %s\n"update_rateInvalid table update rate: %s
"Invalid table update rate: %s\n"'x'Using random seed: %i
"Using random seed: %i\n"Must specify seed filename with -a option!
"Must specify seed filename with -a option!\n"Seed filename: %s
"Seed filename: %s\n"const __normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &Unbuffered decompression is not compatible with seed files!
"Unbuffered decompression is not compatible with seed files!\n"Invalid mode: %s
"Invalid mode: %s\n"No mode specified!
"No mode specified!\n"Using options:
"Using options:\n" EXIT_FAILUREsrc_filecmp_filecomp_resultMust specify input and output filenames!
"Must specify input and output filenames!\n"Too many filenames!
"Too many filenames!\n"decomp_file__decomp_temp_%u__.tmp"__decomp_temp_%u__.tmp"Failed decompressing file "%s" to "%s"
"Failed decompressing file \"%s\" to \"%s\"\n"Comparing file "%s" to "%s"
"Comparing file \"%s\" to \"%s\"\n"Failed comparing decompressed file data while compressing "%s" to "%s"
"Failed comparing decompressed file data while compressing \"%s\" to \"%s\"\n"Decompressed file compared OK to original file.
"Decompressed file compared OK to original file.\n"No directory specified!
"No directory specified!\n"file_stats_vec *vector<file_stats, allocator<file_stats>> *test_recursivefilesstring_array &"*"Failed finding files under path "%s"!
"Failed finding files under path \"%s\"!\n"total_files_compressedtotal_source_sizetotal_comp_size/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamtestlzham_dllpPathpSeed_filenamepStatsmin_file_sizemax_file_sizestart_tick_countfirst_file_indexunique_id__comp_temp_%u__.tmp"__comp_temp_%u__.tmp"file_indexsrc_file_sizefile_optionscomp_timedecomp_timecmp_file_size***** [%u of %u] Compressing file "%s" to "%s"
"***** [%u of %u] Compressing file \"%s\" to \"%s\"\n"Skipping unreadable file "%s"
"Skipping unreadable file \"%s\"\n"Skipping too small or large file "%s"
"Skipping too small or large file \"%s\"\n"Unable to create file "%s"!
"Unable to create file \"%s\"!\n"(LZHAMTEST_MAX_POSSIBLE_DICT_SIZE - LZHAM_MIN_DICT_SIZE_LOG2 + 1)(LZHAM_MAX_HELPER_THREADS + 1)LZHAM_FASTEST_TABLE_UPDATE_RATE - 2LZHAM_FASTEST_TABLE_UPDATE_RATE - 2 + 1(LZHAM_FASTEST_TABLE_UPDATE_RATE - 2 + 1)Failed compressing file "%s" to "%s"
"Failed compressing file \"%s\" to \"%s\"\n"Decompressing file "%s" to "%s"
"Decompressing file \"%s\" to \"%s\"\n"const basic_string<char, char_traits<char>, allocator<char>> &file_stats &end_tick_counttotal_elapsed_timeTest successful: %f secs
"Test successful: %f secs\n"Total files processed: %u
"Total files processed: %u\n"Total source size: %llu
"Total source size: " QUAD_INT_FMT "\n"Total compressed size: %llu
"Total compressed size: " QUAD_INT_FMT "\n"~file_statsfile_stats *find_filespathsepis_directoryis_filecompare_filespFile1Failed opening file: %s
"Failed opening file: %s\n"pFile2fileSize1fileSize2Files to compare are not the same size: %I64i vs. %I64i.
"Files to compare are not the same size: %I64i vs. %I64i.\n"cBufSize1024 * 1024buf1buf2bytes_to_readFailed reading from file: %s
"Failed reading from file: %s\n"pathnamerecursivepFilename1pFilename2File data comparison failed!
"File data comparison failed!\n"decompress_filepInFileUnable to read file: %s
"Unable to read file: %s\n"5+9(5+9)Compressed file is too small!
"Compressed file is too small!\n"h0h1'L''H'Unrecognized/invalid header in file: %s
"Unrecognized/invalid header in file: %s\n"pOutFileUnable to create file: %s
"Unable to create file: %s\n"orig_file_sizetotal_header_bytes256*1024256*1024*1024Output file is too large for unbuffered decompression - switching to streaming decompression.
"Output file is too large for unbuffered decompression - switching to streaming decompression.\n"Testing: Unbuffered decompression
"Testing: Unbuffered decompression\n"Testing: Streaming decompression
"Testing: Streaming decompression\n"cInBufSizeLZHAMTEST_DECOMP_INPUT_BUFFER_SIZEin_file_bufLZHAMTEST_DECOMP_OUTPUT_BUFFER_SIZEout_file_bufFailed allocating output buffer!
"Failed allocating output buffer!\n"src_bytes_leftdst_bytes_leftin_file_buf_sizein_file_buf_ofssizeof(params)start_timedecomp_only_timelzham_uint32 &const void *&void *&init_start_timepDecomp_statetotal_init_timeFailed initializing decompressor!
"Failed initializing decompressor!\n"lzham_decompress_init took %3.3fms
"lzham_decompress_init took %3.3fms\n"in_file_buf_ofs <= in_file_buf_sizepIn_bytesnum_in_bytespOut_bytesout_num_bytesFailure reading from source file!
"Failure reading from source file!\n"decomp_only_timersecsconst timer817bool decompress_file(ilzham &, const char *, const char *, comp_options, const char *, float *)Failure writing to destination file!
"Failure writing to destination file!\n"Decompressor wrote too many bytes to destination file!
"Decompressor wrote too many bytes to destination file!\n"deinit_timerend_timeend_time - start_timetotal_timeDecompression FAILED with status %i
"Decompression FAILED with status %i\n"Decompressor FAILED to output the entire output file!
"Decompressor FAILED to output the entire output file!\n"Decompressor FAILED to read %llu bytes from input buffer (ignore if testing reinit() because we don't truncate the output file between passes)
"Decompressor FAILED to read " QUAD_INT_FMT " bytes from input buffer (ignore if testing reinit() because we don't truncate the output file between passes)\n"const char[144]char[144]Success
"Success\n"Source file size: %llu, Decompressed file size: %llu
"Source file size: " QUAD_INT_FMT ", Decompressed file size: " QUAD_INT_FMT "\n"pSrc_filenamepDst_filenamepTotal_decomp_timeDecompressed adler32: 0x%08X
"Decompressed adler32: 0x%08X\n"Overall decompression time (decompression init+I/O+decompression): %3.6f
  Consumption rate: %9.1f bytes/sec, Decompression rate: %9.1f bytes/sec
"Overall decompression time (decompression init+I/O+decompression): %3.6f\n  Consumption rate: %9.1f bytes/sec, Decompression rate: %9.1f bytes/sec\n"const char[147]char[147]Decompression only time (not counting decompression init or I/O): %3.6f
  Consumption rate: %9.1f bytes/sec, Decompression rate: %9.1f bytes/sec
"Decompression only time (not counting decompression init or I/O): %3.6f\n  Consumption rate: %9.1f bytes/sec, Decompression rate: %9.1f bytes/sec\n"const char[146]char[146]compress_fileTesting: Streaming compression
"Testing: Streaming compression\n"cmp_file_header_sizeLZHAMTEST_COMP_INPUT_BUFFER_SIZEcOutBufSizeLZHAMTEST_COMP_OUTPUT_BUFFER_SIZEOut of memory!
"Out of memory!\n"total_output_bytespComp_statetotal_comp_timeFailed initializing compressor!
"Failed initializing compressor!\n"lzham_compress_init took %3.3fms
"lzham_compress_init took %3.3fms\n"comp_start_timetotal_bytes_processedcomp_rate"\b\b\b\b"Progress: %3.1f%%, Bytes Remaining: %3.1fMB, %3.3fMB/sec"Progress: %3.1f%%, Bytes Remaining: %3.1fMB, %3.3fMB/sec"100.0f1048576.0f1024.0f1024.0f * 1024.0f(1024.0f * 1024.0f)                "                \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"526const char[102]char[102]bool compress_file(ilzham &, const char *, const char *, const comp_options &, const char *, float *)    "\b\b\b\b    \b\b\b\b"Input file size: %llu, Compressed file size: %llu, Ratio: %3.2f%%
"Input file size: " QUAD_INT_FMT ", Compressed file size: " QUAD_INT_FMT ", Ratio: %3.2f%%\n"const char[67]char[67]Failed reinitializing compressor!
"Failed reinitializing compressor!\n"lzham_compress_reinit took %3.3fms
"lzham_compress_reinit took %3.3fms\n"pTotal_comp_timedeinit_start_timetotal_deinit_timeCompression failed with status %i
"Compression failed with status %i\n"Compressor failed to consume entire input file!
"Compressor failed to consume entire input file!\n"Compression-only time: %3.6f
Consumption rate: %9.1f bytes/sec, Emission rate: %9.1f bytes/sec
"Compression-only time: %3.6f\nConsumption rate: %9.1f bytes/sec, Emission rate: %9.1f bytes/sec\n"Total time: %3.6f
Consumption rate: %9.1f bytes/sec, Emission rate: %9.1f bytes/sec
"Total time: %3.6f\nConsumption rate: %9.1f bytes/sec, Emission rate: %9.1f bytes/sec\n"Input file adler32: 0x%08X
"Input file adler32: 0x%08X\n"read_seed_fileseed_file_size1ULL << dict_size_log2seed_sizepSeed_fileUnable to open file: %s
"Unable to open file: %s\n"Failed reading file!
"Failed reading file!\n"Read File "%s", Size: %u bytes
"Read File \"%s\", Size: %u bytes\n"simple_testLZHAM simple memory to memory compression test
"LZHAM simple memory to memory compression test\n"sizeof(comp_params)lzham_uint8[1024]cmp_bufcmp_lensizeof(cmp_buf)This is a test.This is a test.This is a test.1234567This is a test.This is a test.123456"This is a test.This is a test.This is a test.1234567This is a test.This is a test.123456"uncomp_lencomp_adler32comp_statusCompression test failed with status %i!
"Compression test failed with status %i!\n"Uncompressed size: %u
Compressed size: %u
"Uncompressed size: %u\nCompressed size: %u\n"decomp_paramssizeof(decomp_params)decomp_bufdecomp_sizesizeof(decomp_buf)decomp_adler32decomp_statusCompression test failed!
"Compression test failed!\n"Compression test succeeded.
"Compression test succeeded.\n"ensure_file_is_writablecNumRetries 8250000open_file_with_retriesprint_errorchar[1024]pMsgsizeof(buf) - 1Error: %s"Error: %s"print_usageUsage: [options] [mode] inpath/infile [outfile]
"Usage: [options] [mode] inpath/infile [outfile]\n"Modes:
"Modes:\n"c - Compress "infile" to "outfile"
"c - Compress \"infile\" to \"outfile\"\n"d - Decompress "infile" to "outfile"
"d - Decompress \"infile\" to \"outfile\"\n"a - Recursively compress all files under "inpath"
"a - Recursively compress all files under \"inpath\"\n"Options:
"Options:\n"-m[0-4] - Compression level: 0=fastest, 1=faster, 2=default, 3=better, 4=uber
"-m[0-4] - Compression level: 0=fastest, 1=faster, 2=default, 3=better, 4=uber\n"const char[79]char[79]          Default is uber (4).
"          Default is uber (4).\n"-d[15-29] - Set log2 dictionary size, max. is 26 on x86 platforms, 29 on x64.
"-d[15-29] - Set log2 dictionary size, max. is 26 on x86 platforms, 29 on x64.\n"          Default is 26 (64MB) on x86, 28 (256MB) on x64.
"          Default is 26 (64MB) on x86, 28 (256MB) on x64.\n"-c - Do not compute or verify adler32 checksum during decompression (faster).
"-c - Do not compute or verify adler32 checksum during decompression (faster).\n"-u - Use unbuffered decompression on files that can fit into memory.
"-u - Use unbuffered decompression on files that can fit into memory.\n"     Unbuffered decompression is faster, but may have more I/O overhead.
"     Unbuffered decompression is faster, but may have more I/O overhead.\n"const char[74]char[74]-t[0-64] - Number of extra compression helper threads. Default=# CPU's-1.
"-t[0-64] - Number of extra compression helper threads. Default=# CPU's-1.\n"const char[75]char[75]           Note: The total number of threads will be 1 + num_helper_threads,
"           Note: The total number of threads will be 1 + num_helper_threads,\n"           because the main thread is counted separately.
"           because the main thread is counted separately.\n"-v - Immediately decompress compressed file after compression for verification.
"-v - Immediately decompress compressed file after compression for verification.\n"const char[81]char[81]-x - Extreme parsing, for slight compression gain (Uber only, MUCH slower).
"-x - Extreme parsing, for slight compression gain (Uber only, MUCH slower).\n"-o - Permit the compressor to trade off decompression rate for higher ratios.
"-o - Permit the compressor to trade off decompression rate for higher ratios.\n"     Note: This flag can drop the decompression rate by 30%% or more.
"     Note: This flag can drop the decompression rate by 30%% or more.\n"const char[71]char[71]-e - Enable deterministic parsing for slightly higher compression and
"-e - Enable deterministic parsing for slightly higher compression and\n"     predictable output files when enabled, but less scalability.
"     predictable output files when enabled, but less scalability.\n"     The default is disabled, so the generated output data may slightly vary
"     The default is disabled, so the generated output data may slightly vary\n"     between runs when multithreaded compression is enabled.
"     between runs when multithreaded compression is enabled.\n"-afilename Enable delta compression using the specified seed file.
"-afilename Enable delta compression using the specified seed file.\n"           The same seed file MUST be used for compression/decompression.
"           The same seed file MUST be used for compression/decompression.\n"-r - Use randomized parameters for each file.
"-r - Use randomized parameters for each file.\n"-h[0-%u] - Set Huffman table update frequency. 0=Internal def, Def=%u, higher=faster.
"-h[0-%u] - Set Huffman table update frequency. 0=Internal def, Def=%u, higher=faster.\n" Lower settings=slower decompression, but higher ratio. Note 1=impractically slow.
" Lower settings=slower decompression, but higher ratio. Note 1=impractically slow.\n"comp_options &&comp_optionscomp_options *Comp level: %u
"Comp level: %u\n"Dict size: %i (%u bytes)
"Dict size: %i (%u bytes)\n"Compute adler32 during decompression: %u
"Compute adler32 during decompression: %u\n"Max helper threads: %i
"Max helper threads: %i\n"Unbuffered decompression: %u
"Unbuffered decompression: %u\n"Verify compressed data: %u
"Verify compressed data: %u\n"Extreme parsing: %u
"Extreme parsing: %u\n"Randomize parameters: %u
"Randomize parameters: %u\n"Deterministic parsing: %u
"Deterministic parsing: %u\n"Trade off decompression rate for compression ratio: %u
"Trade off decompression rate for compression ratio: %u\n"Test compressor reinit: %u
"Test compressor reinit: %u\n"Table update speed: %u
"Table update speed: %u\n"m_dict_size_log2(LZHAMTEST_DEFAULT_DICT_SIZE)m_compute_adler32_during_decomp(true)m_max_helper_threads(0)m_unbuffered_decompression(false)m_verify_compressed_data(false)m_randomize_params(false)m_extreme_parsing(false)m_deterministic_parsing(false)m_tradeoff_decomp_rate_for_comp_ratio(false)m_test_compressor_reinit(false)file_stats &&const file_statsconst file_stats &file_statsnum_seed_bytespSeed_bytespFilenamepModem_test_compressor_reinitm_tradeoff_decomp_rate_for_comp_ratiom_deterministic_parsingm_extreme_parsingm_randomize_paramsm_verify_compressed_datam_unbuffered_decompressionm_compute_adler32_during_decompm_comp_levelm_lz4_decomp_timem_lz4_comp_timem_lz4_sizem_miniz_decomp_timem_miniz_comp_timem_miniz_sizem_lzham_decomp_timem_lzham_comp_timem_lzham_sizem_lzma_decomp_timem_lzma_comp_timem_lzma_sizem_filenameg_is_debugLZHAMTEST_NO_RANDOM_EXTREME_PARSING65536*4LZHAMTEST_DEFAULT_DICT_SIZELZHAMTEST_MAX_POSSIBLE_DICT_SIZEQUAD_INT_FMT"%llu"_ftelli64_fseeki64_aligned_free_aligned_malloc(size,alignment)memalign(alignment, size)Sleep(ms)usleep(ms*1000)LZHAM_PRINT_OUTPUT_PROGRESSmy_min(a,b)my_max(a,b)(((a) > (b)) ? (a) : (b))_XBOXLZHAM_USE_LZHAM_DLLdefined(WIN32) || defined(_XBOX)!LZHAMTEST_NO_RANDOM_EXTREME_PARSING__TIME__"16:20:49"__DATE__"Apr 20 2023"// -1 = auto-detection//int lzhamtest_main(int argc, char *argv[])//file_options.m_test_compressor_reinit = (rand() & 1) != 0;// Ensure file is actually readable// Avoid running out of memory on large files when using unbuffered decompression.// Performs 1 pass normally, or 2 passes to test compressor reinitialization (with a reinit in between the passes).// -1 = try to auto-detect// 64MB default dictionary size under x86// 256MB default dictionary size under x64 (max is 512MB, but this requires more than 4GB of physical memory without thrashing)// On non-Win32 platforms, this test app currently assumes static libs.// To test lzham as a static library under Win32, set LZHAM_USE_LZHAM_DLL to 0, add ../lzhamcomp and ../lzhamdecomp to the additional inc paths, and link with the lzhamcomp and lzhamdecomp libs.// Note: lzham can be used as static libs, or as a DLL. The default (out of the box) configuration under Win32 loads the DLL.// Tested on Windows, Linux, and OSX. On iOS, I use a small "Hello World" test app to test the codec.// See include/lzham.h for documentation on the public LZHAM API.// See the decompress_file() function to see how to use the decompression API, and the compress_file() function for the compression API.// I also test LZHAM in a private branch of 7zip, mostly to ensure the streaming API is solid. Please contact me if you would like this branch.// This is a small app primarily designed to test the codec. Sorry, it doesn't really make the best sample, it's just a test harness.// File: lzhamtest.cpp__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>basic_string<char, char_traits<char>, allocator<char>> *__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &&__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *const __normal_iterator<_Iter, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __normal_iterator<_Iter, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__normal_iterator<_Iter, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &vector<unsigned char, allocator<unsigned char>>vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>vector<file_stats, allocator<file_stats>>__hash_base<unsigned long, _Str>basic_string<char, char_traits<char>, polymorphic_allocator<char>>basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>__hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>>__hash_string_base__hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &__hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &&const __hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>>const __hash_string_base<basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &__hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>__hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &__hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &&const __hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>const __hash_string_base<basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &__hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>__hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &__hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &&const __hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>const __hash_string_base<basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &__hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>__hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &__hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &&const __hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>const __hash_string_base<basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &is_same<_Tp, basic_string_view<_CharT, _Traits>>rebind<_CharT>pointer_traits<pointer>pointer_traits<const_pointer>is_nothrow_default_constructible<_Alloc>initializer_list<_CharT>allocator<_CharT>basic_string<_CharT, char_traits<_CharT>, _Allocator>basic_string<_CharT, _Traits, _Allocator>basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>__hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>>__hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>> &__hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>> &&const __hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>>const __hash_base<unsigned long, basic_string<char, char_traits<char>, allocator<char>>> &__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &&const __hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const __hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &&const __hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const __hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &&const __hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const __hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &basic_string<_Tp, _Traits, _Alloc>is_same<_Ret, int>__numeric_traits<int>__numeric_traits<int> &__numeric_traits<int> &&const __numeric_traits<int>const __numeric_traits<int> &__hash_base<unsigned long, basic_string_view<char, char_traits<char>>>__hash_base<unsigned long, basic_string_view<char, char_traits<char>>> &__hash_base<unsigned long, basic_string_view<char, char_traits<char>>> &&const __hash_base<unsigned long, basic_string_view<char, char_traits<char>>>const __hash_base<unsigned long, basic_string_view<char, char_traits<char>>> &__hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>>__hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>> &__hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>> &&const __hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>>const __hash_base<unsigned long, basic_string_view<wchar_t, char_traits<wchar_t>>> &__hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>>__hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>> &__hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>> &&const __hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>>const __hash_base<unsigned long, basic_string_view<char16_t, char_traits<char16_t>>> &__hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>>__hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>> &__hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>> &&const __hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>>const __hash_base<unsigned long, basic_string_view<char32_t, char_traits<char32_t>>> &basic_string_view<char, char_traits<char>>basic_string_view<wchar_t, char_traits<wchar_t>>basic_string_view<char16_t, char_traits<char16_t>>basic_string_view<char32_t, char_traits<char32_t>>basic_ios<char, char_traits<char>>basic_streambuf<char, char_traits<char>>basic_istream<char, char_traits<char>>basic_ostream<char, char_traits<char>>basic_iostream<char, char_traits<char>>basic_stringbuf<char, char_traits<char>, allocator<char>>basic_istringstream<char, char_traits<char>, allocator<char>>basic_ostringstream<char, char_traits<char>, allocator<char>>basic_stringstream<char, char_traits<char>, allocator<char>>basic_filebuf<char, char_traits<char>>basic_ifstream<char, char_traits<char>>basic_ofstream<char, char_traits<char>>basic_fstream<char, char_traits<char>>basic_ios<wchar_t, char_traits<wchar_t>>basic_streambuf<wchar_t, char_traits<wchar_t>>basic_istream<wchar_t, char_traits<wchar_t>>basic_ostream<wchar_t, char_traits<wchar_t>>basic_iostream<wchar_t, char_traits<wchar_t>>basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_filebuf<wchar_t, char_traits<wchar_t>>basic_ifstream<wchar_t, char_traits<wchar_t>>basic_ofstream<wchar_t, char_traits<wchar_t>>basic_fstream<wchar_t, char_traits<wchar_t>>fpos<__mbstate_t>basic_string<char, char_traits<char>, allocator<char>>basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>reverse_iterator<_Tp *>reverse_iterator<const _Tp *>_Reference_wrapper_base_memfun<type, value>unary_function<_T1, _Res>binary_function<_T1, _T2, _Res>_Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>const _Class_Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>volatile _Class_Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>const volatile _Class_Maybe_get_result_type<_Functor, void>_Weak_result_type_memfun<type, value>_Refwrap_base_arg2<_Tp, void>_Refwrap_base_arg1<_Tp, void>_Weak_result_type<_Tp>is_member_function_pointer<_Functor>reference_wrapper<const _Tp>binary_function<_Tp, _Tp, _Tp>unary_function<_Tp, _Tp>binary_function<_Tp, _Tp, bool>binary_function<_Tp *, _Tp *, bool>__not_overloaded<_Tp, _Up, void>__not_overloaded2<_Tp, _Up, void>unary_function<_Tp, bool>unary_function<argument_type, bool>binary_function<first_argument_type, second_argument_type, bool>unary_function<_Pair, first_type>unary_function<_Pair, second_type>unary_function<_Tp *, _Ret>unary_function<const _Tp *, _Ret>unary_function<_Tp, _Ret>binary_function<_Tp *, _Arg, _Ret>binary_function<const _Tp *, _Arg, _Ret>binary_function<_Tp, _Arg, _Ret>unary_function<second_argument_type, result_type>unary_function<first_argument_type, result_type>__is_nothrow_invocable<_Callable, _Args...>__inv_unwrap<_Tp, __remove_cvref_t<_Tp>>__invoke_result<_Callable, _Args...>__hash_base<unsigned long, vector<bool, _Alloc>>is_nothrow_default_constructible<other>initializer_list<bool>iterator<random_access_iterator_tag, bool, long, bool *, bool &>iterator<random_access_iterator_tag, bool, long, bool *, bool &> &iterator<random_access_iterator_tag, bool, long, bool *, bool &> &&const iterator<random_access_iterator_tag, bool, long, bool *, bool &>const iterator<random_access_iterator_tag, bool, long, bool *, bool &> &__hash_enum<_Tp, value>__hash_base<unsigned long, _Tp>__hash_base<unsigned long, _Tp *>__hash_base<unsigned long, bool>__hash_base<unsigned long, bool> &__hash_base<unsigned long, bool> &&const __hash_base<unsigned long, bool>const __hash_base<unsigned long, bool> &__hash_base<unsigned long, char>__hash_base<unsigned long, char> &__hash_base<unsigned long, char> &&const __hash_base<unsigned long, char>const __hash_base<unsigned long, char> &__hash_base<unsigned long, signed char>__hash_base<unsigned long, signed char> &__hash_base<unsigned long, signed char> &&const __hash_base<unsigned long, signed char>const __hash_base<unsigned long, signed char> &__hash_base<unsigned long, unsigned char>__hash_base<unsigned long, unsigned char> &__hash_base<unsigned long, unsigned char> &&const __hash_base<unsigned long, unsigned char>const __hash_base<unsigned long, unsigned char> &__hash_base<unsigned long, wchar_t>__hash_base<unsigned long, wchar_t> &__hash_base<unsigned long, wchar_t> &&const __hash_base<unsigned long, wchar_t>const __hash_base<unsigned long, wchar_t> &__hash_base<unsigned long, char16_t>__hash_base<unsigned long, char16_t> &__hash_base<unsigned long, char16_t> &&const __hash_base<unsigned long, char16_t>const __hash_base<unsigned long, char16_t> &__hash_base<unsigned long, char32_t>__hash_base<unsigned long, char32_t> &__hash_base<unsigned long, char32_t> &&const __hash_base<unsigned long, char32_t>const __hash_base<unsigned long, char32_t> &__hash_base<unsigned long, short>__hash_base<unsigned long, short> &__hash_base<unsigned long, short> &&const __hash_base<unsigned long, short>const __hash_base<unsigned long, short> &__hash_base<unsigned long, int>__hash_base<unsigned long, int> &__hash_base<unsigned long, int> &&const __hash_base<unsigned long, int>const __hash_base<unsigned long, int> &__hash_base<unsigned long, long>__hash_base<unsigned long, long> &__hash_base<unsigned long, long> &&const __hash_base<unsigned long, long>const __hash_base<unsigned long, long> &__hash_base<unsigned long, long long>__hash_base<unsigned long, long long> &__hash_base<unsigned long, long long> &&const __hash_base<unsigned long, long long>const __hash_base<unsigned long, long long> &__hash_base<unsigned long, unsigned short>__hash_base<unsigned long, unsigned short> &__hash_base<unsigned long, unsigned short> &&const __hash_base<unsigned long, unsigned short>const __hash_base<unsigned long, unsigned short> &__hash_base<unsigned long, unsigned int>__hash_base<unsigned long, unsigned int> &__hash_base<unsigned long, unsigned int> &&const __hash_base<unsigned long, unsigned int>const __hash_base<unsigned long, unsigned int> &__hash_base<unsigned long, unsigned long>__hash_base<unsigned long, unsigned long> &__hash_base<unsigned long, unsigned long> &&const __hash_base<unsigned long, unsigned long>const __hash_base<unsigned long, unsigned long> &__hash_base<unsigned long, unsigned long long>__hash_base<unsigned long, unsigned long long> &__hash_base<unsigned long, unsigned long long> &&const __hash_base<unsigned long, unsigned long long>const __hash_base<unsigned long, unsigned long long> &__hash_base<unsigned long, __int128_t>__hash_base<unsigned long, __int128_t> &__hash_base<unsigned long, __int128_t> &&const __hash_base<unsigned long, __int128_t>const __hash_base<unsigned long, __int128_t> &__hash_base<unsigned long, __uint128_t>__hash_base<unsigned long, __uint128_t> &__hash_base<unsigned long, __uint128_t> &&const __hash_base<unsigned long, __uint128_t>const __hash_base<unsigned long, __uint128_t> &__hash_base<unsigned long, float>__hash_base<unsigned long, float> &__hash_base<unsigned long, float> &&const __hash_base<unsigned long, float>const __hash_base<unsigned long, float> &__hash_base<unsigned long, double>__hash_base<unsigned long, double> &__hash_base<unsigned long, double> &&const __hash_base<unsigned long, double>const __hash_base<unsigned long, double> &__hash_base<unsigned long, long double>__hash_base<unsigned long, long double> &__hash_base<unsigned long, long double> &&const __hash_base<unsigned long, long double>const __hash_base<unsigned long, long double> &__hash_base<unsigned long, std::nullptr_t>__hash_base<unsigned long, std::nullptr_t> &__hash_base<unsigned long, std::nullptr_t> &&const __hash_base<unsigned long, std::nullptr_t>const __hash_base<unsigned long, std::nullptr_t> &_Vector_base<unsigned char, allocator<unsigned char>>_Vector_base<unsigned char, allocator<unsigned char>> &const _Vector_base<unsigned char, allocator<unsigned char>>const _Vector_base<unsigned char, allocator<unsigned char>> &_Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>_Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const _Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const _Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &_Vector_base<file_stats, allocator<file_stats>>_Vector_base<file_stats, allocator<file_stats>> &const _Vector_base<file_stats, allocator<file_stats>>const _Vector_base<file_stats, allocator<file_stats>> &is_same<type, _Tp>is_nothrow_move_assignable<vector<_Tp, _Alloc>>__alloc_traits<other, value_type>__is_move_insertable<_Tp_alloc_type>allocator<_ValT>vector<_ValT, _Allocator>is_constructible<_ValueType, _Tp>__uninitialized_copy<<expression>>__uninitialized_default_n_1<<expression>>__and_<is_integral<_Size>, is_copy_assignable<value_type>>allocator_traits<_Allocator>is_same<value_type, value_type>allocator<_Tp2>pair<_InputIterator, _ForwardIterator>pair<_RandomAccessIterator, _ForwardIterator>__is_bitwise_relocatable<_Tp, void>allocator<_Up>allocator_traits<allocator<wchar_t>>allocator_traits<allocator<wchar_t>> &allocator_traits<allocator<wchar_t>> &&const allocator_traits<allocator<wchar_t>>const allocator_traits<allocator<wchar_t>> &allocator_traits<allocator<char16_t>>allocator_traits<allocator<char16_t>> &allocator_traits<allocator<char16_t>> &&const allocator_traits<allocator<char16_t>>const allocator_traits<allocator<char16_t>> &allocator_traits<allocator<char32_t>>allocator_traits<allocator<char32_t>> &allocator_traits<allocator<char32_t>> &&const allocator_traits<allocator<char32_t>>const allocator_traits<allocator<char32_t>> &allocator_traits<allocator<unsigned char>>allocator_traits<allocator<unsigned char>> &allocator_traits<allocator<unsigned char>> &&const allocator_traits<allocator<unsigned char>>const allocator_traits<allocator<unsigned char>> &allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const allocator_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &allocator_traits<allocator<file_stats>>allocator_traits<allocator<file_stats>> &allocator_traits<allocator<file_stats>> &&const allocator_traits<allocator<file_stats>>const allocator_traits<allocator<file_stats>> &allocator_traits<allocator<char>>allocator_traits<allocator<char>> &allocator_traits<allocator<char>> &&const allocator_traits<allocator<char>>const allocator_traits<allocator<char>> &__is_custom_pointeris_nothrow_constructible<_Up, _Args...>is_nothrow_destructible<_Up>__rebind<_Alloc, _Tp, void>__rebind<_Alloc, _Up, void>make_unsigned<_DiffT>_Size<_Alloc, type, void>_Diff<_Alloc, type, void>_Ptr<__cv_pointer, const void, void>_Ptr<__v_pointer, void, void>_Ptr<__c_pointer, const value_type, void>is_destructible<value_type>_Destroy_aux<<expression>>allocator<_Tp1>allocator<char16_t>allocator<char32_t>allocator<unsigned char>allocator<basic_string<char, char_traits<char>, allocator<char>>>allocator<file_stats>allocator<_T1>allocator<_T2>allocator<char>allocator<wchar_t>is_copy_constructible<value_type>is_nothrow_move_constructible<value_type>__or_<is_copy_constructible<value_type>, is_nothrow_move_constructible<value_type>>__new_allocator<_Tp1>__new_allocator<_Up>__new_allocator<char>__new_allocator<wchar_t>__new_allocator<char16_t>__new_allocator<char32_t>__new_allocator<unsigned char>__new_allocator<basic_string<char, char_traits<char>, allocator<char>>>__new_allocator<file_stats>__copy_move<_IsMove, __value, iterator_category>is_integral<_Size>_Base_typefile_stats_vecstring_arraystringwstringu32stringu16string__sv_type__const_iteratorconst_reverse_iterator_Alloc_traitsu32string_viewu16string_viewwstring_viewstring_viewwfstreamwofstreamwifstreamwfilebufwstringstreamwostringstreamwistringstreamwstringbufwiostreamwostreamwistreamwstreambufwiosfstreamofstreamifstreamfilebufstringstreamostringstreamistringstreamstringbufiostreamostreamistreamstreambufiosu32streamposu16streamposwstreampos__vararg__arity__ptr_cmprebind_traitsstreamposvector<unsigned char, allocator<unsigned char>> *_Vector_base<unsigned char, allocator<unsigned char>> *const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *_Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *_Vector_base<file_stats, allocator<file_stats>> *basic_string<char, char_traits<char>, allocator<char>> *constbasic_string<char, char_traits<char>, allocator<char>> *const &basic_string<char, char_traits<char>, allocator<char>> *&const __normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *const basic_string<char, char_traits<char>, allocator<char>> *const __normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &const vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const _Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *_Save_errno &const _Save_errno &_Range_chk &_Range_chk &&const _Range_chkconst _Range_chk &_TRet(__numeric_traits<int>::__min)_TRet(__numeric_traits<int>::__max)18446744071562067968-2147483648.02147483648.02147483647.0~_Alloc_hider_S_local_capacity + 1allocator<char> &&sizeof(_CharT)const basic_string_view<char, char_traits<char>>const basic_string_view<char, char_traits<char>> *basic_string_view<char, char_traits<char>> *const basic_string_view<wchar_t, char_traits<wchar_t>>const basic_string_view<wchar_t, char_traits<wchar_t>> *basic_string_view<wchar_t, char_traits<wchar_t>> *const basic_string_view<char16_t, char_traits<char16_t>>const basic_string_view<char16_t, char_traits<char16_t>> *basic_string_view<char16_t, char_traits<char16_t>> *const basic_string_view<char32_t, char_traits<char32_t>>const basic_string_view<char32_t, char_traits<char32_t>> *basic_string_view<char32_t, char_traits<char32_t>> *sizeof(__val)pointer()const _Vector_base<file_stats, allocator<file_stats>> *(_Value)1__digits - 1(__digits - 1)(_Value)1 << (__digits - 1)((_Value)1 << (__digits - 1))((_Value)1 << (__digits - 1)) - 1(((_Value)1 << (__digits - 1)) - 1)(((_Value)1 << (__digits - 1)) - 1) << 1((((_Value)1 << (__digits - 1)) - 1) << 1)((((_Value)1 << (__digits - 1)) - 1) << 1) + 1(((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)(_Value)0~(_Value)0__is_signed
	? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
	: ~(_Value)0-__max-__max - 1__is_signed ? -__max - 1 : (_Value)046116860184273879039223372036854775806__numeric_traits_integer<long>__numeric_traits_integer<long> &__numeric_traits_integer<long> &&const __numeric_traits_integer<long>const __numeric_traits_integer<long> &__are_same<long double, double>__are_same<long double, double> &__are_same<long double, double> &&const __are_same<long double, double>const __are_same<long double, double> &__are_same<long double, float>__are_same<long double, float> &__are_same<long double, float> &&const __are_same<long double, float>const __are_same<long double, float> &__are_same<double, double>__are_same<double, double> &__are_same<double, double> &&const __are_same<double, double>const __are_same<double, double> &__are_same<double, float>__are_same<double, float> &__are_same<double, float> &&const __are_same<double, float>const __are_same<double, float> &__are_same<float, double>__are_same<float, double> &__are_same<float, double> &&const __are_same<float, double>const __are_same<float, double> &__are_same<float, float>__are_same<float, float> &__are_same<float, float> &&const __are_same<float, float>const __are_same<float, float> &__alloc_traits<allocator<file_stats>, file_stats>__alloc_traits__alloc_traits<allocator<file_stats>, file_stats> &__alloc_traits<allocator<file_stats>, file_stats> &&const __alloc_traits<allocator<file_stats>, file_stats>const __alloc_traits<allocator<file_stats>, file_stats> &is_same<long double, int>is_sameis_same<long double, int> &is_same<long double, int> &&const is_same<long double, int>const is_same<long double, int> &is_same<double, int>is_same<double, int> &is_same<double, int> &&const is_same<double, int>const is_same<double, int> &is_same<float, int>is_same<float, int> &is_same<float, int> &&const is_same<float, int>const is_same<float, int> &is_same<unsigned long long, int>is_same<unsigned long long, int> &is_same<unsigned long long, int> &&const is_same<unsigned long long, int>const is_same<unsigned long long, int> &is_same<long long, int>is_same<long long, int> &is_same<long long, int> &&const is_same<long long, int>const is_same<long long, int> &is_same<unsigned long, int>is_same<unsigned long, int> &is_same<unsigned long, int> &&const is_same<unsigned long, int>const is_same<unsigned long, int> &is_same<long, int>is_same<long, int> &is_same<long, int> &&const is_same<long, int>const is_same<long, int> &is_same<int, int>is_same<int, int> &is_same<int, int> &&const is_same<int, int>const is_same<int, int> &is_nothrow_default_constructible<allocator<char>>is_nothrow_default_constructibleis_nothrow_default_constructible<allocator<char>> &is_nothrow_default_constructible<allocator<char>> &&const is_nothrow_default_constructible<allocator<char>>const is_nothrow_default_constructible<allocator<char>> &__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &&const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &const __normal_iterator<_Iter, vector<unsigned char, allocator<unsigned char>>>const __normal_iterator<_Iter, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<_Iter, vector<unsigned char, allocator<unsigned char>>> &__alloc_traits<_Tp_alloc_type, value_type>__normal_iterator<pointer, vector<_Tp, _Alloc>>__normal_iterator<const_pointer, vector<_Tp, _Alloc>>reverse_iterator<__normal_iterator<const_pointer, vector<_Tp, _Alloc>>>reverse_iterator<__normal_iterator<pointer, vector<_Tp, _Alloc>>>_Func<_Alloc>allocator_traits<type>allocator_traits<allocator<_Up>>reverse_iterator<_Bit_const_iterator>reverse_iterator<_Bit_iterator>__and_<__not_overloaded<_Tp, _Up, void>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>_Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>_Class *reverse_iterator<const _CharT *>__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>>reverse_iterator<__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>>>reverse_iterator<__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>>>__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>>vector<_Tp, polymorphic_allocator<_Tp>>basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>__and_<is_same<pointer, _Ptr>, __not_<is_pointer<_Ptr>>>rebind_alloc<_Tp>is_rvalue_reference<char>is_rvalue_reference<char> &is_rvalue_reference<char> &&const is_rvalue_reference<char>const is_rvalue_reference<char> &__or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>__or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>> &__or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>> &&const __or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>const __or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>> &__or_<is_void<char>, __is_array_unknown_bounds<char>>__or_<is_void<char>, __is_array_unknown_bounds<char>> &__or_<is_void<char>, __is_array_unknown_bounds<char>> &&const __or_<is_void<char>, __is_array_unknown_bounds<char>>const __or_<is_void<char>, __is_array_unknown_bounds<char>> &__is_array_unknown_bounds<char>__is_array_unknown_bounds<char> &__is_array_unknown_bounds<char> &&const __is_array_unknown_bounds<char>const __is_array_unknown_bounds<char> &is_array<char>is_array<char> &is_array<char> &&const is_array<char>const is_array<char> &is_rvalue_reference<wchar_t>is_rvalue_reference<wchar_t> &is_rvalue_reference<wchar_t> &&const is_rvalue_reference<wchar_t>const is_rvalue_reference<wchar_t> &__or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>__or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &__or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &&const __or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>const __or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &__or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>__or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &__or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &&const __or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>const __or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>> &__is_array_unknown_bounds<wchar_t>__is_array_unknown_bounds<wchar_t> &__is_array_unknown_bounds<wchar_t> &&const __is_array_unknown_bounds<wchar_t>const __is_array_unknown_bounds<wchar_t> &is_array<wchar_t>is_array<wchar_t> &is_array<wchar_t> &&const is_array<wchar_t>const is_array<wchar_t> &is_rvalue_reference<char16_t>is_rvalue_reference<char16_t> &is_rvalue_reference<char16_t> &&const is_rvalue_reference<char16_t>const is_rvalue_reference<char16_t> &__or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>__or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &__or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &&const __or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>const __or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &__or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>>__or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &__or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &&const __or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>>const __or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>> &__is_array_unknown_bounds<char16_t>__is_array_unknown_bounds<char16_t> &__is_array_unknown_bounds<char16_t> &&const __is_array_unknown_bounds<char16_t>const __is_array_unknown_bounds<char16_t> &is_array<char16_t>is_array<char16_t> &is_array<char16_t> &&const is_array<char16_t>const is_array<char16_t> &is_rvalue_reference<char32_t>is_rvalue_reference<char32_t> &is_rvalue_reference<char32_t> &&const is_rvalue_reference<char32_t>const is_rvalue_reference<char32_t> &__or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>__or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &__or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &&const __or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>const __or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &__or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>>__or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &__or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &&const __or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>>const __or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>> &__is_array_unknown_bounds<char32_t>__is_array_unknown_bounds<char32_t> &__is_array_unknown_bounds<char32_t> &&const __is_array_unknown_bounds<char32_t>const __is_array_unknown_bounds<char32_t> &is_array<char32_t>is_array<char32_t> &is_array<char32_t> &&const is_array<char32_t>const is_array<char32_t> &is_array<basic_string_view<char, char_traits<char>>>is_array<basic_string_view<char, char_traits<char>>> &is_array<basic_string_view<char, char_traits<char>>> &&const is_array<basic_string_view<char, char_traits<char>>>const is_array<basic_string_view<char, char_traits<char>>> &is_array<const basic_string<char, char_traits<char>, allocator<char>> *>is_array<const basic_string<char, char_traits<char>, allocator<char>> *> &is_array<const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_array<const basic_string<char, char_traits<char>, allocator<char>> *>const is_array<const basic_string<char, char_traits<char>, allocator<char>> *> &is_array<const char *>is_array<const char *> &is_array<const char *> &&const is_array<const char *>const is_array<const char *> &is_rvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>>>is_rvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_rvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_rvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const is_rvalue_reference<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>>__or_<is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__or_<is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &&const __or_<is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __or_<is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__or_<is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>>__or_<is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__or_<is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &&const __or_<is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __or_<is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>__is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __is_array_unknown_bounds<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_rvalue_reference<allocator<char>>is_rvalue_reference<allocator<char>> &is_rvalue_reference<allocator<char>> &&const is_rvalue_reference<allocator<char>>const is_rvalue_reference<allocator<char>> &__or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>__or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &__or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &&const __or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>const __or_<is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &__or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>__or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &__or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &&const __or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>const __or_<is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>> &__is_array_unknown_bounds<allocator<char>>__is_array_unknown_bounds<allocator<char>> &__is_array_unknown_bounds<allocator<char>> &&const __is_array_unknown_bounds<allocator<char>>const __is_array_unknown_bounds<allocator<char>> &is_array<allocator<char>>is_array<allocator<char>> &is_array<allocator<char>> &&const is_array<allocator<char>>const is_array<allocator<char>> &__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>__not___not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>__or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>> &__or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>> &&const __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>>const __or_<is_function<basic_string_view<char, char_traits<char>>>, is_array<basic_string_view<char, char_traits<char>>>> &__or_<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_function<const char *>, is_array<const char *>>__or_<is_function<const char *>, is_array<const char *>> &__or_<is_function<const char *>, is_array<const char *>> &&const __or_<is_function<const char *>, is_array<const char *>>const __or_<is_function<const char *>, is_array<const char *>> &__or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>>__or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>> &__or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>> &&const __or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>>const __or_<is_function<input_iterator_tag>, is_array<input_iterator_tag>> &is_array<input_iterator_tag>is_array<input_iterator_tag> &is_array<input_iterator_tag> &&const is_array<input_iterator_tag>const is_array<input_iterator_tag> &is_rvalue_reference<unsigned char>is_rvalue_reference<unsigned char> &is_rvalue_reference<unsigned char> &&const is_rvalue_reference<unsigned char>const is_rvalue_reference<unsigned char> &__or_<is_function<unsigned char>, is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>>__or_<is_function<unsigned char>, is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &__or_<is_function<unsigned char>, is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &&const __or_<is_function<unsigned char>, is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>>const __or_<is_function<unsigned char>, is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &__or_<is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>>__or_<is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &__or_<is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &&const __or_<is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>>const __or_<is_void<unsigned char>, __is_array_unknown_bounds<unsigned char>> &__is_array_unknown_bounds<unsigned char>__is_array_unknown_bounds<unsigned char> &__is_array_unknown_bounds<unsigned char> &&const __is_array_unknown_bounds<unsigned char>const __is_array_unknown_bounds<unsigned char> &is_array<unsigned char>is_array<unsigned char> &is_array<unsigned char> &&const is_array<unsigned char>const is_array<unsigned char> &__or_<__is_array_unknown_bounds<unsigned char>, is_function<unsigned char>>__or_<__is_array_unknown_bounds<unsigned char>, is_function<unsigned char>> &__or_<__is_array_unknown_bounds<unsigned char>, is_function<unsigned char>> &&const __or_<__is_array_unknown_bounds<unsigned char>, is_function<unsigned char>>const __or_<__is_array_unknown_bounds<unsigned char>, is_function<unsigned char>> &is_function<unsigned char>is_function<unsigned char> &is_function<unsigned char> &&const is_function<unsigned char>const is_function<unsigned char> &is_scalar<unsigned char>is_scalaris_scalar<unsigned char> &is_scalar<unsigned char> &&const is_scalar<unsigned char>const is_scalar<unsigned char> &__or_<is_function<unsigned char *>, is_array<unsigned char *>>__or_<is_function<unsigned char *>, is_array<unsigned char *>> &__or_<is_function<unsigned char *>, is_array<unsigned char *>> &&const __or_<is_function<unsigned char *>, is_array<unsigned char *>>const __or_<is_function<unsigned char *>, is_array<unsigned char *>> &is_array<unsigned char *>is_array<unsigned char *> &is_array<unsigned char *> &&const is_array<unsigned char *>const is_array<unsigned char *> &is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>>>is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>>> &is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>>> &&const is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>>>const is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>>> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>>>, is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>>__or_<is_function<basic_string<char, char_traits<char>, allocator<char>>>, is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>>>, is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>>>, is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>>>, is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>>__or_<is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<is_void<basic_string<char, char_traits<char>, allocator<char>>>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>> &__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>> &__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>> &&const __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>const __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>> &is_array<basic_string<char, char_traits<char>, allocator<char>>>is_array<basic_string<char, char_traits<char>, allocator<char>>> &is_array<basic_string<char, char_traits<char>, allocator<char>>> &&const is_array<basic_string<char, char_traits<char>, allocator<char>>>const is_array<basic_string<char, char_traits<char>, allocator<char>>> &__or_<__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>, is_function<basic_string<char, char_traits<char>, allocator<char>>>>__or_<__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>, is_function<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>, is_function<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>, is_function<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>>>, is_function<basic_string<char, char_traits<char>, allocator<char>>>> &is_function<basic_string<char, char_traits<char>, allocator<char>>>is_function<basic_string<char, char_traits<char>, allocator<char>>> &is_function<basic_string<char, char_traits<char>, allocator<char>>> &&const is_function<basic_string<char, char_traits<char>, allocator<char>>>const is_function<basic_string<char, char_traits<char>, allocator<char>>> &is_scalar<basic_string<char, char_traits<char>, allocator<char>>>is_scalar<basic_string<char, char_traits<char>, allocator<char>>> &is_scalar<basic_string<char, char_traits<char>, allocator<char>>> &&const is_scalar<basic_string<char, char_traits<char>, allocator<char>>>const is_scalar<basic_string<char, char_traits<char>, allocator<char>>> &is_floating_point<basic_string<char, char_traits<char>, allocator<char>>>is_floating_pointis_floating_point<basic_string<char, char_traits<char>, allocator<char>>> &is_floating_point<basic_string<char, char_traits<char>, allocator<char>>> &&const is_floating_point<basic_string<char, char_traits<char>, allocator<char>>>const is_floating_point<basic_string<char, char_traits<char>, allocator<char>>> &__or_<is_enum<basic_string<char, char_traits<char>, allocator<char>>>, is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>__or_<is_enum<basic_string<char, char_traits<char>, allocator<char>>>, is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_enum<basic_string<char, char_traits<char>, allocator<char>>>, is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<is_enum<basic_string<char, char_traits<char>, allocator<char>>>, is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<is_enum<basic_string<char, char_traits<char>, allocator<char>>>, is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>__or_<is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<is_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>__or_<is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &__or_<is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &&const __or_<is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>>const __or_<is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>, is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>> &is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>is_null_pointeris_null_pointer<basic_string<char, char_traits<char>, allocator<char>>> &is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>> &&const is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>>const is_null_pointer<basic_string<char, char_traits<char>, allocator<char>>> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_array<basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_array<basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_array<basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_array<basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_array<basic_string<char, char_traits<char>, allocator<char>> *>> &is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>> *>is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>> *> &is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>> *>const is_rvalue_reference<basic_string<char, char_traits<char>, allocator<char>> *> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_function<basic_string<char, char_traits<char>, allocator<char>> *>, is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<basic_string<char, char_traits<char>, allocator<char>> *>, __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>> &__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *> &__is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *> &&const __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *>const __is_array_unknown_bounds<basic_string<char, char_traits<char>, allocator<char>> *> &is_array<basic_string<char, char_traits<char>, allocator<char>> *>is_array<basic_string<char, char_traits<char>, allocator<char>> *> &is_array<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_array<basic_string<char, char_traits<char>, allocator<char>> *>const is_array<basic_string<char, char_traits<char>, allocator<char>> *> &is_rvalue_reference<file_stats>is_rvalue_reference<file_stats> &is_rvalue_reference<file_stats> &&const is_rvalue_reference<file_stats>const is_rvalue_reference<file_stats> &__or_<is_function<file_stats>, is_void<file_stats>, __is_array_unknown_bounds<file_stats>>__or_<is_function<file_stats>, is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &__or_<is_function<file_stats>, is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &&const __or_<is_function<file_stats>, is_void<file_stats>, __is_array_unknown_bounds<file_stats>>const __or_<is_function<file_stats>, is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &__or_<is_void<file_stats>, __is_array_unknown_bounds<file_stats>>__or_<is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &__or_<is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &&const __or_<is_void<file_stats>, __is_array_unknown_bounds<file_stats>>const __or_<is_void<file_stats>, __is_array_unknown_bounds<file_stats>> &__is_array_unknown_bounds<file_stats>__is_array_unknown_bounds<file_stats> &__is_array_unknown_bounds<file_stats> &&const __is_array_unknown_bounds<file_stats>const __is_array_unknown_bounds<file_stats> &is_array<file_stats>is_array<file_stats> &is_array<file_stats> &&const is_array<file_stats>const is_array<file_stats> &__or_<is_function<file_stats *>, is_array<file_stats *>>__or_<is_function<file_stats *>, is_array<file_stats *>> &__or_<is_function<file_stats *>, is_array<file_stats *>> &&const __or_<is_function<file_stats *>, is_array<file_stats *>>const __or_<is_function<file_stats *>, is_array<file_stats *>> &is_rvalue_reference<file_stats *>is_rvalue_reference<file_stats *> &is_rvalue_reference<file_stats *> &&const is_rvalue_reference<file_stats *>const is_rvalue_reference<file_stats *> &__or_<is_function<file_stats *>, is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>>__or_<is_function<file_stats *>, is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &__or_<is_function<file_stats *>, is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &&const __or_<is_function<file_stats *>, is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>>const __or_<is_function<file_stats *>, is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &__or_<is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>>__or_<is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &__or_<is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &&const __or_<is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>>const __or_<is_void<file_stats *>, __is_array_unknown_bounds<file_stats *>> &__is_array_unknown_bounds<file_stats *>__is_array_unknown_bounds<file_stats *> &__is_array_unknown_bounds<file_stats *> &&const __is_array_unknown_bounds<file_stats *>const __is_array_unknown_bounds<file_stats *> &is_array<file_stats *>is_array<file_stats *> &is_array<file_stats *> &&const is_array<file_stats *>const is_array<file_stats *> &__or_<__is_array_unknown_bounds<file_stats>, is_function<file_stats>>__or_<__is_array_unknown_bounds<file_stats>, is_function<file_stats>> &__or_<__is_array_unknown_bounds<file_stats>, is_function<file_stats>> &&const __or_<__is_array_unknown_bounds<file_stats>, is_function<file_stats>>const __or_<__is_array_unknown_bounds<file_stats>, is_function<file_stats>> &is_function<file_stats>is_function<file_stats> &is_function<file_stats> &&const is_function<file_stats>const is_function<file_stats> &is_scalar<file_stats>is_scalar<file_stats> &is_scalar<file_stats> &&const is_scalar<file_stats>const is_scalar<file_stats> &is_floating_point<file_stats>is_floating_point<file_stats> &is_floating_point<file_stats> &&const is_floating_point<file_stats>const is_floating_point<file_stats> &__or_<is_enum<file_stats>, is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>>__or_<is_enum<file_stats>, is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &__or_<is_enum<file_stats>, is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &&const __or_<is_enum<file_stats>, is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>>const __or_<is_enum<file_stats>, is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &__or_<is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>>__or_<is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &__or_<is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &&const __or_<is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>>const __or_<is_pointer<file_stats>, is_member_pointer<file_stats>, is_null_pointer<file_stats>> &__or_<is_member_pointer<file_stats>, is_null_pointer<file_stats>>__or_<is_member_pointer<file_stats>, is_null_pointer<file_stats>> &__or_<is_member_pointer<file_stats>, is_null_pointer<file_stats>> &&const __or_<is_member_pointer<file_stats>, is_null_pointer<file_stats>>const __or_<is_member_pointer<file_stats>, is_null_pointer<file_stats>> &is_null_pointer<file_stats>is_null_pointer<file_stats> &is_null_pointer<file_stats> &&const is_null_pointer<file_stats>const is_null_pointer<file_stats> &__memcpyable<_OI, _II>const file_stats *const char32_t &const char16_t &const wchar_t &is_copy_assignable<value_type>_Vector_impl &const _Vector_implconst _Vector_impl &~_Vector_implis_member_function_pointer<type>char32_t[4]_Alloc_hider &_Alloc_hider &&const _Alloc_hiderconst _Alloc_hider &__sv_wrapper &__sv_wrapper &&const __sv_wrapperconst __sv_wrapper &char16_t[8]__numeric_traits_integer<int>__numeric_traits_integer<int> &__numeric_traits_integer<int> &&const __numeric_traits_integer<int>const __numeric_traits_integer<int> &__alloc_traits<allocator<char>, char>__alloc_traits<allocator<char>, char> &__alloc_traits<allocator<char>, char> &&const __alloc_traits<allocator<char>, char>const __alloc_traits<allocator<char>, char> &__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &__hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &&const __hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>>const __hash_base<unsigned long, basic_string<wchar_t, char_traits<wchar_t>, polymorphic_allocator<wchar_t>>> &__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &__hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &&const __hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>>const __hash_base<unsigned long, basic_string<char32_t, char_traits<char32_t>, polymorphic_allocator<char32_t>>> &__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &__hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &&const __hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>>const __hash_base<unsigned long, basic_string<char16_t, char_traits<char16_t>, polymorphic_allocator<char16_t>>> &__hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>>__hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &__hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &&const __hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>>const __hash_base<unsigned long, basic_string<char, char_traits<char>, polymorphic_allocator<char>>> &polymorphic_allocator<wchar_t>polymorphic_allocator<char32_t>polymorphic_allocator<char16_t>polymorphic_allocator<char>__alloc_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>>>__alloc_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>>> &__alloc_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>>> &&const __alloc_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>>>const __alloc_traits<allocator<basic_string<char, char_traits<char>, allocator<char>>>, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &&__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *__normal_iterator<_Iter, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>__alloc_traits<allocator<unsigned char>, unsigned char>__alloc_traits<allocator<unsigned char>, unsigned char> &__alloc_traits<allocator<unsigned char>, unsigned char> &&const __alloc_traits<allocator<unsigned char>, unsigned char>const __alloc_traits<allocator<unsigned char>, unsigned char> &allocator<wchar_t> *allocator<char16_t> *allocator<char32_t> *allocator<unsigned char> *allocator<basic_string<char, char_traits<char>, allocator<char>>> *_Alloc_traits::_S_nothrow_move()_Alloc_traits::_S_propagate_on_move_assign()_Alloc_traits::_S_always_equal()!_Alloc_traits::_S_always_equal()_Alloc_traits::_S_propagate_on_move_assign()
	    || _Alloc_traits::_S_always_equal()_Alloc_traits::_S_propagate_on_move_assign()
	    || _Alloc_traits::_S_always_equal()
	    || _M_get_allocator() == __str._M_get_allocator()const __new_allocator<char> *__new_allocator<char> *alignof(_Tp)alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__std::align_val_t(alignof(_Tp))static_cast<const void*>(0)std::size_t(-1)std::size_t(-1) / sizeof(_Tp)(std::size_t(-1) / sizeof(_Tp))const __new_allocator<file_stats> *__new_allocator<file_stats> *177372539170284150const __new_allocator<basic_string<char, char_traits<char>, allocator<char>>> *__new_allocator<basic_string<char, char_traits<char>, allocator<char>>> *576460752303423487const __new_allocator<unsigned char> *__new_allocator<unsigned char> *const __new_allocator<char32_t> *__new_allocator<char32_t> *const __new_allocator<char16_t> *__new_allocator<char16_t> *__new_allocator<wchar_t> *unsigned char *const &_Guard &const _Guardconst _Guard &wchar_t *constwchar_t *const &wchar_t *&char *const &char *&allocator<char> *const basic_string<char, char_traits<char>, allocator<char>> *constconst basic_string<char, char_traits<char>, allocator<char>> *const &_CharT()size_type(0)_Alloc_traits::_S_propagate_on_copy_assign()!_Alloc_traits::_S_always_equal() && !_M_is_local()!_Alloc_traits::_S_always_equal() && !_M_is_local()
		&& _M_get_allocator() != __str._M_get_allocator()file_stats *constfile_stats *const &file_stats *&const vector<file_stats, allocator<file_stats>>const vector<file_stats, allocator<file_stats>> *const __normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>>const __normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>> &__normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>> &std::is_nothrow_constructible<_Up, _Args...>::valueconst __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> *__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> *__is_integer_nonstrict<_Value>::__width__is_integer_nonstrict<_Value>::__width - __is_signed(_Value)(-1)(_Value)(-1) < 0__is_integer_nonstrict<int>__is_integer_nonstrict__is_integer_nonstrict<int> &__is_integer_nonstrict<int> &&const __is_integer_nonstrict<int>const __is_integer_nonstrict<int> &sizeof(_Tp) * __CHAR_BIT____value ? sizeof(_Tp) * __CHAR_BIT__ : 0__is_integer_nonstrict<long>__is_integer_nonstrict<long> &__is_integer_nonstrict<long> &&const __is_integer_nonstrict<long>const __is_integer_nonstrict<long> &pointer_traits<char *>pointer_traitspointer_traits<char *> &pointer_traits<char *> &&const pointer_traits<char *>const pointer_traits<char *> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const basic_string<char, char_traits<char>, allocator<char>> &>is_nothrow_constructibleis_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const basic_string<char, char_traits<char>, allocator<char>> &> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const basic_string<char, char_traits<char>, allocator<char>> &> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const basic_string<char, char_traits<char>, allocator<char>> &>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const basic_string<char, char_traits<char>, allocator<char>> &> &is_nothrow_constructible<file_stats, const file_stats &>is_nothrow_constructible<file_stats, const file_stats &> &is_nothrow_constructible<file_stats, const file_stats &> &&const is_nothrow_constructible<file_stats, const file_stats &>const is_nothrow_constructible<file_stats, const file_stats &> &pointer_traits<wchar_t *>pointer_traits<wchar_t *> &pointer_traits<wchar_t *> &&const pointer_traits<wchar_t *>const pointer_traits<wchar_t *> &pointer_traits<char16_t *>pointer_traits<char16_t *> &pointer_traits<char16_t *> &&const pointer_traits<char16_t *>const pointer_traits<char16_t *> &pointer_traits<char32_t *>pointer_traits<char32_t *> &pointer_traits<char32_t *> &&const pointer_traits<char32_t *>const pointer_traits<char32_t *> &rebind<unsigned char>rebind<unsigned char> &rebind<unsigned char> &&const rebind<unsigned char>const rebind<unsigned char> &iterator_traits<basic_string<char, char_traits<char>, allocator<char>> *>iterator_traits<basic_string<char, char_traits<char>, allocator<char>> *> &iterator_traits<basic_string<char, char_traits<char>, allocator<char>> *> &&const iterator_traits<basic_string<char, char_traits<char>, allocator<char>> *>const iterator_traits<basic_string<char, char_traits<char>, allocator<char>> *> &rebind<basic_string<char, char_traits<char>, allocator<char>>>rebind<basic_string<char, char_traits<char>, allocator<char>>> &rebind<basic_string<char, char_traits<char>, allocator<char>>> &&const rebind<basic_string<char, char_traits<char>, allocator<char>>>const rebind<basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>reverse_iterator<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>>reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>reverse_iterator<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>reverse_iterator<__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>__normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>>__normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>> &&const __normal_iterator<_Iter, vector<file_stats, allocator<file_stats>>>const __normal_iterator<_Iter, vector<file_stats, allocator<file_stats>>> &__normal_iterator<_Iter, vector<file_stats, allocator<file_stats>>> &__normal_iterator<const file_stats *, vector<file_stats, allocator<file_stats>>>reverse_iterator<__normal_iterator<const file_stats *, vector<file_stats, allocator<file_stats>>>>reverse_iterator<__normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>>>rebind<char>rebind<char> &rebind<char> &&const rebind<char>const rebind<char> &reverse_iterator<const char *>reverse_iterator<const wchar_t *>reverse_iterator<const char16_t *>reverse_iterator<const char32_t *>__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &&const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &const __normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>> &reverse_iterator<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>reverse_iterator<__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>>__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &&const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &__alloc_traits<allocator<wchar_t>, wchar_t>__alloc_traits<allocator<wchar_t>, wchar_t> &__alloc_traits<allocator<wchar_t>, wchar_t> &&const __alloc_traits<allocator<wchar_t>, wchar_t>const __alloc_traits<allocator<wchar_t>, wchar_t> &__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &&const __normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const __normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &const __normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const __normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &reverse_iterator<__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>reverse_iterator<__normal_iterator<wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &&const __normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const __normal_iterator<const wchar_t *, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &__alloc_traits<allocator<char16_t>, char16_t>__alloc_traits<allocator<char16_t>, char16_t> &__alloc_traits<allocator<char16_t>, char16_t> &&const __alloc_traits<allocator<char16_t>, char16_t>const __alloc_traits<allocator<char16_t>, char16_t> &__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &&const __normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const __normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &const __normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const __normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &reverse_iterator<__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>reverse_iterator<__normal_iterator<char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &&const __normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const __normal_iterator<const char16_t *, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &__alloc_traits<allocator<char32_t>, char32_t>__alloc_traits<allocator<char32_t>, char32_t> &__alloc_traits<allocator<char32_t>, char32_t> &&const __alloc_traits<allocator<char32_t>, char32_t>const __alloc_traits<allocator<char32_t>, char32_t> &__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &&const __normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const __normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &const __normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const __normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &reverse_iterator<__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>reverse_iterator<__normal_iterator<char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &&const __normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const __normal_iterator<const char32_t *, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &__not_<is_pointer<_Ptr>>is_same<pointer, _Ptr>is_member_pointer<file_stats>is_member_pointeris_member_pointer<file_stats> &is_member_pointer<file_stats> &&const is_member_pointer<file_stats>const is_member_pointer<file_stats> &is_pointer<file_stats>is_pointeris_pointer<file_stats> &is_pointer<file_stats> &&const is_pointer<file_stats>const is_pointer<file_stats> &is_enum<file_stats>is_enum<file_stats> &is_enum<file_stats> &&const is_enum<file_stats>const is_enum<file_stats> &__and_<is_array<file_stats *>, __not_<extent<file_stats *, 0U>>>__and_<is_array<file_stats *>, __not_<extent<file_stats *, 0U>>> &__and_<is_array<file_stats *>, __not_<extent<file_stats *, 0U>>> &&const __and_<is_array<file_stats *>, __not_<extent<file_stats *, 0U>>>const __and_<is_array<file_stats *>, __not_<extent<file_stats *, 0U>>> &is_void<file_stats *>is_void<file_stats *> &is_void<file_stats *> &&const is_void<file_stats *>const is_void<file_stats *> &is_function<file_stats *>is_function<file_stats *> &is_function<file_stats *> &&const is_function<file_stats *>const is_function<file_stats *> &__and_<is_array<file_stats>, __not_<extent<file_stats, 0U>>>__and_<is_array<file_stats>, __not_<extent<file_stats, 0U>>> &__and_<is_array<file_stats>, __not_<extent<file_stats, 0U>>> &&const __and_<is_array<file_stats>, __not_<extent<file_stats, 0U>>>const __and_<is_array<file_stats>, __not_<extent<file_stats, 0U>>> &is_void<file_stats>is_void<file_stats> &is_void<file_stats> &&const is_void<file_stats>const is_void<file_stats> &__and_<is_array<basic_string<char, char_traits<char>, allocator<char>> *>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>>__and_<is_array<basic_string<char, char_traits<char>, allocator<char>> *>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>> &__and_<is_array<basic_string<char, char_traits<char>, allocator<char>> *>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>> &&const __and_<is_array<basic_string<char, char_traits<char>, allocator<char>> *>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>>const __and_<is_array<basic_string<char, char_traits<char>, allocator<char>> *>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>> &is_void<basic_string<char, char_traits<char>, allocator<char>> *>is_void<basic_string<char, char_traits<char>, allocator<char>> *> &is_void<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_void<basic_string<char, char_traits<char>, allocator<char>> *>const is_void<basic_string<char, char_traits<char>, allocator<char>> *> &is_function<basic_string<char, char_traits<char>, allocator<char>> *>is_function<basic_string<char, char_traits<char>, allocator<char>> *> &is_function<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_function<basic_string<char, char_traits<char>, allocator<char>> *>const is_function<basic_string<char, char_traits<char>, allocator<char>> *> &is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>> &is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>> &&const is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>>const is_member_pointer<basic_string<char, char_traits<char>, allocator<char>>> &is_pointer<basic_string<char, char_traits<char>, allocator<char>>>is_pointer<basic_string<char, char_traits<char>, allocator<char>>> &is_pointer<basic_string<char, char_traits<char>, allocator<char>>> &&const is_pointer<basic_string<char, char_traits<char>, allocator<char>>>const is_pointer<basic_string<char, char_traits<char>, allocator<char>>> &is_enum<basic_string<char, char_traits<char>, allocator<char>>>is_enum<basic_string<char, char_traits<char>, allocator<char>>> &is_enum<basic_string<char, char_traits<char>, allocator<char>>> &&const is_enum<basic_string<char, char_traits<char>, allocator<char>>>const is_enum<basic_string<char, char_traits<char>, allocator<char>>> &__and_<is_array<basic_string<char, char_traits<char>, allocator<char>>>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>>__and_<is_array<basic_string<char, char_traits<char>, allocator<char>>>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>> &__and_<is_array<basic_string<char, char_traits<char>, allocator<char>>>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>> &&const __and_<is_array<basic_string<char, char_traits<char>, allocator<char>>>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>>const __and_<is_array<basic_string<char, char_traits<char>, allocator<char>>>, __not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>> &is_void<basic_string<char, char_traits<char>, allocator<char>>>is_void<basic_string<char, char_traits<char>, allocator<char>>> &is_void<basic_string<char, char_traits<char>, allocator<char>>> &&const is_void<basic_string<char, char_traits<char>, allocator<char>>>const is_void<basic_string<char, char_traits<char>, allocator<char>>> &is_function<unsigned char *>is_function<unsigned char *> &is_function<unsigned char *> &&const is_function<unsigned char *>const is_function<unsigned char *> &__and_<is_array<unsigned char>, __not_<extent<unsigned char, 0U>>>__and_<is_array<unsigned char>, __not_<extent<unsigned char, 0U>>> &__and_<is_array<unsigned char>, __not_<extent<unsigned char, 0U>>> &&const __and_<is_array<unsigned char>, __not_<extent<unsigned char, 0U>>>const __and_<is_array<unsigned char>, __not_<extent<unsigned char, 0U>>> &is_void<unsigned char>is_void<unsigned char> &is_void<unsigned char> &&const is_void<unsigned char>const is_void<unsigned char> &is_function<input_iterator_tag>is_function<input_iterator_tag> &is_function<input_iterator_tag> &&const is_function<input_iterator_tag>const is_function<input_iterator_tag> &is_function<const char *>is_function<const char *> &is_function<const char *> &&const is_function<const char *>const is_function<const char *> &is_function<const basic_string<char, char_traits<char>, allocator<char>> *>is_function<const basic_string<char, char_traits<char>, allocator<char>> *> &is_function<const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_function<const basic_string<char, char_traits<char>, allocator<char>> *>const is_function<const basic_string<char, char_traits<char>, allocator<char>> *> &is_function<basic_string_view<char, char_traits<char>>>is_function<basic_string_view<char, char_traits<char>>> &is_function<basic_string_view<char, char_traits<char>>> &&const is_function<basic_string_view<char, char_traits<char>>>const is_function<basic_string_view<char, char_traits<char>>> &is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>is_convertibleis_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>const is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *> &__and_<is_array<allocator<char>>, __not_<extent<allocator<char>, 0U>>>__and_<is_array<allocator<char>>, __not_<extent<allocator<char>, 0U>>> &__and_<is_array<allocator<char>>, __not_<extent<allocator<char>, 0U>>> &&const __and_<is_array<allocator<char>>, __not_<extent<allocator<char>, 0U>>>const __and_<is_array<allocator<char>>, __not_<extent<allocator<char>, 0U>>> &is_void<allocator<char>>is_void<allocator<char>> &is_void<allocator<char>> &&const is_void<allocator<char>>const is_void<allocator<char>> &is_function<allocator<char>>is_function<allocator<char>> &is_function<allocator<char>> &&const is_function<allocator<char>>const is_function<allocator<char>> &__and_<is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>>__and_<is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>> &__and_<is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>> &&const __and_<is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>>const __and_<is_array<allocator<basic_string<char, char_traits<char>, allocator<char>>>>, __not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>> &is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const is_void<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const is_function<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__and_<is_array<char32_t>, __not_<extent<char32_t, 0U>>>__and_<is_array<char32_t>, __not_<extent<char32_t, 0U>>> &__and_<is_array<char32_t>, __not_<extent<char32_t, 0U>>> &&const __and_<is_array<char32_t>, __not_<extent<char32_t, 0U>>>const __and_<is_array<char32_t>, __not_<extent<char32_t, 0U>>> &is_void<char32_t>is_void<char32_t> &is_void<char32_t> &&const is_void<char32_t>const is_void<char32_t> &is_function<char32_t>is_function<char32_t> &is_function<char32_t> &&const is_function<char32_t>const is_function<char32_t> &__and_<is_array<char16_t>, __not_<extent<char16_t, 0U>>>__and_<is_array<char16_t>, __not_<extent<char16_t, 0U>>> &__and_<is_array<char16_t>, __not_<extent<char16_t, 0U>>> &&const __and_<is_array<char16_t>, __not_<extent<char16_t, 0U>>>const __and_<is_array<char16_t>, __not_<extent<char16_t, 0U>>> &is_void<char16_t>is_void<char16_t> &is_void<char16_t> &&const is_void<char16_t>const is_void<char16_t> &is_function<char16_t>is_function<char16_t> &is_function<char16_t> &&const is_function<char16_t>const is_function<char16_t> &__and_<is_array<wchar_t>, __not_<extent<wchar_t, 0U>>>__and_<is_array<wchar_t>, __not_<extent<wchar_t, 0U>>> &__and_<is_array<wchar_t>, __not_<extent<wchar_t, 0U>>> &&const __and_<is_array<wchar_t>, __not_<extent<wchar_t, 0U>>>const __and_<is_array<wchar_t>, __not_<extent<wchar_t, 0U>>> &is_void<wchar_t>is_void<wchar_t> &is_void<wchar_t> &&const is_void<wchar_t>const is_void<wchar_t> &is_function<wchar_t>is_function<wchar_t> &is_function<wchar_t> &&const is_function<wchar_t>const is_function<wchar_t> &__and_<is_array<char>, __not_<extent<char, 0U>>>__and_<is_array<char>, __not_<extent<char, 0U>>> &__and_<is_array<char>, __not_<extent<char, 0U>>> &&const __and_<is_array<char>, __not_<extent<char, 0U>>>const __and_<is_array<char>, __not_<extent<char, 0U>>> &is_void<char>is_void<char> &is_void<char> &&const is_void<char>const is_void<char> &is_function<char>is_function<char> &is_function<char> &&const is_function<char>const is_function<char> &polymorphic_allocator<_CharT>is_convertible<_Up, const volatile void *>is_convertible<_Tp, const volatile void *>__normal_iterator<_Iter, vector<unsigned char, allocator<unsigned char>>>remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>remove_reference<basic_string<char, char_traits<char>, allocator<char>> &> &remove_reference<basic_string<char, char_traits<char>, allocator<char>> &> &&const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &> &remove_reference<allocator<char> &>remove_reference<allocator<char> &> &remove_reference<allocator<char> &> &&const remove_reference<allocator<char> &>const remove_reference<allocator<char> &> &rebind<file_stats>rebind<file_stats> &rebind<file_stats> &&const rebind<file_stats>const rebind<file_stats> &iterator_traits<unsigned char *>iterator_traits<unsigned char *> &iterator_traits<unsigned char *> &&const iterator_traits<unsigned char *>const iterator_traits<unsigned char *> &__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp)_S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{})is_nothrow_destructible<_Up>::valueconst __normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>> *__normal_iterator<file_stats *, vector<file_stats, allocator<file_stats>>> *__pocca::value_Base_type::propagate_on_container_copy_assignment::valueconst __normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *__is_trivial(_ValueType1)_GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType2, _From)const char *const &const wchar_t *constconst wchar_t *const &const char16_t *constconst char16_t *const &char16_t *&const char32_t *constconst char32_t *const &char32_t *&std::size_t(__PTRDIFF_MAX__)std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp)230584300921369395128823037615171174388686269585142075__pocma::value_Base_type::is_always_equal::value_Base_type::propagate_on_container_move_assignment::value_S_propagate_on_move_assign()_S_propagate_on_move_assign() || _S_always_equal()pointer_traits<const char *>pointer_traits<const char *> &pointer_traits<const char *> &&const pointer_traits<const char *>const pointer_traits<const char *> &is_nothrow_default_constructible<allocator<basic_string<char, char_traits<char>, allocator<char>>>>is_nothrow_default_constructible<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_nothrow_default_constructible<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_nothrow_default_constructible<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const is_nothrow_default_constructible<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &__uninitialized_copy<false>__uninitialized_copy<false> &__uninitialized_copy<false> &&const __uninitialized_copy<false>const __uninitialized_copy<false> &_Destroy_aux<false>_Destroy_aux<false> &_Destroy_aux<false> &&const _Destroy_aux<false>const _Destroy_aux<false> &is_nothrow_destructible<basic_string<char, char_traits<char>, allocator<char>>>is_nothrow_destructibleis_nothrow_destructible<basic_string<char, char_traits<char>, allocator<char>>> &is_nothrow_destructible<basic_string<char, char_traits<char>, allocator<char>>> &&const is_nothrow_destructible<basic_string<char, char_traits<char>, allocator<char>>>const is_nothrow_destructible<basic_string<char, char_traits<char>, allocator<char>>> &__is_constructible_impl<file_stats, file_stats &&>__is_constructible_impl<file_stats, file_stats &&> &__is_constructible_impl<file_stats, file_stats &&> &&const __is_constructible_impl<file_stats, file_stats &&>const __is_constructible_impl<file_stats, file_stats &&> &__is_move_constructible_impl<file_stats, true>__is_move_constructible_impl<file_stats, true> &__is_move_constructible_impl<file_stats, true> &&const __is_move_constructible_impl<file_stats, true>const __is_move_constructible_impl<file_stats, true> &is_move_constructible<file_stats>is_move_constructible<file_stats> &is_move_constructible<file_stats> &&const is_move_constructible<file_stats>const is_move_constructible<file_stats> &__is_move_insertable<allocator<file_stats>>__is_move_insertable__is_move_insertable<allocator<file_stats>> &__is_move_insertable<allocator<file_stats>> &&const __is_move_insertable<allocator<file_stats>>const __is_move_insertable<allocator<file_stats>> &is_nothrow_destructible<file_stats>is_nothrow_destructible<file_stats> &is_nothrow_destructible<file_stats> &&const is_nothrow_destructible<file_stats>const is_nothrow_destructible<file_stats> &__is_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> &&>__is_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> &&> &__is_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> &&> &&const __is_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> &&>const __is_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>> &&> &__is_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, true>__is_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, true> &__is_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, true> &&const __is_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, true>const __is_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>>, true> &is_move_constructible<basic_string<char, char_traits<char>, allocator<char>>>is_move_constructible<basic_string<char, char_traits<char>, allocator<char>>> &is_move_constructible<basic_string<char, char_traits<char>, allocator<char>>> &&const is_move_constructible<basic_string<char, char_traits<char>, allocator<char>>>const is_move_constructible<basic_string<char, char_traits<char>, allocator<char>>> &__is_move_insertable<allocator<basic_string<char, char_traits<char>, allocator<char>>>>__is_move_insertable<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__is_move_insertable<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&const __is_move_insertable<allocator<basic_string<char, char_traits<char>, allocator<char>>>>const __is_move_insertable<allocator<basic_string<char, char_traits<char>, allocator<char>>>> &__and_<is_same<file_stats *, _Ptr>, __not_<is_pointer<_Ptr>>>is_pointer<_Ptr>__not_<extent<char, 0U>>__not_<extent<wchar_t, 0U>>__not_<extent<char16_t, 0U>>__not_<extent<char32_t, 0U>>__not_<extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>>__not_<extent<allocator<char>, 0U>>__not_<extent<unsigned char, 0U>>__not_<extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>>__not_<extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>>__not_<extent<file_stats, 0U>>__not_<extent<file_stats *, 0U>>__normal_iterator<_Iter, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>rebind<char32_t>rebind<char32_t> &rebind<char32_t> &&const rebind<char32_t>const rebind<char32_t> &__normal_iterator<_Iter, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>rebind<char16_t>rebind<char16_t> &rebind<char16_t> &&const rebind<char16_t>const rebind<char16_t> &__normal_iterator<_Iter, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>rebind<wchar_t>rebind<wchar_t> &rebind<wchar_t> &&const rebind<wchar_t>const rebind<wchar_t> &__normal_iterator<_Iter, basic_string<char, char_traits<char>, allocator<char>>>_Char_types<wchar_t>_Char_types<wchar_t> &_Char_types<wchar_t> &&const _Char_types<wchar_t>const _Char_types<wchar_t> &_Char_types<char>_Char_types<char> &_Char_types<char> &&const _Char_types<char>const _Char_types<char> &__and_<is_same<char *, _Ptr>, __not_<is_pointer<_Ptr>>>__normal_iterator<_Iter, vector<file_stats, allocator<file_stats>>>__and_<is_same<basic_string<char, char_traits<char>, allocator<char>> *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<const basic_string<char, char_traits<char>, allocator<char>> *>iterator_traits<const basic_string<char, char_traits<char>, allocator<char>> *> &iterator_traits<const basic_string<char, char_traits<char>, allocator<char>> *> &&const iterator_traits<const basic_string<char, char_traits<char>, allocator<char>> *>const iterator_traits<const basic_string<char, char_traits<char>, allocator<char>> *> &__and_<is_same<unsigned char *, _Ptr>, __not_<is_pointer<_Ptr>>>__ptr_traits_ptr_to<char32_t *, char32_t, false>__ptr_traits_ptr_to<char32_t *, char32_t, false> &__ptr_traits_ptr_to<char32_t *, char32_t, false> &&const __ptr_traits_ptr_to<char32_t *, char32_t, false>const __ptr_traits_ptr_to<char32_t *, char32_t, false> &iterator_traits<const char32_t *>iterator_traits<const char32_t *> &iterator_traits<const char32_t *> &&const iterator_traits<const char32_t *>const iterator_traits<const char32_t *> &__ptr_traits_ptr_to<char16_t *, char16_t, false>__ptr_traits_ptr_to<char16_t *, char16_t, false> &__ptr_traits_ptr_to<char16_t *, char16_t, false> &&const __ptr_traits_ptr_to<char16_t *, char16_t, false>const __ptr_traits_ptr_to<char16_t *, char16_t, false> &iterator_traits<const char16_t *>iterator_traits<const char16_t *> &iterator_traits<const char16_t *> &&const iterator_traits<const char16_t *>const iterator_traits<const char16_t *> &__ptr_traits_ptr_to<wchar_t *, wchar_t, false>__ptr_traits_ptr_to<wchar_t *, wchar_t, false> &__ptr_traits_ptr_to<wchar_t *, wchar_t, false> &&const __ptr_traits_ptr_to<wchar_t *, wchar_t, false>const __ptr_traits_ptr_to<wchar_t *, wchar_t, false> &iterator_traits<const wchar_t *>iterator_traits<const wchar_t *> &iterator_traits<const wchar_t *> &&const iterator_traits<const wchar_t *>const iterator_traits<const wchar_t *> &iterator_traits<wchar_t *>iterator_traits<wchar_t *> &iterator_traits<wchar_t *> &&const iterator_traits<wchar_t *>const iterator_traits<wchar_t *> &remove_reference<basic_string<char, char_traits<char>, allocator<char>>>remove_reference<basic_string<char, char_traits<char>, allocator<char>>> &remove_reference<basic_string<char, char_traits<char>, allocator<char>>> &&const remove_reference<basic_string<char, char_traits<char>, allocator<char>>>const remove_reference<basic_string<char, char_traits<char>, allocator<char>>> &iterator_traits<const char *>iterator_traits<const char *> &iterator_traits<const char *> &&const iterator_traits<const char *>const iterator_traits<const char *> &remove_reference<const file_stats &>remove_reference<const file_stats &> &remove_reference<const file_stats &> &&const remove_reference<const file_stats &>const remove_reference<const file_stats &> &remove_reference<const basic_string<char, char_traits<char>, allocator<char>> &>remove_reference<const basic_string<char, char_traits<char>, allocator<char>> &> &remove_reference<const basic_string<char, char_traits<char>, allocator<char>> &> &&const remove_reference<const basic_string<char, char_traits<char>, allocator<char>> &>const remove_reference<const basic_string<char, char_traits<char>, allocator<char>> &> &__ptr_traits_ptr_to<char *, char, false>__ptr_traits_ptr_to<char *, char, false> &__ptr_traits_ptr_to<char *, char, false> &&const __ptr_traits_ptr_to<char *, char, false>const __ptr_traits_ptr_to<char *, char, false> &iterator_traits<char *>iterator_traits<char *> &iterator_traits<char *> &&const iterator_traits<char *>const iterator_traits<char *> &std::is_nothrow_destructible<_Up>::valuefile_stats *&&noexcept(std::__relocate_a(std::declval<pointer>(),
					  std::declval<pointer>(),
					  std::declval<pointer>(),
					  std::declval<_Tp_alloc_type&>()))noexcept(__relocate_a_1(std::__niter_base(__first),
				     std::__niter_base(__last),
				     std::__niter_base(__result), __alloc))basic_string<char, char_traits<char>, allocator<char>> *&&__and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value__and_<is_integral<unsigned long>, is_copy_assignable<unsigned char>>__and_<is_integral<unsigned long>, is_copy_assignable<unsigned char>> &__and_<is_integral<unsigned long>, is_copy_assignable<unsigned char>> &&const __and_<is_integral<unsigned long>, is_copy_assignable<unsigned char>>const __and_<is_integral<unsigned long>, is_copy_assignable<unsigned char>> &is_same<unsigned char *, _Ptr>is_same<basic_string<char, char_traits<char>, allocator<char>> *, _Ptr>iterator_traits<file_stats *>iterator_traits<file_stats *> &iterator_traits<file_stats *> &&const iterator_traits<file_stats *>const iterator_traits<file_stats *> &is_same<char *, _Ptr>__and_<is_same<wchar_t *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<char16_t *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<char16_t *>iterator_traits<char16_t *> &iterator_traits<char16_t *> &&const iterator_traits<char16_t *>const iterator_traits<char16_t *> &__and_<is_same<char32_t *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<char32_t *>iterator_traits<char32_t *> &iterator_traits<char32_t *> &&const iterator_traits<char32_t *>const iterator_traits<char32_t *> &extent<file_stats *, 0U>extent<file_stats, 0U>extent<basic_string<char, char_traits<char>, allocator<char>> *, 0U>extent<basic_string<char, char_traits<char>, allocator<char>>, 0U>extent<unsigned char, 0U>__is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *, false>__is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &__is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &&const __is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *, false>const __is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &extent<allocator<char>, 0U>extent<allocator<basic_string<char, char_traits<char>, allocator<char>>>, 0U>extent<char32_t, 0U>extent<char16_t, 0U>extent<wchar_t, 0U>extent<char, 0U>is_same<file_stats *, _Ptr>__is_referenceable<basic_string<char, char_traits<char>, allocator<char>>, void>__is_referenceable<basic_string<char, char_traits<char>, allocator<char>>, void> &__is_referenceable<basic_string<char, char_traits<char>, allocator<char>>, void> &&const __is_referenceable<basic_string<char, char_traits<char>, allocator<char>>, void>const __is_referenceable<basic_string<char, char_traits<char>, allocator<char>>, void> &__is_referenceable<file_stats, void>__is_referenceable<file_stats, void> &__is_referenceable<file_stats, void> &&const __is_referenceable<file_stats, void>const __is_referenceable<file_stats, void> &__iterator_traits<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, void>__iterator_traits<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, void> &__iterator_traits<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, void> &&const __iterator_traits<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, void>const __iterator_traits<__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, void> &__ptr_traits_ptr_to<const char *, const char, false>__ptr_traits_ptr_to<const char *, const char, false> &__ptr_traits_ptr_to<const char *, const char, false> &&const __ptr_traits_ptr_to<const char *, const char, false>const __ptr_traits_ptr_to<const char *, const char, false> &noexcept(std::__relocate_object_a(std::addressof(*__result),
					       std::addressof(*__first),
					       __alloc))pointer_traits<const char32_t *>pointer_traits<const char32_t *> &pointer_traits<const char32_t *> &&const pointer_traits<const char32_t *>const pointer_traits<const char32_t *> &pointer_traits<const char16_t *>pointer_traits<const char16_t *> &pointer_traits<const char16_t *> &&const pointer_traits<const char16_t *>const pointer_traits<const char16_t *> &pointer_traits<const wchar_t *>pointer_traits<const wchar_t *> &pointer_traits<const wchar_t *> &&const pointer_traits<const wchar_t *>const pointer_traits<const wchar_t *> &is_nothrow_copy_constructible<file_stats *>is_nothrow_copy_constructibleis_nothrow_copy_constructible<file_stats *> &is_nothrow_copy_constructible<file_stats *> &&const is_nothrow_copy_constructible<file_stats *>const is_nothrow_copy_constructible<file_stats *> &is_nothrow_copy_constructible<basic_string<char, char_traits<char>, allocator<char>> *>is_nothrow_copy_constructible<basic_string<char, char_traits<char>, allocator<char>> *> &is_nothrow_copy_constructible<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_nothrow_copy_constructible<basic_string<char, char_traits<char>, allocator<char>> *>const is_nothrow_copy_constructible<basic_string<char, char_traits<char>, allocator<char>> *> &is_void<const char>is_void<const char> &is_void<const char> &&const is_void<const char>const is_void<const char> &__or_<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &is_same<char32_t *, _Ptr>is_same<char16_t *, _Ptr>is_same<wchar_t *, _Ptr>__enable_if<true, void>__is_byte<_Tp>::__value__enable_if<true, void> &__enable_if<true, void> &&const __enable_if<true, void>const __enable_if<true, void> &is_copy_assignable<unsigned char>is_copy_assignableis_copy_assignable<unsigned char> &is_copy_assignable<unsigned char> &&const is_copy_assignable<unsigned char>const is_copy_assignable<unsigned char> &is_integral<unsigned long>is_integral<unsigned long> &is_integral<unsigned long> &&const is_integral<unsigned long>const is_integral<unsigned long> &file_stats *__restrict__noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
			 __dest, std::move(*__orig)))noexcept(std::allocator_traits<_Allocator>::destroy(
			    __alloc, std::__addressof(*__orig)))noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
			 __dest, std::move(*__orig)))
	     && noexcept(std::allocator_traits<_Allocator>::destroy(
			    __alloc, std::__addressof(*__orig)))basic_string<char, char_traits<char>, allocator<char>> *__restrict__is_void<const basic_string<char, char_traits<char>, allocator<char>> *>is_void<const basic_string<char, char_traits<char>, allocator<char>> *> &is_void<const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_void<const basic_string<char, char_traits<char>, allocator<char>> *>const is_void<const basic_string<char, char_traits<char>, allocator<char>> *> &__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> &__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> &&const __ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>const __ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> &__ptr_traits_ptr_to<const char16_t *, const char16_t, false>__ptr_traits_ptr_to<const char16_t *, const char16_t, false> &__ptr_traits_ptr_to<const char16_t *, const char16_t, false> &&const __ptr_traits_ptr_to<const char16_t *, const char16_t, false>const __ptr_traits_ptr_to<const char16_t *, const char16_t, false> &__ptr_traits_ptr_to<const char32_t *, const char32_t, false>__ptr_traits_ptr_to<const char32_t *, const char32_t, false> &__ptr_traits_ptr_to<const char32_t *, const char32_t, false> &&const __ptr_traits_ptr_to<const char32_t *, const char32_t, false>const __ptr_traits_ptr_to<const char32_t *, const char32_t, false> &is_nothrow_constructible<file_stats, file_stats>is_nothrow_constructible<file_stats, file_stats> &is_nothrow_constructible<file_stats, file_stats> &&const is_nothrow_constructible<file_stats, file_stats>const is_nothrow_constructible<file_stats, file_stats> &is_void<const char32_t>is_void<const char32_t> &is_void<const char32_t> &&const is_void<const char32_t>const is_void<const char32_t> &is_void<const char16_t>is_void<const char16_t> &is_void<const char16_t> &&const is_void<const char16_t>const is_void<const char16_t> &is_void<const wchar_t>is_void<const wchar_t> &is_void<const wchar_t> &&const is_void<const wchar_t>const is_void<const wchar_t> &remove_reference<file_stats &>remove_reference<file_stats &> &remove_reference<file_stats &> &&const remove_reference<file_stats &>const remove_reference<file_stats &> &remove_reference<file_stats>remove_reference<file_stats> &remove_reference<file_stats> &&const remove_reference<file_stats>const remove_reference<file_stats> &__not_<is_signed<unsigned int>>__not_<is_signed<unsigned int>> &__not_<is_signed<unsigned int>> &&const __not_<is_signed<unsigned int>>const __not_<is_signed<unsigned int>> &__not_<is_signed<unsigned long>>__not_<is_signed<unsigned long>> &__not_<is_signed<unsigned long>> &&const __not_<is_signed<unsigned long>>const __not_<is_signed<unsigned long>> &is_integral<unsigned long long>is_integral<unsigned long long> &is_integral<unsigned long long> &&const is_integral<unsigned long long>const is_integral<unsigned long long> &__not_<is_signed<unsigned long long>>__not_<is_signed<unsigned long long>> &__not_<is_signed<unsigned long long>> &&const __not_<is_signed<unsigned long long>>const __not_<is_signed<unsigned long long>> &__and_<__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[2], const char *>>>__and_<__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[2], const char *>>> &__and_<__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[2], const char *>>> &&const __and_<__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[2], const char *>>>const __and_<__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[2], const char *>>> &__not_<is_convertible<const char(&)[2], const char *>>__not_<is_convertible<const char(&)[2], const char *>> &__not_<is_convertible<const char(&)[2], const char *>> &&const __not_<is_convertible<const char(&)[2], const char *>>const __not_<is_convertible<const char(&)[2], const char *>> &__and_<__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[256], const char *>>>__and_<__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[256], const char *>>> &__and_<__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[256], const char *>>> &&const __and_<__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[256], const char *>>>const __and_<__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char(&)[256], const char *>>> &__not_<is_convertible<const char(&)[256], const char *>>__not_<is_convertible<const char(&)[256], const char *>> &__not_<is_convertible<const char(&)[256], const char *>> &&const __not_<is_convertible<const char(&)[256], const char *>>const __not_<is_convertible<const char(&)[256], const char *>> &__and_<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>>__and_<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>> &__and_<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>> &&const __and_<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>>const __and_<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>> &__and_<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char *const &, const char *>>>__and_<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char *const &, const char *>>> &__and_<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char *const &, const char *>>> &&const __and_<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char *const &, const char *>>>const __and_<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const char *const &, const char *>>> &__not_<is_convertible<const char *const &, const char *>>__not_<is_convertible<const char *const &, const char *>> &__not_<is_convertible<const char *const &, const char *>> &&const __not_<is_convertible<const char *const &, const char *>>const __not_<is_convertible<const char *const &, const char *>> &__and_<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<char *const &, const char *>>>__and_<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<char *const &, const char *>>> &__and_<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<char *const &, const char *>>> &&const __and_<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<char *const &, const char *>>>const __and_<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<char *const &, const char *>>> &__not_<is_convertible<char *const &, const char *>>__not_<is_convertible<char *const &, const char *>> &__not_<is_convertible<char *const &, const char *>> &&const __not_<is_convertible<char *const &, const char *>>const __not_<is_convertible<char *const &, const char *>> &is_integral<unsigned char>is_integral<unsigned char> &is_integral<unsigned char> &&const is_integral<unsigned char>const is_integral<unsigned char> &is_arithmetic<unsigned char>is_arithmeticis_arithmetic<unsigned char> &is_arithmetic<unsigned char> &&const is_arithmetic<unsigned char>const is_arithmetic<unsigned char> &__not_<is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>>__not_<is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_pointer<file_stats *>>__not_<is_pointer<file_stats *>> &__not_<is_pointer<file_stats *>> &&const __not_<is_pointer<file_stats *>>const __not_<is_pointer<file_stats *>> &is_pointer<file_stats *>is_pointer<file_stats *> &is_pointer<file_stats *> &&const is_pointer<file_stats *>const is_pointer<file_stats *> &is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>is_pointer<basic_string<char, char_traits<char>, allocator<char>> *> &is_pointer<basic_string<char, char_traits<char>, allocator<char>> *> &&const is_pointer<basic_string<char, char_traits<char>, allocator<char>> *>const is_pointer<basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<char *const &, const char *>is_convertible<char *const &, const char *> &is_convertible<char *const &, const char *> &&const is_convertible<char *const &, const char *>const is_convertible<char *const &, const char *> &__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &is_convertible<const char *const &, const char *>is_convertible<const char *const &, const char *> &is_convertible<const char *const &, const char *> &&const is_convertible<const char *const &, const char *>const is_convertible<const char *const &, const char *> &__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>>is_convertible<const char(&)[256], const char *>const char[256]const char(&)[256]char(&)[256]is_convertible<const char(&)[256], const char *> &is_convertible<const char(&)[256], const char *> &&const is_convertible<const char(&)[256], const char *>const is_convertible<const char(&)[256], const char *> &__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>> &is_convertible<const char(&)[2], const char *>const char(&)[2]is_convertible<const char(&)[2], const char *> &is_convertible<const char(&)[2], const char *> &&const is_convertible<const char(&)[2], const char *>const is_convertible<const char(&)[2], const char *> &__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>> &__not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>>const __not_<is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>> &is_signed<unsigned long long>is_signed<unsigned long long> &is_signed<unsigned long long> &&const is_signed<unsigned long long>const is_signed<unsigned long long> &is_signed<unsigned long>is_signed<unsigned long> &is_signed<unsigned long> &&const is_signed<unsigned long>const is_signed<unsigned long> &is_signed<unsigned int>is_signed<unsigned int> &is_signed<unsigned int> &&const is_signed<unsigned int>const is_signed<unsigned int> &is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>const char(*)[2]char(*)[2]is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *>const is_convertible<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>const char(*)[256]char(*)[256]is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *>const is_convertible<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, const char *>is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>const is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &&const is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>const is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *> &__is_convertible_helper<char *const &, const char *, false>__or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value__is_convertible_helper<char *const &, const char *, false> &__is_convertible_helper<char *const &, const char *, false> &&const __is_convertible_helper<char *const &, const char *, false>const __is_convertible_helper<char *const &, const char *, false> &__is_convertible_helper<const char *const &, const char *, false>__is_convertible_helper<const char *const &, const char *, false> &__is_convertible_helper<const char *const &, const char *, false> &&const __is_convertible_helper<const char *const &, const char *, false>const __is_convertible_helper<const char *const &, const char *, false> &__is_convertible_helper<const char(&)[256], const char *, false>__is_convertible_helper<const char(&)[256], const char *, false> &__is_convertible_helper<const char(&)[256], const char *, false> &&const __is_convertible_helper<const char(&)[256], const char *, false>const __is_convertible_helper<const char(&)[256], const char *, false> &__is_convertible_helper<const char(&)[2], const char *, false>__is_convertible_helper<const char(&)[2], const char *, false> &__is_convertible_helper<const char(&)[2], const char *, false> &&const __is_convertible_helper<const char(&)[2], const char *, false>const __is_convertible_helper<const char(&)[2], const char *, false> &__is_convertible_helper<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *, false>__is_convertible_helper<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *, false> &__is_convertible_helper<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *, false> &&const __is_convertible_helper<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *, false>const __is_convertible_helper<const char(*)[2], const basic_string<char, char_traits<char>, allocator<char>> *, false> &__or_<is_void<const char(&)[2]>, is_function<const char *>, is_array<const char *>>__or_<is_void<const char(&)[2]>, is_function<const char *>, is_array<const char *>> &__or_<is_void<const char(&)[2]>, is_function<const char *>, is_array<const char *>> &&const __or_<is_void<const char(&)[2]>, is_function<const char *>, is_array<const char *>>const __or_<is_void<const char(&)[2]>, is_function<const char *>, is_array<const char *>> &__is_convertible_helper<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *, false>__is_convertible_helper<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *, false> &__is_convertible_helper<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *, false> &&const __is_convertible_helper<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *, false>const __is_convertible_helper<const char(*)[256], const basic_string<char, char_traits<char>, allocator<char>> *, false> &__or_<is_void<const char(&)[256]>, is_function<const char *>, is_array<const char *>>__or_<is_void<const char(&)[256]>, is_function<const char *>, is_array<const char *>> &__or_<is_void<const char(&)[256]>, is_function<const char *>, is_array<const char *>> &&const __or_<is_void<const char(&)[256]>, is_function<const char *>, is_array<const char *>>const __or_<is_void<const char(&)[256]>, is_function<const char *>, is_array<const char *>> &__is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false>__is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &__is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &&const __is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false>const __is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &__or_<is_void<const char *const &>, is_function<const char *>, is_array<const char *>>__or_<is_void<const char *const &>, is_function<const char *>, is_array<const char *>> &__or_<is_void<const char *const &>, is_function<const char *>, is_array<const char *>> &&const __or_<is_void<const char *const &>, is_function<const char *>, is_array<const char *>>const __or_<is_void<const char *const &>, is_function<const char *>, is_array<const char *>> &__is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false>__is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &__is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &&const __is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false>const __is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *, false> &__or_<is_void<char *const &>, is_function<const char *>, is_array<const char *>>__or_<is_void<char *const &>, is_function<const char *>, is_array<const char *>> &__or_<is_void<char *const &>, is_function<const char *>, is_array<const char *>> &&const __or_<is_void<char *const &>, is_function<const char *>, is_array<const char *>>const __or_<is_void<char *const &>, is_function<const char *>, is_array<const char *>> &is_void<char *const &>is_void<char *const &> &is_void<char *const &> &&const is_void<char *const &>const is_void<char *const &> &__or_<is_void<char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &is_void<const char *const &>is_void<const char *const &> &is_void<const char *const &> &&const is_void<const char *const &>const is_void<const char *const &> &__or_<is_void<const char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<const char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<const char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<const char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<const char *const *>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &is_void<const char(&)[256]>is_void<const char(&)[256]> &is_void<const char(&)[256]> &&const is_void<const char(&)[256]>const is_void<const char(&)[256]> &__or_<is_void<const char(*)[256]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<const char(*)[256]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<const char(*)[256]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<const char(*)[256]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<const char(*)[256]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &is_void<const char(&)[2]>is_void<const char(&)[2]> &is_void<const char(&)[2]> &&const is_void<const char(&)[2]>const is_void<const char(&)[2]> &__or_<is_void<const char(*)[2]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>__or_<is_void<const char(*)[2]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &__or_<is_void<const char(*)[2]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &&const __or_<is_void<const char(*)[2]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>>const __or_<is_void<const char(*)[2]>, is_function<const basic_string<char, char_traits<char>, allocator<char>> *>, is_array<const basic_string<char, char_traits<char>, allocator<char>> *>> &is_void<const char(*)[2]>is_void<const char(*)[2]> &is_void<const char(*)[2]> &&const is_void<const char(*)[2]>const is_void<const char(*)[2]> &is_void<const char(*)[256]>is_void<const char(*)[256]> &is_void<const char(*)[256]> &&const is_void<const char(*)[256]>const is_void<const char(*)[256]> &is_void<const char *const *>is_void<const char *const *> &is_void<const char *const *> &&const is_void<const char *const *>const is_void<const char *const *> &is_void<char *const *>is_void<char *const *> &is_void<char *const *> &&const is_void<char *const *>const is_void<char *const *> &timer &timer &&const timer &timerconst timer *timer *// File: timer.h/usr/include/sys/timex.hntp_adjtimentp_gettimentptimeval *ntp_gettimexadjtimexntptimeval &ntptimeval &&const ntptimevalconst ntptimeval &ntptimeval__glibc_reserved4__glibc_reserved3__glibc_reserved2__glibc_reserved1MAXTCTIME_BADTIME_ERRORTIME_WAITTIME_OOPTIME_DELTIME_INSTIME_OKNTP_API_SYS_TIMEX_H(struct ntptimeval *__ntv)"ntp_gettimex"/* sys/timex.h *//* Maximum time constant of the PLL.  *//* bw compat *//* clock not synchronized *//* leap second has occurred *//* leap second in progress *//* delete leap second *//* insert leap second *//* clock synchronized, no leap second *//* Clock states (time_state) *//* estimated error (us) (ro) *//* maximum error (us) (ro) *//* current time (ro) *//* NTP API version *//* These definitions from linux/timex.h as of 2.6.30.  */__tntx__ntv__ntx/home/atharvakale/390r-debugging-setup/p7zip/C/lzham_codec/lzhamtest/timer.cpp<sys/timex.h>cur_timeunsigned long long timer::get_elapsed_us() constdouble timer::get_elapsed_secs() constvoid timer::stop()defined(_XBOX)// File: timer.cpp((expr) ? __ASSERT_VOID_CAST (0) : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/zstd_deps.hZSTD_DEPS_ASSERTZSTD_memset(p,v,l)__builtin_memset((p),(v),(l))ZSTD_memmove(d,s,l)__builtin_memmove((d),(s),(l))ZSTD_memcpy(d,s,l)__builtin_memcpy((d),(s),(l))ZSTD_DEPS_COMMONdefined(__GNUC__) && __GNUC__ >= 4ZSTD_DEPS_NEED_MALLOCZSTD_DEPS_MALLOCZSTD_DEPS_NEED_MATH64ZSTD_DEPS_MATH64ZSTD_DEPS_NEED_ASSERTZSTD_DEPS_NEED_IOZSTD_DEPS_IOZSTD_DEPS_NEED_STDINTZSTD_DEPS_STDINT/* ZSTD_DEPS_NEED_STDINT *//* ZSTD_DEPS_STDINT *//* Only requested when <stdint.h> is known to be present.
 * Need:
 * intptr_t
 *//* ZSTD_DEPS_NEED_IO *//* ZSTD_DEPS_IO *//* Need:
 * ZSTD_DEBUG_PRINT()
 *//* ZSTD_DEPS_NEED_ASSERT *//* ZSTD_DEPS_ASSERT *//* Need:
 * assert()
 *//* ZSTD_DEPS_NEED_MATH64 *//* ZSTD_DEPS_MATH64 *//*
 * Provides 64-bit math support.
 * Need:
 * U64 ZSTD_div64(U64 dividend, U32 divisor)
 *//* ZSTD_DEPS_NEED_MALLOC *//* ZSTD_DEPS_MALLOC *//* Need:
 * ZSTD_malloc()
 * ZSTD_free()
 * ZSTD_calloc()
 *//* ZSTD_DEPS_COMMON *//* Need:
 * NULL
 * INT_MAX
 * UINT_MAX
 * ZSTD_memcpy()
 * ZSTD_memset()
 * ZSTD_memmove()
 *//* This file provides common libc dependencies that zstd requires.
 * The purpose is to allow replacing this file with a custom implementation
 * to compile zstd without libc support.
 *//*
 * Copyright (c) Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/debug.h"zstd_deps.h"DEBUG_STATIC_ASSERT(c)(void)sizeof(char[(c) ? 1 : -1])DEBUG_H_12987983217DEBUGLEVEL(DEBUGLEVEL>=1)(DEBUGLEVEL>=2)/* DEBUG_H_12987983217 *//* the variable is only declared,
                            it actually lives in debug.c,
                            and is shared by the whole process.
                            It's not thread-safe.
                            It's useful when enabling very verbose levels
                            on selective conditions (such as position in src) *//* disable assert (default) *//* assert may be already defined, due to prior #include <assert.h> *//* recommended values for DEBUGLEVEL :
 * 0 : release mode, no debug, all run-time checks disabled
 * 1 : enables assert() only, no display
 * 2 : reserved, for currently active debug path
 * 3 : events once per object lifetime (CCtx, CDict, etc.)
 * 4 : events once per frame
 * 5 : events once per block
 * 6 : events once per sequence (verbose)
 * 7+: events at every position (*very* verbose)
 *
 * It's generally inconvenient to output traces > 5.
 * In which case, it's possible to selectively trigger high verbosity levels
 * by modifying g_debug_level.
 *//* DEBUGLEVEL is expected to be defined externally,
 * typically through compiler command line.
 * Value must be a number. *//* static assert is triggered at compile time, leaving no runtime artefact.
 * static assert only works with compile-time constants.
 * Also, this variant can only be used inside a function. *//*
 * The purpose of this header is to enable debug functions.
 * They regroup assert(), DEBUGLOG() and RAWLOG() for run-time,
 * and DEBUG_STATIC_ASSERT() for compile-time.
 *
 * By default, DEBUGLEVEL==0, which means run-time debug is disabled.
 *
 * Level 1 enables assert() only.
 * Starting level 2, traces can be generated and pushed to stderr.
 * The higher the level, the more verbose the traces.
 *
 * It's possible to dynamically adjust level using variable g_debug_level,
 * which is only declared if DEBUGLEVEL>=2,
 * and is a global variable, not multi-thread protected (use with care)
 *//* ******************************************************************
 * debug
 * Part of FSE library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 * You can contact the author at :
 * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/debug.c"debug.h"g_debuglevel/*
 * This module only hosts one global variable
 * which can be used to dynamically influence the verbosity of traces,
 * such as DEBUGLOG and RAWLOG
 *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/bitstream.hBIT_reloadDStreamFastbitD->ptr < bitD->limitPtrbitD->bitsConsumed <= sizeof(bitD->bitContainer)*8428nbBits >= 1413regMask388regMask+1(regMask+1)nbBits < BIT_MASK_SIZEnbBits < (sizeof(BIT_mask) / sizeof(BIT_mask[0]))const unsigned int[32]358sizeof(bitContainer)sizeof(bitContainer)*8sizeof(bitContainer)*8 - 1340((U64)1)18446744073709551544fallthroughbitC->bitPos < sizeof(bitC->bitContainer) * 8bitC->ptr <= bitC->endPtr(value>>nbBits) == 0nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8BIT_MASK_SIZE == 32(sizeof(BIT_mask) / sizeof(BIT_mask[0])) == 32sizeof(bitC->bitContainer)18446744073709551546limitPtrBIT_MASK_SIZE(sizeof(BIT_mask) / sizeof(BIT_mask[0]))STREAM_ACCUMULATOR_MIN((U32)(MEM_32bits() ? STREAM_ACCUMULATOR_MIN_32 : STREAM_ACCUMULATOR_MIN_64))STREAM_ACCUMULATOR_MIN_64STREAM_ACCUMULATOR_MIN_32ZSTD_NO_INTRINSICSdefined(__ICCARM__)STATIC_BMI2 == 1defined(__x86_64__) || defined(_M_X86)defined(STATIC_BMI2) && STATIC_BMI2 == 1/*! BIT_endOfDStream() :
 * @return : 1 if DStream has _exactly_ reached its end (all bits consumed).
 *//* reminder : srcSize > sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start *//* start < ptr < limitPtr *//* overflow detected, like end of stream *//*! BIT_reloadDStream() :
 *  Refill `bitD` from buffer previously set in BIT_initDStream() .
 *  This function is safe, it guarantees it will not read beyond src buffer.
 * @return : status of `BIT_DStream_t` internal register.
 *           when status == BIT_DStream_unfinished, internal register is filled with at least 25 or 57 bits *//*! BIT_reloadDStreamFast() :
 *  Similar to BIT_reloadDStream(), but with two differences:
 *  1. bitsConsumed <= sizeof(bitD->bitContainer)*8 must hold!
 *  2. Returns BIT_DStream_overflow when bitD->ptr < bitD->limitPtr, at this
 *     point you must use BIT_reloadDStream() to reload.
 *//*! BIT_readBitsFast() :
 *  unsafe version; only works only if nbBits >= 1 *//*! BIT_readBits() :
 *  Read (consume) next n bits from local register and update.
 *  Pay attention to not read more than nbBits contained into local register.
 * @return : extracted value. *//*! BIT_lookBitsFast() :
 *  unsafe version; only works if nbBits >= 1 *//* this code path is slower on my os-x laptop *//* if bitD->bitsConsumed + nbBits > sizeof(bitD->bitContainer)*8,
     * bitstream is likely corrupted, and result is undefined *//* arbitrate between double-shift and shift+mask *//*! BIT_lookBits() :
 *  Provides next n bits from local register.
 *  local register is not modified.
 *  On 32-bits, maxNbBits==24.
 *  On 64-bits, maxNbBits==56.
 * @return : value extracted *//* x86 transform & ((1 << nbBits) - 1) to bzhi instruction, it is better
     * than accessing memory. When bmi2 instruction is not present, we consider
     * such cpus old (pre-Haswell, 2013) and their performance is not of that
     * importance.
     *//* if start > regMask, bitstream is corrupted, and result is undefined *//*! BIT_initDStream() :
 *  Initialize a BIT_DStream_t.
 * `bitD` : a pointer to an already allocated BIT_DStream_t structure.
 * `srcSize` must be the *exact* size of the bitStream, in bytes.
 * @return : size of stream (== srcSize), or an errorCode if a problem is detected
 *//*-********************************************************
*  bitStream decoding
**********************************************************//* overflow detected *//*! BIT_closeCStream() :
 *  @return : size of CStream, in bytes,
 *            or 0 if it could not fit into dstBuffer *//*! BIT_flushBits() :
 *  assumption : bitContainer has not overflowed
 *  safe version; check for buffer overflow, and prevents it.
 *  note : does not signal buffer overflow.
 *  overflow will be revealed later on using BIT_closeCStream() *//*! BIT_flushBitsFast() :
 *  assumption : bitContainer has not overflowed
 *  unsafe version; does not check buffer overflow *//*! BIT_addBitsFast() :
 *  works only if `value` is _clean_,
 *  meaning all high bits above nbBits are 0 *//*! BIT_addBits() :
 *  can add up to 31 bits into `bitC`.
 *  Note : does not check for register overflow ! *//*! BIT_initCStream() :
 *  `dstCapacity` must be > sizeof(size_t)
 *  @return : 0 if success,
 *            otherwise an error code (can be tested using ERR_isError()) *//* up to 31 bits *//* IAR Intrinsic *//* Should not reach this code path *//* bitStream can mix input from multiple sources.
 * A critical property of these streams is that they encode and decode in **reverse** direction.
 * So the first bit sequence you add will be the last to be read, like a LIFO stack.
 *//* assert(), DEBUGLOG(), RAWLOG() *//* UNLIKELY() *//* ******************************************************************
 * bitstream
 * Part of FSE library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 * You can contact the author at :
 * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/fse.hFSE_bitCostminNbBitstableLog < 16576accuracyLog < 31-tableLogdeltaFromThresholdnormalizedDeltaFromThresholdbitMultipliersymbolTT[symbolValue].deltaNbBits + tableSize <= thresholdnormalizedDeltaFromThreshold <= bitMultiplier583FSE_getMaxNbBits(1<<16)-1((1<<16)-1)FSE_decompress_wksp_bmi2FSE_buildDTable_wkspFSE_repeatFSE_repeat_noneFSE_repeat_checkFSE_repeat_valid(((tableSize)>>1) + ((tableSize)>>3) + 3)FSE_DECOMPRESS_WKSP_SIZE(maxTableLog,maxSymbolValue)(FSE_DECOMPRESS_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(unsigned))FSE_DECOMPRESS_WKSP_SIZE_U32(maxTableLog,maxSymbolValue)(FSE_DTABLE_SIZE_U32(maxTableLog) + FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) + (FSE_MAX_SYMBOL_VALUE + 1) / 2 + 1)FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxTableLog,maxSymbolValue)((FSE_BUILD_DTABLE_WKSP_SIZE(maxTableLog, maxSymbolValue) + sizeof(unsigned) - 1) / sizeof(unsigned))FSE_BUILD_DTABLE_WKSP_SIZE(maxTableLog,maxSymbolValue)(sizeof(short) * (maxSymbolValue + 1) + (1ULL << maxTableLog) + 8)FSE_BUILD_CTABLE_WORKSPACE_SIZE(maxSymbolValue,tableLog)(sizeof(unsigned) * FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog))FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue,tableLog)(((maxSymbolValue + 2) + (1ull << (tableLog)))/2 + sizeof(U64)/sizeof(U32) )FSE_COMPRESS_WKSP_SIZE_U32(maxTableLog,maxSymbolValue)( FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) + ((maxTableLog > 12) ? (1 << (maxTableLog - 2)) : 1024) )FSE_DTABLE_SIZE(maxTableLog)(FSE_DTABLE_SIZE_U32(maxTableLog) * sizeof(FSE_DTable))FSE_CTABLE_SIZE(maxTableLog,maxSymbolValue)(FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(FSE_CTable))(1 + (1<<((maxTableLog)-1)) + (((maxSymbolValue)+1)*2))((size) + ((size)>>7) + 4 + sizeof(size_t) )FSE_H_FSE_STATIC_LINKING_ONLYdefined(FSE_STATIC_LINKING_ONLY) && !defined(FSE_H_FSE_STATIC_LINKING_ONLY)(FSE_DEFAULT_MEMORY_USAGE > FSE_MAX_MEMORY_USAGE)FSE_readNCount_bmi2/* linear interpolation (very approximate) *//* ensure enough room for renormalization double shift *//* FSE_bitCost() :
 * Approximate symbol cost, as fractional value, using fixed-point format (accuracyLog fractional bits)
 * note 1 : assume symbolValue is valid (<= maxSymbolValue)
 * note 2 : if freq[symbolValue]==0, @return a fake cost of tableLog+1 bits *//* FSE_getMaxNbBits() :
 * Approximate maximum cost of a symbol, in bits.
 * Fractional get rounded up (i.e : a symbol with a normalized frequency of 3 gives the same result as a frequency of 2)
 * note 1 : assume symbolValue is valid (<= maxSymbolValue)
 * note 2 : if freq[symbolValue]==0, @return a fake cost of tableLog+1 bits *//**< Can use the previous table and it is assumed to be valid *//**< Can use the previous table but it must be checked *//**< Cannot use the previous table *//**< Same as FSE_decompress_wksp() but with dynamic BMI2 support. Pass 1 if your CPU supports BMI2 or 0 if it doesn't. *//**< same as FSE_decompress(), using an externally allocated `workSpace` produced with `FSE_DECOMPRESS_WKSP_SIZE_U32(maxLog, maxSymbolValue)` *//**< Same as FSE_buildDTable(), using an externally allocated `workspace` produced with `FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxSymbolValue)` *//* additional 8 bytes for potential table overwrite *//* FSE_buildCTable_wksp() :
 * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).
 * `wkspSize` must be >= `FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog)` of `unsigned`.
 * See FSE_buildCTable_wksp() for breakdown of workspace usage.
 *//* FSE_compress_wksp() :
 * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).
 * FSE_COMPRESS_WKSP_SIZE_U32() provides the minimum size required for `workSpace` as a table of FSE_CTable.
 *//* *****************************************
 *  FSE advanced API
 ***************************************** *//* or use the size to malloc() space directly. Pay attention to alignment restrictions though *//* bitContainer *//* fse states *//*! FSE_readNCount_bmi2():
 * Same as FSE_readNCount() but pass bmi2=1 when your CPU supports BMI2 and 0 otherwise.
 *//*! FSE_normalizeCount():
    normalize counts so that sum(count[]) == Power_of_2 (2^tableLog)
    'normalizedCounter' is a table of short, of minimum size (maxSymbolValue+1).
    useLowProbCount is a boolean parameter which trades off compressed size for
    faster header decoding. When it is set to 1, the compressed data will be slightly
    smaller. And when it is set to 0, FSE_readNCount() and FSE_buildDTable() will be
    faster. If you are compressing a small amount of data (< 2 KB) then useLowProbCount=0
    is a good default, since header deserialization makes a big speed difference.
    Otherwise, useLowProbCount=1 is a good default, since the speed difference is small.
    @return : tableLog,
              or an errorCode, which can be tested using FSE_isError() *//*!
FSE_compress() does the following:
1. count symbol occurrence from source[] into table count[] (see hist.h)
2. normalize counters so that sum(count[]) == Power_of_2 (2^tableLog)
3. save normalized counters to memory buffer using writeNCount()
4. build encoding table 'CTable' from normalized counters
5. encode the data stream using encoding table 'CTable'

FSE_decompress() does the following:
1. read normalized counters with readNCount()
2. build decoding table 'DTable' from normalized counters
3. decode the data stream using decoding table 'DTable'

The following API allows targeting specific sub-functions for advanced tasks.
For example, it's possible to compress several blocks using the same 'CTable',
or to save and provide normalized distribution using external method.
*//* ******************************************************************
 * FSE : Finite State Entropy codec
 * Public Prototypes declaration
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 * You can contact the author at :
 * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */symbolTTPtraccuracyLogbmi2useLowProbCount/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/huf.hHUF_readDTableX2_wksp_bmi2HUF_readDTableX1_wksp_bmi2HUF_decompress4X_hufOnly_wksp_bmi2HUF_decompress4X_usingDTable_bmi2HUF_decompress1X1_DCtx_wksp_bmi2HUF_decompress1X_usingDTable_bmi2HUF_decompress1X1_usingDTableHUF_decompress1X2_DCtx_wkspHUF_decompress1X1_DCtx_wkspHUF_decompress1X1_DCtxHUF_decompress1X_DCtx_wkspHUF_decompress1X1HUF_compress1X_repeatHUF_repeat *HUF_compress1X_usingCTable_bmi2HUF_decompress4X1_usingDTableHUF_readDTableX2_wkspHUF_readDTableX1_wkspHUF_readDTableX1HUF_getNbBitsFromCTableHUF_compress4X_repeatHUF_validateCTableHUF_estimateCompressedSizeHUF_compress4X_usingCTable_bmi2HUF_writeCTable_wkspHUF_decompress4X2_DCtx_wkspHUF_decompress4X1_DCtx_wkspHUF_decompress4X1_DCtxHUF_decompress4X_hufOnly_wkspHUF_decompress4X1HUF_repeatHUF_repeat_noneHUF_repeat_checkHUF_repeat_validHUF_DECOMPRESS_WORKSPACE_SIZE_U32(HUF_DECOMPRESS_WORKSPACE_SIZE / sizeof(U32))HUF_DECOMPRESS_WORKSPACE_SIZE((2 << 10) + (1 << 9))HUF_READ_STATS_WORKSPACE_SIZE(HUF_READ_STATS_WORKSPACE_SIZE_U32 * sizeof(unsigned))HUF_READ_STATS_WORKSPACE_SIZE_U32FSE_DECOMPRESS_WKSP_SIZE_U32(6, HUF_TABLELOG_MAX-1)HUF_CTABLE_WORKSPACE_SIZE(HUF_CTABLE_WORKSPACE_SIZE_U32 * sizeof(unsigned))HUF_CTABLE_WORKSPACE_SIZE_U32(2*HUF_SYMBOLVALUE_MAX +1 +1)HUF_CREATE_STATIC_DTABLEX1(DTable,maxTableLog)HUF_CElt name[HUF_CTABLE_SIZE_ST(maxSymbolValue)]HUF_CTABLE_SIZE(maxSymbolValue)(HUF_CTABLE_SIZE_ST(maxSymbolValue) * sizeof(size_t))HUF_CTABLE_SIZE_ST(maxSymbolValue)((maxSymbolValue)+2)HUF_H_HUF_STATIC_LINKING_ONLYHUF_WORKSPACE_SIZE_U64(HUF_WORKSPACE_SIZE / sizeof(U64))HUF_WORKSPACE_SIZE((8 << 10) + 512 )defined(HUF_STATIC_LINKING_ONLY) && !defined(HUF_H_HUF_STATIC_LINKING_ONLY)HUF_FORCE_DECOMPRESS_X1HUF_FORCE_DECOMPRESS_X2HUF_readStats_wksp/* BMI2 variants.
 * If the CPU has BMI2 support, pass bmi2=1, otherwise pass bmi2=0.
 *//**< `workSpace` must be aligned on 4-bytes boundaries, `wkspSize` must be >= HUF_WORKSPACE_SIZE *//** HUF_compress1X_repeat() :
 *  Same as HUF_compress1X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none.
 *  If it uses hufTable it does not modify hufTable or repeat.
 *  If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used.
 *  If preferRepeat then the old table will always be used if valid.
 *  If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding *//**< `workSpace` must be a table of at least HUF_WORKSPACE_SIZE_U64 U64 *//* ====================== *//**
 *  The minimum workspace size for the `workSpace` used in
 *  HUF_readDTableX1_wksp() and HUF_readDTableX2_wksp().
 *
 *  The space used depends on HUF_TABLELOG_MAX, ranging from ~1500 bytes when
 *  HUF_TABLE_LOG_MAX=12 to ~1850 bytes when HUF_TABLE_LOG_MAX=15.
 *  Buffer overflow errors may potentially occur if code modifications result in
 *  a required workspace size greater than that specified in the following
 *  macro.
 *//** HUF_selectDecoder() :
 *  Tells which decoder is likely to decode faster,
 *  based on a set of pre-computed metrics.
 * @return : 0==HUF_decompress4X1, 1==HUF_decompress4X2 .
 *  Assumption : 0 < dstSize <= 128 KB *//*
 * HUF_decompress() does the following:
 * 1. select the decompression algorithm (X1, X2) based on pre-computed heuristics
 * 2. build Huffman table from save, using HUF_readDTableX?()
 * 3. decode 1 or 4 segments in parallel using HUF_decompress?X?_usingDTable()
 *//** HUF_getNbBitsFromCTable() :
 *  Read nbBits from CTable symbolTable, for symbol `symbolValue` presumed <= HUF_SYMBOLVALUE_MAX
 *  Note 1 : is not inlined, as HUF_CElt definition is private *//** HUF_readCTable() :
 *  Loading a CTable saved with HUF_writeCTable() *//*! HUF_readStats_wksp() :
 * Same as HUF_readStats() but takes an external workspace which must be
 * 4-byte aligned and its size must be >= HUF_READ_STATS_WORKSPACE_SIZE.
 * If the CPU has BMI2 support, pass bmi2=1, otherwise pass bmi2=0.
 *//*! HUF_readStats() :
 *  Read compact Huffman tree, saved by HUF_writeCTable().
 * `huffWeight` is destination buffer.
 * @return : size read from `src` , or an error Code .
 *  Note : Needed by HUF_readCTable() and HUF_readDTableXn() . *//** HUF_buildCTable_wksp() :
 *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
 * `workSpace` must be aligned on 4-bytes boundaries, and its size must be >= HUF_CTABLE_WORKSPACE_SIZE.
 *//** HUF_compress4X_repeat() :
 *  Same as HUF_compress4X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none.
 *  If it uses hufTable it does not modify hufTable or repeat.
 *  If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used.
 *  If preferRepeat then the old table will always be used if valid.
 *  If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding *//**< Can use the previous table but it must be checked. Note : The previous table must have been constructed by HUF_compress{1, 4}X_repeat *//* @return : maxNbBits; CTable and count can overlap. In which case, CTable will overwrite count content *//*! HUF_compress() does the following:
 *  1. count symbol occurrence from source[] into table count[] using FSE_count() (exposed within "fse.h")
 *  2. (optional) refine tableLog using HUF_optimalTableLog()
 *  3. build Huffman table from count using HUF_buildCTable()
 *  4. save Huffman table to memory buffer using HUF_writeCTable()
 *  5. encode the data stream using HUF_compress4X_usingCTable()
 *
 *  The following API allows targeting specific sub-functions for advanced tasks.
 *  For example, it's possible to compress several blocks using the same 'CTable',
 *  or to save and regenerate 'CTable' using external methods.
 *//* ****************************************
 *  HUF detailed API
 * ****************************************//* Use tables of size_t, for proper alignment *//* consider it an incomplete type *//* this is a private definition, just exposed for allocation and strict aliasing purpose. never EVER access its members directly *//* only true when incompressible is pre-filtered with fast heuristic *//* default tableLog value when none specified *//* max runtime value of tableLog (due to static allocation); can be modified up to HUF_TABLELOG_ABSOLUTEMAX *//* ******************************************************************
 *  WARNING !!
 *  The following section contains advanced and experimental definitions
 *  which shall never be used in the context of a dynamic library,
 *  because they are not guaranteed to remain stable in the future.
 *  Only consider them in association with static linking.
 * *****************************************************************//* sorting scratch space *//** HUF_compress4X_wksp() :
 *  Same as HUF_compress2(), but uses externally allocated `workSpace`.
 * `workspace` must be at least as large as HUF_WORKSPACE_SIZE *//** HUF_compress2() :
 *  Same as HUF_compress(), but offers control over `maxSymbolValue` and `tableLog`.
 * `maxSymbolValue` must be <= HUF_SYMBOLVALUE_MAX .
 * `tableLog` must be `<= HUF_TABLELOG_MAX` . *//** HUF_decompress() :
 *  Decompress HUF data from buffer 'cSrc', of size 'cSrcSize',
 *  into already allocated buffer 'dst', of minimum size 'dstSize'.
 * `originalSize` : **must** be the ***exact*** size of original (uncompressed) data.
 *  Note : in contrast with FSE, HUF_decompress can regenerate
 *         RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data,
 *         because it knows size to regenerate (originalSize).
 * @return : size of regenerated data (== originalSize),
 *           or an error code, which can be tested using HUF_isError()
 *//** HUF_compress() :
 *  Compress content from buffer 'src', of size 'srcSize', into buffer 'dst'.
 * 'dst' buffer must be already allocated.
 *  Compression runs faster if `dstCapacity` >= HUF_compressBound(srcSize).
 * `srcSize` must be <= `HUF_BLOCKSIZE_MAX` == 128 KB.
 * @return : size of compressed data (<= `dstCapacity`).
 *  Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!
 *                   if HUF_isError(return), compression failed (more details using HUF_getErrorName())
 *//* ========================== *//* ***  simple functions  *** *//* not required, just to generate faster code (saves a function pointer load from IAT and an indirect jump) *//* Note : when linking with -fvisibility=hidden on gcc, or by default on Visual,
 *        HUF symbols remain "private" (internal symbols for library only).
 *        Set macro FSE_DLL_EXPORT to 1 if you want HUF symbols visible on DLL interface *//* *** library symbols visibility *** *//* ******************************************************************
 * huff0 huffman codec,
 * part of Finite State Entropy library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 * You can contact the author at :
 * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */hufTablepreferRepeatsuspectUncompressiblesymbolTablehasZeroWeightsworkspaceworkspaceSize/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/mem.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/compiler.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/portability_macros.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/error_private.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/zstd_errors.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/entropy_common.cHUF_readStats_body_bmi2"lzcnt,bmi,bmi2"HUF_readStats_body_defaultHUF_readStats_body(12 + 1) * sizeof(U32)HUF_TABLELOG_MAX-112-1U32[218]unsigned int[218]wksp872sizeof(wksp)FSE_readNCount_body_bmi2FSE_readNCount_body_defaultFSE_readNCount_bodycountSizesizeof(buffer)hbSize >= 8(*maxSVPtr+1) * sizeof(normalizedCounter[0])18446744073709551572ip <= iend-7(bitStream & 3) < 3(bitCount >> 3) <= 3count == -1threshold > 1repeats3 * 1218446744073709551568FSE_ctz/* Avoids the FORCE_INLINE of the _body() function. *//* ZSTD_memset(huffWeight, 0, hwSize);   *//* bmi2 *//* Only possible when there are too many zeros. *//* This branch can be folded into the
                 * threshold update condition because we
                 * know that threshold > 1.
                 *//* When it matters (small blocks), this is a
             * predictable branch, because we don't use -1.
             *//* For first condition to work *//* We don't need to set the normalized count to 0
             * because we already memset the whole buffer to 0.
             *//* This is an error, but break and return an error
             * at the end, because returning out of a loop makes
             * it harder for the compiler to optimize.
             *//* Add the final repeat which isn't 0b11. *//* Count the number of repeats. Each time the
             * 2-bit repeat code is 0b11 there is another
             * repeat.
             * Avoid UB by setting the high bit to 1.
             *//* all symbols not present in NCount have a frequency of 0 *//* This function only works when hbSize >= 8 *//*===   Error Management   ===*//*===   Version   ===*//* ******************************************************************
 * Common functions of New Generation Entropy library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */"portability_macros.h"ZSTD_ALIGNOF(T)__alignof(T)ZSTD_FALLTHROUGH; __attribute__((__fallthrough__))ZSTD_HAS_CPP_ATTRIBUTE(x)ZSTD_HAS_C_ATTRIBUTE(x)ZSTD_ARCH_X86_SSE2STATIC_BMI2UNLIKELY(x)(__builtin_expect((x), 0))LIKELY(x)(__builtin_expect((x), 1))DONT_VECTORIZE__attribute__((optimize("no-tree-vectorize")))BMI2_TARGET_ATTRIBUTETARGET_ATTRIBUTE("lzcnt,bmi,bmi2")static __attribute__((__noinline__))UNUSED_ATTR__attribute__((unused))WIN_CDECLZSTD_COMPILER_H!defined(ZSTD_NO_INLINE)(defined(__GNUC__) && !defined(__STRICT_ANSI__)) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901Ldefined(__GNUC__) || defined(__ICCARM__)defined(__aarch64__)!defined(__INTEL_COMPILER) && !defined(__clang__) && defined(__GNUC__) && !defined(__LCC__)(__GNUC__ == 4 && __GNUC_MINOR__ > 3) || (__GNUC__ >= 5)!defined(ZSTD_NO_INTRINSICS)defined(__SSE2__) || defined(_M_AMD64) || (defined (_M_IX86) && defined(_M_IX86_FP) && (_M_IX86_FP >= 2))defined(__ARM_NEON) || defined(_M_ARM64)defined(ZSTD_ARCH_X86_SSE2)defined(ZSTD_ARCH_ARM_NEON)defined(__STDC_VERSION__) && (__STDC_VERSION__ > 201710L) && defined(__has_c_attribute)defined(__cplusplus) && defined(__has_cpp_attribute)ZSTD_HAS_C_ATTRIBUTE(fallthrough)ZSTD_HAS_CPP_ATTRIBUTE(fallthrough)__has_attribute(__fallthrough__)ZSTD_ALIGNOFdefined(__GNUC__) || defined(_MSC_VER)defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)ZSTD_MEMORY_SANITIZERZSTD_ADDRESS_SANITIZER/* ZSTD_COMPILER_H *//**
 * Marks a memory region (<c>[addr, addr+size)</c>) as addressable.
 *
 * This memory must be previously allocated by your program. Accessing
 * addresses in this region is allowed until this region is poisoned again.
 * This function could unpoison a super-region of <c>[addr, addr+size)</c> due
 * to ASan alignment restrictions.
 *
 * \note This function is not thread-safe because no two threads can
 * poison or unpoison memory in the same memory region simultaneously.
 *
 * \param addr Start of memory region.
 * \param size Size of memory region. *//**
 * Marks a memory region (<c>[addr, addr+size)</c>) as unaddressable.
 *
 * This memory must be previously allocated by your program. Instrumented
 * code is forbidden from accessing addresses in this region until it is
 * unpoisoned. This function is not guaranteed to poison the entire region -
 * it could poison only a subregion of <c>[addr, addr+size)</c> due to ASan
 * alignment restrictions.
 *
 * \note This function is not thread-safe because no two threads can poison or
 * unpoison memory in the same memory region simultaneously.
 *
 * \param addr Start of memory region.
 * \param size Size of memory region. *//* Not all platforms that support asan provide sanitizers/asan_interface.h.
 * We therefore declare the functions we need ourselves, rather than trying to
 * include the header file... *//* Returns the offset of the first (at least partially) poisoned byte in the
   memory range, or -1 if the whole range is good. *//* Make memory region fully uninitialized (without changing its contents).
   This is a legacy interface that does not update origin information. Use
   __msan_allocated_memory() instead. *//* Make memory region fully initialized (without changing its contents). *//* Not all platforms that support msan provide sanitizers/msan_interface.h.
 * We therefore declare the functions we need ourselves, rather than trying to
 * include the header file... *//*-**************************************************************
*  Sanitizer
*****************************************************************//* ZSTD_ALIGNOF *//* No known support for alignof() - imperfect backup *//* C11 support *//* note : this section must come first, before C11,
 * due to a limitation in the kernel source generator *//* covers gcc, clang & MSVC *//* this test was initially positioned in mem.h,
 * but this file is removed (or replaced) for linux kernel
 * so it's now hosted in compiler.h,
 * which remains valid for both user & kernel spaces.
 *//*-**************************************************************
*  Alignment check
*****************************************************************//* Leading semicolon is to satisfy gcc-11 with -pedantic. Without the semicolon
 * gcc complains about: a label can only be part of a statement and a declaration is not a statement.
 *//* Define ZSTD_FALLTHROUGH macro for annotating switch case with the 'fallthrough' attribute.
 * - C23: https://en.cppreference.com/w/c/language/attributes/fallthrough
 * - CPP17: https://en.cppreference.com/w/cpp/language/attributes/fallthrough
 * - Else: __attribute__((__fallthrough__))
 *//* Only use C++ attributes in C++. Some compilers report support for C++
 * attributes when compiling with C.
 *//* C-language Attributes are added in C23. *//* compile time determination of SIMD support *///MSVC does not have a BMI2 specific flag, but every CPU that supports AVX2 also supports BMI2/*Like DYNAMIC_BMI2 but for compile time determination of BMI2 support*//* Tell the compiler that a branch is likely or unlikely.
 * Only use these macros if it causes the compiler to generate better code.
 * If you can remove a LIKELY/UNLIKELY annotation without speed changes in gcc
 * and clang, please do.
 *//* vectorization
 * older GCC (pre gcc-4.3 picked as the cutoff) uses a different syntax,
 * and some compilers, like Intel ICC and MCST LCC, do not support it at all. *//* Target attribute for BMI2 dynamic dispatch.
 * Enable lzcnt, bmi, and bmi2.
 * We test for bmi1 & bmi2. lzcnt is included in bmi1.
 *//* UNUSED_ATTR tells the compiler it is okay if the function is unused. *//**
  On MSVC qsort requires that functions passed into it use the __cdecl calling conversion(CC).
  This explicitly marks such functions as __cdecl so that the code will still compile
  if a CC other than __cdecl has been made the default.
*//*
 * Copyright (c) Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/error_private.cprefix_unknownversion_unsupportedframeParameter_unsupportedframeParameter_windowTooLargeworkSpace_tooSmalldictionary_corrupteddictionary_wrongdictionaryCreation_faileddstBuffer_nullframeIndex_tooLargeseekableIOdstBuffer_wrongsrcBuffer_wrongUnknown frame descriptor"Unknown frame descriptor"Version not supported"Version not supported"Unsupported frame parameter"Unsupported frame parameter"Frame requires too much memory for decoding"Frame requires too much memory for decoding"workSpace buffer is not large enough"workSpace buffer is not large enough"Operation not authorized at current processing stage"Operation not authorized at current processing stage"Dictionary is corrupted"Dictionary is corrupted"Dictionary mismatch"Dictionary mismatch"Cannot create Dictionary from provided samples"Cannot create Dictionary from provided samples"Operation on NULL destination buffer"Operation on NULL destination buffer"Frame index is too large"Frame index is too large"An I/O error occurred when reading/seeking"An I/O error occurred when reading/seeking"Destination buffer is wrong"Destination buffer is wrong"Source buffer is wrong"Source buffer is wrong"ZSTD_STRIP_ERROR_STRINGS/* The purpose of this file is to have a single list of error strings embedded in binary */ZSTD_free(p)free((p))ZSTD_calloc(n,s)calloc((n), (s))ZSTD_malloc(s)/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/fse_decompress.cU32[5380]unsigned int[5380]46084616462046191154525153795380FSE_DECOMPRESS_WKSP_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)21520U32[8322]unsigned int[8322]332803328833292332918322FSE_BUILD_DTABLE_WKSP_SIZE_U32(FSE_TABLELOG_ABSOLUTE_MAX, FSE_MAX_SYMBOL_VALUE)FSE_decompress_wksp_body_bmi2FSE_decompress_wksp_body_defaultFSE_decompress_wksp_bodyFSE_DecompressWksp *FSE_DecompressWksp *const(FSE_MAX_SYMBOL_VALUE + 1) % 2 == 0(255 + 1) % 2 == 0sizeof(*wksp)NCountLength <= cSrcSizeFSE_DTable[1]FSE_buildDTable_internal(wksp->dtable, wksp->ncount, maxSymbolValue, tableLog, workSpace, wkspSize)FSE_buildDTable_internalspread18446744073709551570&DTableHtableSize % unroll == 0position == 0723401728380766730x0101010101010101ullsvunrolluPositionFSE_DTABLE_SIZE_U32(tableLog) * sizeof (U32)(1 + (1<<(tableLog))) * sizeof (U32)FSE_DecompressWkspdtablencountZSTD_NO_UNUSED_FUNCTIONS/* Dynamically sized *//* FSE_MIN_TABLELOG is 5 *//* Now we spread those positions across the table.
         * The benefit of doing it in two stages is that we avoid the the
         * variable size inner loop, which caused lots of branch misses.
         * Now we can run through all the positions without any branch misses.
         * We unroll the loop twice, since that is what emperically worked best.
         *//* First lay down the symbols in order.
         * We use a uint64_t to lay down 8 bytes at a time. This reduces branch
         * misses since small blocks generally have small table logs, so nearly
         * all symbols have counts <= 8. We ensure we have 8 bytes at the end of
         * our buffer to handle the over-write.
         *//* ******************************************************************
 * FSE : Finite State Entropy decoder
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/zstd.hZSTD_insertBlockZSTD_DCtx *ZSTD_DCtx_s *ZSTD_decompressBlockZSTD_compressBlockZSTD_CCtx *ZSTD_CCtx_s *ZSTD_getBlockSizeconst ZSTD_CCtxconst ZSTD_CCtx *ZSTD_nextInputTypeZSTD_copyDCtxconst ZSTD_DCtxconst ZSTD_DCtx *ZSTD_decompressContinueZSTD_nextSrcSizeToDecompressZSTD_decompressBegin_usingDDictconst ZSTD_DDictconst ZSTD_DDict *ZSTD_DDict_s *ZSTD_decompressBegin_usingDictZSTD_decompressBeginZSTD_decodingBufferSize_minZSTD_getFrameHeader_advancedZSTD_frameHeader *ZSTD_getFrameHeaderZSTD_compressBegin_usingCDict_advancedZSTD_CCtx *constconst ZSTD_CDictconst ZSTD_CDict *ZSTD_CDict_s *const ZSTD_CDict *constconst ZSTD_frameParametersZSTD_compressBegin_advancedZSTD_compressEndZSTD_compressContinueZSTD_copyCCtxZSTD_compressBegin_usingCDictZSTD_compressBegin_usingDictZSTD_compressBeginZSTD_resetDStreamZSTD_DStream *ZSTD_initDStream_usingDDictZSTD_initDStream_usingDictZSTD_toFlushNowZSTD_getFrameProgressionZSTD_resetCStreamZSTD_CStream *ZSTD_initCStream_usingCDict_advancedZSTD_initCStream_usingCDictZSTD_initCStream_advancedZSTD_initCStream_usingDictZSTD_initCStream_srcSizeZSTD_decompressStream_simpleArgsZSTD_DCtx_setFormatZSTD_DCtx_getParameterZSTD_DCtx_setMaxWindowSizeZSTD_DCtx_refPrefix_advancedZSTD_DCtx_loadDictionary_advancedZSTD_DCtx_loadDictionary_byReferenceZSTD_DDict *ZSTD_createDDict_byReferenceZSTD_isFrameZSTD_compressStream2_simpleArgsZSTD_CCtx_setParametersUsingCCtxParamsconst ZSTD_CCtx_paramsconst ZSTD_CCtx_params *ZSTD_CCtx_params_s *ZSTD_CCtxParams_getParameterZSTD_CCtxParams_setParameterZSTD_CCtx_params *ZSTD_CCtxParams_init_advancedZSTD_CCtxParams_initZSTD_CCtxParams_resetZSTD_freeCCtxParamsZSTD_createCCtxParamsZSTD_CCtx_getParameterZSTD_CCtx_refPrefix_advancedZSTD_CCtx_loadDictionary_advancedZSTD_CCtx_loadDictionary_byReferenceZSTD_compress_usingCDict_advancedZSTD_compress_advancedZSTD_adjustCParamsZSTD_checkCParamsZSTD_getParamsZSTD_getCParamsZSTD_CDict *ZSTD_createCDict_byReferenceZSTD_createDDict_advancedZSTD_createCDict_advanced2ZSTD_CCtx_refThreadPoolZSTD_threadPool *POOL_ctx_s *ZSTD_createCDict_advancedZSTD_createDStream_advancedZSTD_createDCtx_advancedZSTD_createCStream_advancedZSTD_createCCtx_advancedZSTD_initStaticDDictZSTD_initStaticCDictZSTD_initStaticDStreamZSTD_initStaticDCtxZSTD_initStaticCStreamZSTD_initStaticCCtxZSTD_estimateDDictSizeZSTD_estimateCDictSize_advancedZSTD_estimateCDictSizeZSTD_estimateDStreamSize_fromFrameZSTD_estimateDStreamSizeZSTD_estimateCStreamSize_usingCCtxParamsZSTD_estimateCStreamSize_usingCParamsZSTD_estimateCStreamSizeZSTD_estimateDCtxSizeZSTD_estimateCCtxSize_usingCCtxParamsZSTD_estimateCCtxSize_usingCParamsZSTD_estimateCCtxSizeZSTD_isSkippableFrameZSTD_readSkippableFrameZSTD_writeSkippableFrameZSTD_compressSequencesconst ZSTD_Sequenceconst ZSTD_Sequence *ZSTD_mergeBlockDelimitersZSTD_Sequence *ZSTD_generateSequencesZSTD_frameHeaderSizeZSTD_decompressBoundZSTD_findDecompressedSizeZSTD_sizeof_DDictZSTD_sizeof_CDictZSTD_sizeof_DStreamconst ZSTD_DStreamconst ZSTD_DStream *ZSTD_sizeof_CStreamconst ZSTD_CStreamconst ZSTD_CStream *ZSTD_sizeof_DCtxZSTD_sizeof_CCtxZSTD_DCtx_refPrefixZSTD_DCtx_refDDictZSTD_DCtx_loadDictionaryZSTD_CCtx_refPrefixZSTD_CCtx_refCDictZSTD_CCtx_loadDictionaryZSTD_getDictID_fromFrameZSTD_getDictID_fromDDictZSTD_getDictID_fromCDictZSTD_getDictID_fromDictZSTD_decompress_usingDDictZSTD_freeDDictZSTD_createDDictZSTD_compress_usingCDictZSTD_freeCDictZSTD_createCDictZSTD_decompress_usingDictZSTD_compress_usingDictZSTD_DStreamOutSizeZSTD_DStreamInSizeZSTD_decompressStreamZSTD_outBuffer *ZSTD_outBuffer_s *ZSTD_inBuffer *ZSTD_inBuffer_s *ZSTD_initDStreamZSTD_freeDStreamZSTD_createDStreamZSTD_endStreamZSTD_flushStreamZSTD_compressStreamZSTD_initCStreamZSTD_CStreamOutSizeZSTD_CStreamInSizeZSTD_compressStream2ZSTD_freeCStreamZSTD_createCStreamZSTD_DCtx_resetZSTD_DCtx_setParameterZSTD_dParam_getBoundsZSTD_compress2ZSTD_CCtx_resetZSTD_CCtx_setPledgedSrcSizeZSTD_CCtx_setParameterZSTD_cParam_getBoundsZSTD_decompressDCtxZSTD_freeDCtxZSTD_createDCtxZSTD_compressCCtxZSTD_freeCCtxZSTD_createCCtxZSTD_defaultCLevelZSTD_maxCLevelZSTD_minCLevelZSTD_getErrorNameZSTD_isErrorZSTD_compressBoundZSTD_findFrameCompressedSizeZSTD_getDecompressedSizeZSTD_getFrameContentSizeZSTD_decompressZSTD_compressZSTD_versionStringZSTD_versionNumberZSTD_nextInputType_eZSTDnit_frameHeaderZSTDnit_blockHeaderZSTDnit_blockZSTDnit_lastBlockZSTDnit_checksumZSTDnit_skippableFrameZSTD_frameHeaderZSTD_frameType_eZSTD_frameZSTD_skippableFrameZSTD_frameProgressionZSTD_threadPoolZSTD_customMemZSTD_freeFunctionZSTD_allocFunctionZSTD_sequenceFormat_eZSTD_sf_noBlockDelimitersZSTD_sf_explicitBlockDelimitersZSTD_paramSwitch_eZSTD_ps_autoZSTD_ps_enableZSTD_ps_disableZSTD_literalCompressionMode_eZSTD_lcm_autoZSTD_lcm_huffmanZSTD_lcm_uncompressedZSTD_dictAttachPref_eZSTD_dictDefaultAttachZSTD_dictForceAttachZSTD_dictForceCopyZSTD_dictForceLoadZSTD_refMultipleDDicts_eZSTD_rmd_refSingleDDictZSTD_rmd_refMultipleDDictsZSTD_forceIgnoreChecksum_eZSTD_d_validateChecksumZSTD_d_ignoreChecksumZSTD_format_eZSTD_f_zstd1ZSTD_f_zstd1_magiclessZSTD_dictLoadMethod_eZSTD_dlm_byCopyZSTD_dlm_byRefZSTD_dictContentType_eZSTD_dct_autoZSTD_dct_rawContentZSTD_dct_fullDictZSTD_parametersZSTD_frameParametersZSTD_compressionParametersZSTD_SequenceZSTD_CCtx_paramsZSTD_CCtx_params_sZSTD_DDictZSTD_DDict_sZSTD_CDictZSTD_CDict_sZSTD_DStreamZSTD_EndDirectiveZSTD_e_continueZSTD_e_flushZSTD_e_endZSTD_CStreamZSTD_outBufferZSTD_outBuffer_sZSTD_inBufferZSTD_inBuffer_sZSTD_dParameterZSTD_d_windowLogMaxZSTD_d_experimentalParam1ZSTD_d_experimentalParam2ZSTD_d_experimentalParam3ZSTD_d_experimentalParam4ZSTD_ResetDirectiveZSTD_reset_session_onlyZSTD_reset_parametersZSTD_reset_session_and_parametersZSTD_boundsZSTD_cParameterZSTD_c_compressionLevelZSTD_c_windowLogZSTD_c_hashLogZSTD_c_chainLogZSTD_c_searchLogZSTD_c_minMatchZSTD_c_targetLengthZSTD_c_strategyZSTD_c_enableLongDistanceMatchingZSTD_c_ldmHashLogZSTD_c_ldmMinMatchZSTD_c_ldmBucketSizeLogZSTD_c_ldmHashRateLogZSTD_c_contentSizeFlagZSTD_c_checksumFlagZSTD_c_dictIDFlagZSTD_c_nbWorkers400ZSTD_c_jobSize401ZSTD_c_overlapLog402ZSTD_c_experimentalParam1ZSTD_c_experimentalParam2ZSTD_c_experimentalParam3ZSTD_c_experimentalParam4ZSTD_c_experimentalParam5ZSTD_c_experimentalParam6ZSTD_c_experimentalParam7ZSTD_c_experimentalParam8ZSTD_c_experimentalParam9ZSTD_c_experimentalParam10ZSTD_c_experimentalParam111008ZSTD_c_experimentalParam121009ZSTD_c_experimentalParam13ZSTD_c_experimentalParam141011ZSTD_c_experimentalParam151012ZSTD_strategyZSTD_fastZSTD_dfastZSTD_greedyZSTD_lazyZSTD_lazy2ZSTD_btlazy2ZSTD_btoptZSTD_btultraZSTD_btultra2ZSTD_DCtxZSTD_DCtx_sZSTD_CCtxZSTD_CCtx_schecksumFlagblockSizeMaxwindowSizeframeContentSizenbActiveWorkerscurrentJobIDflushedproducedingestedfParamsnoDictIDFlagminMatchsearchLogupperBoundlowerBoundconst ZSTD_customMemZSTD_defaultCMemZSTD_d_refMultipleDDictsZSTD_d_forceIgnoreChecksumZSTD_d_stableOutBufferZSTD_d_formatZSTD_c_deterministicRefPrefixZSTD_c_useRowMatchFinderZSTD_c_useBlockSplitterZSTD_c_validateSequencesZSTD_c_blockDelimitersZSTD_c_stableOutBufferZSTD_c_stableInBufferZSTD_c_enableDedicatedDictSearchZSTD_c_srcSizeHintZSTD_c_targetCBlockSizeZSTD_c_literalCompressionModeZSTD_c_forceAttachDictZSTD_c_forceMaxWindowZSTD_c_formatZSTD_c_rsyncableZSTD_SRCSIZEHINT_MAXZSTD_SRCSIZEHINT_MINZSTD_TARGETCBLOCKSIZE_MAXZSTD_BLOCKSIZE_MAXZSTD_TARGETCBLOCKSIZE_MINZSTD_LDM_HASHRATELOG_MAX(ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN)ZSTD_LDM_HASHRATELOG_MINZSTD_LDM_BUCKETSIZELOG_MAXZSTD_LDM_BUCKETSIZELOG_MINZSTD_LDM_MINMATCH_MAXZSTD_LDM_MINMATCH_MINZSTD_LDM_HASHLOG_MAXZSTD_HASHLOG_MAXZSTD_LDM_HASHLOG_MINZSTD_HASHLOG_MINZSTD_WINDOWLOG_LIMIT_DEFAULTZSTD_OVERLAPLOG_MAXZSTD_OVERLAPLOG_MINZSTD_STRATEGY_MAXZSTD_STRATEGY_MINZSTD_TARGETLENGTH_MINZSTD_TARGETLENGTH_MAXZSTD_MINMATCH_MINZSTD_MINMATCH_MAXZSTD_SEARCHLOG_MINZSTD_SEARCHLOG_MAX(ZSTD_WINDOWLOG_MAX-1)ZSTD_CHAINLOG_MINZSTD_CHAINLOG_MAX((int)(sizeof(size_t) == 4 ? ZSTD_CHAINLOG_MAX_32 : ZSTD_CHAINLOG_MAX_64))ZSTD_CHAINLOG_MAX_64ZSTD_CHAINLOG_MAX_32((ZSTD_WINDOWLOG_MAX < 30) ? ZSTD_WINDOWLOG_MAX : 30)ZSTD_WINDOWLOG_MINZSTD_WINDOWLOG_MAX((int)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))ZSTD_WINDOWLOG_MAX_64ZSTD_WINDOWLOG_MAX_32ZSTD_SKIPPABLEHEADERSIZEZSTD_FRAMEHEADERSIZE_MAXZSTD_FRAMEHEADERSIZE_MIN(format)((format) == ZSTD_f_zstd1 ? 6 : 2)ZSTD_FRAMEHEADERSIZE_PREFIX(format)((format) == ZSTD_f_zstd1 ? 5 : 1)ZSTD_DEPRECATED(message)ZSTDLIB_STATIC_API __attribute__((deprecated))ZSTDLIB_STATIC_APIZSTDLIB_VISIBLEZSTD_H_ZSTD_STATIC_LINKING_ONLYZSTD_COMPRESSBOUND(srcSize)((srcSize) + ((srcSize)>>8) + (((srcSize) < (128<<10)) ? (((128<<10) - (srcSize)) >> 11) : 0))ZSTD_CONTENTSIZE_ERROR(0ULL - 2)ZSTD_CONTENTSIZE_UNKNOWN(0ULL - 1)(1<<ZSTD_BLOCKSIZELOG_MAX)ZSTD_BLOCKSIZELOG_MAXZSTD_MAGIC_SKIPPABLE_MASK0xFFFFFFF0ZSTD_MAGIC_SKIPPABLE_START0x184D2A50ZSTD_MAGIC_DICTIONARY0xEC30A437ZSTD_MAGICNUMBER0xFD2FB528ZSTD_CLEVEL_DEFAULTZSTD_VERSION_STRINGZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)ZSTD_EXPAND_AND_QUOTE(str)ZSTD_QUOTE(str)ZSTD_LIB_VERSIONZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASEZSTD_VERSION_NUMBER(ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)ZSTD_VERSION_RELEASEZSTD_VERSION_MINORZSTD_VERSION_MAJORZSTDLIB_APIZSTDLIB_HIDDENZSTD_H_235446defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)defined(ZSTD_STATIC_LINKING_ONLY) && !defined(ZSTD_H_ZSTD_STATIC_LINKING_ONLY)ZSTD_DISABLE_DEPRECATE_WARNINGS(defined(GNUC) && (GNUC > 4 || (GNUC == 4 && GNUC_MINOR >= 5))) || defined(__clang__)"use advanced API to access custom parameters""use ZSTD_CCtx_reset, see zstd.h for detailed instructions""use ZSTD_CCtx_reset and ZSTD_CCtx_refCDict, see zstd.h for detailed instructions""use ZSTD_DCtx_setParameter() instead"blockStartpreparedDCtxddictzfhPtrpledgedSrcSizepreparedCCtxzdszcsdstPosmaxWindowSizedictContentTypedictLoadMethodendOpcctxParams"use ZSTD_compress2 with ZSTD_CCtx_loadDictionary""use ZSTD_compress2"ZSTD_freeThreadPoolPOOL_ctx *ZSTD_createThreadPoolPOOL_ctx_s/* ZSTD_H_ZSTD_STATIC_LINKING_ONLY *//**< insert uncompressed block into `dctx` history. Useful for multi-blocks decompression. *//*=====   Raw zstd block functions  =====*//*!
    Block functions produce and decode raw zstd blocks, without frame metadata.
    Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes).
    But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.

    A few rules to respect :
    - Compressing and decompressing require a context structure
      + Use ZSTD_createCCtx() and ZSTD_createDCtx()
    - It is necessary to init context before starting
      + compression : any ZSTD_compressBegin*() variant, including with dictionary
      + decompression : any ZSTD_decompressBegin*() variant, including with dictionary
      + copyCCtx() and copyDCtx() can be used too
    - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB
      + If input is larger than a block size, it's necessary to split input data into multiple blocks
      + For inputs larger than a single block, consider using regular ZSTD_compress() instead.
        Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.
    - When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !
      ===> In which case, nothing is produced into `dst` !
      + User __must__ test for such outcome and deal directly with uncompressed data
      + A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.
        Doing so would mess up with statistics history, leading to potential data corruption.
      + ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!
      + In case of multiple successive blocks, should some of them be uncompressed,
        decoder must be informed of their existence in order to follow proper history.
        Use ZSTD_insertBlock() for such a case.
*//* ============================ *//**       Block level API       *//**< when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN *//*! ZSTD_getFrameHeader_advanced() :
 *  same as ZSTD_getFrameHeader(),
 *  with added capability to select a format (like ZSTD_f_zstd1_magicless) *//**< doesn't consume input *//*! ZSTD_getFrameHeader() :
 *  decode Frame Header, or requires larger `srcSize`.
 * @return : 0, `zfhPtr` is correctly filled,
 *          >0, `srcSize` is too small, value is wanted `srcSize` amount,
 *           or an error code, which can be tested using ZSTD_isError() *//* if == ZSTD_skippableFrame, frameContentSize is the size of skippable content *//* can be very large, up to <= frameContentSize *//* if == ZSTD_CONTENTSIZE_UNKNOWN, it means this field is not available. 0 means "empty" *//*=====   Buffer-less streaming decompression functions  =====*//**
  Buffer-less streaming decompression (synchronous mode)

  A ZSTD_DCtx object is required to track streaming operations.
  Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
  A ZSTD_DCtx object can be re-used multiple times.

  First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().
  Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.
  Data fragment must be large enough to ensure successful decoding.
 `ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.
  @result : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.
           >0 : `srcSize` is too small, please provide at least @result bytes on next attempt.
           errorCode, which can be tested using ZSTD_isError().

  It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,
  such as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).
  Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.
  As a consequence, check that values remain within valid application range.
  For example, do not allocate memory blindly, check that `windowSize` is within expectation.
  Each application can set its own limits, depending on local restrictions.
  For extended interoperability, it is recommended to support `windowSize` of at least 8 MB.

  ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.
  ZSTD_decompressContinue() is very sensitive to contiguity,
  if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,
  or that previous contiguous segment is large enough to properly handle maximum back-reference distance.
  There are multiple ways to guarantee this condition.

  The most memory efficient way is to use a round buffer of sufficient size.
  Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),
  which can @return an error code if required value is too large for current system (in 32-bits mode).
  In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,
  up to the moment there is not enough room left in the buffer to guarantee decoding another full block,
  which maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.
  At which point, decoding can resume from the beginning of the buffer.
  Note that already decoded data stored in the buffer should be flushed before being overwritten.

  There are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.

  Finally, if you control the compression process, you can also ignore all buffer size rules,
  as long as the encoder and decoder progress in "lock-step",
  aka use exactly the same buffer sizes, break contiguity at the same place, etc.

  Once buffers are setup, start decompression, with ZSTD_decompressBegin().
  If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().

  Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
  ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().
  ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.

 @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).
  It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.
  It can also be an error code, which can be tested with ZSTD_isError().

  A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
  Context can then be reset to start a new decompression.

  Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
  This information is not required to properly decode a frame.

  == Special case : skippable frames ==

  Skippable frames allow integration of user-defined data into a flow of concatenated frames.
  Skippable frames will be ignored (skipped) by decompressor.
  The format of skippable frames is as follows :
  a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
  b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
  c) Frame Content - any content (User Data) of length equal to Frame Size
  For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.
  For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.
*//* compression parameters are already set within cdict. pledgedSrcSize must be correct. If srcSize is not known, use macro ZSTD_CONTENTSIZE_UNKNOWN *//**< pledgedSrcSize : If srcSize is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN *//* The ZSTD_compressBegin_advanced() and ZSTD_compressBegin_usingCDict_advanced() are now DEPRECATED and will generate a compiler warning *//**<  note: if pledgedSrcSize is not known, use ZSTD_CONTENTSIZE_UNKNOWN *//**< note: fails if cdict==NULL *//*=====   Buffer-less streaming compression functions  =====*//**
  Buffer-less streaming compression (synchronous mode)

  A ZSTD_CCtx object is required to track streaming operations.
  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
  ZSTD_CCtx object can be re-used multiple times within successive compression operations.

  Start by initializing a context.
  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression.
  It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()

  Then, consume your input using ZSTD_compressContinue().
  There are some important considerations to keep in mind when using this advanced function :
  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.
  - Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.
  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
    Worst case evaluation is provided by ZSTD_compressBound().
    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
    In which case, it will "discard" the relevant memory section from its history.

  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
  Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.

  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again.
*//*********************************************************************
*  Buffer-less and synchronous inner streaming functions
*
*  This is an advanced API, giving full control over buffer management, for users which need direct control over memory.
*  But it's also a complex one, with several restrictions, documented below.
*  Prefer normal streaming API for an easier experience.
********************************************************************* *//*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *
 * re-use decompression parameters from previous init; saves dictionary loading
 * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x
 *//*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_refDDict(zds, ddict);
 *
 * note : ddict is referenced, it must outlive decompression session
 * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x
 *//*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);
 *
 * note: no dictionary will be used if dict == NULL or dictSize < 8
 * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x
 *//*=====   Advanced Streaming decompression functions  =====*//*! ZSTD_toFlushNow() :
 *  Tell how many bytes are ready to be flushed immediately.
 *  Useful for multithreading scenarios (nbWorkers >= 1).
 *  Probe the oldest active job, defined as oldest job not yet entirely flushed,
 *  and check its output buffer.
 * @return : amount of data stored in oldest job and ready to be flushed immediately.
 *  if @return == 0, it means either :
 *  + there is no active job (could be checked with ZSTD_frameProgression()), or
 *  + oldest job is still actively compressing data,
 *    but everything it has produced has also been flushed so far,
 *    therefore flush speed is limited by production speed of oldest job
 *    irrespective of the speed of concurrent (and newer) jobs.
 *//* ZSTD_getFrameProgression() :
 * tells how much data has been ingested (read from input)
 * consumed (input actually compressed) and produced (output) for current frame.
 * Note : (ingested - consumed) is amount of input data buffered internally, not yet compressed.
 * Aggregates progression inside active worker threads.
 *//* MT only : nb of workers actively compressing at probe time *//* MT only : latest started job nb *//* nb of compressed bytes flushed : not provided; can be tracked from caller side *//* nb of compressed bytes generated and buffered *//* nb input bytes actually compressed *//* nb input bytes read and buffered *//*! ZSTD_resetCStream() :
 * This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 * Note: ZSTD_resetCStream() interprets pledgedSrcSize == 0 as ZSTD_CONTENTSIZE_UNKNOWN, but
 *       ZSTD_CCtx_setPledgedSrcSize() does not do the same, so ZSTD_CONTENTSIZE_UNKNOWN must be
 *       explicitly specified.
 *
 *  start a new frame, using same parameters from previous frame.
 *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place.
 *  Note that zcs must be init at least once before using ZSTD_resetCStream().
 *  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.
 *  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
 *  For the time being, pledgedSrcSize==0 is interpreted as "srcSize unknown" for compatibility with older programs,
 *  but it will change to mean "empty" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.
 * @return : 0, or an error code (which can be tested using ZSTD_isError())
 *  This prototype will generate compilation warnings.
 *//*! ZSTD_initCStream_usingCDict_advanced() :
 *   This function is DEPRECATED, and is approximately equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     // Pseudocode: Set each zstd frame parameter and leave the rest as-is.
 *     for ((fParam, value) : fParams) {
 *         ZSTD_CCtx_setParameter(zcs, fParam, value);
 *     }
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *     ZSTD_CCtx_refCDict(zcs, cdict);
 *
 * same as ZSTD_initCStream_usingCDict(), with control over frame parameters.
 * pledgedSrcSize must be correct. If srcSize is not known at init time, use
 * value ZSTD_CONTENTSIZE_UNKNOWN.
 * This prototype will generate compilation warnings.
 *//*! ZSTD_initCStream_usingCDict() :
 * This function is DEPRECATED, and equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, cdict);
 *
 * note : cdict will just be referenced, and must outlive compression session
 * This prototype will generate compilation warnings.
 *//*! ZSTD_initCStream_advanced() :
 * This function is DEPRECATED, and is approximately equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     // Pseudocode: Set each zstd parameter and leave the rest as-is.
 *     for ((param, value) : params) {
 *         ZSTD_CCtx_setParameter(zcs, param, value);
 *     }
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
 *
 * dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.
 * pledgedSrcSize must be correct.
 * If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
 * This prototype will generate compilation warnings.
 *//*! ZSTD_initCStream_usingDict() :
 * This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
 *
 * Creates of an internal CDict (incompatible with static CCtx), except if
 * dict == NULL or dictSize < 8, in which case no dict is used.
 * Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if
 * it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.
 * This prototype will generate compilation warnings.
 *//*! ZSTD_initCStream_srcSize() :
 * This function is DEPRECATED, and equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *
 * pledgedSrcSize must be correct. If it is not known at init time, use
 * ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,
 * "0" also disables frame content size field. It may be enabled in the future.
 * This prototype will generate compilation warnings.
 *//*=====   Advanced Streaming compression functions  =====*//********************************************************************
*  Advanced streaming functions
*  Warning : most of these functions are now redundant with the Advanced API.
*  Once Advanced API reaches "stable" status,
*  redundant functions will be deprecated, and then at some point removed.
********************************************************************//*! ZSTD_decompressStream_simpleArgs() :
 *  Same as ZSTD_decompressStream(),
 *  but using only integral types as arguments.
 *  This can be helpful for binders from dynamic languages
 *  which have troubles handling structures containing memory pointers.
 *//*! ZSTD_DCtx_setFormat() :
 *  This function is REDUNDANT. Prefer ZSTD_DCtx_setParameter().
 *  Instruct the decoder context about what kind of data to decode next.
 *  This instruction is mandatory to decode data without a fully-formed header,
 *  such ZSTD_f_zstd1_magicless for example.
 * @return : 0, or an error code (which can be tested using ZSTD_isError()). *//* ZSTD_d_refMultipleDDicts
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable
 *
 * If enabled and dctx is allocated on the heap, then additional memory will be allocated
 * to store references to multiple ZSTD_DDict. That is, multiple calls of ZSTD_refDDict()
 * using a given ZSTD_DCtx, rather than overwriting the previous DDict reference, will instead
 * store all references. At decompression time, the appropriate dictID is selected
 * from the set of DDicts based on the dictID in the frame.
 *
 * Usage is simply calling ZSTD_refDDict() on multiple dict buffers.
 *
 * Param has values of byte ZSTD_refMultipleDDicts_e
 *
 * WARNING: Enabling this parameter and calling ZSTD_DCtx_refDDict(), will trigger memory
 * allocation for the hash table. ZSTD_freeDCtx() also frees this memory.
 * Memory is allocated as per ZSTD_DCtx::customMem.
 *
 * Although this function allocates memory for the table, the user is still responsible for
 * memory management of the underlying ZSTD_DDict* themselves.
 *//* ZSTD_d_forceIgnoreChecksum
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable
 *
 * Tells the decompressor to skip checksum validation during decompression, regardless
 * of whether checksumming was specified during compression. This offers some
 * slight performance benefits, and may be useful for debugging.
 * Param has values of type ZSTD_forceIgnoreChecksum_e
 *//* ZSTD_d_stableOutBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells the decompressor that the ZSTD_outBuffer will ALWAYS be the same
 * between calls, except for the modifications that zstd makes to pos (the
 * caller must not modify pos). This is checked by the decompressor, and
 * decompression will fail if it ever changes. Therefore the ZSTD_outBuffer
 * MUST be large enough to fit the entire decompressed frame. This will be
 * checked when the frame content size is known. The data in the ZSTD_outBuffer
 * in the range [dst, dst + pos) MUST not be modified during decompression
 * or you will get data corruption.
 *
 * When this flags is enabled zstd won't allocate an output buffer, because
 * it can write directly to the ZSTD_outBuffer, but it will still allocate
 * an input buffer large enough to fit any compressed block. This will also
 * avoid the memcpy() from the internal output buffer to the ZSTD_outBuffer.
 * If you need to avoid the input buffer allocation use the buffer-less
 * streaming API.
 *
 * NOTE: So long as the ZSTD_outBuffer always points to valid memory, using
 * this flag is ALWAYS memory safe, and will never access out-of-bounds
 * memory. However, decompression WILL fail if you violate the preconditions.
 *
 * WARNING: The data in the ZSTD_outBuffer in the range [dst, dst + pos) MUST
 * not be modified during decompression or you will get data corruption. This
 * is because zstd needs to reference data in the ZSTD_outBuffer to regenerate
 * matches. Normally zstd maintains its own buffer for this purpose, but passing
 * this flag tells zstd to use the user provided buffer.
 *//* ZSTD_d_format
 * experimental parameter,
 * allowing selection between ZSTD_format_e input compression formats
 *//*! ZSTD_DCtx_getParameter() :
 *  Get the requested decompression parameter value, selected by enum ZSTD_dParameter,
 *  and store it into int* value.
 * @return : 0, or an error code (which can be tested with ZSTD_isError()).
 *//*! ZSTD_DCtx_setMaxWindowSize() :
 *  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.
 *  This protects a decoder context from reserving too much memory for itself (potential attack scenario).
 *  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
 *  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
 * @return : 0, or an error code (which can be tested using ZSTD_isError()).
 *//*! ZSTD_DCtx_refPrefix_advanced() :
 *  Same as ZSTD_DCtx_refPrefix(), but gives finer control over
 *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) *//*! ZSTD_DCtx_loadDictionary_advanced() :
 *  Same as ZSTD_DCtx_loadDictionary(),
 *  but gives direct control over
 *  how to load the dictionary (by copy ? by reference ?)
 *  and how to interpret it (automatic ? force raw mode ? full mode only ?). *//*! ZSTD_DCtx_loadDictionary_byReference() :
 *  Same as ZSTD_DCtx_loadDictionary(),
 *  but references `dict` content instead of copying it into `dctx`.
 *  This saves memory if `dict` remains around.,
 *  However, it's imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression. *//*! ZSTD_createDDict_byReference() :
 *  Create a digested dictionary, ready to start decompression operation without startup delay.
 *  Dictionary content is referenced, and therefore stays in dictBuffer.
 *  It is important that dictBuffer outlives DDict,
 *  it must remain read accessible throughout the lifetime of DDict *//*! ZSTD_isFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier.
 *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
 *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
 *  Note 3 : Skippable Frame Identifiers are considered valid. *//***************************************
*  Advanced decompression functions
***************************************//*! ZSTD_compressStream2_simpleArgs() :
 *  Same as ZSTD_compressStream2(),
 *  but using only integral types as arguments.
 *  This variant might be helpful for binders from dynamic languages
 *  which have troubles handling structures containing memory pointers.
 *//*! ZSTD_CCtx_setParametersUsingCCtxParams() :
 *  Apply a set of ZSTD_CCtx_params to the compression context.
 *  This can be done even after compression is started,
 *    if nbWorkers==0, this will have no impact until a new compression is started.
 *    if nbWorkers>=1, new parameters will be picked up at next job,
 *       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).
 *//*! ZSTD_CCtxParams_getParameter() :
 * Similar to ZSTD_CCtx_getParameter.
 * Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *//*! ZSTD_CCtxParams_setParameter() : Requires v1.4.0+
 *  Similar to ZSTD_CCtx_setParameter.
 *  Set one compression parameter, selected by enum ZSTD_cParameter.
 *  Parameters must be applied to a ZSTD_CCtx using
 *  ZSTD_CCtx_setParametersUsingCCtxParams().
 * @result : a code representing success or failure (which can be tested with
 *           ZSTD_isError()).
 *//*! ZSTD_CCtxParams_init_advanced() :
 *  Initializes the compression and frame parameters of cctxParams according to
 *  params. All other parameters are reset to their default values.
 *//*! ZSTD_CCtxParams_init() :
 *  Initializes the compression parameters of cctxParams according to
 *  compression level. All other parameters are reset to their default values.
 *//*! ZSTD_CCtxParams_reset() :
 *  Reset params to default values.
 *//* accept NULL pointer *//*! ZSTD_CCtx_params :
 *  Quick howto :
 *  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure
 *  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into
 *                                     an existing ZSTD_CCtx_params structure.
 *                                     This is similar to
 *                                     ZSTD_CCtx_setParameter().
 *  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to
 *                                    an existing CCtx.
 *                                    These parameters will be applied to
 *                                    all subsequent frames.
 *  - ZSTD_compressStream2() : Do compression using the CCtx.
 *  - ZSTD_freeCCtxParams() : Free the memory, accept NULL pointer.
 *
 *  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()
 *  for static allocation of CCtx for single-threaded compression.
 *//*! ZSTD_CCtx_getParameter() :
 *  Get the requested compression parameter value, selected by enum ZSTD_cParameter,
 *  and store it into int* value.
 * @return : 0, or an error code (which can be tested with ZSTD_isError()).
 *//* ZSTD_c_deterministicRefPrefix
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Zstd produces different results for prefix compression when the prefix is
 * directly adjacent to the data about to be compressed vs. when it isn't.
 * This is because zstd detects that the two buffers are contiguous and it can
 * use a more efficient match finding algorithm. However, this produces different
 * results than when the two buffers are non-contiguous. This flag forces zstd
 * to always load the prefix in non-contiguous mode, even if it happens to be
 * adjacent to the data, to guarantee determinism.
 *
 * If you really care about determinism when using a dictionary or prefix,
 * like when doing delta compression, you should select this option. It comes
 * at a speed penalty of about ~2.5% if the dictionary and data happened to be
 * contiguous, and is free if they weren't contiguous. We don't expect that
 * intentionally making the dictionary and data contiguous will be worth the
 * cost to memcpy() the data.
 *//* ZSTD_c_useRowMatchFinder
 * Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never use row-based matchfinder.
 * Set to ZSTD_ps_enable to force usage of row-based matchfinder.
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * the row-based matchfinder based on support for SIMD instructions and the window log.
 * Note that this only pertains to compression strategies: greedy, lazy, and lazy2
 *//* ZSTD_c_useBlockSplitter
 * Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never use block splitter.
 * Set to ZSTD_ps_enable to always use block splitter.
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * block splitting based on the compression parameters.
 *//* ZSTD_c_validateSequences
 * Default is 0 == disabled. Set to 1 to enable sequence validation.
 *
 * For use with sequence compression API: ZSTD_compressSequences().
 * Designates whether or not we validate sequences provided to ZSTD_compressSequences()
 * during function execution.
 *
 * Without validation, providing a sequence that does not conform to the zstd spec will cause
 * undefined behavior, and may produce a corrupted block.
 *
 * With validation enabled, a if sequence is invalid (see doc/zstd_compression_format.md for
 * specifics regarding offset/matchlength requirements) then the function will bail out and
 * return an error.
 *
 *//* ZSTD_c_blockDelimiters
 * Default is 0 == ZSTD_sf_noBlockDelimiters.
 *
 * For use with sequence compression API: ZSTD_compressSequences().
 *
 * Designates whether or not the given array of ZSTD_Sequence contains block delimiters
 * and last literals, which are defined as sequences with offset == 0 and matchLength == 0.
 * See the definition of ZSTD_Sequence for more specifics.
 *//* ZSTD_c_stableOutBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells he compressor that the ZSTD_outBuffer will not be resized between
 * calls. Specifically: (out.size - out.pos) will never grow. This gives the
 * compressor the freedom to say: If the compressed data doesn't fit in the
 * output buffer then return ZSTD_error_dstSizeTooSmall. This allows us to
 * always decompress directly into the output buffer, instead of decompressing
 * into an internal buffer and copying to the output buffer.
 *
 * When this flag is enabled zstd won't allocate an output buffer, because
 * it can write directly to the ZSTD_outBuffer. It will still allocate the
 * input window buffer (see ZSTD_c_stableInBuffer).
 *
 * Zstd will check that (out.size - out.pos) never grows and return an error
 * if it does. While not strictly necessary, this should prevent surprises.
 *//* ZSTD_c_stableInBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells the compressor that the ZSTD_inBuffer will ALWAYS be the same
 * between calls, except for the modifications that zstd makes to pos (the
 * caller must not modify pos). This is checked by the compressor, and
 * compression will fail if it ever changes. This means the only flush
 * mode that makes sense is ZSTD_e_end, so zstd will error if ZSTD_e_end
 * is not used. The data in the ZSTD_inBuffer in the range [src, src + pos)
 * MUST not be modified during compression or you will get data corruption.
 *
 * When this flag is enabled zstd won't allocate an input window buffer,
 * because the user guarantees it can reference the ZSTD_inBuffer until
 * the frame is complete. But, it will still allocate an output buffer
 * large enough to fit a block (see ZSTD_c_stableOutBuffer). This will also
 * avoid the memcpy() from the input buffer to the input window buffer.
 *
 * NOTE: ZSTD_compressStream2() will error if ZSTD_e_end is not used.
 * That means this flag cannot be used with ZSTD_compressStream().
 *
 * NOTE: So long as the ZSTD_inBuffer always points to valid memory, using
 * this flag is ALWAYS memory safe, and will never access out-of-bounds
 * memory. However, compression WILL fail if you violate the preconditions.
 *
 * WARNING: The data in the ZSTD_inBuffer in the range [dst, dst + pos) MUST
 * not be modified during compression or you will get data corruption. This
 * is because zstd needs to reference data in the ZSTD_inBuffer to find
 * matches. Normally zstd maintains its own window buffer for this purpose,
 * but passing this flag tells zstd to use the user provided buffer.
 *//* Controls whether the new and experimental "dedicated dictionary search
 * structure" can be used. This feature is still rough around the edges, be
 * prepared for surprising behavior!
 *
 * How to use it:
 *
 * When using a CDict, whether to use this feature or not is controlled at
 * CDict creation, and it must be set in a CCtxParams set passed into that
 * construction (via ZSTD_createCDict_advanced2()). A compression will then
 * use the feature or not based on how the CDict was constructed; the value of
 * this param, set in the CCtx, will have no effect.
 *
 * However, when a dictionary buffer is passed into a CCtx, such as via
 * ZSTD_CCtx_loadDictionary(), this param can be set on the CCtx to control
 * whether the CDict that is created internally can use the feature or not.
 *
 * What it does:
 *
 * Normally, the internal data structures of the CDict are analogous to what
 * would be stored in a CCtx after compressing the contents of a dictionary.
 * To an approximation, a compression using a dictionary can then use those
 * data structures to simply continue what is effectively a streaming
 * compression where the simulated compression of the dictionary left off.
 * Which is to say, the search structures in the CDict are normally the same
 * format as in the CCtx.
 *
 * It is possible to do better, since the CDict is not like a CCtx: the search
 * structures are written once during CDict creation, and then are only read
 * after that, while the search structures in the CCtx are both read and
 * written as the compression goes along. This means we can choose a search
 * structure for the dictionary that is read-optimized.
 *
 * This feature enables the use of that different structure.
 *
 * Note that some of the members of the ZSTD_compressionParameters struct have
 * different semantics and constraints in the dedicated search structure. It is
 * highly recommended that you simply set a compression level in the CCtxParams
 * you pass into the CDict creation call, and avoid messing with the cParams
 * directly.
 *
 * Effects:
 *
 * This will only have any effect when the selected ZSTD_strategy
 * implementation supports this feature. Currently, that's limited to
 * ZSTD_greedy, ZSTD_lazy, and ZSTD_lazy2.
 *
 * Note that this means that the CDict tables can no longer be copied into the
 * CCtx, so the dict attachment mode ZSTD_dictForceCopy will no longer be
 * usable. The dictionary can only be attached or reloaded.
 *
 * In general, you should expect compression to be faster--sometimes very much
 * so--and CDict creation to be slightly slower. Eventually, we will probably
 * make this mode the default.
 *//* User's best guess of source size.
 * Hint is not valid when srcSizeHint == 0.
 * There is no guarantee that hint is close to actual source size,
 * but compression ratio may regress significantly if guess considerably underestimates *//* Tries to fit compressed block size to be around targetCBlockSize.
 * No target when targetCBlockSize == 0.
 * There is no guarantee on compressed block size (default:0) *//* Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never compress literals.
 * Set to ZSTD_ps_enable to always compress literals. (Note: uncompressed literals
 * may still be emitted if huffman is not beneficial to use.)
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * literals compression based on the compression parameters - specifically,
 * negative compression levels do not use literal compression.
 *//* Controls whether the contents of a CDict
 * are used in place, or copied into the working context.
 * Accepts values from the ZSTD_dictAttachPref_e enum.
 * See the comments on that enum for an explanation of the feature. *//* Force back-reference distances to remain < windowSize,
 * even when referencing into Dictionary content (default:0) *//* Select a compression format.
 * The value must be of type ZSTD_format_e.
 * See ZSTD_format_e enum definition for details *//* Enables rsyncable mode,
  * which makes compressed files more rsync friendly
  * by adding periodic synchronization points to the compressed data.
  * The target average block size is ZSTD_c_jobSize / 2.
  * It's possible to modify the job size to increase or decrease
  * the granularity of the synchronization point.
  * Once the jobSize is smaller than the window size,
  * it will result in compression ratio degradation.
  * NOTE 1: rsyncable mode only works when multithreading is enabled.
  * NOTE 2: rsyncable performs poorly in combination with long range mode,
  * since it will decrease the effectiveness of synchronization points,
  * though mileage may vary.
  * NOTE 3: Rsyncable mode limits maximum compression speed to ~400 MB/s.
  * If the selected compression level is already running significantly slower,
  * the overall speed won't be significantly impacted.
  *//* these parameters can be used with ZSTD_setParameter()
 * they are not guaranteed to remain supported in the future *//* ===   experimental parameters   === *//*! ZSTD_CCtx_refPrefix_advanced() :
 *  Same as ZSTD_CCtx_refPrefix(), but gives finer control over
 *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) *//*! ZSTD_CCtx_loadDictionary_advanced() :
 *  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over
 *  how to load the dictionary (by copy ? by reference ?)
 *  and how to interpret it (automatic ? force raw mode ? full mode only ?) *//*! ZSTD_CCtx_loadDictionary_byReference() :
 *  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.
 *  It saves some memory, but also requires that `dict` outlives its usage within `cctx` *//*! ZSTD_compress_usingCDict_advanced() :
 *  Note : this function is now DEPRECATED.
 *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.
 *  This prototype will generate compilation warnings. *//*! ZSTD_compress_advanced() :
 *  Note : this function is now DEPRECATED.
 *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.
 *  This prototype will generate compilation warnings. *//*! ZSTD_adjustCParams() :
 *  optimize params for a given `srcSize` and `dictSize`.
 * `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.
 * `dictSize` must be `0` when there is no dictionary.
 *  cPar can be invalid : all parameters will be clamped within valid range in the @return struct.
 *  This function never fails (wide contract) *//*! ZSTD_checkCParams() :
 *  Ensure param values remain within authorized range.
 * @return 0 on success, or an error code (can be checked with ZSTD_isError()) *//*! ZSTD_getParams() :
 *  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
 *  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0 *//*! ZSTD_getCParams() :
 * @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
 * `estimatedSrcSize` value is optional, select 0 if not known *//*! ZSTD_createCDict_byReference() :
 *  Create a digested dictionary for compression
 *  Dictionary content is just referenced, not duplicated.
 *  As a consequence, `dictBuffer` **must** outlive CDict,
 *  and its content must remain unmodified throughout the lifetime of CDict.
 *  note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef *//***************************************
*  Advanced compression functions
***************************************//*
 * This API is temporary and is expected to change or disappear in the future!
 *//*! Thread pool :
 *  These prototypes make it possible to share a thread pool among multiple compression contexts.
 *  This can limit resources for applications with multiple threads where each one uses
 *  a threaded compression mode (via ZSTD_c_nbWorkers parameter).
 *  ZSTD_createThreadPool creates a new thread pool with a given number of threads.
 *  Note that the lifetime of such pool must exist while being used.
 *  ZSTD_CCtx_refThreadPool assigns a thread pool to a context (use NULL argument value
 *  to use an internal thread pool).
 *  ZSTD_freeThreadPool frees a thread pool, accepts NULL pointer.
 *//*! Custom memory allocation :
 *  These prototypes make it possible to pass your own allocation/free functions.
 *  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.
 *  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones.
 *//**< same as ZSTD_initStaticDCtx() *//**< same as ZSTD_initStaticCCtx() *//*! ZSTD_initStatic*() :
 *  Initialize an object using a pre-allocated fixed-size buffer.
 *  workspace: The memory area to emplace the object into.
 *             Provided pointer *must be 8-bytes aligned*.
 *             Buffer must outlive object.
 *  workspaceSize: Use ZSTD_estimate*Size() to determine
 *                 how large workspace must be to support target scenario.
 * @return : pointer to object (same address as workspace, just different type),
 *           or NULL if error (size too small, incorrect alignment, etc.)
 *  Note : zstd will never resize nor malloc() when using a static buffer.
 *         If the object requires more memory than available,
 *         zstd will just error out (typically ZSTD_error_memory_allocation).
 *  Note 2 : there is no corresponding "free" function.
 *           Since workspace is allocated externally, it must be freed externally too.
 *  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level
 *           into its associated cParams.
 *  Limitation 1 : currently not compatible with internal dictionary creation, triggered by
 *                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().
 *  Limitation 2 : static cctx currently not compatible with multi-threading.
 *  Limitation 3 : static dctx is incompatible with legacy support.
 *//*! ZSTD_estimate?DictSize() :
 *  ZSTD_estimateCDictSize() will bet that src size is relatively "small", and content is copied, like ZSTD_createCDict().
 *  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().
 *  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller.
 *//*! ZSTD_estimateCStreamSize() :
 *  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.
 *  It will also consider src size to be arbitrarily "large", which is worst case.
 *  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.
 *  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.
 *  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1.
 *  Note : CStream size estimation is only correct for single-threaded compression.
 *  ZSTD_DStream memory budget depends on window Size.
 *  This information can be passed manually, using ZSTD_estimateDStreamSize,
 *  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();
 *  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
 *         an internal ?Dict will be created, which additional size is not estimated here.
 *         In this case, get total size by adding ZSTD_estimate?DictSize *//*! ZSTD_estimate*() :
 *  These functions make it possible to estimate memory usage
 *  of a future {D,C}Ctx, before its creation.
 *
 *  ZSTD_estimateCCtxSize() will provide a memory budget large enough
 *  for any compression level up to selected one.
 *  Note : Unlike ZSTD_estimateCStreamSize*(), this estimate
 *         does not include space for a window buffer.
 *         Therefore, the estimation is only guaranteed for single-shot compressions, not streaming.
 *  The estimate will assume the input may be arbitrarily large,
 *  which is the worst case.
 *
 *  When srcSize can be bound by a known and rather "small" value,
 *  this fact can be used to provide a tighter estimation
 *  because the CCtx compression context will need less memory.
 *  This tighter estimation can be provided by more advanced functions
 *  ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with ZSTD_getCParams(),
 *  and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with ZSTD_CCtxParams_setParameter().
 *  Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.
 *
 *  Note 2 : only single-threaded compression is supported.
 *  ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.
 *//***************************************
*  Memory management
***************************************//*! ZSTD_isSkippableFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame.
 *//*! ZSTD_readSkippableFrame() :
 * Retrieves a zstd skippable frame containing data given by src, and writes it to dst buffer.
 *
 * The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,
 * i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested
 * in the magicVariant.
 *
 * Returns an error if destination buffer is not large enough, or if the frame is not skippable.
 *
 * @return : number of bytes written or a ZSTD error.
 *//*! ZSTD_writeSkippableFrame() :
 * Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.
 *
 * Skippable frames begin with a a 4-byte magic number. There are 16 possible choices of magic number,
 * ranging from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15.
 * As such, the parameter magicVariant controls the exact skippable frame magic number variant used, so
 * the magic number used will be ZSTD_MAGIC_SKIPPABLE_START + magicVariant.
 *
 * Returns an error if destination buffer is not large enough, if the source size is not representable
 * with a 4-byte unsigned int, or if the parameter magicVariant is greater than 15 (and therefore invalid).
 *
 * @return : number of bytes written or a ZSTD error.
 *//*! ZSTD_compressSequences() :
 * Compress an array of ZSTD_Sequence, generated from the original source buffer, into dst.
 * If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)
 * The entire source is compressed into a single frame.
 *
 * The compression behavior changes based on cctx params. In particular:
 *    If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of ZSTD_Sequence is expected to contain
 *    no block delimiters (defined in ZSTD_Sequence). Block boundaries are roughly determined based on
 *    the block size derived from the cctx, and sequences may be split. This is the default setting.
 *
 *    If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of ZSTD_Sequence is expected to contain
 *    block delimiters (defined in ZSTD_Sequence). Behavior is undefined if no block delimiters are provided.
 *
 *    If ZSTD_c_validateSequences == 0, this function will blindly accept the sequences provided. Invalid sequences cause undefined
 *    behavior. If ZSTD_c_validateSequences == 1, then if sequence is invalid (see doc/zstd_compression_format.md for
 *    specifics regarding offset/matchlength requirements) then the function will bail out and return an error.
 *
 *    In addition to the two adjustable experimental params, there are other important cctx params.
 *    - ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.
 *    - ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.
 *    - ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset
 *      is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md
 *
 * Note: Repcodes are, as of now, always re-calculated within this function, so ZSTD_Sequence::rep is unused.
 * Note 2: Once we integrate ability to ingest repcodes, the explicit block delims mode must respect those repcodes exactly,
 *         and cannot emit an RLE block that disagrees with the repcode history
 * @return : final compressed size or a ZSTD error.
 *//*! ZSTD_mergeBlockDelimiters() :
 * Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals
 * by merging them into into the literals of the next sequence.
 *
 * As such, the final generated result has no explicit representation of block boundaries,
 * and the final last literals segment is not represented in the sequences.
 *
 * The output of this function can be fed into ZSTD_compressSequences() with CCtx
 * setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters
 * @return : number of sequences left after merging
 *//*! ZSTD_generateSequences() :
 * Generate sequences using ZSTD_compress2, given a source buffer.
 *
 * Each block will end with a dummy sequence
 * with offset == 0, matchLength == 0, and litLength == length of last literals.
 * litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0)
 * simply acts as a block delimiter.
 *
 * zc can be used to insert custom compression params.
 * This function invokes ZSTD_compress2
 *
 * The output of this function can be fed into ZSTD_compressSequences() with CCtx
 * setting of ZSTD_c_blockDelimiters as ZSTD_sf_explicitBlockDelimiters
 * @return : number of sequences generated
 *//* Representation of ZSTD_Sequence contains explicit block delimiters *//* Representation of ZSTD_Sequence has no block delimiters, sequences only *//*! ZSTD_frameHeaderSize() :
 *  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX.
 * @return : size of the Frame Header,
 *           or an error code (if srcSize is too small) *//*! ZSTD_decompressBound() :
 *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
 *  `srcSize` must be the _exact_ size of this series
 *       (i.e. there should be a frame boundary at `src + srcSize`)
 *  @return : - upper-bound for the decompressed size of all data in all successive frames
 *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
 *
 *  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame.
 *  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`.
 *            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value.
 *  note 3  : when the decompressed size field isn't available, the upper-bound for that frame is calculated by:
 *              upper-bound = # blocks * min(128 KB, Window_Size)
 *//*! ZSTD_findDecompressedSize() :
 *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
 *  `srcSize` must be the _exact_ size of this series
 *       (i.e. there should be a frame boundary at `src + srcSize`)
 *  @return : - decompressed size of all data in all successive frames
 *            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
 *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
 *
 *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
 *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
 *   note 3 : decompressed size can be very large (64-bits value),
 *            potentially larger than what local system can handle as a single memory segment.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
 *            Always ensure result fits within application's authorized limits.
 *            Each application can set its own limits.
 *   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
 *            read each contained frame header.  This is fast as most of the data is skipped,
 *            however it does mean that all frame data must be present and valid. *//***************************************
*  Frame size functions
***************************************//* Do not use the feature *//* Force-enable the feature *//* Let the library automatically determine whether the feature shall be enabled *//* Note: This enum controls features which are conditionally beneficial. Zstd typically will make a final
   * decision on whether or not to enable the feature (ZSTD_ps_auto), but setting the switch to ZSTD_ps_enable
   * or ZSTD_ps_disable allow for a force enable/disable the feature.
   *//**< Always emit uncompressed literals. *//**< Always attempt Huffman compression. Uncompressed literals will still be
                               *   emitted if Huffman compression is not profitable. *//**< Automatically determine the compression mode based on the compression level.
                               *   Negative compression levels will be uncompressed, and positive compression
                               *   levels will be compressed. *//* Always reload the dictionary *//* Always copy the dictionary. *//* Never copy the dictionary. *//* Use the default heuristic. *//* Note: this enum and the behavior it controls are effectively internal
     * implementation details of the compressor. They are expected to continue
     * to evolve and should be considered only in the context of extremely
     * advanced performance tuning.
     *
     * Zstd currently supports the use of a CDict in three ways:
     *
     * - The contents of the CDict can be copied into the working context. This
     *   means that the compression can search both the dictionary and input
     *   while operating on a single set of internal tables. This makes
     *   the compression faster per-byte of input. However, the initial copy of
     *   the CDict's tables incurs a fixed cost at the beginning of the
     *   compression. For small compressions (< 8 KB), that copy can dominate
     *   the cost of the compression.
     *
     * - The CDict's tables can be used in-place. In this model, compression is
     *   slower per input byte, because the compressor has to search two sets of
     *   tables. However, this model incurs no start-up cost (as long as the
     *   working context's tables can be reused). For small inputs, this can be
     *   faster than copying the CDict's tables.
     *
     * - The CDict's tables are not used at all, and instead we use the working
     *   context alone to reload the dictionary and use params based on the source
     *   size. See ZSTD_compress_insertDictionary() and ZSTD_compress_usingDict().
     *   This method is effective when the dictionary sizes are very small relative
     *   to the input size, and the input size is fairly large to begin with.
     *
     * Zstd has a simple internal heuristic that selects which strategy to use
     * at the beginning of a compression. However, if experimentation shows that
     * Zstd is making poor choices, it is possible to override that choice with
     * this enum.
     *//* Note: this enum controls ZSTD_d_refMultipleDDicts *//* Note: this enum controls ZSTD_d_forceIgnoreChecksum *//* Variant of zstd frame format, without initial 4-bytes magic number.
                                 * Useful to save 4 bytes per generated frame.
                                 * Decoder cannot recognise automatically this format, requiring this instruction. *//* zstd frame format, specified in zstd_compression_format.md (default) *//**< Reference dictionary content -- the dictionary buffer must outlive its users. *//**< Copy dictionary content internally *//* refuses to load a dictionary if it does not respect Zstandard's specification, starting with ZSTD_MAGIC_DICTIONARY *//* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY *//* dictionary is "full" when starting with ZSTD_MAGIC_DICTIONARY, otherwise it is "rawContent" *//**< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression) *//**< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection *//**< 1: content size will be in frame header (when known) *//**< see ZSTD_strategy definition above *//**< acceptable match size for optimal parser (only) : larger == more compression, slower *//**< match length searched : larger == faster decompression, sometimes less compression *//**< nb of searches : larger == more compression, slower *//**< dispatch table : larger == faster, more memory *//**< fully searched segment : larger == more compression, slower, more memory (useless for fast) *//**< largest match distance : larger == more compression, more memory needed during decompression *//* Represents which repeat offset is represented by the field 'offset'.
                               * Ranges from [0, 3].
                               *
                               * Repeat offsets are essentially previous offsets from previous sequences sorted in
                               * recency order. For more detail, see doc/zstd_compression_format.md
                               *
                               * If rep == 0, then 'offset' does not contain a repeat offset.
                               * If rep > 0:
                               *  If litLength != 0:
                               *      rep == 1 --> offset == repeat_offset_1
                               *      rep == 2 --> offset == repeat_offset_2
                               *      rep == 3 --> offset == repeat_offset_3
                               *  If litLength == 0:
                               *      rep == 1 --> offset == repeat_offset_2
                               *      rep == 2 --> offset == repeat_offset_3
                               *      rep == 3 --> offset == repeat_offset_1 - 1
                               *
                               * Note: This field is optional. ZSTD_generateSequences() will calculate the value of
                               * 'rep', but repeat offsets do not necessarily need to be calculated from an external
                               * sequence provider's perspective. For example, ZSTD_compressSequences() does not
                               * use this 'rep' field at all (as of now).
                               *//* Note: Users of this API may provide a sequence with matchLength == litLength == offset == 0.
                               * In this case, we will treat the sequence as a marker for a block boundary.
                               *//* Match length of the sequence. *//* Literal length of the sequence. *//* The offset of the match. (NOT the same as the offset code)
                               * If offset == 0 and matchLength == 0, this sequence represents the last
                               * literals in the block of litLength size.
                               *//* ---  Advanced types  --- *//* Advanced parameter bounds *//* LDM parameter bounds *//* by default, the streaming decoder will refuse any frame
                                           * requiring larger than (1<<ZSTD_WINDOWLOG_LIMIT_DEFAULT) window size,
                                           * to preserve host's memory from unreasonable requirements.
                                           * This limit can be overridden using ZSTD_DCtx_setParameter(,ZSTD_d_windowLogMax,).
                                           * The limit does not apply for one-pass decoders (such as ZSTD_decompress()), since no additional memory is allocated *//* note : comparing this constant to an unsigned results in a tautological test *//* only for ZSTD_btopt+, faster strategies are limited to 4 *//* only for ZSTD_fast, other strategies are limited to 6 *//* compression parameter bounds *//* can be useful for static allocation *//* minimum input size required to query frame header size *//****************************************************************************************
 *   experimental API (static linking only)
 ****************************************************************************************
 * The following symbols and constants
 * are not planned to join "stable API" status in the near future.
 * They can still change in future versions.
 * Some of them are planned to remain in the static_only section indefinitely.
 * Some of them might be removed in the future (especially when redundant with existing stable functions)
 * ***************************************************************************************//* ZSTD_DISABLE_DEPRECATE_WARNINGS *//* Deprecation warnings :
 * Should these warnings be a problem, it is generally possible to disable them,
 * typically with -Wno-deprecated-declarations for gcc or _CRT_SECURE_NO_WARNINGS in Visual.
 * Otherwise, it's also possible to define ZSTD_DISABLE_DEPRECATE_WARNINGS.
 *//* This can be overridden externally to hide static symbols. *//* **************************************************************************************
 *   ADVANCED AND EXPERIMENTAL FUNCTIONS
 ****************************************************************************************
 * The definitions in the following section are considered experimental.
 * They are provided for advanced scenarios.
 * They should never be used with a dynamic library, as prototypes may change in the future.
 * Use them only in association with static linking.
 * ***************************************************************************************//* ZSTD_H_235446 *//*! ZSTD_sizeof_*() : Requires v1.4.0+
 *  These functions give the _current_ memory usage of selected object.
 *  Note that object memory usage can evolve (increase or decrease) over time. *//* ===   Memory management   === *//*! ZSTD_DCtx_refPrefix() : Requires v1.4.0+
 *  Reference a prefix (single-usage dictionary) to decompress next frame.
 *  This is the reverse operation of ZSTD_CCtx_refPrefix(),
 *  and must use the same prefix as the one used during compression.
 *  Prefix is **only used once**. Reference is discarded at end of frame.
 *  End of frame is reached when ZSTD_decompressStream() returns 0.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
 *  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
 *           Prefix buffer must remain unmodified up to the end of frame,
 *           reached when ZSTD_decompressStream() returns 0.
 *  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
 *           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
 *  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
 *           A full dictionary is more costly, as it requires building tables.
 *//*! ZSTD_DCtx_refDDict() : Requires v1.4.0+
 *  Reference a prepared dictionary, to be used to decompress next frames.
 *  The dictionary remains active for decompression of future frames using same DCtx.
 *
 *  If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function
 *  will store the DDict references in a table, and the DDict used for decompression
 *  will be determined at decompression time, as per the dict ID in the frame.
 *  The memory for the table is allocated on the first call to refDDict, and can be
 *  freed with ZSTD_freeDCtx().
 *
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Note 1 : Currently, only one dictionary can be managed.
 *           Referencing a new dictionary effectively "discards" any previous one.
 *  Special: referencing a NULL DDict means "return to no-dictionary mode".
 *  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.
 *//*! ZSTD_DCtx_loadDictionary() : Requires v1.4.0+
 *  Create an internal DDict from dict buffer,
 *  to be used to decompress next frames.
 *  The dictionary remains valid for all future frames, until explicitly invalidated.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
 *            meaning "return to no-dictionary mode".
 *  Note 1 : Loading a dictionary involves building tables,
 *           which has a non-negligible impact on CPU usage and latency.
 *           It's recommended to "load once, use many times", to amortize the cost
 *  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
 *           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
 *  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
 *           how dictionary content is loaded and interpreted.
 *//*! ZSTD_CCtx_refPrefix() : Requires v1.4.0+
 *  Reference a prefix (single-usage dictionary) for next compressed frame.
 *  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
 *  Decompression will need same prefix to properly regenerate data.
 *  Compressing with a prefix is similar in outcome as performing a diff and compressing it,
 *  but performs much faster, especially during decompression (compression speed is tunable with compression level).
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
 *  Note 1 : Prefix buffer is referenced. It **must** outlive compression.
 *           Its content must remain unmodified during compression.
 *  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
 *           ensure that the window size is large enough to contain the entire source.
 *           See ZSTD_c_windowLog.
 *  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
 *           It's a CPU consuming operation, with non-negligible impact on latency.
 *           If there is a need to use the same prefix multiple times, consider loadDictionary instead.
 *  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
 *           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation. *//*! ZSTD_CCtx_refCDict() : Requires v1.4.0+
 *  Reference a prepared dictionary, to be used for all next compressed frames.
 *  Note that compression parameters are enforced from within CDict,
 *  and supersede any compression parameter previously set within CCtx.
 *  The parameters ignored are labelled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
 *  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
 *  The dictionary will remain valid for future compressed frames using same CCtx.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special : Referencing a NULL CDict means "return to no-dictionary mode".
 *  Note 1 : Currently, only one dictionary can be managed.
 *           Referencing a new dictionary effectively "discards" any previous one.
 *  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx. *//*! ZSTD_CCtx_loadDictionary() : Requires v1.4.0+
 *  Create an internal CDict from `dict` buffer.
 *  Decompression will have to use same dictionary.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
 *           meaning "return to no-dictionary mode".
 *  Note 1 : Dictionary is sticky, it will be used for all future compressed frames.
 *           To return to "no-dictionary" situation, load a NULL dictionary (or reset parameters).
 *  Note 2 : Loading a dictionary involves building tables.
 *           It's also a CPU consuming operation, with non-negligible impact on latency.
 *           Tables are dependent on compression parameters, and for this reason,
 *           compression parameters can no longer be changed after loading a dictionary.
 *  Note 3 :`dict` content will be copied internally.
 *           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
 *           In such a case, dictionary buffer must outlive its users.
 *  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
 *           to precisely select how dictionary content must be interpreted. *//*******************************************************************************
 * Advanced dictionary and prefix API (Requires v1.4.0+)
 *
 * This API allows dictionaries to be used with ZSTD_compress2(),
 * ZSTD_compressStream2(), and ZSTD_decompressDCtx(). Dictionaries are sticky, and
 * only reset with the context is reset with ZSTD_reset_parameters or
 * ZSTD_reset_session_and_parameters. Prefixes are single-use.
 ******************************************************************************//*! ZSTD_getDictID_fromFrame() : Requires v1.4.0+
 *  Provides the dictID required to decompressed the frame stored within `src`.
 *  If @return == 0, the dictID could not be decoded.
 *  This could for one of the following reasons :
 *  - The frame does not require a dictionary to be decoded (most common case).
 *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.
 *    Note : this use case also happens when using a non-conformant dictionary.
 *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
 *  - This is not a Zstandard frame.
 *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code. *//*! ZSTD_getDictID_fromDDict() : Requires v1.4.0+
 *  Provides the dictID of the dictionary loaded into `ddict`.
 *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
 *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. *//*! ZSTD_getDictID_fromCDict() : Requires v1.5.0+
 *  Provides the dictID of the dictionary loaded into `cdict`.
 *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
 *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. *//*! ZSTD_getDictID_fromDict() : Requires v1.4.0+
 *  Provides the dictID stored within dictionary.
 *  if @return == 0, the dictionary is not conformant with Zstandard specification.
 *  It can still be loaded, but as a content-only dictionary. *//********************************
 *  Dictionary helper functions
 *******************************//*! ZSTD_decompress_usingDDict() :
 *  Decompression using a digested Dictionary.
 *  Recommended when same dictionary is used multiple times. *//*! ZSTD_freeDDict() :
 *  Function frees memory allocated with ZSTD_createDDict()
 *  If a NULL pointer is passed, no operation is performed. *//*! ZSTD_createDDict() :
 *  Create a digested dictionary, ready to start decompression operation without startup delay.
 *  dictBuffer can be released after DDict creation, as its content is copied inside DDict. *//*! ZSTD_compress_usingCDict() :
 *  Compression using a digested Dictionary.
 *  Recommended when same dictionary is used multiple times.
 *  Note : compression level is _decided at dictionary creation time_,
 *     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) *//*! ZSTD_freeCDict() :
 *  Function frees memory allocated by ZSTD_createCDict().
 *  If a NULL pointer is passed, no operation is performed. *//*! ZSTD_createCDict() :
 *  When compressing multiple messages or blocks using the same dictionary,
 *  it's recommended to digest the dictionary only once, since it's a costly operation.
 *  ZSTD_createCDict() will create a state from digesting a dictionary.
 *  The resulting state can be used for future compression operations with very limited startup cost.
 *  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
 * @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
 *  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
 *  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
 *      in which case the only thing that it transports is the @compressionLevel.
 *      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
 *      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary. *//***********************************
 *  Bulk processing dictionary API
 **********************************//*! ZSTD_decompress_usingDict() :
 *  Decompression using a known Dictionary.
 *  Dictionary must be identical to the one used during compression.
 *  Note : This function loads the dictionary, resulting in significant startup delay.
 *         It's intended for a dictionary used only once.
 *  Note : When `dict == NULL || dictSize < 8` no dictionary is used. *//*! ZSTD_compress_usingDict() :
 *  Compression at an explicit compression level using a Dictionary.
 *  A dictionary can be any arbitrary data segment (also called a prefix),
 *  or a buffer with specified information (see zdict.h).
 *  Note : This function loads the dictionary, resulting in significant startup delay.
 *         It's intended for a dictionary used only once.
 *  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used. *//**************************
*  Simple dictionary API
***************************//*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. *//*!< recommended size for input buffer *//* This function is redundant with the advanced API and equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_refDDict(zds, NULL);
 *//*===== ZSTD_DStream management functions =====*//* For compatibility with versions <= v1.2.0, prefer differentiating them. *//**< DCtx and DStream are now effectively same object (>= v1.3.0) *//*-***************************************************************************
*  Streaming decompression - HowTo
*
*  A ZSTD_DStream object is required to track streaming operations.
*  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.
*  ZSTD_DStream objects can be re-used multiple times.
*
*  Use ZSTD_initDStream() to start a new decompression operation.
* @return : recommended first input size
*  Alternatively, use advanced API to set specific properties.
*
*  Use ZSTD_decompressStream() repetitively to consume your input.
*  The function will update both `pos` fields.
*  If `input.pos < input.size`, some input has not been consumed.
*  It's up to the caller to present again remaining data.
*  The function tries to flush all data decoded immediately, respecting output buffer size.
*  If `output.pos < output.size`, decoder has flushed everything it could.
*  But if `output.pos == output.size`, there might be some data left within internal buffers.,
*  In which case, call ZSTD_decompressStream() again to flush whatever remains in the buffer.
*  Note : with no additional input provided, amount of data flushed is necessarily <= ZSTD_BLOCKSIZE_MAX.
* @return : 0 when a frame is completely decoded and fully flushed,
*        or an error code, which can be tested using ZSTD_isError(),
*        or any other value > 0, which means there is still some decoding or flushing to do to complete current frame :
*                                the return value is a suggested next input size (just a hint for better latency)
*                                that will never request more than the remaining frame size.
* *******************************************************************************//*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end). *//*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush). *//*!
 * Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
 * NOTE: The return value is different. ZSTD_compressStream() returns a hint for
 * the next read size (if non-zero and not an error). ZSTD_compressStream2()
 * returns the minimum nb of bytes left to flush (if non-zero and not an error).
 *//*!
 * Equivalent to:
 *
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *//* *****************************************************************************
 * This following is a legacy streaming API, available since v1.0+ .
 * It can be replaced by ZSTD_CCtx_reset() and ZSTD_compressStream2().
 * It is redundant, but remains fully supported.
 * Streaming in combination with advanced parameters and dictionary compression
 * can only be used through the new API.
 ******************************************************************************//**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. *//**< recommended size for input buffer *//* These buffer sizes are softly recommended.
 * They are not required : ZSTD_compressStream*() happily accepts any buffer size, for both input and output.
 * Respecting the recommended size just makes it a bit easier for ZSTD_compressStream*(),
 * reducing the amount of memory shuffling and buffering, resulting in minor performance savings.
 *
 * However, note that these recommendations are from the perspective of a C caller program.
 * If the streaming interface is invoked from some other language,
 * especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo,
 * a major performance rule is to reduce crossing such interface to an absolute minimum.
 * It's not rare that performance ends being spent more into the interface, rather than compression itself.
 * In which cases, prefer using large buffers, as large as practical,
 * for both input and output, to reduce the nb of roundtrips.
 *//*! ZSTD_compressStream2() : Requires v1.4.0+
 *  Behaves about the same as ZSTD_compressStream, with additional control on end directive.
 *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
 *  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
 *  - output->pos must be <= dstCapacity, input->pos must be <= srcSize
 *  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
 *  - endOp must be a valid directive
 *  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
 *  - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
 *                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.
 *                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
 *  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
 *  - @return provides a minimum amount of data remaining to be flushed from internal buffers
 *            or an error code, which can be tested using ZSTD_isError().
 *            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
 *            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
 *            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
 *  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
 *            only ZSTD_e_end or ZSTD_e_flush operations are allowed.
 *            Before starting a new compression job, or changing compression parameters,
 *            it is required to fully flush internal buffers.
 *//* flush any remaining data _and_ close current frame.
                        * note that frame is only closed after compressed data is fully flushed (return value == 0).
                        * After that point, any additional data starts a new frame.
                        * note : each frame is independent (does not reference any content from previous frame).
                        : note : multithreaded compression will block to flush as much output as possible. *//* flush any data provided so far,
                        * it creates (at least) one new block, that can be decoded immediately on reception;
                        * frame will continue: any future data can still reference previously compressed data, improving compression.
                        * note : multithreaded compression will block to flush as much output as possible. *//* collect more data, encoder decides when to output compressed result, for optimal compression ratio *//*===== ZSTD_CStream management functions =====*//* Continue to distinguish them for compatibility with older versions <= v1.2.0 *//**< CCtx and CStream are now effectively same object (>= v1.3.0) *//*-***********************************************************************
*  Streaming compression - HowTo
*
*  A ZSTD_CStream object is required to track streaming operation.
*  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.
*  ZSTD_CStream objects can be reused multiple times on consecutive compression operations.
*  It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.
*
*  For parallel execution, use one separate ZSTD_CStream per thread.
*
*  note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.
*
*  Parameters are sticky : when starting a new compression on the same context,
*  it will re-use the same sticky parameters as previous compression session.
*  When in doubt, it's recommended to fully initialize the context before usage.
*  Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),
*  ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to
*  set more specific parameters, the pledged source size, or load a dictionary.
*
*  Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to
*  consume input stream. The function will automatically update both `pos`
*  fields within `input` and `output`.
*  Note that the function may not consume the entire input, for example, because
*  the output buffer is already full, in which case `input.pos < input.size`.
*  The caller must check if input has been entirely consumed.
*  If not, the caller must make some room to receive more compressed data,
*  and then present again remaining input data.
*  note: ZSTD_e_continue is guaranteed to make some forward progress when called,
*        but doesn't guarantee maximal forward progress. This is especially relevant
*        when compressing with multiple threads. The call won't block if it can
*        consume some input, but if it can't it will wait for some, but not all,
*        output to be flushed.
* @return : provides a minimum amount of data remaining to be flushed from internal buffers
*           or an error code, which can be tested using ZSTD_isError().
*
*  At any moment, it's possible to flush whatever data might remain stuck within internal buffer,
*  using ZSTD_compressStream2() with ZSTD_e_flush. `output->pos` will be updated.
*  Note that, if `output->size` is too small, a single invocation with ZSTD_e_flush might not be enough (return code > 0).
*  In which case, make some room to receive more compressed data, and call again ZSTD_compressStream2() with ZSTD_e_flush.
*  You must continue calling ZSTD_compressStream2() with ZSTD_e_flush until it returns 0, at which point you can change the
*  operation.
*  note: ZSTD_e_flush will flush as much output as possible, meaning when compressing with multiple threads, it will
*        block until the flush is complete or the output buffer is full.
*  @return : 0 if internal buffers are entirely flushed,
*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
*            or an error code, which can be tested using ZSTD_isError().
*
*  Calling ZSTD_compressStream2() with ZSTD_e_end instructs to finish a frame.
*  It will perform a flush and write frame epilogue.
*  The epilogue is required for decoders to consider a frame completed.
*  flush operation is the same, and follows same rules as calling ZSTD_compressStream2() with ZSTD_e_flush.
*  You must continue calling ZSTD_compressStream2() with ZSTD_e_end until it returns 0, at which point you are free to
*  start a new frame.
*  note: ZSTD_e_end will flush as much output as possible, meaning when compressing with multiple threads, it will
*        block until the flush is complete or the output buffer is full.
*  @return : 0 if frame fully completed and fully flushed,
*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
*            or an error code, which can be tested using ZSTD_isError().
*
* *******************************************************************//*! ZSTD_DCtx_reset() :
 *  Return a DCtx to clean state.
 *  Session and parameters can be reset jointly or separately.
 *  Parameters can only be reset when no active frame is being decompressed.
 * @return : 0, or an error code, which can be tested with ZSTD_isError()
 *//*! ZSTD_DCtx_setParameter() :
 *  Set one compression parameter, selected by enum ZSTD_dParameter.
 *  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
 *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
 *  Setting a parameter is only possible during frame initialization (before starting decompression).
 * @return : 0, or an error code (which can be tested using ZSTD_isError()).
 *//*! ZSTD_dParam_getBounds() :
 *  All parameters must belong to an interval with lower and upper bounds,
 *  otherwise they will either trigger an error or be automatically clamped.
 * @return : a structure, ZSTD_bounds, which contains
 *         - an error status field, which must be tested using ZSTD_isError()
 *         - both lower and upper bounds, inclusive
 *//* note : additional experimental parameters are also available
     * within the experimental section of the API.
     * At the time of this writing, they include :
     * ZSTD_d_format
     * ZSTD_d_stableOutBuffer
     * ZSTD_d_forceIgnoreChecksum
     * ZSTD_d_refMultipleDDicts
     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
     * note : never ever use experimentalParam? names directly
     *//* Select a size limit (in power of 2) beyond which
                              * the streaming API will refuse to allocate memory buffer
                              * in order to protect the host from unreasonable memory requirements.
                              * This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
                              * By default, a decompression context accepts window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT).
                              * Special: value 0 means "use default maximum windowLog". *//* The advanced API pushes parameters one by one into an existing DCtx context.
 * Parameters are sticky, and remain valid for all following frames
 * using the same DCtx context.
 * It's possible to reset parameters to default values using ZSTD_DCtx_reset().
 * Note : This API is compatible with existing ZSTD_decompressDCtx() and ZSTD_decompressStream().
 *        Therefore, no new decompression function is necessary.
 *//***********************************************
*  Advanced decompression API (Requires v1.4.0+)
************************************************//*! ZSTD_compress2() :
 *  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
 *  ZSTD_compress2() always starts a new frame.
 *  Should cctx hold data from a previously unfinished frame, everything about it is forgotten.
 *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
 *  - The function is always blocking, returns when compression is completed.
 *  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
 * @return : compressed size written into `dst` (<= `dstCapacity),
 *           or an error code if it fails (which can be tested using ZSTD_isError()).
 *//*! ZSTD_CCtx_reset() :
 *  There are 2 different things that can be reset, independently or jointly :
 *  - The session : will stop compressing current frame, and make CCtx ready to start a new one.
 *                  Useful after an error, or to interrupt any ongoing compression.
 *                  Any internal data not yet flushed is cancelled.
 *                  Compression parameters and dictionary remain unchanged.
 *                  They will be used to compress next frame.
 *                  Resetting session never fails.
 *  - The parameters : changes all parameters back to "default".
 *                  This removes any reference to any dictionary too.
 *                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)
 *                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())
 *  - Both : similar to resetting the session, followed by resetting parameters.
 *//*! ZSTD_CCtx_setPledgedSrcSize() :
 *  Total input data size to be compressed as a single frame.
 *  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
 *  This value will also be controlled at end of frame, and trigger an error if not respected.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
 *           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
 *           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
 *  Note 2 : pledgedSrcSize is only valid once, for the next frame.
 *           It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
 *  Note 3 : Whenever all input data is provided and consumed in a single round,
 *           for example with ZSTD_compress2(),
 *           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
 *           this value is automatically overridden by srcSize instead.
 *//*! ZSTD_CCtx_setParameter() :
 *  Set one compression parameter, selected by enum ZSTD_cParameter.
 *  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
 *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
 *  Setting a parameter is generally only possible during frame initialization (before starting compression).
 *  Exception : when using multi-threading mode (nbWorkers >= 1),
 *              the following parameters can be updated _during_ compression (within same frame):
 *              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
 *              new parameters will be active for next job only (after a flush()).
 * @return : an error code (which can be tested using ZSTD_isError()).
 *//*! ZSTD_cParam_getBounds() :
 *  All parameters must belong to an interval with lower and upper bounds,
 *  otherwise they will either trigger an error or be automatically clamped.
 * @return : a structure, ZSTD_bounds, which contains
 *         - an error status field, which must be tested using ZSTD_isError()
 *         - lower and upper bounds, both inclusive
 *//* note : additional experimental parameters are also available
     * within the experimental section of the API.
     * At the time of this writing, they include :
     * ZSTD_c_rsyncable
     * ZSTD_c_format
     * ZSTD_c_forceMaxWindow
     * ZSTD_c_forceAttachDict
     * ZSTD_c_literalCompressionMode
     * ZSTD_c_targetCBlockSize
     * ZSTD_c_srcSizeHint
     * ZSTD_c_enableDedicatedDictSearch
     * ZSTD_c_stableInBuffer
     * ZSTD_c_stableOutBuffer
     * ZSTD_c_blockDelimiters
     * ZSTD_c_validateSequences
     * ZSTD_c_useBlockSplitter
     * ZSTD_c_useRowMatchFinder
     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
     * note : never ever use experimentalParam? names directly;
     *        also, the enums values themselves are unstable and can still change.
     *//* Control the overlap size, as a fraction of window size.
                              * The overlap size is an amount of data reloaded from previous job at the beginning of a new job.
                              * It helps preserve compression ratio, while each job is compressed in parallel.
                              * This value is enforced only when nbWorkers >= 1.
                              * Larger values increase compression ratio, but decrease speed.
                              * Possible values range from 0 to 9 :
                              * - 0 means "default" : value will be determined by the library, depending on strategy
                              * - 1 means "no overlap"
                              * - 9 means "full overlap", using a full window size.
                              * Each intermediate rank increases/decreases load size by a factor 2 :
                              * 9: full window;  8: w/2;  7: w/4;  6: w/8;  5:w/16;  4: w/32;  3:w/64;  2:w/128;  1:no overlap;  0:default
                              * default value varies between 6 and 9, depending on strategy *//* Size of a compression job. This value is enforced only when nbWorkers >= 1.
                              * Each compression job is completed in parallel, so this value can indirectly impact the nb of active threads.
                              * 0 means default, which is dynamically determined based on compression parameters.
                              * Job size must be a minimum of overlap size, or ZSTDMT_JOBSIZE_MIN (= 512 KB), whichever is largest.
                              * The minimum size is automatically and transparently enforced. *//* Select how many threads will be spawned to compress in parallel.
                              * When nbWorkers >= 1, triggers asynchronous mode when invoking ZSTD_compressStream*() :
                              * ZSTD_compressStream*() consumes input and flush output if possible, but immediately gives back control to caller,
                              * while compression is performed in parallel, within worker thread(s).
                              * (note : a strong exception to this rule is when first invocation of ZSTD_compressStream2() sets ZSTD_e_end :
                              *  in which case, ZSTD_compressStream2() delegates to ZSTD_compress2(), which is always a blocking call).
                              * More workers improve speed, but also increase memory usage.
                              * Default value is `0`, aka "single-threaded mode" : no worker is spawned,
                              * compression is performed inside Caller's thread, and all invocations are blocking *//* These parameters are only active if multi-threading is enabled (compiled with build macro ZSTD_MULTITHREAD).
     * Otherwise, trying to set any other value than default (0) will be a no-op and return an error.
     * In a situation where it's unknown if the linked library supports multi-threading or not,
     * setting ZSTD_c_nbWorkers to any value >= 1 and consulting the return value provides a quick way to check this property.
     *//* multi-threading parameters *//* When applicable, dictionary's ID is written into frame header (default:1) *//* A 32-bits checksum of content is written at end of frame (default:0) *//* Content size will be written into frame header _whenever known_ (default:1)
                              * Content size must be known at the beginning of compression.
                              * This is automatically the case when using ZSTD_compress2(),
                              * For streaming scenarios, content size must be provided with ZSTD_CCtx_setPledgedSrcSize() *//* frame parameters *//* Frequency of inserting/looking up entries into the LDM hash table.
                              * Must be clamped between 0 and (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).
                              * Default is MAX(0, (windowLog - ldmHashLog)), optimizing hash table usage.
                              * Larger values improve compression speed.
                              * Deviating far from default value will likely result in a compression ratio decrease.
                              * Special: value 0 means "automatically determine hashRateLog". *//* Log size of each bucket in the LDM hash table for collision resolution.
                              * Larger values improve collision resolution but decrease compression speed.
                              * The maximum value is ZSTD_LDM_BUCKETSIZELOG_MAX.
                              * Special: value 0 means "use default value" (default: 3). *//* Minimum match size for long distance matcher.
                              * Larger/too small values usually decrease compression ratio.
                              * Must be clamped between ZSTD_LDM_MINMATCH_MIN and ZSTD_LDM_MINMATCH_MAX.
                              * Special: value 0 means "use default value" (default: 64). *//* Size of the table for long distance matching, as a power of 2.
                              * Larger values increase memory usage and compression ratio,
                              * but decrease compression speed.
                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX
                              * default: windowlog - 7.
                              * Special: value 0 means "automatically determine hashlog". *//* Enable long distance matching.
                                     * This parameter is designed to improve compression ratio
                                     * for large inputs, by finding large matches at long distance.
                                     * It increases memory usage and window size.
                                     * Note: enabling this parameter increases default ZSTD_c_windowLog to 128 MB
                                     * except when expressly set to a different value.
                                     * Note: will be enabled by default if ZSTD_c_windowLog >= 128 MB and
                                     * compression strategy >= ZSTD_btopt (== compression level 16+) *//* LDM mode parameters *//* See ZSTD_strategy enum definition.
                              * The higher the value of selected strategy, the more complex it is,
                              * resulting in stronger and slower compression.
                              * Special: value 0 means "use default strategy". *//* Impact of this field depends on strategy.
                              * For strategies btopt, btultra & btultra2:
                              *     Length of Match considered "good enough" to stop search.
                              *     Larger values make compression stronger, and slower.
                              * For strategy fast:
                              *     Distance between match sampling.
                              *     Larger values make compression faster, and weaker.
                              * Special: value 0 means "use default targetLength". *//* Minimum size of searched matches.
                              * Note that Zstandard can still find matches of smaller size,
                              * it just tweaks its search algorithm to look for this size and larger.
                              * Larger values increase compression and decompression speed, but decrease ratio.
                              * Must be clamped between ZSTD_MINMATCH_MIN and ZSTD_MINMATCH_MAX.
                              * Note that currently, for all strategies < btopt, effective minimum is 4.
                              *                    , for all strategies > fast, effective maximum is 6.
                              * Special: value 0 means "use default minMatchLength". *//* Number of search attempts, as a power of 2.
                              * More attempts result in better and slower compression.
                              * This parameter is useless for "fast" and "dFast" strategies.
                              * Special: value 0 means "use default searchLog". *//* Size of the multi-probe search table, as a power of 2.
                              * Resulting memory usage is (1 << (chainLog+2)).
                              * Must be clamped between ZSTD_CHAINLOG_MIN and ZSTD_CHAINLOG_MAX.
                              * Larger tables result in better and slower compression.
                              * This parameter is useless for "fast" strategy.
                              * It's still useful when using "dfast" strategy,
                              * in which case it defines a secondary probe table.
                              * Special: value 0 means "use default chainLog". *//* Size of the initial probe table, as a power of 2.
                              * Resulting memory usage is (1 << (hashLog+2)).
                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.
                              * Larger tables improve compression ratio of strategies <= dFast,
                              * and improve speed of strategies > dFast.
                              * Special: value 0 means "use default hashLog". *//* Maximum allowed back-reference distance, expressed as power of 2.
                              * This will set a memory budget for streaming decompression,
                              * with larger values requiring more memory
                              * and typically compressing more.
                              * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.
                              * Special: value 0 means "use default windowLog".
                              * Note: Using a windowLog greater than ZSTD_WINDOWLOG_LIMIT_DEFAULT
                              *       requires explicitly allowing such size at streaming decompression stage. *//* Advanced compression parameters :
     * It's possible to pin down compression parameters to some specific values.
     * In which case, these values are no longer dynamically selected by the compressor *//* Set compression parameters according to pre-defined cLevel table.
                              * Note that exact compression parameters are dynamically determined,
                              * depending on both compression level and srcSize (when known).
                              * Default level is ZSTD_CLEVEL_DEFAULT==3.
                              * Special: value 0 means default, which is controlled by ZSTD_CLEVEL_DEFAULT.
                              * Note 1 : it's possible to pass a negative compression level.
                              * Note 2 : setting a level does not automatically set all other compression parameters
                              *   to default. Setting this will however eventually dynamically impact the compression
                              *   parameters which have not been manually set. The manually set
                              *   ones will 'stick'. *//* compression parameters
     * Note: When compressing with a ZSTD_CDict these parameters are superseded
     * by the parameters used to construct the ZSTD_CDict.
     * See ZSTD_CCtx_refCDict() for more info (superseded-by-cdict). *//* note : new strategies _might_ be added in the future.
                         Only the order (from fast to strong) is guaranteed *//* Compression strategies, listed from fastest to strongest *//* API design :
 *   Parameters are pushed one by one into an existing context,
 *   using ZSTD_CCtx_set*() functions.
 *   Pushed parameters are sticky : they are valid for next compressed frame, and any subsequent frame.
 *   "sticky" parameters are applicable to `ZSTD_compress2()` and `ZSTD_compressStream*()` !
 *   __They do not apply to "simple" one-shot variants such as ZSTD_compressCCtx()__ .
 *
 *   It's possible to reset all parameters to "default" using ZSTD_CCtx_reset().
 *
 *   This API supersedes all other "advanced" API entry points in the experimental section.
 *   In the future, we expect to remove from experimental API entry points which are redundant with this API.
 *//*********************************************
*  Advanced compression API (Requires v1.4.0+)
**********************************************//*! ZSTD_decompressDCtx() :
 *  Same as ZSTD_decompress(),
 *  requires an allocated ZSTD_DCtx.
 *  Compatible with sticky parameters.
 *//*= Decompression context
 *  When decompressing many times,
 *  it is recommended to allocate a context only once,
 *  and re-use it for each successive compression operation.
 *  This will make workload friendlier for system's memory.
 *  Use one context per thread for parallel execution. *//*! ZSTD_compressCCtx() :
 *  Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
 *  Important : in order to behave similarly to `ZSTD_compress()`,
 *  this function compresses at requested compression level,
 *  __ignoring any other parameter__ .
 *  If any advanced parameter was set using the advanced API,
 *  they will all be reset. Only `compressionLevel` remains.
 *//*= Compression context
 *  When compressing many times,
 *  it is recommended to allocate a context just once,
 *  and re-use it for each successive compression operation.
 *  This will make workload friendlier for system's memory.
 *  Note : re-using context is just a speed / resource optimization.
 *         It doesn't change the compression ratio, which remains identical.
 *  Note 2 : In multi-threaded environments,
 *         use one different context per thread for parallel execution.
 *//***************************************
*  Explicit context
***************************************//*!< default compression level, specified by ZSTD_CLEVEL_DEFAULT, requires v1.5.0+ *//*!< minimum negative compression level allowed, requires v1.4.0+ *//*!< maximum compressed size in worst case single-pass scenario *//* this formula ensures that bound(A) + bound(B) <= bound(A+B) as long as A and B >= 128 KB *//* margin, from 64 to 0 *//*! ZSTD_findFrameCompressedSize() : Requires v1.4.0+
 * `src` should point to the start of a ZSTD frame or skippable frame.
 * `srcSize` must be >= first frame size
 * @return : the compressed size of the first frame starting at `src`,
 *           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,
 *        or an error code if input is invalid *//*! ZSTD_getDecompressedSize() :
 *  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
 *  Both functions work the same way, but ZSTD_getDecompressedSize() blends
 *  "empty", "unknown" and "error" results to the same return value (0),
 *  while ZSTD_getFrameContentSize() gives them separate return values.
 * @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise. *//*! ZSTD_getFrameContentSize() : requires v1.3.0+
 *  `src` should point to the start of a ZSTD encoded frame.
 *  `srcSize` must be at least as large as the frame header.
 *            hint : any size >= `ZSTD_frameHeaderSize_max` is large enough.
 *  @return : - decompressed size of `src` frame content, if known
 *            - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
 *            - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small)
 *   note 1 : a 0 return value means the frame is valid but "empty".
 *   note 2 : decompressed size is an optional field, it may not be present, typically in streaming mode.
 *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *            Optionally, application can rely on some implicit limit,
 *            as ZSTD_decompress() only needs an upper bound of decompressed size.
 *            (For example, data could be necessarily cut into blocks <= 16 KB).
 *   note 3 : decompressed size is always present when compression is completed using single-pass functions,
 *            such as ZSTD_compress(), ZSTD_compressCCtx() ZSTD_compress_usingDict() or ZSTD_compress_usingCDict().
 *   note 4 : decompressed size can be very large (64-bits value),
 *            potentially larger than what local system can handle as a single memory segment.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified.
 *            Always ensure return value fits within application's authorized limits.
 *            Each application can set its own limits.
 *   note 6 : This function replaces ZSTD_getDecompressedSize() *//*! ZSTD_decompress() :
 *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
 *  `dstCapacity` is an upper bound of originalSize to regenerate.
 *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
 *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
 *            or an errorCode if it fails (which can be tested using ZSTD_isError()). *//*! ZSTD_compress() :
 *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
 *  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
 *  @return : compressed size written into `dst` (<= `dstCapacity),
 *            or an error code if it fails (which can be tested using ZSTD_isError()). *//* all 16 values, from 0x184D2A50 to 0x184D2A5F, signal the beginning of a skippable frame *//* valid since v0.7.0 *//* valid since v0.8.0 *//* All magic numbers are supposed read/written to/from files/memory using little-endian convention *//* *************************************
 *  Constants
 ***************************************//* *************************************
 *  Default constant
 ***************************************//*! ZSTD_versionString() :
 *  Return runtime library version, like "1.4.5". Requires v1.3.0+. *//*! ZSTD_versionNumber() :
 *  Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE). *//*******************************************************************************
  Introduction

  zstd, short for Zstandard, is a fast lossless compression algorithm, targeting
  real-time compression scenarios at zlib-level and better compression ratios.
  The zstd compression library provides in-memory compression and decompression
  functions.

  The library supports regular compression levels from 1 up to ZSTD_maxCLevel(),
  which is currently 22. Levels >= 20, labeled `--ultra`, should be used with
  caution, as they require more memory. The library also offers negative
  compression levels, which extend the range of speed vs. ratio preferences.
  The lower the level, the faster the speed (at the cost of compression).

  Compression can be done in:
    - a single step (described as Simple API)
    - a single step, reusing a context (described as Explicit context)
    - unbounded multiple steps (described as Streaming compression)

  The compression ratio achievable on small data can be highly improved using
  a dictionary. Dictionary compression can be performed in:
    - a single step (described as Simple dictionary API)
    - a single step, reusing a dictionary (described as Bulk-processing
      dictionary API)

  Advanced experimental functions can be accessed using
  `#define ZSTD_STATIC_LINKING_ONLY` before including zstd.h.

  Advanced experimental APIs should never be used with a dynamically-linked
  library. They are not "stable"; their definitions or signatures may change in
  the future. Only static linking is allowed.
*******************************************************************************//* =====   ZSTDLIB_API : control library symbols visibility   ===== *//* INT_MAX */cParestimatedSrcSizemagicVariantinSeqsinSeqsSizesequencesseqsSizezcoutSeqsoutSeqsSizedParam/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/pool.h"../zstd.h"POOL_ctxPOOL_functionZSTD_STATIC_LINKING_ONLYPOOL_HPOOL_tryAddPOOL_addPOOL_sizeofconst POOL_ctxconst POOL_ctx *POOL_resizePOOL_freePOOL_create_advancedPOOL_create/*! POOL_tryAdd() :
 *  Add the job `function(opaque)` to thread pool _if_ a queue slot is available.
 *  Returns immediately even if not (does not block).
 * @return : 1 if successful, 0 if not.
 *//*! POOL_add() :
 *  Add the job `function(opaque)` to the thread pool. `ctx` must be valid.
 *  Possibly blocks until there is room in the queue.
 *  Note : The function may be executed asynchronously,
 *         therefore, `opaque` must live until function has been completed.
 *//*! POOL_function :
 *  The function type that can be added to a thread pool.
 *//*! POOL_sizeof() :
 * @return threadpool memory usage
 *  note : compatible with NULL (returns 0 in this case)
 *//*! POOL_resize() :
 *  Expands or shrinks pool's number of threads.
 *  This is more efficient than releasing + creating a new context,
 *  since it tries to preserve and re-use existing threads.
 * `numThreads` must be at least 1.
 * @return : 0 when resize was successful,
 *           !0 (typically 1) if there is an error.
 *    note : only numThreads can be resized, queueSize remains unchanged.
 *//*! POOL_free() :
 *  Free a thread pool returned by POOL_create().
 *//*! POOL_create() :
 *  Create a thread pool with at most `numThreads` threads.
 * `numThreads` must be at least 1.
 *  The maximum number of queued jobs before blocking is `queueSize`.
 * @return : POOL_ctx pointer on success, else NULL.
*//* ZSTD_customMem */queueSize/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/zstd_internal.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/cpu.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/xxhash.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/zstd_trace.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/threading.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/pool.c"threading.h""pool.h""zstd_internal.h"ctx != ((void *)0)290pthread_mutex_t **union <unnamed> **277&ctx->queuePushCondpthread_cond_t **POOL_add_internalconst POOL_jobPOOL_job *POOL_job_s *&ctx->queuePopCondisQueueFullPOOL_resize_internalpthread_t *constthreadPoolsizeof(ZSTD_pthread_t)ctx->threadsctx->threadCapacity * sizeof(*threadPool)threadId&threadPool[threadId]&POOL_threadsizeof(POOL_job)POOL_joinsizeof(POOL_ctx)POOL_threadPOOL_ctx *constPOOL_jobPOOL_job_squeuePopCondqueuePushCondqueueEmptyqueueTailqueueHeadthreadLimitthreadCapacityZSTD_MULTITHREAD/* ZSTD_MULTITHREAD *//* We don't need any data, but if it is empty, malloc() might return NULL. *//* No multi-threading support *//* ZSTD_MULTITHREAD  not defined *//* Wait until there is space in the queue for the new job *//**
 * Returns 1 if the queue is full and 0 otherwise.
 *
 * When queueSize is 1 (pool was created with an intended queueSize of 0),
 * then a queue is empty if there is a thread free _and_ no job is waiting.
 *//* @return : 0 on success, 1 on error *//* successfully expanded *//* Initialize additional threads *//* replace existing thread pool *//* numThreads > threadCapacity *//* note : could fail *//*! POOL_join() :
    Shutdown the queue, wake any sleeping threads, and join all of the threads.
*//* Check for errors *//* Allocate space for the thread handles *//* Initialize the job queue.
     * It needs one extra space since one space is wasted to differentiate
     * empty and full queues.
     *//* Check parameters *//* ZSTD_createThreadPool() : public access point *//* If the intended queue size was 0, signal after finishing job *//* Unlock the mutex, signal a pusher, and run the job *//* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),
                 * a few threads will be shutdown while !queueEmpty,
                 * but enough threads will remain active to finish the queue *//* Lock the mutex and wait for a non-empty queue or until shutdown *//* POOL_thread() :
 * Work thread for the thread pool.
 * Waits for jobs and executes them.
 * @returns : NULL on failure else non-null.
 *//* Condition variables for poppers to wait on when the queue is empty *//* Indicates if the queue is empty *//* The queue is a circular buffer *//* A job is a function and an opaque argument *//* ======   Compiler specifics   ====== *//* ZSTD_customMalloc, ZSTD_customFree */ZSTD_pthread_join(a,b)ZSTD_pthread_create(a,b,c,d)ZSTD_pthread_tZSTD_pthread_cond_broadcast(a)pthread_cond_broadcast(*(a))ZSTD_pthread_cond_signal(a)pthread_cond_signal(*(a))ZSTD_pthread_cond_wait(a,b)pthread_cond_wait(*(a), *(b))ZSTD_pthread_cond_tpthread_cond_t*ZSTD_pthread_mutex_unlock(a)pthread_mutex_unlock(*(a))ZSTD_pthread_mutex_lock(a)pthread_mutex_lock(*(a))ZSTD_pthread_mutex_tpthread_mutex_t*defined(ZSTD_MULTITHREAD) && defined(_WIN32)defined(ZSTD_MULTITHREAD)DEBUGLEVEL < 1ZSTD_pthread_cond_destroyZSTD_pthread_cond_initZSTD_pthread_mutex_destroyZSTD_pthread_mutex_init/* do not use ZSTD_pthread_t *//* ZSTD_MULTITHREAD not defined *//* Debug implementation of threading.
 * In this implementation we use pointers for mutexes and condition variables.
 * This way, if we forget to init/destroy them the program will crash or ASAN
 * will report leaks.
 *//* DEBUGLEVEL >= 1 *//* ZSTD_pthread_create() and ZSTD_pthread_join() *//**
 * Copyright (c) 2016 Tino Reichardt
 * All rights reserved.
 *
 * You can contact the author at:
 * - zstdmt source repository: https://github.com/mcmilk/zstdmt
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/threading.c*condsizeof(pthread_cond_t)*mutexsizeof(pthread_mutex_t)g_ZSTD_threading_useless_symboldefined(ZSTD_MULTITHREAD) && DEBUGLEVEL >= 1 && !defined(_WIN32)ZSTD_XXH64_hashFromCanonicalZSTD_ZSTD_XXH64_canonicalFromHashZSTD_XXH64_digeststate->v[0]state->v[1]state->v[2]state->v[3]XXH64_hash_t[4]const XXH64_hash_tconst XXH64_hash_t *XXH_PRIME64_5const xxh_u8const xxh_u8 *ZSTD_XXH64_updatelen == 0const xxh_u8 *constxxh_u8 *ZSTD_XXH64_resetstatePtr != NULLstatePtr != ((void *)0)2547sizeof(*statePtr)XXH_PRIME64_1XXH_PRIME64_2ZSTD_XXH64_copyStateZSTD_XXH64_freeStateZSTD_XXH64_createStateZSTD_XXH6424712434const xxh_u64XXH_PRIME64_4XXH_PRIME64_3const xxh_u64 *xxh_u64 *ZSTD_XXH32_hashFromCanonicalZSTD_XXH32_canonicalFromHashZSTD_XXH32_digestXXH32_hash_t[4]const XXH32_hash_tconst XXH32_hash_t *XXH_PRIME32_5ZSTD_XXH32_update2148const xxh_u32const xxh_u32 *ZSTD_XXH32_reset2133XXH_PRIME32_1XXH_PRIME32_2ZSTD_XXH32_copyStateZSTD_XXH32_freeStateZSTD_XXH32_createStateZSTD_XXH3220601980XXH32_ENDJMP!XXH32_ENDJMP2034XXH_PRIME32_3ZSTD_XXH_versionNumber800xxh_u32 *xxh_u64xxh_u32xxh_u8sizeof(XXH64_hash_t)reserved64reserved32XXH_PROCESS8_64XXH_PROCESS4_64XXH_PROCESS1_64XXH_readLE64_align(p, align)0x27D4EB2F165667C5ULL0x85EBCA77C2B2AE63ULL0x165667B19E3779F9ULL0xC2B2AE3D27D4EB4FULL0x9E3779B185EBCA87ULLXXH_PROCESS4XXH_PROCESS1do { h32 += XXH_get32bits(ptr) * XXH_PRIME32_3; ptr += 4; h32 = XXH_rotl32(h32, 17) * XXH_PRIME32_4; } while (0)do { h32 += (*ptr++) * XXH_PRIME32_5; h32 = XXH_rotl32(h32, 11) * XXH_PRIME32_1; } while (0)XXH_readLE32_align(p, align)0x165667B1UXXH_PRIME32_40x27D4EB2FU0xC2B2AE3DU0x85EBCA77U0x9E3779B1U(((x) << (r)) | ((x) >> (64 - (r))))(((x) << (r)) | ((x) >> (32 - (r))))XXH_HAS_BUILTIN(x)XXH_COMPILER_GUARD(var)__asm__ __volatile__("" : "+r" (var))XXH_STATIC_ASSERT_WITH_MESSAGE((c),#c)XXH_STATIC_ASSERT_WITH_MESSAGE(c,m)do { struct xxh_sa { char x[(c) ? 1 : -1]; }; } while(0)XXH_ASSERT(c)assert(c)XXH_DEBUGLEVELXXH_NO_INLINEXXH_FORCE_INLINEXXH_NO_INLINE_HINTSXXH_IMPLEM_13a8737387XXHASH_H_STATIC_13879238742XXH_FALLTHROUGH__attribute__ ((fallthrough))XXH_HAS_CPP_ATTRIBUTE(x)XXH_HAS_C_ATTRIBUTE(x)XXH_HAS_ATTRIBUTE(x)__has_attribute(x)XXH128_hashFromCanonicalXXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)XXH128_canonicalFromHashXXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)XXH128_cmpXXH_NAME2(XXH_NAMESPACE, XXH128_cmp)XXH128_isEqualXXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)XXH3_128bits_digestXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)XXH3_128bits_updateXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)XXH3_128bits_reset_withSecretandSeedXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecretandSeed)XXH3_128bits_reset_withSecretXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)XXH3_128bits_reset_withSeedXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)XXH3_128bits_resetXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)XXH3_128bits_withSecretandSeedXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecretandSeed)XXH3_128bits_withSecretXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)XXH3_128bits_withSeedXXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)XXH3_128bitsXXH_NAME2(XXH_NAMESPACE, XXH3_128bits)XXH128XXH_NAME2(XXH_NAMESPACE, XXH128)XXH3_generateSecret_fromSeedXXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret_fromSeed)XXH3_generateSecretXXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)XXH3_64bits_digestXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)XXH3_64bits_updateXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)XXH3_64bits_reset_withSecretandSeedXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecretandSeed)XXH3_64bits_reset_withSecretXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)XXH3_64bits_reset_withSeedXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)XXH3_64bits_resetXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)XXH3_copyStateXXH_NAME2(XXH_NAMESPACE, XXH3_copyState)XXH3_freeStateXXH_NAME2(XXH_NAMESPACE, XXH3_freeState)XXH3_createStateXXH_NAME2(XXH_NAMESPACE, XXH3_createState)XXH3_64bits_withSecretandSeedXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecretandSeed)XXH3_64bits_withSeedXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)XXH3_64bits_withSecretXXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)XXH3_64bitsXXH_NAME2(XXH_NAMESPACE, XXH3_64bits)XXH_NO_XXH3(defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \!defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))XXH_EXPORTXXH_IMPORTXXH_DOXYGENdefined(XXH_DOXYGEN)UINT_MAX == 0xFFFFFFFFULULONG_MAX == 0xFFFFFFFFULXXH_HAS_ATTRIBUTE(__fallthrough__)defined(__LP64__) && ULONG_MAX == 0xFFFFFFFFFFFFFFFFULLdefined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)defined(__cplusplus) && (__cplusplus >= 201103L)!(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \!defined(__clang__) && \defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) \defined(__OPTIMIZE_SIZE__)defined (__cplusplus) \(XXH_DEBUGLEVEL>=1)XXH_STATIC_ASSERTXXH_OLD_NAMES(defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))!defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \(defined(__SSE4_1__) || defined(__aarch64__)) && !defined(XXH_ENABLE_AUTOVECTORIZE)((defined(sun) || defined(__sun)) && __cplusplus)(defined(__GNUC__) && (__GNUC__ >= 3))  \defined(__ARM_NEON__) || defined(__ARM_NEON) \defined(__AVX2__)defined(__SSE2__)defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)XXH_VECTOR( \defined(__AVX512F__)defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))(defined(__PPC64__) && defined(__POWER8_VECTOR__)) \XXH_ACC_ALIGNdefined(XXH_X86DISPATCH)XXH_VECTOR == XXH_SCALARXXH_VECTOR == XXH_SSE2XXH_VECTOR == XXH_AVX2XXH_VECTOR == XXH_NEONXXH_VECTOR == XXH_VSXXXH_VECTOR == XXH_AVX512defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \!defined(XXH_NO_VZIP_HACK)XXH3_NEON_LANES(defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || defined(_M_ARM64EC)) \defined(__s390x__)defined(__GNUC__) && !defined(__APPLE_ALTIVEC__)XXH_VSX_BEdefined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)defined(XXH_NO_PREFETCH)defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))(XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)defined(_MSC_VER) && defined(_M_IX86)(defined(__GNUC__) || defined(__clang__)) && !defined(__wasm__) \(defined(_M_X64) || defined(_M_IA64)) && !defined(_M_ARM64EC)defined(_M_ARM64) || defined(_M_ARM64EC)defined(__GNUC__) && !defined(__clang__)(XXH_VECTOR == XXH_AVX512) \XXH_TARGET_AVX512(XXH_VECTOR == XXH_AVX2) \XXH_TARGET_AVX2(XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)XXH_TARGET_SSE2defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900(XXH_VECTOR == XXH_NEON)(XXH_VECTOR == XXH_VSX)__s390x__defined(__clang__) && defined(__aarch64__)(XXH_VECTOR == XXH_AVX512)(XXH_VECTOR == XXH_AVX2)(XXH_VECTOR == XXH_SSE2)XXH_PREFETCH_DISTXXH3_STREAM_USE_STACKdefined(XXH3_STREAM_USE_STACK) && XXH3_STREAM_USE_STACK >= 1(XXH_DEBUGLEVEL >= 1)__builtin_rotateleft64__builtin_rotateleft32__fallthrough__/* XXH_IMPLEMENTATION *//*!
 * @}
 *//* XXH_NO_XXH3 *//* respect -O0 and -Os *//* GCC, not Clang *//* AVX2 *//* Pop our optimization override from above *//*! @ingroup xxh3_family *//* last segment *//* Fill secretBuffer with a copy of customSeed - repeat as needed *//* production mode, assert() are disabled *//* ==========================================
 * Secret generators
 * ==========================================
 *//* note : bets that, in most cases, hash values are different *//* This prototype is compatible with stdlib's qsort().
 * return : >0 if *h128_1  > *h128_2
 *          <0 if *h128_1  < *h128_2
 *          =0 if *h128_1 == *h128_2  *//* note : XXH128_hash_t is compact, it has no padding byte *//* return : 1 is equal, 0 if different *//* memcmp, memcpy *//* 128-bit utility functions *//* len <= XXH3_MIDSIZE_MAX : short code *//*
 * All initialization and update functions are identical to 64-bit streaming variant.
 * The only difference is the finalization routine.
 *//* ===   XXH3 128-bit streaming   === *//* ===   Public XXH128 API   === *//*
     * If an action is to be taken if `secret` conditions are not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     *//*
 * It's important for performance that XXH3_hashLong is not inlined.
 *//*
 * It's important for performance to pass @secretLen (when it's static)
 * to the compiler, so that it can properly optimize the vectorized loop.
 *//* converge into final hash *//* last bytes *//*
 * A bit slower than XXH3_mix16B, but handles multiply by zero better.
 *//*
 * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
 *//* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; *//* m128 ^= XXH_swap64(m128 >> 64); *//*
             * 64-bit optimized (albeit more confusing) version.
             *
             * Uses some properties of addition and multiplication to remove the mask:
             *
             * Let:
             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
             *    c = XXH_PRIME32_2
             *
             *    a + (b * c)
             * Inverse Property: x + y - x == y
             *    a + (b * (1 + c - 1))
             * Distributive Property: x * (y + z) == (x * y) + (x * z)
             *    a + (b * 1) + (b * (c - 1))
             * Identity Property: x * 1 == x
             *    a + b + (b * (c - 1))
             *
             * Substitute a, b, and c:
             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
             *
             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
             *    input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
             *//*
             * 32-bit optimized version, which is more readable.
             *
             * On 32-bit, it removes an ADC and delays a dependency between the two
             * halves of m128.high64, but it generates an extra mask on 64-bit.
             *//* 32-bit *//*
         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
         * the high 64 bits of m128.
         *
         * The best approach to this operation is different on 32-bit and 64-bit.
         *//*
         * Put len in the middle of m128 to ensure that the length gets mixed to
         * both the low and high bits in the 128x64 multiply below.
         *//* Shift len to the left to ensure it is even, this avoids even multiplies. *//*
     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
     *//* A doubled version of 1to3_64b with different constants. *//* ==========================================
 * XXH3 128 bits (a.k.a XXH128)
 * ==========================================
 * XXH3's 128-bit variant has better mixing and strength than the 64-bit variant,
 * even without counting the significantly larger output size.
 *
 * For example, extra steps are taken to avoid the seed-dependent collisions
 * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).
 *
 * This strength naturally comes at the cost of some speed, especially on short
 * lengths. Note that longer hashes are about as fast as the 64-bit version
 * due to it using only a slight modification of the 64-bit loop.
 *
 * XXH128 is also more oriented towards 64-bit machines. It is still extremely
 * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).
 *//* totalLen <= XXH3_MIDSIZE_MAX: digesting a short input *//* there is always some input buffered *//* bufferedSize < XXH_STRIPE_LEN *//* last stripe *//*
     * Digest on a local copy. This way, the state remains unaltered, and it can
     * continue ingesting more input afterwards.
     *//* save stack accumulators into state *//* Some remaining input (always) : buffer it *//* buffer predecessor of last partial stripe *//* Consume input by a multiple of internal buffer size *//* content to consume <= block size *//* at least some bytes left *//* consume last partial block *//* consume per entire blocks *//* join to current block's end *//* large input to consume : ingest per full block *//*
         * Internal buffer is partially filled (always, except at beginning)
         * Complete it, then consume it.
         *//* clean multiple *//* total input is now > XXH3_INTERNALBUFFER_SIZE *//* small input : just fill in tmp buffer *//* For some reason, gcc and MSVC seem to suffer greatly
         * when operating accumulators directly into state.
         * Operating into stack space seems to enable proper optimization.
         * clang, on the other hand, doesn't seem to need this trick *//*
 * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
 *//* clang doesn't need additional stack space *//* need a scrambling operation *//* can handle max 1 scramble per invocation *//* Note : when XXH3_consumeStripes() is invoked,
 * there must be a guarantee that at least one more byte must be consumed from input
 * so that the function can blindly consume all stripes using the "normal" secret segment *//* always, even if seed64==0 *//* set members from bufferedSize to nbStripesPerBlock (excluded) to 0 *//* Free the original malloc'd pointer *//* Get the offset byte we added in XXH_malloc. *//*
 * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass
 * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.
 *//* Store the offset immediately before the returned pointer. *//* Add the offset for the now-aligned pointer *//* base % align *//*
             * Get the offset needed to align this pointer.
             *
             * Even if the returned pointer is aligned, there will always be
             * at least one byte to store the offset to the original pointer.
             *//* Overallocate to make room for manual realignment and an offset byte *//* empty/overflow *//* power of 2 *//* range check *//*
 * Malloc's a pointer that is always aligned to align.
 *
 * This must be freed with `XXH_alignedFree()`.
 *
 * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte
 * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2
 * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.
 *
 * This underalignment previously caused a rather obvious crash which went
 * completely unnoticed due to XXH3_createState() not actually being tested.
 * Credit to RedSpah for noticing this bug.
 *
 * The alignment is done manually: Functions like posix_memalign or _mm_malloc
 * are avoided: To maintain portability, we would have to write a fallback
 * like this anyways, and besides, testing for the existence of library
 * functions without relying on external build tools is impossible.
 *
 * The method is simple: Overallocate, manually align, and store the offset
 * to the original behind the returned pointer.
 *
 * Align must be a power of 2 and 8 <= align <= 128.
 *//* ===   XXH3 streaming   === *//* ===   Public entry point   === *//*
     * If an action is to be taken if `secretLen` condition is not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     * Also, note that function signature doesn't offer room to return an error.
     *//*
 * XXH3_hashLong_64b_withSeed():
 * Generate a custom key based on alteration of default XXH3_kSecret with the seed,
 * and then use this key for long mode hashing.
 *
 * This operation is decently fast but nonetheless costs a little bit of time.
 * Try to avoid it whenever possible (typically when seed==0).
 *
 * It's important for performance that XXH3_hashLong is not inlined. Not sure
 * why (uop cache maybe?), but the difference is large and easily measurable.
 *//*
 * It's preferable for performance that XXH3_hashLong is not inlined,
 * as it results in a smaller function for small data, easier to the instruction cache.
 * Note that inside this no_inline function, we do inline the internal loop,
 * and provide a statically defined secret size to allow optimization of vector loop.
 *//*
 * It's important for performance to transmit secret's size (when it's static)
 * so that the compiler can properly optimize the vectorized loop.
 * This makes a big performance difference for "medium" keys (<1 KB) when using AVX instruction set.
 *//* do not align on 8, so that the secret is different from the accumulator *//*
         * UGLY HACK:
         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
         * XXH3_64bits, len == 256, Snapdragon 835:
         *   without hack: 2063.7 MB/s
         *   with hack:    2560.7 MB/s
         *//* Define to disable *//* NEON *//* Clang *//* not aligned on 8, last secret is different from acc & scrambler *//* last partial block *//*
 * XXH3_accumulate()
 * Loops over XXH3_accumulate_512().
 * Assumption: nbStripes will not overflow the secret size
 *//* XXH_PREFETCH_DIST *//* __clang__ *//* scalar *//*
             * The asm hack causes Clang to assume that kSecretPtr aliases with
             * customSecret, and on aarch64, this prevented LDP from merging two
             * loads together for free. Putting the loads together before the stores
             * properly generates LDP.
             *//*
     * Note: in debug mode, this overrides the asm optimization
     * and Clang will emit MOVK chains again.
     *//*
     * UGLY HACK:
     * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are
     * placed sequentially, in order, at the top of the unrolled loop.
     *
     * While MOVK is great for generating constants (2 cycles for a 64-bit
     * constant compared to 4 cycles for LDR), it fights for bandwidth with
     * the arithmetic instructions.
     *
     *   I   L   S
     * MOVK
     * MOVK
     * MOVK
     * MOVK
     * ADD
     * SUB      STR
     *          STR
     * By forcing loads from memory (as the asm line causes Clang to assume
     * that XXH3_kSecretPtr has been changed), the pipelines are used more
     * efficiently:
     *   I   L   S
     *      LDR
     *  ADD LDR
     *  SUB     STR
     *          STR
     *
     * See XXH3_NEON_LANES for details on the pipsline.
     *
     * XXH3_64bits_withSeed, len == 256, Snapdragon 835
     *   without hack: 2654.4 MB/s
     *   with hack:    3202.9 MB/s
     *//*
     * We need a separate pointer for the hack below,
     * which requires a non-const pointer.
     * Any decent compiler will optimize this out otherwise.
     *//*!
 * @internal
 * @brief Scrambles the accumulators after a large chunk has been read
 *//* no alignment restriction *//* presumed aligned *//*!
 * @internal
 * @brief Scalar scramble step for @ref XXH3_scrambleAcc_scalar().
 *
 * This is extracted to its own function because the NEON path uses a combination
 * of NEON and scalar.
 *//*!
 * @internal
 * @brief Processes a 64 byte block of data using the scalar path.
 *//* swap adjacent lanes *//*!
 * @internal
 * @brief Scalar round for @ref XXH3_accumulate_512_scalar().
 *
 * This is extracted to its own function because the NEON path uses a combination
 * of NEON and scalar.
 *//* scalar variants - universal *//* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  *//* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  *//* xacc[i] *= XXH_PRIME32_1 *//* xacc[i] ^= xsecret[i]; *//* xacc[i] ^= (xacc[i] >> 47); *//* constants *//* xacc[i] = acc_vec; *//* swap high and low halves *//* acc_vec = xacc[i]; *//* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); *//* shuffled = (data_key << 32) | (data_key >> 32); *//* key_vec = xsecret[i]; *//* data_vec = xinput[i]; *//* Scalar for the remainder. This may be a zero iteration loop. *//* xacc[i] += (prod_hi & 0xFFFFFFFF) * XXH_PRIME32_1; *//* xacc[i] = prod_hi << 32; *//*
                 * prod_hi = (data_key >> 32) * XXH_PRIME32_1;
                 *
                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
                 * incorrectly "optimize" this:
                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
                 *   shifted = vshll_n_u32(tmp, 32);
                 * to this:
                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
                 *   shifted = vshlq_n_u64(tmp, 32);
                 *
                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
                 * for NEON, and it scalarizes two 64-bit multiplies instead.
                 *
                 * vmull_u32 has the same timing as vmul_u32, and it avoids
                 * this bug completely.
                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
                 *//* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
             * xacc[i] = UNDEFINED; *//* NEON for the first few lanes (these loops are normally interleaved) *//* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; *//* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (data_key >> 32);
             * data_key = UNDEFINED; *//* data_key = data_vec ^ key_vec; *//* xacc[i] += swap(data_vec); *//* key_vec  = xsecret[i];  *//* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. *//*!
 * @internal
 * @brief The bulk processing loop for NEON.
 *
 * The NEON code path is actually partially scalar when running on AArch64. This
 * is to optimize the pipelining and can have up to 15% speedup depending on the
 * CPU, and it also mitigates some GCC codegen issues.
 *
 * @see XXH3_NEON_LANES for configuring this and details about this optimization.
 *//* forward declarations for the scalar routines *//* control alignment *//*
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         *//* MSVC 32bit mode does not support _mm_set_epi64x before 2015 *//* xacc[i] *= XXH_PRIME32_1; *//* xacc[i] ^= (xacc[i] >> 47) *//* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. *//* xacc[i] += product; *//* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); *//* data_key_lo = data_key >> 32; *//* data_key    = data_vec ^ key_vec; *//* key_vec     = xsecret[i]; *//* data_vec    = xinput[i]; *//* SSE2 is just a half-scale version of the AVX2 version. *//* disable attribute target *//* x86dispatch always generates SSE2 *//* GCC -O2 need unroll loop manually *//* xacc[i] ^= xsecret; *//* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. *//* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. *//* GCC has a bug, _mm512_stream_load_si512 accepts 'void*', not 'void const*',
             * this will warn "discards 'const' qualifier". *//* xacc[0] *= XXH_PRIME32_1; *//* xacc[0] ^= secret; *//* xacc[0] ^= (xacc[0] >> 47) *//*
 * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
 *
 * Multiplication isn't perfect, as explained by Google in HighwayHash:
 *
 *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
 *  // varying degrees. In descending order of goodness, bytes
 *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
 *  // As expected, the upper and lower bytes are much worse.
 *
 * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
 *
 * Since our algorithm uses a pseudorandom secret to add some variance into the
 * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
 *
 * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
 * extraction.
 *
 * Both XXH3_64bits and XXH3_128bits use this subroutine.
 *//* xacc[0] += product; *//* xacc[0] += swap(data_vec); *//* key_vec     = secret[0]; *//* data_vec    = input[0]; *//*
 * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
 *
 * It is a hardened version of UMAC, based off of FARSH's implementation.
 *
 * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
 * implementations, and it is ridiculously fast.
 *
 * We harden it by mixing the original input to the accumulators as well as the product.
 *
 * This means that in the (relatively likely) case of a multiply by zero, the
 * original input is preserved.
 *
 * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
 * cross-pollination, as otherwise the upper and lower halves would be
 * essentially independent.
 *
 * This doesn't matter on 64-bit hashes since they all get merged together in
 * the end, so we skip the extra step.
 *
 * Both XXH3_64bits and XXH3_128bits use this subroutine.
 *//* the following type must have a width of 64-bit *//* Several intrinsic functions below are supposed to accept __int64 as argument,
 * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
 * However, several environments do not define __int64 type,
 * requiring a workaround.
 *//* nb of secret bytes consumed at each accumulation *//* =======     Long Keys     ======= *//*
         * UGLY HACK:
         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
         * In everywhere else, it uses scalar code.
         *
         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
         * would still be slower than UMAAL (see XXH_mult64to128).
         *
         * Unfortunately, Clang doesn't handle the long multiplies properly and
         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
         * scalarized into an ugly mess of VMOV.32 instructions.
         *
         * This mess is difficult to avoid without turning autovectorization
         * off completely, but they are usually relatively minor and/or not
         * worth it to fix.
         *
         * This loop is the easiest to fix, as unlike XXH32, this pragma
         * _actually works_ because it is a loop vectorization instead of an
         * SLP vectorization.
         *//* For mid range keys, XXH3 uses a Mum-hash variant. *//*
     * UGLY HACK:
     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
     * slower code.
     *
     * By forcing seed64 into a register, we disrupt the cost model and
     * cause it to scalarize. See `XXH32_round()`
     *
     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
     * GCC 9.2, despite both emitting scalar code.
     *
     * GCC generates much better scalar code than Clang for the rest of XXH3,
     * which is why finding a more optimal codepath is an interest.
     *//* Define to disable like XXH32 hack *//* x86 + SSE2 *//*
 * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
 * multiplication by zero, affecting hashes of lengths 17 to 240.
 *
 * However, they are very unlikely.
 *
 * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
 * unseeded non-cryptographic hashes, it does not attempt to defend itself
 * against specially crafted inputs, only random inputs.
 *
 * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
 * cancelling out the secret is taken an arbitrary number of times (addressed
 * in XXH3_accumulate_512), this collision is very unlikely with random inputs
 * and/or proper seeding:
 *
 * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
 * function that is only called up to 16 times per hash with up to 240 bytes of
 * input.
 *
 * This is not too bad for a non-cryptographic hash function, especially with
 * only 64 bit outputs.
 *
 * The 128-bit variant (which trades some speed for strength) is NOT affected
 * by this, although it is always a good idea to use a proper seed if you care
 * about strength.
 *//*
     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
     *//*
 * At very short lengths, there isn't enough input to fully hide secrets, or use
 * the entire secret.
 *
 * There is also only a limited amount of mixing we can do before significantly
 * impacting performance.
 *
 * Therefore, we use different sections of the secret and always mix two secret
 * samples with an XOR. This should have no effect on performance on the
 * seedless or withSeed variants because everything _should_ be constant folded
 * by modern compilers.
 *
 * The XOR mixing hides individual parts of the secret and increases entropy.
 *
 * This adds an extra layer of strength for custom secrets.
 *//* ==========================================
 * Short keys
 * ==========================================
 * One of the shortcomings of XXH32 and XXH64 was that their performance was
 * sub-optimal on short lengths. It used an iterative algorithm which strongly
 * favored lengths that were a multiple of 4 or 8.
 *
 * Instead of iterating over individual inputs, we use a set of single shot
 * functions which piece together a range of lengths and operate in constant time.
 *
 * Additionally, the number of multiplies has been significantly reduced. This
 * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
 *
 * Depending on the platform, this may or may not be faster than XXH32, but it
 * is almost guaranteed to be faster than XXH64.
 *//* this mix is inspired by Pelle Evensen's rrmxmx *//*
 * This is a stronger avalanche,
 * inspired by Pelle Evensen's rrmxmx
 * preferable when input has not been previously mixed
 *//*
 * This is a fast avalanche stage,
 * suitable when input bits are already partially mixed
 *//*! Seems to produce slightly better code on GCC for some reason. *//*!
 * @brief Calculates a 64-bit to 128-bit multiply, then XOR folds it.
 *
 * The reason for the separate function is to prevent passing too many structs
 * around by value. This will hopefully inline the multiply, but we don't force it.
 *
 * @param lhs , rhs The 64-bit integers to multiply
 * @return The low 64 bits of the product XOR'd by the high 64 bits.
 * @see XXH_mult64to128()
 *//* Now add the products together. These will never overflow. *//* First calculate all of the cross products. *//*
     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
     *
     * This is a fast and simple grade school multiply, which is shown below
     * with base 10 arithmetic instead of base 0x100000000.
     *
     *           9 3 // D2 lhs = 93
     *         x 7 5 // D2 rhs = 75
     *     ----------
     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
     *     ---------
     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
     *     ---------
     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
     *
     * The reasons for adding the products like this are:
     *  1. It avoids manual carry tracking. Just like how
     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
     *     This avoids a lot of complexity.
     *
     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
     *     instruction available in ARM's Digital Signal Processing extension
     *     in 32-bit ARMv6 and later, which is shown below:
     *
     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
     *         {
     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;
     *             *RdLo = (xxh_u32)(product & 0xFFFFFFFF);
     *             *RdHi = (xxh_u32)(product >> 32);
     *         }
     *
     *     This instruction was designed for efficient long multiplication, and
     *     allows this to be calculated in only 4 instructions at speeds
     *     comparable to some 64-bit ALUs.
     *
     *  3. It isn't terrible on other platforms. Usually this will be a couple
     *     of 32-bit ADD/ADCs.
     *//*
     * MSVC for ARM64's __umulh method.
     *
     * This compiles to the same MUL + UMULH as GCC/Clang's __uint128_t method.
     *//*
     * MSVC for x64's _umul128 method.
     *
     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
     *
     * This compiles to single operand MUL on x64.
     *//*
     * GCC/Clang __uint128_t method.
     *
     * On most 64-bit targets, GCC and Clang define a __uint128_t type.
     * This is usually the best way as it usually uses a native long 64-bit
     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.
     *
     * Usually.
     *
     * Despite being a 32-bit platform, Clang (and emscripten) define this type
     * despite not having the arithmetic for it. This results in a laggy
     * compiler builtin call which calculates a full 128-bit multiply.
     * In that case it is best to use the portable one.
     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
     *//*!
 * @brief Calculates a 64->128-bit long multiply.
 *
 * Uses `__uint128_t` and `_umul128` if available, otherwise uses a scalar
 * version.
 *
 * @param lhs , rhs The 64-bit integers to be multiplied
 * @return The 128-bit result represented in an @ref XXH128_hash_t.
 *//*
 * Downcast + upcast is usually better than masking on older compilers like
 * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
 *
 * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
 * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
 *//*!
 * @brief Calculates a 32-bit to 64-bit long multiply.
 *
 * Implemented as a macro.
 *
 * Wraps `__emulu` on MSVC x86 because it tends to call `__allmul` when it doesn't
 * need to (but it shouldn't need to anyways, it is about 7 instructions to do
 * a 64x64 multiply...). Since we know that this will _always_ emit `MULL`, we
 * use that instead of the normal method.
 *
 * If you are compiling for platforms like Thumb-1 and don't have a better option,
 * you may also want to write your own long multiply routine here.
 *
 * @param x, y Numbers to be multiplied
 * @return 64-bit product of the low 32 bits of @p x and @p y.
 *//*! Pseudorandom secret taken directly from FARSH. *//* minimum XXH3_SECRET_SIZE_MIN *//* ==========================================
 * XXH3 default settings
 * ========================================== *//* XXH_NO_PREFETCH *//* _mm_prefetch() not defined outside of x86/x64 *//* prefetch
 * can be disabled, by declaring XXH_NO_PREFETCH build macro *//* XXH_VECTOR == XXH_VSX *//* XXH_vec_mulo, XXH_vec_mule *//* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. *//* gcc needs inline assembly *//* Clang has a better way to control this, we can just use the builtin which doesn't swap. *//* s390x is always big endian, no issue on this platform *//*
 * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
 *
 * These intrinsics weren't added until GCC 8, despite existing for a while,
 * and they are endian dependent. Also, their meaning swap depending on version.
 * *//*!
 * Performs an unaligned vector load and byte swaps it on big endian.
 *//* XXH_VSX_BE *//*!
 * A polyfill for POWER9's vec_revb().
 *//* !defined(XXH_VSX_BE) *//* gcc's altivec.h can have the unwanted consequence to unconditionally
 * #define bool, vector, and pixel keywords,
 * with bad consequences for programs already using these keywords for other purposes.
 * The paragraph defining these macros is skipped when __APPLE_ALTIVEC__ is defined.
 * __APPLE_ALTIVEC__ is _generally_ defined automatically by the compiler,
 * but it seems that, in some cases, it isn't.
 * Force the build macro to be defined, so that keywords are not altered.
 *//*
 * VSX and Z Vector helpers.
 *
 * This is very messy, and any pull requests to clean this up are welcome.
 *
 * There are a lot of problems with supporting VSX and s390x, due to
 * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
 *//* XXH_VECTOR == XXH_NEON *//*!
 * @ingroup tuning
 * @brief Controls the NEON to scalar ratio for XXH3
 *
 * On AArch64 when not optimizing for size, XXH3 will run 6 lanes using NEON and
 * 2 lanes on scalar by default.
 *
 * This can be set to 2, 4, 6, or 8. ARMv7 will default to all 8 NEON lanes, as the
 * emulated 64-bit arithmetic is too slow.
 *
 * Modern ARM CPUs are _very_ sensitive to how their pipelines are used.
 *
 * For example, the Cortex-A73 can dispatch 3 micro-ops per cycle, but it can't
 * have more than 2 NEON (F0/F1) micro-ops. If you are only using NEON instructions,
 * you are only using 2/3 of the CPU bandwidth.
 *
 * This is even more noticable on the more advanced cores like the A76 which
 * can dispatch 8 micro-ops per cycle, but still only 2 NEON micro-ops at once.
 *
 * Therefore, @ref XXH3_NEON_LANES lanes will be processed using NEON, and the
 * remaining lanes will use scalar instructions. This improves the bandwidth
 * and also gives the integer pipelines something to do besides twiddling loop
 * counters and pointers.
 *
 * This change benefits CPUs with large micro-op buffers without negatively affecting
 * other CPUs:
 *
 *  | Chipset               | Dispatch type       | NEON only | 6:2 hybrid | Diff. |
 *  |:----------------------|:--------------------|----------:|-----------:|------:|
 *  | Snapdragon 730 (A76)  | 2 NEON/8 micro-ops  |  8.8 GB/s |  10.1 GB/s |  ~16% |
 *  | Snapdragon 835 (A73)  | 2 NEON/3 micro-ops  |  5.1 GB/s |   5.3 GB/s |   ~5% |
 *  | Marvell PXA1928 (A53) | In-order dual-issue |  1.9 GB/s |   1.9 GB/s |    0% |
 *
 * It also seems to fix some bad codegen on GCC, making it almost as fast as clang.
 *
 * @see XXH3_accumulate_512_neon()
 *//* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 *//* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 *//* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half *//* define to disable *//*!
 * Function-like macro:
 * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
 * {
 *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
 *     outHi = (uint32x2_t)(in >> 32);
 *     in = UNDEFINED;
 * }
 *//*
 * NEON's setup for vmlal_u32 is a little more complicated than it is on
 * SSE2, AVX2, and VSX.
 *
 * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
 *
 * To do the same operation, the 128-bit 'Q' register needs to be split into
 * two 64-bit 'D' registers, performing this operation::
 *
 *   [                a                 |                 b                ]
 *            |              '---------. .--------'                |
 *            |                         x                          |
 *            |              .---------' '--------.                |
 *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
 *
 * Due to significant changes in aarch64, the fastest method for aarch64 is
 * completely different than the fastest method for ARMv7-A.
 *
 * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
 * D11 will modify the high half of Q5. This is similar to how modifying AH
 * will only affect bits 8-15 of AX on x86.
 *
 * VZIP takes two registers, and puts even lanes in one register and odd lanes
 * in the other.
 *
 * On ARMv7-A, this strangely modifies both parameters in place instead of
 * taking the usual 3-operand form.
 *
 * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
 * lower and upper halves of the Q register to end up with the high and low
 * halves where we want - all in one instruction.
 *
 *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
 *
 * Unfortunately we need inline assembly for this: Instructions modifying two
 * registers at once is not possible in GCC or Clang's IR, and they have to
 * create a copy.
 *
 * aarch64 requires a different approach.
 *
 * In order to make it easier to write a decent compiler for aarch64, many
 * quirks were removed, such as conditional execution.
 *
 * NEON was also affected by this.
 *
 * aarch64 cannot access the high bits of a Q-form register, and writes to a
 * D-form register zero the high bits, similar to how writes to W-form scalar
 * registers (or DWORD registers on x86_64) work.
 *
 * The formerly free vget_high intrinsics now require a vext (with a few
 * exceptions)
 *
 * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
 * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
 * operand.
 *
 * The equivalent of the VZIP.32 on the lower and upper halves would be this
 * mess:
 *
 *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
 *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
 *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
 *
 * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
 *
 *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
 *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
 *
 * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
 *//*
 * UGLY HACK:
 * GCC usually generates the best code with -O3 for xxHash.
 *
 * However, when targeting AVX2, it is overzealous in its unrolling resulting
 * in code roughly 3/4 the speed of Clang.
 *
 * There are other issues, such as GCC splitting _mm256_loadu_si256 into
 * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
 * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
 *
 * That is why when compiling the AVX2 version, it is recommended to use either
 *   -O2 -mavx2 -march=haswell
 * or
 *   -O2 -mavx2 -mno-avx256-split-unaligned-load
 * for decent performance, or to use Clang instead.
 *
 * Fortunately, we can control the first one with a pragma that forces GCC into
 * -O2, but the other one we can't control without "failed to inline always
 * inline function due to target mismatch" warnings.
 *//* avx512 *//* vsx *//* neon *//* avx2 *//* sse2 *//* for compatibility with avx512 *//*
 * Controls the alignment of the accumulator,
 * for compatibility with aligned vector loads, which are usually faster.
 *//* TODO: IBM XL *//* little endian only *//* msvc *//* can be defined on command line *//* Actual definition *//*!
 * @ingroup tuning
 * @brief Selects the minimum alignment for XXH3's accumulators.
 *
 * When using SIMD, this should match the alignment reqired for said vector
 * type, so, for example, 32 for AVX2.
 *
 * Default: Auto detected.
 *//*!< VSX and ZVector for POWER8/z13 (64-bit) *//*!< NEON for most ARMv7-A and all AArch64 *//*!< AVX512 for Skylake and Icelake *//*!< AVX2 for Haswell and Bulldozer *//*!<
                      * SSE2 for Pentium 4, Opteron, all x86_64.
                      *
                      * @note SSE2 is also guaranteed on Windows 10, macOS, and
                      * Android x86.
                      *//*!< Portable scalar version *//* fake enum *//*!
 * @ingroup tuning
 * @brief Possible values for @ref XXH_VECTOR.
 *
 * Note that these are actually implemented as macros.
 *
 * If this is not defined, it is detected automatically.
 * @ref XXH_X86DISPATCH overrides this.
 *//*!
 * @ingroup tuning
 * @brief Overrides the vectorization implementation chosen for XXH3.
 *
 * Can be defined to 0 to disable SIMD or any of the values mentioned in
 * @ref XXH_VECTOR_TYPE.
 *
 * If this is not defined, it uses predefined macros to determine the best
 * implementation.
 *//* ==========================================
 * Vectorization detection
 * ========================================== *//*
 * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
 * remaining a true 64-bit/128-bit hash function.
 *
 * This is done by prioritizing a subset of 64-bit operations that can be
 * emulated without too many steps on the average 32-bit machine.
 *
 * For example, these two lines seem similar, and run equally fast on 64-bit:
 *
 *   xxh_u64 x;
 *   x ^= (x >> 47); // good
 *   x ^= (x >> 13); // bad
 *
 * However, to a 32-bit machine, there is a major difference.
 *
 * x ^= (x >> 47) looks like this:
 *
 *   x.lo ^= (x.hi >> (47 - 32));
 *
 * while x ^= (x >> 13) looks like this:
 *
 *   // note: funnel shifts are not usually cheap.
 *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
 *   x.hi ^= (x.hi >> 13);
 *
 * The first one is significantly faster than the second, simply because the
 * shift is larger than 32. This means:
 *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
 *    32 bits in the shift.
 *  - The shift result will always fit in the lower 32 bits, and therefore,
 *    we can ignore the upper 32 bits in the xor.
 *
 * Thanks to this optimization, XXH3 only requires these features to be efficient:
 *
 *  - Usable unaligned access
 *  - A 32-bit or 64-bit ALU
 *      - If 32-bit, a decent ADC instruction
 *  - A 32 or 64-bit multiply with a 64-bit result
 *  - For the 128-bit variant, a decent byteswap helps short inputs.
 *
 * The first two are already required by XXH32, and almost all 32-bit and 64-bit
 * platforms which can run XXH32 can run XXH3 efficiently.
 *
 * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
 * notable exception.
 *
 * First of all, Thumb-1 lacks support for the UMULL instruction which
 * performs the important long multiply. This means numerous __aeabi_lmul
 * calls.
 *
 * Second of all, the 8 functional registers are just not enough.
 * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need
 * Lo registers, and this shuffling results in thousands more MOVs than A32.
 *
 * A32 and T32 don't have this limitation. They can access all 14 registers,
 * do a 32->64 multiply with UMULL, and the flexible operand allowing free
 * shifts is helpful, too.
 *
 * Therefore, we do a quick sanity check.
 *
 * If compiling Thumb-1 for a target which supports ARM instructions, we will
 * emit a warning, as it is not a "sane" platform to compile for.
 *
 * Usually, if this happens, it is because of an accident and you probably need
 * to specify -march, as you likely meant to compile for a newer architecture.
 *
 * Credit: large sections of the vectorial and asm source code paths
 *         have been contributed by @easyaspi314
 *//* circumvent a clang bug *//* disable *//* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers *//* >= C99 *//* Solaris includes __STDC_VERSION__ with C++. Tested with GCC 5.5 *//* ===   Compiler specifics   === *//*!
 * @}
 * @defgroup xxh3_impl XXH3 implementation
 * @ingroup impl
 * @{
 *//* *********************************************************************
*  XXH3
*  New generation hash designed for speed on small keys and vectorization
************************************************************************ *//*! @ingroup xxh64_family *//* XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t)); *//******* Canonical representation   *******//*! @ingroup xxh64_family*//*******   Hash Streaming   *******//*!< 0b0010011111010100111010110010111100010110010101100110011111000101 *//*!< 0b1000010111101011110010100111011111000010101100101010111001100011 *//*!< 0b0001011001010110011001111011000110011110001101110111100111111001 *//*!< 0b1100001010110010101011100011110100100111110101001110101101001111 *//*!< 0b1001111000110111011110011011000110000101111010111100101010000111 *//* #define rather that static const, to be used as initializers *//*!
 * @}
 * @defgroup xxh64_impl XXH64 implementation
 * @ingroup impl
 * @{
 *//*******   xxh64   *******//* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. *//*
 * Portable and safe solution. Generally efficient.
 * see: http://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html
 *//*
 * __pack instructions are safer, but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 *//*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE64 and XXH_readBE64.
 *//*******   Memory access   *******//*!
 * @}
 * @ingroup impl
 * @{
 *//*! @ingroup xxh32_family *//* XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t)); *//*!
 * @ingroup xxh32_family
 * The default return values from XXH functions are unsigned 32 and 64 bit
 * integers.
 *
 * The canonical representation uses big endian convention, the same convention
 * as human-readable numbers (large digits first).
 *
 * This way, hash values can be written into a file or buffer, remaining
 * comparable across different systems.
 *
 * The following functions allow transformation of hash values to and from their
 * canonical format.
 *//*******   Canonical representation   *******//*!
 * @ingroup xxh32_family
 *//*******   Hash streaming   *******//*!
 * @internal
 * @brief The implementation for @ref XXH32().
 *
 * @param input , len , seed Directly passed from @ref XXH32().
 * @param align Whether @p input is aligned.
 * @return The calculated hash.
 *//* Compact rerolled version; generally faster *//*!
 * @internal
 * @brief Processes the last 0-15 bytes of @p ptr.
 *
 * There may be up to 15 bytes remaining to consume from the input.
 * This final stage will digest them to ensure that all input bytes are present
 * in the final mix.
 *
 * @param h32 The hash to finalize.
 * @param ptr The pointer to the remaining input.
 * @param len The remaining length, modulo 16.
 * @param align Whether @p ptr is aligned.
 * @return The finalized hash.
 *//*!
 * @internal
 * @brief Mixes all bits to finalize the hash.
 *
 * The final mix ensures that all input bits have a chance to impact any bit in
 * the output digest, resulting in an unbiased distribution.
 *
 * @param h32 The hash to avalanche.
 * @return The avalanched hash.
 *//*
     * UGLY HACK:
     * A compiler fence is the only thing that prevents GCC and Clang from
     * autovectorizing the XXH32 loop (pragmas and attributes don't work for some
     * reason) without globally disabling SSE4.1.
     *
     * The reason we want to avoid vectorization is because despite working on
     * 4 integers at a time, there are multiple factors slowing XXH32 down on
     * SSE4:
     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
     *   newer chips!) making it slightly slower to multiply four integers at
     *   once compared to four integers independently. Even when pmulld was
     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
     *   just to multiply unless doing a long operation.
     *
     * - Four instructions are required to rotate,
     *      movqda tmp,  v // not required with VEX encoding
     *      pslld  tmp, 13 // tmp <<= 13
     *      psrld  v,   19 // x >>= 19
     *      por    v,  tmp // x |= tmp
     *   compared to one for scalar:
     *      roll   v, 13    // reliably fast across the board
     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
     *
     * - Instruction level parallelism is actually more beneficial here because
     *   the SIMD actually serializes this operation: While v1 is rotating, v2
     *   can load data, while v3 can multiply. SSE forces them to operate
     *   together.
     *
     * This is also enabled on AArch64, as Clang autovectorizes it incorrectly
     * and it is pointless writing a NEON implementation that is basically the
     * same speed as scalar for XXH32.
     *//*!
 * @internal
 * @brief Normal stripe processing routine.
 *
 * This shuffles the bits so that any bit from @p input impacts several bits in
 * @p acc.
 *
 * @param acc The accumulator lane.
 * @param input The stripe of input to mix.
 * @return The mixed accumulator lane.
 *//*!< 0b00010110010101100110011110110001 *//*!< 0b00100111110101001110101100101111 *//*!< 0b11000010101100101010111000111101 *//*!< 0b10000101111010111100101001110111 *//*!< 0b10011110001101110111100110110001 *//* #define instead of static const, to be used as initializers *//*!
 * @}
 * @defgroup xxh32_impl XXH32 implementation
 * @ingroup impl
 * @{
 *//*! @ingroup public *//* *************************************
*  Misc
***************************************//*
 * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
 *
 * This is ideal for older compilers which don't inline memcpy.
 *//*!< Possibly unaligned *//*!< Aligned *//*!
 * @internal
 * @brief Enum to indicate whether a pointer is aligned.
 *//*!
 * @internal
 * @fn xxh_u32 XXH_swap32(xxh_u32 x)
 * @brief A 32-bit byteswap.
 *
 * @param x The 32-bit integer to byteswap.
 * @return @p x, byteswapped.
 *//* Note: although _rotl exists for minGW (GCC under windows), performance seems poor *//*!
 * @internal
 * @def XXH_rotl32(x,r)
 * @brief 32-bit rotate left.
 *
 * @param x The 32-bit integer to be rotated.
 * @param r The number of bits to rotate.
 * @pre
 *   @p r > 0 && @p r < 32
 * @note
 *   @p x and @p r may be evaluated multiple times.
 * @return The rotated result.
 *//*
     * Portable and well-defined behavior.
     * Don't use static: it is detrimental to performance.
     *//*!
 * @internal
 * @brief Runtime check for @ref XXH_CPU_LITTLE_ENDIAN.
 *
 * Most compilers will constant fold this.
 *//* Windows is always little endian *//*
 * Try to detect endianness automatically, to avoid the nonstandard behavior
 * in `XXH_isLittleEndian()`
 *//*!
 * @ingroup tuning
 * @def XXH_CPU_LITTLE_ENDIAN
 * @brief Whether the target is little endian.
 *
 * Defined to 1 if the target is little endian, or 0 if it is big endian.
 * It can be defined externally, for example on the compiler command line.
 *
 * If it is not defined,
 * a runtime check (which is usually constant folded) is used instead.
 *
 * @note
 *   This is not necessarily defined to an integer constant.
 *
 * @see XXH_isLittleEndian() for the runtime check.
 *//* ***   Endianness   *** *//*
 * __pack instructions are safer but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 *//*
 * Force direct memory access. Only works on CPU which support unaligned memory
 * access in hardware.
 *//*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE32 and XXH_readBE32.
 *//*!
 * @internal
 * @fn xxh_u32 XXH_readLE32_align(const void* ptr, XXH_alignment align)
 * @brief Like @ref XXH_readLE32(), but has an option for aligned reads.
 *
 * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
 * Note that when @ref XXH_FORCE_ALIGN_CHECK == 0, the @p align parameter is
 * always @ref XXH_alignment::XXH_unaligned.
 *
 * @param ptr The pointer to read from.
 * @param align Whether @p ptr is aligned.
 * @pre
 *   If @p align == @ref XXH_alignment::XXH_aligned, @p ptr must be 4 byte
 *   aligned.
 * @return The 32-bit little endian integer from the bytes at @p ptr.
 *//*!
 * @internal
 * @fn xxh_u32 XXH_readBE32(const void* ptr)
 * @brief Reads an unaligned 32-bit big endian integer from @p ptr.
 *
 * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
 *
 * @param ptr The pointer to read from.
 * @return The 32-bit big endian integer from the bytes at @p ptr.
 *//*!
 * @internal
 * @fn xxh_u32 XXH_readLE32(const void* ptr)
 * @brief Reads an unaligned 32-bit little endian integer from @p ptr.
 *
 * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
 *
 * @param ptr The pointer to read from.
 * @return The 32-bit little endian integer from the bytes at @p ptr.
 *//*!
 * @internal
 * @fn xxh_u32 XXH_read32(const void* ptr)
 * @brief Reads an unaligned 32-bit integer from @p ptr in native endianness.
 *
 * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
 *
 * @param ptr The pointer to read from.
 * @return The 32-bit native endian integer from the bytes at @p ptr.
 *//* ***   Memory access   *** *//*!
 * @internal
 * @def XXH_COMPILER_GUARD(var)
 * @brief Used to prevent unwanted optimizations for @p var.
 *
 * It uses an empty GCC inline assembly statement with a register constraint
 * which forces @p var into a general purpose register (eg eax, ebx, ecx
 * on x86) and marks it as modified.
 *
 * This is used in a few places to avoid unwanted autovectorization (e.g.
 * XXH32_round()). All vectorization we want is explicit via intrinsics,
 * and _usually_ isn't wanted elsewhere.
 *
 * We also use it to prevent unwanted constant folding for AArch64 in
 * XXH3_initCustomSecret_scalar().
 *//* note: use after variable declarations *//* note: can still be disabled with NDEBUG *//* backwards compat *//*!
 * @ingroup tuning
 * @def XXH_DEBUGLEVEL
 * @brief Sets the debugging level.
 *
 * XXH_DEBUGLEVEL is expected to be defined externally, typically via the
 * compiler's command line options. The value must be a number.
 *//* *************************************
*  Debug
***************************************//* enable inlining hints *//* disable inlining hints *//* Visual Studio warning fix *//* size_t, ZSTD_malloc, ZSTD_free, ZSTD_memcpy *//* for ZSTD_malloc(), ZSTD_free() *//*!
 * @defgroup impl Implementation
 * @{
 *//* generally preferable for performance *//* -O0, -fno-inline *//* -Os, -Oz *//* visual *//* prefer __packed__ structures (method 1) for gcc on armv7+ and mips *//* XXH_DOXYGEN *//* don't actually use, it is ugly. *//*!
 * @internal
 * @brief Redefines old internal names.
 *
 * For compatibility with code that uses xxHash's internals before the names
 * were changed to improve namespacing. There is no other reason to use this.
 *//*!
 * @def XXH32_ENDJMP
 * @brief Whether to use a jump for `XXH32_finalize`.
 *
 * For performance, `XXH32_finalize` uses multiple branches in the finalizer.
 * This is generally preferable for performance,
 * but depending on exact architecture, a jmp may be preferable.
 *
 * This setting is only possibly making a difference for very small inputs.
 *//*!
 * @def XXH_NO_INLINE_HINTS
 * @brief When non-zero, sets all functions to `static`.
 *
 * By default, xxHash tries to force the compiler to inline almost all internal
 * functions.
 *
 * This can usually improve performance due to reduced jumping and improved
 * constant folding, but significantly increases the size of the binary which
 * might not be favorable.
 *
 * Additionally, sometimes the forced inlining can be detrimental to performance,
 * depending on the architecture.
 *
 * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
 * compiler full control on whether to inline or not.
 *
 * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
 * -fno-inline with GCC or Clang, this will automatically be defined.
 *//*!
 * @def XXH_FORCE_ALIGN_CHECK
 * @brief If defined to non-zero, adds a special path for aligned inputs (XXH32()
 * and XXH64() only).
 *
 * This is an important performance trick for architectures without decent
 * unaligned memory access performance.
 *
 * It checks for input alignment, and when conditions are met, uses a "fast
 * path" employing direct 32-bit/64-bit reads, resulting in _dramatically
 * faster_ read speed.
 *
 * The check costs one initial branch per hash, which is generally negligible,
 * but not zero.
 *
 * Moreover, it's not useful to generate an additional code path if memory
 * access uses the same instruction for both aligned and unaligned
 * addresses (e.g. x86 and aarch64).
 *
 * In these cases, the alignment check can be removed by setting this macro to 0.
 * Then the code will always use unaligned memory access.
 * Align check is automatically disabled on x86, x64 & arm64,
 * which are platforms known to offer good unaligned memory accesses performance.
 *
 * This option does not affect XXH3 (only XXH32 and XXH64).
 *//*!
 * @brief Controls how unaligned memory is accessed.
 *
 * By default, access to unaligned memory is controlled by `memcpy()`, which is
 * safe and portable.
 *
 * Unfortunately, on some target/compiler combinations, the generated assembly
 * is sub-optimal.
 *
 * The below switch allow selection of a different access method
 * in the search for improved performance.
 *
 * @par Possible options:
 *
 *  - `XXH_FORCE_MEMORY_ACCESS=0` (default): `memcpy`
 *   @par
 *     Use `memcpy()`. Safe and portable. Note that most modern compilers will
 *     eliminate the function call and treat it as an unaligned access.
 *
 *  - `XXH_FORCE_MEMORY_ACCESS=1`: `__attribute__((packed))`
 *   @par
 *     Depends on compiler extensions and is therefore not portable.
 *     This method is safe _if_ your compiler supports it,
 *     and *generally* as fast or faster than `memcpy`.
 *
 *  - `XXH_FORCE_MEMORY_ACCESS=2`: Direct cast
 *  @par
 *     Casts directly and dereferences. This method doesn't depend on the
 *     compiler, but it violates the C standard as it directly dereferences an
 *     unaligned pointer. It can generate buggy code on targets which do not
 *     support unaligned memory accesses, but in some circumstances, it's the
 *     only known way to get the most performance.
 *
 *  - `XXH_FORCE_MEMORY_ACCESS=3`: Byteshift
 *  @par
 *     Also portable. This can generate the best code on old compilers which don't
 *     inline small `memcpy()` calls, and it might also be faster on big-endian
 *     systems which lack a native byteswap instruction. However, some compilers
 *     will emit literal byteshifts even if the target supports unaligned access.
 *  .
 *
 * @warning
 *   Methods 1 and 2 rely on implementation-defined behavior. Use these with
 *   care, as what works on one compiler/platform/optimization level may cause
 *   another to read garbage data or even crash.
 *
 * See http://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html for details.
 *
 * Prefer these methods in priority order (0 > 3 > 1 > 2)
 *//* don't actually *//*!
 * @brief Define this to disable 64-bit code.
 *
 * Useful if only using the @ref xxh32_family and you have a strict C90 compiler.
 *//*!
 * @defgroup tuning Tuning parameters
 * @{
 *
 * Various macros to control xxHash's behavior.
 *//*-**********************************************************************
 * xxHash implementation
 *-**********************************************************************
 * xxHash's implementation used to be hosted inside xxhash.c.
 *
 * However, inlining requires implementation to be visible to the compiler,
 * hence be included alongside the header.
 * Previously, implementation was hosted inside xxhash.c,
 * which was then #included when inlining was activated.
 * This construction created issues with a few build and install systems,
 * as it required xxhash.c to be stored in /include directory.
 *
 * xxHash implementation is now directly integrated within xxhash.h.
 * As a consequence, xxhash.c is no longer needed in /include.
 *
 * xxhash.c is still available and is still useful.
 * In a "normal" setup, when xxhash is not inlined,
 * xxhash.h only exposes the prototypes and public symbols,
 * while xxhash.c can be built into an object file xxhash.o
 * which can then be linked into the final binary.
 ************************************************************************//* ======================================================================== *//* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) *//*
 * *_withSecretandSeed() :
 * These variants generate hash values using either
 * @seed for "short" keys (< XXH3_MIDSIZE_MAX = 240 bytes)
 * or @secret for "large" keys (>= XXH3_MIDSIZE_MAX).
 *
 * This generally benefits speed, compared to `_withSeed()` or `_withSecret()`.
 * `_withSeed()` has to generate the secret on the fly for "large" keys.
 * It's fast, but can be perceptible for "not so large" keys (< 1 KB).
 * `_withSecret()` has to generate the masks on the fly for "small" keys,
 * which requires more instructions than _withSeed() variants.
 * Therefore, _withSecretandSeed variant combines the best of both worlds.
 *
 * When @secret has been generated by XXH3_generateSecret_fromSeed(),
 * this variant produces *exactly* the same results as `_withSeed()` variant,
 * hence offering only a pure speed benefit on "large" input,
 * by skipping the need to regenerate the secret for every large input.
 *
 * Another usage scenario is to hash the secret to a 64-bit hash value,
 * for example with XXH3_64bits(), which then becomes the seed,
 * and then employ both the seed and the secret in _withSecretandSeed().
 * On top of speed, an added benefit is that each bit in the secret
 * has a 50% chance to swap each bit in the output,
 * via its impact to the seed.
 * This is not guaranteed when using the secret directly in "small data" scenarios,
 * because only portions of the secret are employed for small data.
 *//*
 * XXH3_generateSecret_fromSeed():
 *
 * Generate the same secret as the _withSeed() variants.
 *
 * The resulting secret has a length of XXH3_SECRET_DEFAULT_SIZE (necessarily).
 * @secretBuffer must be already allocated, of size at least XXH3_SECRET_DEFAULT_SIZE bytes.
 *
 * The generated secret can be used in combination with
 *`*_withSecret()` and `_withSecretandSeed()` variants.
 * This generator is notably useful in combination with `_withSecretandSeed()`,
 * as a way to emulate a faster `_withSeed()` variant.
 *//*
 * XXH3_generateSecret():
 *
 * Derive a high-entropy secret from any user-defined content, named customSeed.
 * The generated secret can be used in combination with `*_withSecret()` functions.
 * The `_withSecret()` variants are useful to provide a higher level of protection than 64-bit seed,
 * as it becomes much more difficult for an external actor to guess how to impact the calculation logic.
 *
 * The function accepts as input a custom seed of any length and any content,
 * and derives from it a high-entropy secret of length @secretSize
 * into an already allocated buffer @secretBuffer.
 * @secretSize must be >= XXH3_SECRET_SIZE_MIN
 *
 * The generated secret can then be used with any `*_withSecret()` variant.
 * Functions `XXH3_128bits_withSecret()`, `XXH3_64bits_withSecret()`,
 * `XXH3_128bits_reset_withSecret()` and `XXH3_64bits_reset_withSecret()`
 * are part of this list. They all accept a `secret` parameter
 * which must be large enough for implementation reasons (>= XXH3_SECRET_SIZE_MIN)
 * _and_ feature very high entropy (consist of random-looking bytes).
 * These conditions can be a high bar to meet, so
 * XXH3_generateSecret() can be employed to ensure proper quality.
 *
 * customSeed can be anything. It can have any size, even small ones,
 * and its content can be anything, even "poor entropy" sources such as a bunch of zeroes.
 * The resulting `secret` will nonetheless provide all required qualities.
 *
 * When customSeedSize > 0, supplying NULL as customSeed is undefined behavior.
 *//* Symbols defined below must be considered tied to a specific library version. *//* ===   Experimental API   === *//* XXH128() :
 * simple alias to pre-selected XXH3_128bits variant
 *//*!
 * @brief Initializes a stack-allocated `XXH3_state_s`.
 *
 * When the @ref XXH3_state_t structure is merely emplaced on stack,
 * it should be initialized with XXH3_INITSTATE() or a memset()
 * in case its first reset uses XXH3_NNbits_reset_withSeed().
 * This init can be omitted if the first reset uses default or _withSecret mode.
 * This operation isn't necessary when the state is created with XXH3_createState().
 * Note that this doesn't prepare the state for a streaming operation,
 * it's still necessary to use XXH3_NNbits_reset*() afterwards.
 *//* typedef'd to XXH3_state_t *//* note: there may be some padding at the end due to alignment on 64 bytes *//*!< Reference to an external secret for the _withSecret variants, NULL
        *   for other variants. *//*!< Reserved field. *//*!< Seed for _withSeed variants. Must be zero otherwise, @see XXH3_INITSTATE() *//*!< Size of @ref customSecret or @ref extSecret *//*!< Number of stripes per block. *//*!< Total length hashed. 64-bit even on 32-bit targets. *//*!< Number or stripes processed. *//*!< Reserved field. Needed for padding on 64-bit. *//*!< The amount of memory in @ref buffer, @see XXH32_state_s::memsize *//*!< The internal buffer. @see XXH32_state_s::mem32 *//*!< Used to store a custom secret generated from a seed. *//*!< The 8 accumulators. Similar to `vN` in @ref XXH32_state_s::v1 and @ref XXH64_state_s *//*!
 * @internal
 * @brief Structure for XXH3 streaming API.
 *
 * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
 * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined.
 * Otherwise it is an opaque type.
 * Never use this definition in combination with dynamic library.
 * This allows fields to safely be changed in the future.
 *
 * @note ** This structure has a strict alignment requirement of 64 bytes!! **
 * Do not allocate this with `malloc()` or `new`,
 * it will not be sufficiently aligned.
 * Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation.
 *
 * Typedef'd to @ref XXH3_state_t.
 * Do never access the members of this struct directly.
 *
 * @see XXH3_INITSTATE() for stack initialization.
 * @see XXH3_createState(), XXH3_freeState().
 * @see XXH32_state_s, XXH64_state_s
 *//*!
 * @brief Default size of the secret buffer (and @ref XXH3_kSecret).
 *
 * This is the size used in @ref XXH3_kSecret and the seeded functions.
 *
 * Not to be confused with @ref XXH3_SECRET_SIZE_MIN.
 *//*!
 * @brief The size of the internal XXH3 buffer.
 *
 * This is the optimal update size for incremental hashing.
 *
 * @see XXH3_64b_update(), XXH3_128b_update().
 *//* >= C++11 *//* C11+ *//* Old GCC versions only accept the attribute after the type in structures. *//* In C++ alignas() is a keyword *//* >= C11 *//*!< Reserved field. Do not read or write to it. *//*!< Reserved field, needed for padding anyways*//*!< Amount of data in @ref mem64 *//*!< Internal buffer for partial reads. Treated as unsigned char[32]. *//*!< Accumulator lanes *//*!< Total length hashed. This is always 64-bit. *//*!
 * @internal
 * @brief Structure for XXH64 streaming API.
 *
 * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
 * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
 * an opaque type. This allows fields to safely be changed.
 *
 * Typedef'd to @ref XXH64_state_t.
 * Do not access the members of this struct directly.
 * @see XXH32_state_s, XXH3_state_s
 *//* defined when there is no 64-bit support *//*!< Reserved field. Do not read nor write to it. *//*!< Amount of data in @ref mem32 *//*!< Internal buffer for partial reads. Treated as unsigned char[16]. *//*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) *//*!< Total length hashed, modulo 2^32 *//*!
 * @internal
 * @brief Structure for XXH32 streaming API.
 *
 * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
 * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
 * an opaque type. This allows fields to safely be changed.
 *
 * Typedef'd to @ref XXH32_state_t.
 * Do not access the members of this struct directly.
 * @see XXH64_state_s, XXH3_state_s
 *//*
 * These definitions are only present to allow static allocation
 * of XXH states, on stack or in a struct, for example.
 * Never **ever** access their members directly.
 *//* ****************************************************************************
 * This section contains declarations which are not guaranteed to remain stable.
 * They may change in future versions, becoming incompatible with a different
 * version of the library.
 * These declarations should only be used with static linking.
 * Never use them in association with dynamic linking!
 ***************************************************************************** *//* !XXH_NO_XXH3 *//*!
 * XXH128_cmp():
 *
 * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
 *
 * return: >0 if *h128_1  > *h128_2
 *         =0 if *h128_1 == *h128_2
 *         <0 if *h128_1  < *h128_2
 *//*!
 * XXH128_isEqual():
 * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
 *//* Following helper functions make it possible to compare XXH128_hast_t values.
 * Since XXH128_hash_t is a structure, this capability is not offered by the language.
 * Note: For better performance, these functions can be inlined using XXH_INLINE_ALL *//*
 * Streaming requires state maintenance.
 * This operation costs memory and CPU.
 * As a consequence, streaming is slower than one-shot hashing.
 * For better performance, prefer one-shot functions whenever applicable.
 *
 * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().
 * Use already declared XXH3_createState() and XXH3_freeState().
 *
 * All reset and streaming functions have same meaning as their 64-bit counterpart.
 *//*******   Streaming   *******//*!< `value >> 64` *//*!< `value & 0xFFFFFFFFFFFFFFFF` *//*!
 * @brief The return value from 128-bit hashes.
 *
 * Stored in little endian order, although the fields themselves are in native
 * endianness.
 *//*-**********************************************************************
*  XXH3 128-bit variant
************************************************************************//* note : canonical representation of XXH3 is the same as XXH64
 * since they both produce XXH64_hash_t values *//*
 * XXH3_64bits_reset_withSecret():
 * `secret` is referenced, it _must outlive_ the hash streaming session.
 * Similar to one-shot API, `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`,
 * and the quality of produced hash values depends on secret's entropy
 * (secret's content should look like a bunch of random bytes).
 * When in doubt about the randomness of a candidate `secret`,
 * consider employing `XXH3_generateSecret()` instead (see below).
 *//*
 * XXH3_64bits_reset_withSeed():
 * Generate a custom secret from `seed`, and store it into `statePtr`.
 * digest will be equivalent to `XXH3_64bits_withSeed()`.
 *//*
 * XXH3_64bits_reset():
 * Initialize with default parameters.
 * digest will be equivalent to `XXH3_64bits()`.
 *//*!
 * @brief The state struct for the XXH3 streaming API.
 *
 * @see XXH3_state_s for details.
 *//*
 * Streaming requires state maintenance.
 * This operation costs memory and CPU.
 * As a consequence, streaming is slower than one-shot hashing.
 * For better performance, prefer one-shot functions whenever applicable.
 *//*
 * XXH3_64bits_withSecret():
 * It's possible to provide any blob of bytes as a "secret" to generate the hash.
 * This makes it more difficult for an external actor to prepare an intentional collision.
 * The main condition is that secretSize *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
 * However, the quality of the secret impacts the dispersion of the hash algorithm.
 * Therefore, the secret _must_ look like a bunch of random bytes.
 * Avoid "trivial" or structured data such as repeated sequences or a text document.
 * Whenever in doubt about the "randomness" of the blob of bytes,
 * consider employing "XXH3_generateSecret()" instead (see below).
 * It will generate a proper high entropy secret derived from the blob of bytes.
 * Another advantage of using XXH3_generateSecret() is that
 * it guarantees that all bits within the initial blob of bytes
 * will impact every bit of the output.
 * This is not necessarily the case when using the blob of bytes directly
 * because, when hashing _small_ inputs, only a portion of the secret is employed.
 *//*!
 * The bare minimum size for a custom secret.
 *
 * @see
 *  XXH3_64bits_withSecret(), XXH3_64bits_reset_withSecret(),
 *  XXH3_128bits_withSecret(), XXH3_128bits_reset_withSecret().
 *//*
 * XXH3_64bits_withSeed():
 * This variant generates a custom secret on the fly
 * based on default secret altered using the `seed` value.
 * While this operation is decently fast, note that it's not completely free.
 * Note: seed==0 produces the same results as XXH3_64bits().
 *//* XXH3_64bits():
 * default 64-bit variant, using default secret and default seed of 0.
 * It's the fastest variant. *//*-**********************************************************************
*  XXH3 64-bit variant
************************************************************************//*!
 * @}
 * ************************************************************************
 * @defgroup xxh3_family XXH3 family
 * @ingroup public
 * @{
 *
 * XXH3 is a more recent hash algorithm featuring:
 *  - Improved speed for both small and large inputs
 *  - True 64-bit and 128-bit outputs
 *  - SIMD acceleration
 *  - Improved 32-bit viability
 *
 * Speed analysis methodology is explained here:
 *
 *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
 *
 * Compared to XXH64, expect XXH3 to run approximately
 * ~2x faster on large inputs and >3x faster on small ones,
 * exact differences vary depending on platform.
 *
 * XXH3's speed benefits greatly from SIMD and 64-bit arithmetic,
 * but does not require it.
 * Any 32-bit and 64-bit targets that can run XXH32 smoothly
 * can run XXH3 at competitive speeds, even without vector support.
 * Further details are explained in the implementation.
 *
 * Optimized implementations are provided for AVX512, AVX2, SSE2, NEON, POWER8,
 * ZVector and scalar targets. This can be controlled via the XXH_VECTOR macro.
 *
 * XXH3 implementation is portable:
 * it has a generic C90 formulation that can be compiled on any platform,
 * all implementations generage exactly the same hash value on all platforms.
 * Starting from v0.8.0, it's also labelled "stable", meaning that
 * any future version will also generate the same hash value.
 *
 * XXH3 offers 2 variants, _64bits and _128bits.
 *
 * When only 64 bits are needed, prefer invoking the _64bits variant, as it
 * reduces the amount of mixing, resulting in faster speed on small inputs.
 * It's also generally simpler to manipulate a scalar return type than a struct.
 *
 * The API supports one-shot hashing, streaming mode, and custom secrets.
 *//*!
 * @brief The opaque state struct for the XXH64 streaming API.
 *
 * @see XXH64_state_s for details.
 *//*!
 * @brief Calculates the 64-bit hash of @p input using xxHash64.
 *
 * This function usually runs faster on 64-bit systems, but slower on 32-bit
 * systems (see benchmark).
 *
 * @param input The block of data to be hashed, at least @p length bytes in size.
 * @param length The length of @p input, in bytes.
 * @param seed The 64-bit seed to alter the hash's output predictably.
 *
 * @pre
 *   The memory between @p input and @p input + @p length must be valid,
 *   readable, contiguous memory. However, if @p length is `0`, @p input may be
 *   `NULL`. In C++, this also must be *TriviallyCopyable*.
 *
 * @return The calculated 64-bit hash.
 *
 * @see
 *    XXH32(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():
 *    Direct equivalents for the other variants of xxHash.
 * @see
 *    XXH64_createState(), XXH64_update(), XXH64_digest(): Streaming version.
 *//*!
 * @}
 *
 * @defgroup xxh64_family XXH64 family
 * @ingroup public
 * @{
 * Contains functions used in the classic 64-bit xxHash algorithm.
 *
 * @note
 *   XXH3 provides competitive speed for both 32-bit and 64-bit systems,
 *   and offers true 64/128 bit hash results.
 *   It provides better speed for systems with vector processing capabilities.
 *//* LP64 ABI says uint64_t is unsigned long *//*!
 * @brief An unsigned 64-bit integer.
 *
 * Not necessarily defined to `uint64_t` but functionally equivalent.
 *//* don't include <stdint.h> *//*!
 * @}
 * @ingroup public
 * @{
 *//*
Define XXH_FALLTHROUGH macro for annotating switch case with the 'fallthrough' attribute
introduced in CPP17 and C23.
CPP17 : https://en.cppreference.com/w/cpp/language/attributes/fallthrough
C23   : https://en.cppreference.com/w/c/language/attributes/fallthrough
*//*!
 * @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t.
 *
 * @param src The @ref XXH32_canonical_t to convert.
 *
 * @pre
 *   @p src must not be `NULL`.
 *
 * @return The converted hash.
 *//*!
 * @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t.
 *
 * @param dst The @ref XXH32_canonical_t pointer to be stored to.
 * @param hash The @ref XXH32_hash_t to be converted.
 *
 * @pre
 *   @p dst must not be `NULL`.
 *//*!< Hash bytes, big endian *//*!
 * @brief Canonical (big endian) representation of @ref XXH32_hash_t.
 *//*
 * The default return values from XXH functions are unsigned 32 and 64 bit
 * integers.
 * This the simplest and fastest format for further post-processing.
 *
 * However, this leaves open the question of what is the order on the byte level,
 * since little and big endian conventions will store the same number differently.
 *
 * The canonical representation settles this issue by mandating big-endian
 * convention, the same convention as human-readable numbers (large digits first).
 *
 * When writing hash values to storage, sending them over a network, or printing
 * them, it's highly recommended to use the canonical representation to ensure
 * portability across a wider range of systems, present and future.
 *
 * The following functions allow transformation of hash values to and from
 * canonical format.
 *//*!
 * @brief Returns the calculated hash value from an @ref XXH32_state_t.
 *
 * @note
 *   Calling XXH32_digest() will not affect @p statePtr, so you can update,
 *   digest, and update again.
 *
 * @param statePtr The state struct to calculate the hash from.
 *
 * @pre
 *  @p statePtr must not be `NULL`.
 *
 * @return The calculated xxHash32 value from that state.
 *//*!
 * @brief Consumes a block of @p input to an @ref XXH32_state_t.
 *
 * Call this to incrementally consume blocks of data.
 *
 * @param statePtr The state struct to update.
 * @param input The block of data to be hashed, at least @p length bytes in size.
 * @param length The length of @p input, in bytes.
 *
 * @pre
 *   @p statePtr must not be `NULL`.
 * @pre
 *   The memory between @p input and @p input + @p length must be valid,
 *   readable, contiguous memory. However, if @p length is `0`, @p input may be
 *   `NULL`. In C++, this also must be *TriviallyCopyable*.
 *
 * @return @ref XXH_OK on success, @ref XXH_ERROR on failure.
 *//*!
 * @brief Resets an @ref XXH32_state_t to begin a new hash.
 *
 * This function resets and seeds a state. Call it before @ref XXH32_update().
 *
 * @param statePtr The state struct to reset.
 * @param seed The 32-bit seed to alter the hash result predictably.
 *
 * @pre
 *   @p statePtr must not be `NULL`.
 *
 * @return @ref XXH_OK on success, @ref XXH_ERROR on failure.
 *//*!
 * @brief Copies one @ref XXH32_state_t to another.
 *
 * @param dst_state The state to copy to.
 * @param src_state The state to copy from.
 * @pre
 *   @p dst_state and @p src_state must not be `NULL` and must not overlap.
 *//*!
 * @brief Frees an @ref XXH32_state_t.
 *
 * Must be allocated with XXH32_createState().
 * @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState().
 * @return XXH_OK.
 *//*!
 * @brief Allocates an @ref XXH32_state_t.
 *
 * Must be freed with XXH32_freeState().
 * @return An allocated XXH32_state_t on success, `NULL` on failure.
 *//*!
 * @typedef struct XXH32_state_s XXH32_state_t
 * @brief The opaque state struct for the XXH32 streaming API.
 *
 * @see XXH32_state_s for details.
 *//*!
 * Streaming functions generate the xxHash value from an incremental input.
 * This method is slower than single-call functions, due to state management.
 * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
 *
 * An XXH state must first be allocated using `XXH*_createState()`.
 *
 * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
 *
 * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
 *
 * The function returns an error code, with 0 meaning OK, and any other value
 * meaning there is an error.
 *
 * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
 * This function returns the nn-bits hash as an int or long long.
 *
 * It's still possible to continue inserting input into the hash state after a
 * digest, and generate new hash values later on by invoking `XXH*_digest()`.
 *
 * When done, release the state using `XXH*_freeState()`.
 *
 * Example code for incrementally hashing a file:
 * @code{.c}
 *    #include <stdio.h>
 *    #include <xxhash.h>
 *    #define BUFFER_SIZE 256
 *
 *    // Note: XXH64 and XXH3 use the same interface.
 *    XXH32_hash_t
 *    hashFile(FILE* stream)
 *    {
 *        XXH32_state_t* state;
 *        unsigned char buf[BUFFER_SIZE];
 *        size_t amt;
 *        XXH32_hash_t hash;
 *
 *        state = XXH32_createState();       // Create a state
 *        assert(state != NULL);             // Error check here
 *        XXH32_reset(state, 0xbaad5eed);    // Reset state with our seed
 *        while ((amt = fread(buf, 1, sizeof(buf), stream)) != 0) {
 *            XXH32_update(state, buf, amt); // Hash the file in chunks
 *        }
 *        hash = XXH32_digest(state);        // Finalize the hash
 *        XXH32_freeState(state);            // Clean up
 *        return hash;
 *    }
 * @endcode
 *//*!
 * @brief Calculates the 32-bit hash of @p input using xxHash32.
 *
 * Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
 *
 * @param input The block of data to be hashed, at least @p length bytes in size.
 * @param length The length of @p input, in bytes.
 * @param seed The 32-bit seed to alter the hash's output predictably.
 *
 * @pre
 *   The memory between @p input and @p input + @p length must be valid,
 *   readable, contiguous memory. However, if @p length is `0`, @p input may be
 *   `NULL`. In C++, this also must be *TriviallyCopyable*.
 *
 * @return The calculated 32-bit hash value.
 *
 * @see
 *    XXH64(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():
 *    Direct equivalents for the other variants of xxHash.
 * @see
 *    XXH32_createState(), XXH32_update(), XXH32_digest(): Streaming version.
 *//*!
 * @}
 *
 * @defgroup xxh32_family XXH32 family
 * @ingroup public
 * Contains functions used in the classic 32-bit xxHash algorithm.
 *
 * @note
 *   XXH32 is useful for older platforms, with no or poor 64-bit performance.
 *   Note that @ref xxh3_family provides competitive speed
 *   for both 32-bit and 64-bit systems, and offers true 64/128 bit hash results.
 *
 * @see @ref xxh64_family, @ref xxh3_family : Other xxHash families
 * @see @ref xxh32_impl for implementation details
 * @{
 *//*!
 * @brief An unsigned 32-bit integer.
 *
 * Not necessarily defined to `uint32_t` but functionally equivalent.
 *//* Don't show <stdint.h> include *//* ****************************
*  Common basic types
******************************//*!
 * @brief Obtains the xxHash version.
 *
 * This is mostly useful when xxHash is compiled as a shared library,
 * since the returned value comes from the library, as opposed to header file.
 *
 * @return `XXH_VERSION_NUMBER` of the invoked library.
 *//* XXH3_128bits *//* XXH3_64bits *//* XXH64 *//* XXH32 *//* YOUR NAME HERE *//*!
 * @brief Emulate a namespace by transparently prefixing all symbols.
 *
 * If you want to include _and expose_ xxHash functions from within your own
 * library, but also want to avoid symbol collisions with other libraries which
 * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
 * any public symbol from xxhash library with the value of XXH_NAMESPACE
 * (therefore, avoid empty or numeric values).
 *
 * Note that no change is required within the calling program as long as it
 * includes `xxhash.h`: Regular symbol names will be automatically translated
 * by this header.
 *//* specific declaration modes for Windows *//*!
 * @defgroup public Public API
 * Contains details on the public xxHash functions.
 * @{
 *//* ****************************************************************
 *  Stable API
 *****************************************************************//* Ensure the header is parsed again, even if it was previously included *//*
    * Some identifiers (enums, type names) are not symbols,
    * but they must nonetheless be renamed to avoid redeclaration.
    * Alternative solution: do not redeclare them.
    * However, this requires some #ifdefs, and has a more dispersed impact.
    * Meanwhile, renaming can be achieved in a single place.
    *//* employ the namespace for XXH_INLINE_ALL *//* Finally, free the namespace itself *//* Before that, we unconditionally #undef all symbols,
    * in case they were already defined with XXH_NAMESPACE.
    * They will then be redefined for XXH_INLINE_ALL
    *//*
    * This part deals with the special case where a unit wants to inline xxHash,
    * but "xxhash.h" has previously been included without XXH_INLINE_ALL,
    * such as part of some previously included *.h header file.
    * Without further action, the new include would just be ignored,
    * and functions would effectively _not_ be inlined (silent failure).
    * The following macros solve this situation by prefixing all inlined names,
    * avoiding naming collision with previous inclusions.
    *//* note: this version may generate warnings for unused static functions *//* make all functions private *//* avoid macro redef *//* give access to the advanced API, required to compile implementations *//* this section should be traversed only once *//*!
 * XXH_INLINE_ALL (and XXH_PRIVATE_API)
 * Use these build macros to inline xxhash into the target unit.
 * Inlining improves performance on small inputs, especially when the length is
 * expressed as a compile-time constant:
 *
 *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
 *
 * It also keeps xxHash symbols private to the unit, so they are not exported.
 *
 * Usage:
 *     #define XXH_INLINE_ALL
 *     #include "xxhash.h"
 *
 * Do not compile and link xxhash.o as a separate object, as it is not useful.
 *//* ****************************
 *  INLINE mode
 ******************************//* Notice extracted from xxHash homepage:

xxHash is an extremely fast hash algorithm, running at RAM speed limits.
It also successfully passes all tests from the SMHasher suite.

Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)

Name            Speed       Q.Score   Author
xxHash          5.4 GB/s     10
CrapWow         3.2 GB/s      2       Andrew
MurmurHash 3a   2.7 GB/s     10       Austin Appleby
SpookyHash      2.0 GB/s     10       Bob Jenkins
SBox            1.4 GB/s      9       Bret Mulvey
Lookup3         1.2 GB/s      9       Bob Jenkins
SuperFastHash   1.2 GB/s      1       Paul Hsieh
CityHash64      1.05 GB/s    10       Pike & Alakuijala
FNV             0.55 GB/s     5       Fowler, Noll, Vo
CRC32           0.43 GB/s     9
MD5-32          0.33 GB/s    10       Ronald L. Rivest
SHA1-32         0.28 GB/s    10

Q.Score is a measure of quality of the hash function.
It depends on successfully passing SMHasher test set.
10 is a perfect score.

Note: SMHasher's CRC32 implementation is not the fastest one.
Other speed-oriented implementations can be faster,
especially in combination with PCLMUL instruction:
https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735

A 64-bit version, named XXH64, is available since r35.
It offers much better speed, but for 64-bit applications only.
Name     Speed on 64 bits    Speed on 32 bits
XXH64       13.8 GB/s            1.9 GB/s
XXH32        6.8 GB/s            6.0 GB/s
*//* TODO: update *//*!
 * @mainpage xxHash
 *
 * @file xxhash.h
 * xxHash prototypes and implementation
 *//*
 *  xxHash - Fast Hash algorithm
 *  Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - xxHash homepage: http://www.xxhash.com
 *  - xxHash source repository : https://github.com/Cyan4973/xxHash
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
*//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/xxhash.cXXH_IMPLEMENTATION/* access definitions *//* access advanced declarations *//*
 * xxhash.c instantiates functions defined in xxhash.h
 */ZSTD_ErrorCodeZSTD_error_no_errorZSTD_error_GENERICZSTD_error_prefix_unknownZSTD_error_version_unsupportedZSTD_error_frameParameter_unsupportedZSTD_error_frameParameter_windowTooLargeZSTD_error_corruption_detectedZSTD_error_checksum_wrongZSTD_error_dictionary_corruptedZSTD_error_dictionary_wrongZSTD_error_dictionaryCreation_failedZSTD_error_parameter_unsupportedZSTD_error_parameter_outOfBoundZSTD_error_tableLog_tooLargeZSTD_error_maxSymbolValue_tooLargeZSTD_error_maxSymbolValue_tooSmallZSTD_error_stage_wrongZSTD_error_init_missingZSTD_error_memory_allocationZSTD_error_workSpace_tooSmallZSTD_error_dstSize_tooSmallZSTD_error_srcSize_wrongZSTD_error_dstBuffer_nullZSTD_error_frameIndex_tooLargeZSTD_error_seekableIOZSTD_error_dstBuffer_wrongZSTD_error_srcBuffer_wrongZSTD_error_maxCodeZSTDERRORLIB_APIZSTDERRORLIB_VISIBILITYZSTD_ERRORS_H_398273423ZSTD_getErrorStringZSTD_getErrorCode/* ZSTD_ERRORS_H_398273423 *//**< Same as ZSTD_getErrorName, but using a `ZSTD_ErrorCode` enum argument *//*! ZSTD_getErrorCode() :
    convert a `size_t` function result into a `ZSTD_ErrorCode` enum type,
    which can be used to compare with enum list published above *//* never EVER use this value directly, it can change in future versions! Use ZSTD_isError() instead *//* following error codes are __NOT STABLE__, they can be removed or changed in future versions *//*-*********************************************
 *  Error codes list
 *-*********************************************
 *  Error codes _values_ are pinned down since v1.3.1 only.
 *  Therefore, don't rely on values if you may link to any version < v1.3.1.
 *
 *  Only values < 100 are considered stable.
 *
 *  note 1 : this API shall be used with static linking only.
 *           dynamic linking is not yet officially supported.
 *  note 2 : Prefer relying on the enum than on its value whenever possible
 *           This is the only supported way to use the error list < v1.3.1
 *  note 3 : ZSTD_isError() is always correct, whatever the library version.
 **********************************************//* =====   ZSTDERRORLIB_API : control library symbols visibility   ===== */ZSTD_ENABLE_ASM_X86_64_BMI2ZSTD_ASM_SUPPORTEDZSTD_HIDE_ASM_FUNCTION(func).hidden funcZSTD_DATAFLOW_SANITIZERZSTD_PORTABILITY_MACROS_H__has_feature__has_feature(memory_sanitizer)__has_feature(dataflow_sanitizer)__ELF__defined(__linux__) || defined(__linux) || defined(__APPLE__)!defined(ZSTD_DISABLE_ASM) &&                                 \/* ZSTD_PORTABILITY_MACROS_H *//**
 * Determines whether we should enable assembly for x86-64
 * with BMI2.
 *
 * Enable if all of the following conditions hold:
 * - ASM hasn't been explicitly disabled by defining ZSTD_DISABLE_ASM
 * - Assembly is supported
 * - We are compiling for x86-64 and either:
 *   - DYNAMIC_BMI2 is enabled
 *   - BMI2 is supported at compile time
 *//**
 * Only enable assembly for GNUC comptabile compilers,
 * because other platforms may not support GAS assembly syntax.
 *
 * Only enable assembly for Linux / MacOS, other platforms may
 * work, but they haven't been tested. This could likely be
 * extended to BSD systems.
 *
 * Disable assembly when MSAN is enabled, because MSAN requires
 * 100% of code to be instrumented to work.
 *//* Mark the internal assembly functions as hidden  *//* detects whether we are being compiled under dfsan *//* detects whether we are being compiled under asan *//* detects whether we are being compiled under msan *//**
 * This header file contains macro defintions to support portability.
 * This header is shared between C and ASM code, so it MUST only
 * contain macro definitions. It MUST not contain any C code.
 *
 * This header ONLY defines macros to detect platforms/feature support.
 *
 */_m_pshufw(A,N)_mm_shuffle_pi16 (A, N)_mm_shuffle_pi16(A,N)((__m64) __builtin_ia32_pshufw ((__v4hi)(__m64)(A), (int)(N)))_m_pinsrw(A,D,N)_mm_insert_pi16(A, D, N)_mm_insert_pi16(A,D,N)((__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)(__m64)(A), (int)(D), (int)(N)))_m_pextrw(A,N)_mm_extract_pi16(A, N)_mm_extract_pi16(A,N)((int) (unsigned short) __builtin_ia32_vec_ext_v4hi ((__v4hi)(__m64)(A), (int)(N)))_mm_shuffle_ps(A,B,MASK)((__m128) __builtin_ia32_shufps ((__v4sf)(__m128)(A), (__v4sf)(__m128)(B), (int)(MASK)))_mm_prefetch(P,I)__builtin_prefetch ((P), ((I & 0x4) >> 2), (I & 0x3))_mm_shuffle_epi32(A,N)((__m128i)__builtin_ia32_pshufd ((__v4si)(__m128i)(A), (int)(N)))_mm_shufflelo_epi16(A,N)((__m128i)__builtin_ia32_pshuflw ((__v8hi)(__m128i)(A), (int)(N)))_mm_shufflehi_epi16(A,N)((__m128i)__builtin_ia32_pshufhw ((__v8hi)(__m128i)(A), (int)(N)))_mm_insert_epi16(A,D,N)((__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)(__m128i)(A), (int)(D), (int)(N)))_mm_extract_epi16(A,N)((int) (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)(__m128i)(A), (int)(N)))_mm_slli_si128(A,N)((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))_mm_srli_si128(A,N)((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))_mm_bslli_si128(A,N)_mm_bsrli_si128(A,N)_mm_shuffle_pd(A,B,N)((__m128d)__builtin_ia32_shufpd ((__v2df)(__m128d)(A), (__v2df)(__m128d)(B), (int)(N)))"../zstd_errors.h"_force_has_format_string18446744073709551496FORWARD_IF_ERROR(err,__VA_ARGS__...)do { size_t const err_code = (err); if (ERR_isError(err_code)) { RAWLOG(3, "%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(err), ERR_getErrorName(err_code)); _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); RAWLOG(3, ": " __VA_ARGS__); RAWLOG(3, "\n"); return err_code; } } while(0);RETURN_ERROR(err,__VA_ARGS__...)do { RAWLOG(3, "%s:%d: ERROR!: unconditional check failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERROR(err))); _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); RAWLOG(3, ": " __VA_ARGS__); RAWLOG(3, "\n"); return ERROR(err); } while(0);RETURN_ERROR_IF(cond,err,__VA_ARGS__...)if (cond) { RAWLOG(3, "%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cond), ERR_QUOTE(ERROR(err))); _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); RAWLOG(3, ": " __VA_ARGS__); RAWLOG(3, "\n"); return ERROR(err); }ERR_QUOTE(str)_FORCE_HAS_FORMAT_STRING(__VA_ARGS__...)if (0) { _force_has_format_string(__VA_ARGS__); }size_t const e = f; if (ERR_isError(e)) return eZSTD_ERROR(name)ZSTD_error_ ## name/**
 * If the provided expression evaluates to an error code, returns that error code.
 *
 * In debug modes, prints additional information.
 *//**
 * Unconditionally return the specified error.
 *
 * In debug modes, prints additional information.
 *//**
 * Return the specified error if the condition evaluates to true.
 *
 * In debug modes, prints additional information.
 * In order to do that (particularly, printing the conditional that failed),
 * this can't just wrap RETURN_ERROR().
 *//**
 * Ignore: this is an internal helper.
 *
 * We want to force this function invocation to be syntactically correct, but
 * we don't want to force runtime evaluation of its arguments.
 *//**
 * Ignore: this is an internal helper.
 *
 * This is a helper function to help force C99-correctness during compilation.
 * Under strict compilation modes, variadic macro arguments can't be empty.
 * However, variadic function arguments can be. Using a function therefore lets
 * us statically check that at least one (string) argument was passed,
 * independent of the compilation flags.
 *//* error_private.c *//* already defined on Visual Studio */S8U8defined(_AIX)defined(__INTEL_COMPILER) || defined(__GNUC__) || defined(__ICCARM__)defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)defined(__clang__) && __LITTLE_ENDIAN__defined(__clang__) && __BIG_ENDIAN__defined(_MSC_VER) && (_M_AMD64 || _M_IX86)defined(__DMC__) && defined(_M_IX86)/*-**************************************************************
*  Memory I/O Implementation
*****************************************************************//*=== Byteswap ===*//*=== Big endian unaligned read/write ===*//*=== Little endian unaligned read/write ===*//*=== Native unaligned read/write ===*//*=== Static platform detection ===*//*-**************************************************************
*  Memory I/O API
*****************************************************************//* ZSTD_memcpy *//* DEBUG_STATIC_ASSERT *//* __has_builtin */ZSTD_cpuid_avx512vbmiconst ZSTD_cpuid_tavx512vbmif7cZSTD_cpuid_prefetchwt1prefetchwt1ZSTD_cpuid_avx512vlavx512vlf7bZSTD_cpuid_avx512bwavx512bwZSTD_cpuid_shaZSTD_cpuid_avx512cdavx512cdZSTD_cpuid_avx512eravx512erZSTD_cpuid_avx512pfavx512pfZSTD_cpuid_clwbclwbZSTD_cpuid_clflushoptclflushoptZSTD_cpuid_pcommitpcommitZSTD_cpuid_avx512ifmaavx512ifmaZSTD_cpuid_smapsmapZSTD_cpuid_adxadxZSTD_cpuid_rdseedrdseedZSTD_cpuid_avx512dqavx512dqZSTD_cpuid_avx512favx512fZSTD_cpuid_mpxmpxZSTD_cpuid_rtmrtmZSTD_cpuid_invpcidinvpcidZSTD_cpuid_ermsermsZSTD_cpuid_bmi2ZSTD_cpuid_smepsmepZSTD_cpuid_avx2avx2ZSTD_cpuid_hlehleZSTD_cpuid_bmi1bmi1ZSTD_cpuid_pbepbef1dZSTD_cpuid_tmZSTD_cpuid_htthttZSTD_cpuid_ssssZSTD_cpuid_sse2sse2ZSTD_cpuid_ssesseZSTD_cpuid_fxsrfxsrZSTD_cpuid_mmxmmxZSTD_cpuid_acpiacpiZSTD_cpuid_dsdsZSTD_cpuid_clfshclfshZSTD_cpuid_psnpsnZSTD_cpuid_pse36pse36ZSTD_cpuid_patpatZSTD_cpuid_cmovcmovZSTD_cpuid_mcamcaZSTD_cpuid_pgepgeZSTD_cpuid_mtrrmtrrZSTD_cpuid_sepZSTD_cpuid_apicapicZSTD_cpuid_cx8cx8ZSTD_cpuid_mcemceZSTD_cpuid_paepaeZSTD_cpuid_msrmsrZSTD_cpuid_tsctscZSTD_cpuid_psepseZSTD_cpuid_dedeZSTD_cpuid_vmevmeZSTD_cpuid_fpufpuZSTD_cpuid_rdrandrdrandf1cZSTD_cpuid_f16cf16cZSTD_cpuid_avxavxZSTD_cpuid_osxsaveosxsaveZSTD_cpuid_xsavexsaveZSTD_cpuid_aesZSTD_cpuid_tscdeadlinetscdeadlineZSTD_cpuid_popcntZSTD_cpuid_movbemovbeZSTD_cpuid_x2apicx2apicZSTD_cpuid_sse42sse42ZSTD_cpuid_sse41sse41ZSTD_cpuid_dcadcaZSTD_cpuid_pcidpcidZSTD_cpuid_pdcmpdcmZSTD_cpuid_xtprxtprZSTD_cpuid_cx16cx16ZSTD_cpuid_fmaZSTD_cpuid_cnxtidcnxtidZSTD_cpuid_ssse3ssse3ZSTD_cpuid_tm2tm2ZSTD_cpuid_eisteistZSTD_cpuid_smxsmxZSTD_cpuid_vmxvmxZSTD_cpuid_dscpldscplZSTD_cpuid_monitormonitorZSTD_cpuid_dtes64dtes64ZSTD_cpuid_pclmuldqpclmuldqZSTD_cpuid_sse3sse3ZSTD_cpuidf1af7aZSTD_cpuid_tC(name,bit)X(name, f7c, bit)B(name,bit)X(name, f7b, bit)D(name,bit)X(name, f1d, bit)X(name, f1c, bit)X(name,r,bit)MEM_STATIC int ZSTD_cpuid_ ## name(ZSTD_cpuid_t const cpuid) { return ((cpuid.r) & (1U << bit)) != 0; }ZSTD_COMMON_CPU_Hdefined(__i386__) && defined(__PIC__) && !defined(__clang__) && defined(__GNUC__)defined(__x86_64__) || defined(_M_X64) || defined(__i386__)/* ZSTD_COMMON_CPU_H *//* cpuid(7): Extended Features. *//* cpuid(1): Processor Info and Feature Bits. *//* The following block like the normal cpuid branch below, but gcc
     * reserves ebx for use of its pic register so we must specially
     * handle the save and restore to avoid clobbering the register
     *//**
 * Implementation taken from folly/CpuId.h
 * https://github.com/facebook/folly/blob/master/folly/CpuId.h
 */"zstd_trace.h""cpu.h"ZSTD_cpuSupportsBmi2ZSTD_decodeSeqHeadersZSTD_getcBlockSizeblockProperties_t *ZSTD_invalidateRepCodesZSTD_countTrailingZeros365ZSTD_seqToCodesconst seqStore_tconst seqStore_t *ZSTD_getSeqStoreZSTD_getSequenceLengthconst seqDefconst seqDef *seqDef_s *seqLenseqDef *ZSTD_llt_literalLengthZSTD_llt_matchLengthZSTD_limitCopyZSTD_wildcopyconst ZSTD_overlap_ediff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLENdiff >= 16 || diff <= -16ZSTD_overlap_src_before_dstWILDCOPY_VECLENZSTD_copy16ZSTD_copy8blockProperties_tZSTD_frameSizeInfoZSTD_sequenceLengthseqStore_tZSTD_longLengthType_eZSTD_llt_noneseqDefseqDef_sZSTD_bufferMode_eZSTD_bm_bufferedZSTD_bm_stableZSTD_overlap_eZSTD_no_overlapsymbolEncodingType_eset_basicset_rleset_compressedset_repeatblockType_ebt_rawbt_rlebt_compressedbt_reservedorigSizelastBlockblockTypedecompressedBoundlongLengthPoslongLengthTypemaxNbLitmaxNbSeqofCodemlCodellCodelitStartsequencesStartmlBaseoffBaseOF_defaultNormLogOF_DEFAULTNORMLOGconst S16[29]signed short[29]DefaultMaxOffOF_defaultNormML_defaultNormLogML_DEFAULTNORMLOGconst S16[53]signed short[53]MaxMLML_defaultNormconst U8const U8[53]unsigned char[53]ML_bitsLL_defaultNormLogLL_DEFAULTNORMLOGconst S16[36]signed short[36]MaxLLLL_defaultNormconst U8[36]unsigned char[36]LL_bitsseqStoreovtypeZSTD_blockHeaderSizeZSTD_BLOCKHEADERSIZEZSTD_did_fieldSizeZSTD_fcs_fieldSizeZSTD_REP_NUMrepStartValueZSTD_WORKSPACETOOLARGE_MAXDURATIONZSTD_WORKSPACETOOLARGE_FACTORWILDCOPY_OVERLENGTHCOPY16(d,s){ ZSTD_copy16(d,s); d+=16; s+=16; }{ ZSTD_copy8(d,s); d+=8; s+=8; }ZSTD_MAX_FSE_HEADERS_SIZE(((MaxML + 1) * MLFSELog + (MaxLL + 1) * LLFSELog + (MaxOff + 1) * OffFSELog + 7) / 8)ZSTD_MAX_HUF_HEADER_SIZEMaxFSELogMAX(MAX(MLFSELog, LLFSELog), OffFSELog)OffFSELogLLFSELogMLFSELogMaxSeqMAX(MaxLL, MaxML)MaxOffMaxLit((1<<Litbits) - 1)LitbitsLONGNBSEQ0x7F00HufLogMIN_CBLOCK_SIZE(1 + 1 + MIN_SEQUENCES_SIZE )MIN_SEQUENCES_SIZEZSTD_FRAMECHECKSUMSIZEZSTD_FRAMEIDSIZEZSTD_WINDOWLOG_ABSOLUTEMINBIT0BIT1BIT4BIT5BIT6BIT7ZSTD_OPT_NUMBOUNDED(min,val,max)(MAX(min,MIN(val,max)))ZSTD_STATIC_ASSERT(c)ZSTD_CCOMMON_H_MODULEZSTD_NO_TRACE__aarch64__ZSTD_customFreeZSTD_customCallocZSTD_customMalloc/* ZSTD_CCOMMON_H_MODULE *//**
 * @returns true iff the CPU supports dynamic BMI2 dispatch.
 *//* Used by: decompress, fullbench (does not get its definition from here) *//*! ZSTD_decodeSeqHeaders() :
 *  decode sequence header from src *//*! ZSTD_getcBlockSize() :
 *  Provides the size of compressed block from block header `src` *//* declared here for decompress and fullbench *//* zstdmt, adaptive_compression (shouldn't get this definition from here) *//* ZSTD_invalidateRepCodes() :
 * ensures next compression will not use repcodes from previous block.
 * Note : only works with regular variant;
 *        do not use with extDict variant ! *//**
 * Counts the number of trailing zeros of a `size_t`.
 * Most compilers should support CTZ as a builtin. A backup
 * implementation is provided if the builtin isn't supported, but
 * it may not be terribly efficient.
 *//* compress, dictBuilder, decodeCorpus *//* custom memory allocation functions *//* compress, dictBuilder, decodeCorpus (shouldn't get its definition from here) *//* compress & dictBuilder *//* decompress & legacy *//**
 * Contains the compressed frame size and an upper-bound for the decompressed frame size.
 * Note: before using `compressedSize`, check for errors using ZSTD_isError().
 *       similarly, before using `decompressedBound`, check for errors using:
 *          `decompressedBound != ZSTD_CONTENTSIZE_ERROR`
 *//**
 * Returns the ZSTD_sequenceLength for the given sequences. It handles the decoding of long sequences
 * indicated by longLengthPos and longLengthType, and adds MINMATCH back to matchLength.
 *//* Index of the sequence to apply long length modification to *//* longLengthPos and longLengthType to allow us to represent either a single litLength or matchLength
     * in the seqStore that has a value larger than U16 (if it exists). To do so, we increment
     * the existing value of the litLength or matchLength by 0x10000.
     *//* ptr to end of literals *//* ptr to end of sequences *//* represents a long match *//* represents a long literal *//* no longLengthType *//* Controls whether seqStore has a single "long" litLength or matchLength. See seqStore_t. *//* mlBase == matchLength - MINMATCH *//* offBase == Offset + ZSTD_REP_NUM, or repcode 1,2,3 *//*-*******************************************
*  Private declarations
*********************************************//* ZSTD_inBuffer/ZSTD_outBuffer is stable *//* Buffer the input/output *//* Controls whether the input/output buffer is buffered or stable. *//* when workspace is continuously too large
 * during at least this number of times,
 * context's memory usage is considered wasteful,
 * because it's sized to handle a worst case scenario which rarely happens.
 * In which case, resize it down to free some memory *//* define "workspace is too large" as this number of times larger than needed *//* Separate out the first COPY16() call because the copy length is
         * almost certain to be short, so the branches have different
         * probabilities. Since it is almost certain to be short, only do
         * one COPY16() in the first call. Then, do two calls per loop since
         * at that point it is more likely to have a high trip count.
         *//* Handle short offset copies. *//*! ZSTD_wildcopy() :
 *  Custom version of ZSTD_memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
 *  @param ovtype controls the overlap detection
 *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
 *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
 *           The src buffer must be before the dst buffer.
 *//*  ZSTD_overlap_dst_before_src, *//* ZSTD_memmove is not inlined properly by gcc *//* Need to use memmove here since the literal buffer can now be located within
   the dst buffer. In circumstances where the op "catches up" to where the
   literal buffer is, there can be partial overlaps in this call on the final
   copy if the literal is being shifted by less than 16 bytes. *//*-*******************************************
*  Shared functions to include for inlining
*********************************************//* for static allocation *//* Each table cannot take more than #symbols * FSELog bits *//* header + <= 127 byte tree description *//* Assumption : MaxOff < MaxLL,MaxML *//* for a non-null block *//* nbSeq==0 *//* RLE or RAW *//*litCSize*//* C standard doesn't allow `static const` variable to be init using another `static const` variable *//* magic number size *//* number of repcodes *//*-*************************************
*  Common constants
***************************************//* for inlining *//* ---- static assert (debug) --- *//* XXH_reset, update, digest *//* XXH64_state_t *//* assert, DEBUGLOG, RAWLOG, g_debuglevel *//* this module contains definitions which must be identical
 * across compression, decompression and dictBuilder.
 * It also contains a few functions useful to at least 2 of them
 * and which benefit from being inlined */nbSeqPtrbpPtrseqStorePtr/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/common/zstd_common.c1.5.210502/* calloc implemented as malloc+memset;
         * not as efficient as calloc, but next best guess for custom malloc *//*=**************************************************************
*  Custom allocator
****************************************************************//*! ZSTD_getErrorString() :
 *  provides error code string from enum *//*! ZSTD_getError() :
 *  convert a `size_t` function result into a proper ZSTD_errorCode enum *//*! ZSTD_getErrorName() :
 *  provides error code string from function result (useful for debugging) *//*! ZSTD_isError() :
 *  tells if a return value is an error code
 *  symbol is required for external callers *//* defined within zstd_internal.h *//*-****************************************
*  ZSTD Error Management
******************************************//* ZSTD_malloc, ZSTD_calloc, ZSTD_free, ZSTD_memset *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/hist.h"../common/zstd_deps.h"HIST_count_simpleHIST_countFast_wkspHIST_countFastHIST_count_wkspHIST_isErrorHIST_countHIST_WKSP_SIZE(HIST_WKSP_SIZE_U32 * sizeof(unsigned))HIST_WKSP_SIZE_U32/*! HIST_count_simple() :
 *  Same as HIST_countFast(), this function is unsafe,
 *  and will segfault if any value within `src` is `> *maxSymbolValuePtr`.
 *  It is also a bit slower for large inputs.
 *  However, it does not need any additional memory (not even on stack).
 * @return : count of the most frequent symbol.
 *  Note this function doesn't produce any error (i.e. it must succeed).
 *//** HIST_countFast_wksp() :
 *  Same as HIST_countFast(), but using an externally provided scratch buffer.
 * `workSpace` is a writable buffer which must be 4-bytes aligned,
 * `workSpaceSize` must be >= HIST_WKSP_SIZE
 *//** HIST_countFast() :
 *  same as HIST_count(), but blindly trusts that all byte values within src are <= *maxSymbolValuePtr.
 *  This function is unsafe, and will segfault if any value within `src` is `> *maxSymbolValuePtr`
 *//** HIST_count_wksp() :
 *  Same as HIST_count(), but using an externally provided scratch buffer.
 *  Benefit is this function will use very little stack space.
 * `workSpace` is a writable buffer which must be 4-bytes aligned,
 * `workSpaceSize` must be >= HIST_WKSP_SIZE
 *//* --- advanced histogram functions --- *//*! HIST_count():
 *  Provides the precise count of each byte within a table 'count'.
 * 'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1).
 *  Updates *maxSymbolValuePtr with actual largest symbol value detected.
 * @return : count of the most frequent symbol (which isn't identified).
 *           or an error code, which can be tested using HIST_isError().
 *           note : if return == srcSize, there is only one symbol.
 *//* --- simple histogram functions --- *//* --- dependencies --- *//* ******************************************************************
 * hist : Histogram functions
 * part of Finite State Entropy project
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compressworkSpaceSizeZSTD_div64(dividend,divisor)((dividend) / (divisor))/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/fse_compress.c"../common/error_private.h""../common/fse.h""../common/bitstream.h""hist.h""../common/debug.h""../common/mem.h""../common/compiler.h"sizeof(scratchBuffer) >= FSE_COMPRESS_WKSP_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)sizeof(scratchBuffer) >= ( (1 + (1<<(((14-2))-1)) + (((255)+1)*2)) + (((14-2) > 12) ? (1 << ((14-2) - 2)) : 1024) )HIST_count_wksp(count, &maxSymbolValue, src, srcSize, scratchBuffer, scratchBufferSize)FSE_normalizeCount(norm, tableLog, count, srcSize, maxSymbolValue, srcSize >= 2048)lowProbCount(U32)totalNOT_YET_ASSIGNED(((U64)1<<vStepLog) * ToDistribute) + midsrcSize > 1361alphabetSizepreviousIs0symbol <= alphabetSize315((size_t)workSpace & 1) == 0normalizedCounter[u-1] >= 0cumul[u] >= cumul[u-1]n>=0position==0nbOccurrencestotal <= INT_MAXtotal <= 0x7fffffffnormalizedCounter[s] > 1U32[1024]hist_wksp__clang_analyzer__/* useLowProbCount *//* all of the symbols were low enough for the lowOne or lowThreshold *//* Not supported, RLE should be used instead *//* write in buffer is safe *//* incorrect normalized distribution *//* incorrect distribution *//* additional two bytes for bitstream flush *//* round up to whole nb bytes *//* first two symbols may use one additional bit each *//* bitCount initialized at 4 *//*-**************************************************************
*  FSE NCount encoding
****************************************************************//* debug : symbol costs *//* filling nonetheless, for compatibility with FSE_getMaxNbBits() *//* Must have initialized all positions *//* Experimentally determined optimal unroll *//* Spread symbols across the table. Lack of lowprob symbols means that
         * we don't need variable sized inner loop, so we can unroll the loop and
         * reduce branch misses.
         *//* size = tableSize + 8 (may write beyond tableSize) *//* Case for no low prob count symbols. Lay down 8 bytes at a time
         * to reduce branch misses since we are operating on a small block
         *//* no overflow *//* useless initialization, just to keep scan-build happy *//* For explanations on how to distribute symbol values over the table :
     * http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html *//* required for threshold strategy to work *//* Must be 2 bytes-aligned *//* size = tableSize *//* size = maxSV1 *//* ZSTD_malloc, ZSTD_free, ZSTD_memcpy, ZSTD_memset *//* HIST_count_wksp *//* assert, DEBUGLOG *//* U32, U16, etc. *//* ******************************************************************
 * FSE : Finite State Entropy encoder
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/hist.csizeof(tmpCounters)18446744073709551550checkMaxSymbolValuetrustInputHIST_count_parallel_wksp*maxSymbolValuePtr <= 255largestCount(maxSymbolValue+1) * sizeof(*count)*ip <= maxSymbolValueHIST_checkInput_e/* must be aligned on 4-bytes boundaries *//* HIST_count_wksp() :
 * Same as HIST_count(), but using an externally provided scratch buffer.
 * `workSpace` size must be table of >= HIST_WKSP_SIZE_U32 unsigned *//* heuristic threshold *//* HIST_countFast_wksp() :
 * Same as HIST_countFast(), but using an externally provided scratch buffer.
 * `workSpace` is a writable buffer which must be 4-bytes aligned,
 * `workSpaceSize` must be >= HIST_WKSP_SIZE
 *//* in case count & Counting1 are overlapping *//* HIST_count_parallel_wksp() :
 * store histogram into 4 intermediate tables, recombined at the end.
 * this design makes better use of OoO cpus,
 * and is noticeably faster when some values are heavily repeated.
 * But it needs some additional workspace for intermediate tables.
 * `workSpace` must be a U32 table of size >= HIST_WKSP_SIZE_U32.
 * @return : largest histogram frequency,
 *           or an error code (notably when histogram's alphabet is larger than *maxSymbolValuePtr) *//*-**************************************************************
 *  Histogram functions
 ****************************************************************//* --- Error management --- *//* ERROR *//* U32, BYTE, etc. *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/huf_compress.c"../common/huf.h"U64[1088]unsigned long[1088]8704HUF_buildCTable_wksp_tables *4864sizeof(workspace)HUF_fourStreamsHUF_singleStreamHUF_compress_tables_t *HUF_compress_tables_t *constZSTD_ALIGNOF(size_t)sizeof(*table) + HUF_WORKSPACE_MAX_ALIGNMENT <= HUF_WORKSPACE_SIZEsizeof(*table) + 8 <= ((8 << 10) + 512 )7944SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO >= 210 >= 2largestBeginHIST_count_simple (table->count, &maxSymbolValueBegin, (const BYTE*)src, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE)HIST_count_simple (table->count, &maxSymbolValueBegin, (const BYTE*)src, 4096)largestEndHIST_count_simple (table->count, &maxSymbolValueEnd, (const BYTE*)src + srcSize - SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE)HIST_count_simple (table->count, &maxSymbolValueEnd, (const BYTE*)src + srcSize - 4096, 4096)SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZESUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO(SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE * SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO)largestTotalmaxSymbolValueBeginmaxSymbolValueEnd2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE(2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE)(2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) >> 7((2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) >> 7)((2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) >> 7)+4HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, table->wksps.hist_wksp, sizeof(table->wksps.hist_wksp))HUF_CElt[257]unsigned long[257]HUF_CTABLE_SIZE_ST(HUF_SYMBOLVALUE_MAX)sizeof(table->wksps.buildCTable_wksp)ctableSizeunusedSize2056sizeof(table->CTable)sizeof(HUF_CElt)table->CTable + ctableSizeHUF_writeCTable_wksp(op, dstSize, table->CTable, maxSymbolValue, huffLog, &table->wksps.writeCTable_wksp, sizeof(table->wksps.writeCTable_wksp))HUF_WriteCTableWksp *748nbStreamsoldHufTableoldSize12ultable->CTableHUF_compressCTable_internalop >= ostart1156HUF_compress4X_usingCTable_internalop <= oend1098HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2)ip <= iendHUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, bmi2)HUF_compress1X_usingCTable_internalHUF_compress1X_usingCTable_internal_defaultHUF_compress1X_usingCTable_internal_bmi2HUF_compress1X_usingCTable_internal_bodyHUF_CStream_t *bitC.ptr <= bitC.endPtrHUF_tightCompressBoundHUF_compress1X_usingCTable_internal_body_loopn % kUnroll == 0915n % (2 * kUnroll) == 0927n == 0HUF_closeCStreamHUF_endMarkendMarkHUF_flushBitsHUF_BITS_IN_CONTAINERnbBits > 0856nbBits <= sizeof(bitC->bitContainer[0]) * 8857858!kFast || bitC->ptr <= bitC->endPtr861HUF_mergeIndex1(bitC->bitPos[1] & 0xFF) < HUF_BITS_IN_CONTAINER(bitC->bitPos[1] & 0xFF) < (sizeof(size_t) * 8)833(bitC->bitPos[0] & 0xFF) <= HUF_BITS_IN_CONTAINER(bitC->bitPos[0] & 0xFF) <= (sizeof(size_t) * 8)HUF_zeroIndex1HUF_addBitsidx <= 1789HUF_getNbBits(elt) <= HUF_TABLELOG_ABSOLUTEMAXHUF_getNbBits(elt) <= 12790(bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER(bitC->bitPos[idx] & 0xFF) <= (sizeof(size_t) * 8)802dirtyBits((elt >> dirtyBits) << (dirtyBits + nbBits)) == 0kUnrollkFastFlushkLastFastkFastelt813!kFast || (bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER!kFast || (bitC->bitPos[idx] & 0xFF) <= (sizeof(size_t) * 8)815HUF_initCStreamsizeof(*bitC)sizeof(bitC->bitContainer[0])badHUF_buildCTable_wksp_tables *constwksp_tablesZSTD_ALIGNOF(U32)sizeof(HUF_buildCTable_wksp_tables)rankPos[192]struct <unnamed>[192]RANK_POSITION_TABLE_SIZEconst nodeEltconst nodeElt *HUF_buildCTableFromTreeHUF_CElt *constHUF_buildTreenodeElt[]nodeElt_s[]rankPos[]maxSymbolValue1rankPositionsizeof(*rankPosition) * RANK_POSITION_TABLE_SIZEsizeof(*rankPosition) * 192lowerRank < RANK_POSITION_TABLE_SIZE - 1lowerRank < 192 - 1lowerRank563rankPosition[RANK_POSITION_TABLE_SIZE - 1].base == 0rankPosition[192 - 1].base == 0567pos < maxSymbolValue1579bucketStartIdx < maxSymbolValue1bucketSizebucketStartIdx589HUF_isSorted(huffNode, maxSymbolValue1)594HUF_simpleQuickSortkInsertionSortThresholdHUF_quickSortPartitionpivotHUF_insertionSortarrHUF_isSortedHUF_swapNodesHUF_getIndexhuffNode[n].nbBits <= maxNbBits329(totalCost & (baseCost - 1)) == 0335totalCost > 0337rankLast[nBitsToDecrease] != noSymbol || nBitsToDecrease == 1rankLast[nBitsToDecrease] != noSymbol371375n >= 0415symbolValue <= HUF_SYMBOLVALUE_MAXsymbolValue <= 255currconst HUF_CElt *constsizeof(HUF_WriteCTableWksp)HUF_compressWeights(op+1, maxDstSize-1, wksp->huffWeight, maxSymbolValue, &wksp->wksp, sizeof(wksp->wksp))HUF_CompressWeightsWksp *480HUF_setValue(value >> nbBits) == 0sizeof(HUF_CElt) * 8HUF_setNbBitsnbBits <= HUF_TABLELOG_ABSOLUTEMAXnbBits <= 12HUF_getValueFastHUF_getValue18446744073709551360~0xFFHUF_getNbBitsFastHUF_getNbBitssizeof(HUF_CompressWeightsWksp)FSE_normalizeCount(wksp->norm, tableLog, wksp->count, wtSize, maxSymbolValue, 0)FSE_writeNCount(op, (size_t)(oend-op), wksp->norm, maxSymbolValue, tableLog)FSE_buildCTable_wksp(wksp->CTable, wksp->norm, maxSymbolValue, tableLog, wksp->scratchBuffer, sizeof(wksp->scratchBuffer))U32[41]unsigned int[41]FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(HUF_TABLELOG_MAX, MAX_FSE_TABLELOG_FOR_HUFF_HEADER)FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, wksp->CTable)HUF_alignUpWorkspace(align & (align - 1)) == 0align <= HUF_WORKSPACE_MAX_ALIGNMENTalign <= 8add < align((size_t)aligned & mask) == 0HUF_compress_tables_tHUF_nbStreams_eHUF_CStream_tHUF_buildCTable_wksp_tablesHUF_WriteCTableWkspHUF_CompressWeightsWkspwkspswriteCTable_wkspbuildCTable_wksphuffNodeTbl(sizeof(size_t) * 8)RANK_POSITION_DISTINCT_COUNT_CUTOFFRANK_POSITION_LOG_BUCKETS_BEGIN + BIT_highbit32(RANK_POSITION_LOG_BUCKETS_BEGIN)RANK_POSITION_LOG_BUCKETS_BEGIN(RANK_POSITION_TABLE_SIZE - 1) - RANK_POSITION_MAX_COUNT_LOG - 1RANK_POSITION_MAX_COUNT_LOGHUF_WORKSPACE_MAX_ALIGNMENTDEBUGLEVEL >= 1/** HUF_buildCTable() :
 * @return : maxNbBits
 *  Note : count is used before tree is written, so they can safely overlap
 *//* HUF_compress4X_repeat():
 * compress input using 4 streams.
 * consider skipping quickly
 * re-use an existing huffman compression table *//*bmi2*//* HUF_compress4X_repeat():
 * compress input using 4 streams.
 * provide workspace to generate compression tables *//* Save new table *//* Use the new huffman table *//* Check if using previous huffman table is beneficial *//* Zero unused symbols in CTable, so we can check it for validity *//* Heuristic : use existing table for small inputs *//* Check validity of previous table *//* heuristic : probably not compressible enough *//* If uncompressible data is suspected, do a smaller sampling first *//* Heuristic : If old table is valid, use it for small inputs *//* cannot fit anything within dst budget *//* Uncompressed *//* HUF_compress_internal() :
 * `workSpace_align4` must be aligned on 4-bytes boundaries,
 * and occupies the same space as a table of HUF_WORKSPACE_SIZE_U64 unsigned *//* Must be >= 2 *//* kLastFast *//* kFastFlush *//* kUnroll *//* kFast *//**
 * Returns a tight upper bound on the output space needed by Huffman
 * with 8 bytes buffer to handle over-writes. If the output is at least
 * this large we don't need to do bounds checks during Huffman encoding.
 *//* Merge bitstream @ index 1 into the bitstream @ index 0 *//* Encode kUnroll symbols into the bitstream @ index 1.
         * This allows us to start filling the bit container
         * without any data dependencies.
         *//* Encode kUnroll symbols into the bitstream @ index 0. *//* Join to 2 * kUnroll *//* Join to kUnroll *//*! HUF_closeCStream() :
 *  @return Size of CStream, in bytes,
 *          or 0 if it could not fit into dstBuffer *//*! HUF_endMark()
 * @returns The Huffman stream end mark: A 1-bit value = 1.
 *//* bitContainer doesn't need to be modified because the leftover
     * bits are already the top bitPos bits. And we don't care about
     * noise in the lower values.
     *//* Mask bitPos to account for the bytes we consumed. *//* The top nbBits bits of bitContainer are the ones we need. *//* The upper bits of bitPos are noisy, so we must mask by 0xFF. *//*! HUF_flushBits() :
* Flushes the bits in the bit container @ index 0.
*
* @post bitPos will be < 8.
* @param kFast If kFast is set then we must know a-priori that
*              the bit container will not overflow.
*//*! HUF_mergeIndex1() :
 * Merges the bit container @ index 1 into the bit container @ index 0
 * and zeros the bit container @ index 1.
 *//* We didn't overwrite any bits in the bit container. *//* Middle bits are 0. *//* The last 4-bits of elt are dirty if fast is set,
     * so we must not be overwriting bits that have already been
     * inserted into the bit container.
     *//* We only read the low 8 bits of bitC->bitPos[idx] so it
     * doesn't matter that the high bits have noise from the value.
     *//* This is efficient on x86-64 with BMI2 because shrx
     * only reads the low 6 bits of the register. The compiler
     * knows this and elides the mask. When fast is set,
     * every operation can use the same value loaded from elt.
     *//*! HUF_addBits():
 * Adds the symbol stored in HUF_CElt elt to the bitstream.
 *
 * @param elt   The element we're adding. This is a (nbBits, value) pair.
 *              See the HUF_CStream_t docs for the format.
 * @param idx   Insert into the bitstream at this idx.
 * @param kFast This is a template parameter. If the bitstream is guaranteed
 *              to have at least 4 unused bits after this call it may be 1,
 *              otherwise it must be 0. HUF_addBits() is faster when fast is set.
 *//**! HUF_initCStream():
 * Initializes the bitstream.
 * @returns 0 or an error code.
 *//** HUF_CStream_t:
 * Huffman uses its own BIT_CStream_t implementation.
 * There are three major differences from BIT_CStream_t:
 *   1. HUF_addBits() takes a HUF_CElt (size_t) which is
 *      the pair (nbBits, value) in the format:
 *      format:
 *        - Bits [0, 4)            = nbBits
 *        - Bits [4, 64 - nbBits)  = 0
 *        - Bits [64 - nbBits, 64) = value
 *   2. The bitContainer is built from the upper bits and
 *      right shifted. E.g. to add a new value of N bits
 *      you right shift the bitContainer by N, then or in
 *      the new value into the N upper bits.
 *   3. The bitstream has two bit containers. You can add
 *      bits to the second container and merge them into
 *      the first container.
 *//* build tree *//* determine starting value per rank *//* fill result into ctable (val, nbBits) *//**
 * HUF_buildCTableFromTree():
 * Build the CTable given the Huffman tree in huffNode.
 *
 * @param[out] CTable         The output Huffman CTable.
 * @param      huffNode       The Huffman tree.
 * @param      nonNullRank    The last and smallest node in the Huffman tree.
 * @param      maxSymbolValue The maximum symbol value.
 * @param      maxNbBits      The exact maximum number of bits used in the Huffman tree.
 *//* HUF_buildTree():
 * Takes the huffNode array sorted by HUF_sort() and builds an unlimited-depth Huffman tree.
 *
 * @param huffNode        The array sorted by HUF_sort(). Builds the Huffman tree in this array.
 * @param maxSymbolValue  The maximum symbol value.
 * @return                The smallest node in the Huffman tree (by count).
 *//** HUF_buildCTable_wksp() :
 *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
 *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as sizeof(HUF_buildCTable_wksp_tables).
 *//* Sort each bucket. *//* Insert each symbol into their appropriate bucket, setting up rankPosition table. *//* Set up the rankPosition table *//* Compute base and set curr to base.
     * For symbol s let lowerRank = HUF_getIndex(count[n]) and rank = lowerRank + 1.
     * See HUF_getIndex to see bucketing strategy.
     * We attribute each symbol to lowerRank's base value, because we want to know where
     * each rank begins in the output, so for rank R we want to count ranks R+1 and above.
     *//**
 * HUF_sort():
 * Sorts the symbols [0, maxSymbolValue] by count[symbol] in decreasing order.
 * This is a typical bucket sorting strategy that uses either quicksort or insertion sort to sort each bucket.
 *
 * @param[out] huffNode       Sorted symbols by decreasing count. Only members `.count` and `.byte` are filled.
 *                            Must have (maxSymbolValue + 1) entries.
 * @param[in]  count          Histogram of the symbols.
 * @param[in]  maxSymbolValue Maximum symbol value.
 * @param      rankPosition   This is a scratch workspace. Must have RANK_POSITION_TABLE_SIZE entries.
 *//* Classic quicksort by descending with partially iterative calls
 * to reduce worst case callstack size.
 *//* Simply select rightmost element as pivot. "Better" selectors like
     * median-of-three don't experimentally appear to have any benefit.
     *//* Pivot helper function for quicksort. *//* Insertion sort by descending order *//* Returns 0 if the huffNode array is not sorted by descending count *//* Helper swap function for HUF_quickSortPartition() *//* Return the appropriate bucket index for a given count. See definition of
 * RANK_POSITION_DISTINCT_COUNT_CUTOFF for explanation of bucketing strategy.
 *//* == 166 *//* == 158 *//* RANK_POSITION_DISTINCT_COUNT_CUTOFF == Cutoff point in HUF_sort() buckets for which we use log2 bucketing.
 * Strategy is to use as many buckets as possible for representing distinct
 * counts while using the remainder to represent all "large" counts.
 *
 * To satisfy this requirement for 192 buckets, we can do the following:
 * Let buckets 0-166 represent distinct counts of [0, 166]
 * Let buckets 166 to 192 represent all remaining counts up to RANK_POSITION_MAX_COUNT_LOG using log2 bucketing.
 *//* Number of buckets available for HUF_sort() *//* special case : no rank 1 symbol (using maxNbBits-1);
                 * let's create one from largest rank 0 (using maxNbBits).
                 *//* If we've removed too much weight, then we have to add it back.
             * To avoid overshooting again, we only adjust the smallest rank.
             * We take the largest nodes from the lowest rank 0 and move them
             * to rank 1. There's guaranteed to be enough rank 0 symbols because
             * TODO.
             *//* Fix up the old rank.
                 * If the symbol was at position 0, meaning it was the highest weight symbol in the tree,
                 * it must be the only symbol in its rank, so the old rank now has no symbols.
                 * Otherwise, since the Huffman nodes are sorted by count, the previous position is now
                 * the smallest node in the rank. If the previous position belongs to a different rank,
                 * then the rank is now empty.
                 *//* Fix up the new rank.
                 * If the new rank was empty, this symbol is now its smallest.
                 * Otherwise, this symbol will be the largest in the new rank so no adjustment.
                 *//* Increase the number of bits to gain back half the rank cost. *//* Decrease highPos if no symbols of lowPos or if it is
                     * not cheaper to remove 2 lowPos than highPos.
                     *//* Try to reduce the next power of 2 above totalCost because we
                 * gain back half the rank.
                 *//* Get pos of last (smallest = lowest cum. count) symbol per rank *//* renorm totalCost from 2^largestBits to 2^maxNbBits
         * note : totalCost is necessarily a multiple of baseCost *//* Adjust any ranks > maxNbBits to maxNbBits.
         * Compute totalCost, which is how far the sum of the ranks is
         * we are over 2^largestBits after adjust the offending ranks.
         *//* early exit : no elt > maxNbBits, so the tree is already valid. *//**
 * HUF_setMaxHeight():
 * Enforces maxNbBits on the Huffman tree described in huffNode.
 *
 * It sets all nodes with nbBits > maxNbBits to be maxNbBits. Then it adjusts
 * the tree to so that it is a valid canonical Huffman tree.
 *
 * @pre               The sum of the ranks of each symbol == 2^largestBits,
 *                    where largestBits == huffNode[lastNonNull].nbBits.
 * @post              The sum of the ranks of each symbol == 2^largestBits,
 *                    where largestBits is the return value <= maxNbBits.
 *
 * @param huffNode    The Huffman tree modified in place to enforce maxNbBits.
 * @param lastNonNull The symbol with the lowest count in the Huffman tree.
 * @param maxNbBits   The maximum allowed number of bits, which the Huffman tree
 *                    may not respect. After this function the Huffman tree will
 *                    respect maxNbBits.
 * @return            The maximum number of bits of the Huffman tree after adjustment,
 *                    necessarily no more than maxNbBits.
 *//*! HUF_writeCTable() :
    `CTable` : Huffman tree to save, using huf representation.
    @return : size of saved CTable *//* never fails *//* pow 2 *//* ZSTD_memcpy, ZSTD_memset *//* ******************************************************************
 * Huffman encoder, part of New Generation Entropy library
 * Copyright (c) Yann Collet, Facebook, Inc.
 *
 *  You can contact the author at :
 *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
 *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
****************************************************************** */workspaceSizePtr/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_lazy.h"zstd_compress_internal.h"ZSTD_compressBlock_btlazy2_extDictZSTD_matchState_t *seqStore_t *U32[3]ZSTD_compressBlock_lazy2_extDict_rowZSTD_compressBlock_lazy_extDict_rowZSTD_compressBlock_greedy_extDict_rowZSTD_compressBlock_lazy2_extDictZSTD_compressBlock_lazy_extDictZSTD_compressBlock_greedy_extDictZSTD_compressBlock_greedy_dedicatedDictSearch_rowZSTD_compressBlock_lazy_dedicatedDictSearch_rowZSTD_compressBlock_lazy2_dedicatedDictSearch_rowZSTD_compressBlock_greedy_dedicatedDictSearchZSTD_compressBlock_lazy_dedicatedDictSearchZSTD_compressBlock_lazy2_dedicatedDictSearchZSTD_compressBlock_greedy_dictMatchState_rowZSTD_compressBlock_lazy_dictMatchState_rowZSTD_compressBlock_lazy2_dictMatchState_rowZSTD_compressBlock_greedy_dictMatchStateZSTD_compressBlock_lazy_dictMatchStateZSTD_compressBlock_lazy2_dictMatchStateZSTD_compressBlock_btlazy2_dictMatchStateZSTD_compressBlock_greedy_rowZSTD_compressBlock_lazy_rowZSTD_compressBlock_lazy2_rowZSTD_compressBlock_greedyZSTD_compressBlock_lazyZSTD_compressBlock_lazy2ZSTD_compressBlock_btlazy2ZSTD_preserveUnsortedMarkZSTD_dedicatedDictSearch_lazy_loadDictionaryZSTD_row_updateZSTD_matchState_t *constZSTD_insertAndFindFirstIndexZSTD_LAZY_DDSS_BUCKET_LOGZSTD_LAZY_H/* ZSTD_LAZY_H *//*! used in ZSTD_reduceIndex(). preemptively increase value of ZSTD_DUBT_UNSORTED_MARK *//**
 * Dedicated Dictionary Search Structure bucket log. In the
 * ZSTD_dedicatedDictSearch mode, the hashTable has
 * 2 ** ZSTD_LAZY_DDSS_BUCKET_LOG entries in each bucket, rather than just
 * one.
 */msreducerValue/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/clevels.hconst ZSTD_compressionParametersconst ZSTD_compressionParameters[23]struct <unnamed>[23]ZSTD_MAX_CLEVELconst ZSTD_compressionParameters[4][23]struct <unnamed>[4][23]ZSTD_defaultCParametersZSTD_CLEVELS_H/* ZSTD_CLEVELS_H *//* level 22.*//* level 21.*//* level 20.*//* level 19.*//* level 18.*//* level 17.*//* level 16.*//* level 15.*//* level 14.*//* level 13.*//* level 12.*//* level 11.*//* level 10.*//* level  9.*//* level  8.*//* level  7 *//* level  6 *//* level  5.*//* level  4 *//* level  3 *//* level  2 *//* level  1 *//* base for negative levels *//* W,  C,  H,  S,  L,  T, strat *//* for srcSize <= 16 KB *//* level 12 *//* level 11 *//* level 10 *//* level  9 *//* level  8 *//* level  5 *//* for srcSize <= 128 KB *//* level 13 *//* level  6.*//* level  4.*//* for srcSize <= 256 KB *//* level 22 *//* level 21 *//* level 20 *//* level 19 *//* level 18 *//* level 17 *//* level 16 *//* level 15 *//* level 14 *//* W,  C,  H,  S,  L, TL, strat *//* "default" - for any srcSize > 256 KB *//* ZSTD_compressionParameters  *//home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress_internal.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_cwksp.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstdmt_compress.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress_sequences.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress_literals.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_fast.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_double_fast.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_opt.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_ldm.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress_superblock.h/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress.c"clevels.h""zstd_compress_superblock.h""zstd_ldm.h""zstd_opt.h""zstd_lazy.h""zstd_double_fast.h""zstd_fast.h""zstd_compress_literals.h""zstd_compress_sequences.h"ZSTD_cpm_unknownZSTD_getParams_internal"ZSTD_getParams (cLevel=%i)", compressionLevel&paramsZSTD_parameters *ZSTD_getCParams_internalrSize16 KBrow"ZSTD_getCParams_internal (cLevel=%i)", compressionLevelcpconst ZSTD_compressionParameters(*)[23]struct <unnamed>(*)[23]const ZSTD_compressionParameters *"ZSTD_getCParams_internal selected tableID: %u row: %u strat: %u", tableID, row, (U32)cp.strategyZSTD_minCLevel()clampedCompressionLevelZSTD_getCParamRowSizeZSTD_cpm_noAttachDictZSTD_cpm_createCDictZSTD_cpm_attachDict6258unknownZSTD_dedicatedDictSearch_revertCParamsZSTD_compressionParameters *ZSTD_dedicatedDictSearch_isSupportedZSTD_dedicatedDictSearch_getCParams-131072(int)-ZSTD_TARGETLENGTH_MAXremainingToFlush"ZSTD_compressStream2 failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(remainingToFlush), ERR_getErrorName(err_code)": " "ZSTD_compressStream2 failed"err_codeZSTD_compressStream2 failedchecksumSizetoFlush"ZSTD_endStream : remaining to flush : %u", (unsigned)toFlushcompressedBlocksSize"ZSTD_compressSequences()"cctx != NULLcctx != ((void *)0)6125ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize)"CCtx initialization failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize)), ERR_getErrorName(err_code)": " "CCtx initialization failed"CCtx initialization failed"Compressing blocks failed!""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(compressedBlocksSize), ERR_getErrorName(err_code)": " "Compressing blocks failed!"Compressing blocks failed!dstCapacity<4"no room for checksum""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dstCapacity<4), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "no room for checksum""Write checksum : %08X", (unsigned)checksumno room for checksumsrcSizeHint"Final compressed size: %zu", cSizeZSTD_compressSequences_internalcompressedSeqsSizeseqPosconst ZSTD_sequenceCopierZSTD_sequencePosition *const ZSTD_Sequence *constsequenceCopier"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu", srcSize, inSeqsSize"No room for empty frame block header"": " "No room for empty frame block header"cBlockHeader24(U32)bt_raw((U32)bt_raw)((U32)bt_raw)<<1(((U32)bt_raw)<<1)1 /* last block */ + (((U32)bt_raw)<<1)No room for empty frame block header"Working on new block. Blocksize: %zu", blockSizeadditionalByteAdjustment"Bad sequence copy""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(additionalByteAdjustment), ERR_getErrorName(err_code)": " "Bad sequence copy"cBlockSize"Nocompress block failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(cBlockSize), ERR_getErrorName(err_code)": " "Nocompress block failed""Block too small, writing out nocompress block: cSize: %zu", cBlockSize"Compressing sequences of block failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(compressedSeqsSize), ERR_getErrorName(err_code)": " "Compressing sequences of block failed""Compressed sequences size: %zu", compressedSeqsSize"Writing out nocompress block, size: %zu", cBlockSize"RLE compress block failed"": " "RLE compress block failed""Writing out RLE block, size: %zu", cBlockSize"Writing out compressed block, size: %zu", cBlockSize"cSize running total: %zu", cSizeBad sequence copyNocompress block failedconst ZSTD_entropyCTables_tconst ZSTD_entropyCTables_t *ZSTD_entropyCTables_t *ZSTD_compressedBlockState_t *8920ENTROPY_WORKSPACE_SIZECompressing sequences of block failedRLE compress block failedcBlockHeaderZSTD_blockState_t *ZSTD_blockState_t *const(U32)bt_compressed((U32)bt_compressed)((U32)bt_compressed)<<1(((U32)bt_compressed)<<1)ZSTD_selectSequenceCopierZSTD_cParam_withinBounds(ZSTD_c_blockDelimiters, mode)ZSTD_cParam_withinBounds(ZSTD_c_experimentalParam11, mode)5986sequenceCopier != NULLsequenceCopier != ((void *)0)5992ZSTD_copySequencesToSeqStoreNoBlockDelimstartPosInSequenceendPosInSequenceupdatedRepcodesbytesAdjustmentfinalMatchSplit"ZSTD_copySequencesToSeqStore: idx: %u PIS: %u blockSize: %zu", idx, startPosInSequence, blockSize"Start seq: idx: %u (of: %u ml: %u ll: %u)", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLengthupdatedRepcodes.repcctx->blockState.prevCBlock->repsizeof(repcodes_t)"Require a split: diff: %u, idx: %u PIS: %u", currSeq.litLength + currSeq.matchLength - endPosInSequence, idx, endPosInSequenceZSTD_validateSequence(offCode, matchLength, seqPos->posInSrc, cctx->appliedParams.cParams.windowLog, dictSize)"Sequence validation failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_validateSequence(offCode, matchLength, seqPos->posInSrc, cctx->appliedParams.cParams.windowLog, dictSize)), ERR_getErrorName(err_code)": " "Sequence validation failed""Storing sequence: (of: %u, ml: %u, ll: %u)", offCode, matchLength, litLengthidx - seqPos->idx > cctx->seqStore.maxNbSeq"Not enough memory allocated. Try adjusting ZSTD_c_minMatch.""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(idx - seqPos->idx > cctx->seqStore.maxNbSeq), ERR_QUOTE(ERROR(memory_allocation))": " "Not enough memory allocated. Try adjusting ZSTD_c_minMatch."currSeqrawOffsetoffCodefirstHalfMatchLengthsecondHalfMatchLengthll0Sequence validation failedNot enough memory allocated. Try adjusting ZSTD_c_minMatch.char[60]18446744073709551552"Ending seq: idx: %u (of: %u ml: %u ll: %u)", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLengthidx == inSeqsSize || endPosInSequence <= inSeqs[idx].litLength + inSeqs[idx].matchLength5962cctx->blockState.nextCBlock->rep"Storing last literals of size: %u", lastLLSizelastLLSize5971ZSTD_copySequencesToSeqStoreExplicitBlockDelim"Storing last literals of size: %u", inSeqs[idx].litLengthip != iend"Blocksize doesn't agree with block delimiter!""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ip != iend), ERR_QUOTE(ERROR(corruption_detected))": " "Blocksize doesn't agree with block delimiter!"Blocksize doesn't agree with block delimiter!ZSTD_finalizeOffCode(rawOffset)>05781(1)>=1(1)<=32 - ll0(2 - ll0)>=1(2 - ll0)<=33 - ll0(3 - ll0)>=1(3 - ll0)<=3(3)>=1(3)<=35784578657885790ZSTD_validateSequenceoffsetBoundoffCode > STORE_OFFSET(offsetBound)offCode > ((((offsetBound)>0) ? (void) (0) : __assert_fail ("(offsetBound)>0", "/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress.c", 5773, __extension__ __PRETTY_FUNCTION__)), offsetBound + (3-1))"Offset too large!""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(offCode > ((((offsetBound)>0) ? (void) (0) : __assert_fail ("(offsetBound)>0", "/home/atharvakale/390r-debugging-setup/p7zip/C/zstd/lib/compress/zstd_compress.c", 5773, __extension__ __PRETTY_FUNCTION__)), offsetBound + (3-1))), ERR_QUOTE(ERROR(corruption_detected))": " "Offset too large!"(offsetBound)>0posInSrc5773Offset too large!matchLength < MINMATCHmatchLength < 3"Matchlength too small""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(matchLength < 3), ERR_QUOTE(ERROR(corruption_detected))": " "Matchlength too small"Matchlength too smallconst ZSTD_bufferMode_eoriginalInBufferModeoriginalOutBufferMode"ZSTD_compress2 (srcSize=%u)", (unsigned)srcSizeoPosiPos"ZSTD_compressStream2_simpleArgs failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(result), ERR_getErrorName(err_code)": " "ZSTD_compressStream2_simpleArgs failed"ZSTD_compressStream2_simpleArgs failedoPos == dstCapacity"%s:%d: ERROR!: unconditional check failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERROR(dstSize_tooSmall))": " ""5744iPos == srcSize5747cErr"ZSTD_compressStream2, endOp=%u ", (unsigned)endOpoutput->pos > output->size"invalid output buffer""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(output->pos > output->size), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "invalid output buffer"invalid output bufferinput->pos > input->size"invalid input buffer""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(input->pos > input->size), ERR_QUOTE(ERROR(srcSize_wrong))": " "invalid input buffer"invalid input buffer(U32)endOp > (U32)ZSTD_e_end"invalid endDirective""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE((U32)endOp > (U32)ZSTD_e_end), ERR_QUOTE(ERROR(parameter_outOfBound))": " "invalid endDirective"invalid endDirective184467440737095515745644ZSTD_CCtx_init_compressStream2(cctx, endOp, input->size)"CompressStream2 initialization failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_init_compressStream2(cctx, endOp, input->size)), ERR_getErrorName(err_code)": " "CompressStream2 initialization failed"zcss_initCompressStream2 initialization failedconst ZSTD_outBufferconst ZSTD_outBuffer *const ZSTD_inBufferconst ZSTD_inBuffer *ZSTD_checkBufferStability(cctx, output, input, endOp)"invalid buffers""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_checkBufferStability(cctx, output, input, endOp)), ERR_getErrorName(err_code)": " "invalid buffers"invalid buffersflushMin"ZSTDMT_compressStream_generic failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(flushMin), ERR_getErrorName(err_code)": " "ZSTDMT_compressStream_generic failed"endOp == ZSTD_e_flush || endOp == ZSTD_e_end"completed ZSTD_compressStream2 delegating to ZSTDMT_compressStream_generic"endOp == ZSTD_e_continue || flushMin == 0 || output->pos == output->sizeZSTDMT_CCtx *ZSTDMT_CCtx_s *iposoposZSTDMT_compressStream_generic failed56845696ZSTD_compressStream_generic(cctx, output, input, endOp)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_compressStream_generic(cctx, output, input, endOp)), ERR_getErrorName(err_code)const ZSTD_EndDirective"completed ZSTD_compressStream2"ZSTD_CCtx_init_compressStream2const ZSTD_prefixDictprefixDictZSTD_initLocalDict(cctx)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_initLocalDict(cctx)), ERR_getErrorName(err_code)&cctx->prefixDictsizeof(cctx->prefixDict)ZSTD_prefixDict *ZSTD_prefixDict_s *prefixDict.dict==NULL || cctx->cdict==NULLprefixDict.dict==((void *)0) || cctx->cdict==((void *)0)5556"ZSTD_compressStream2 : transparent init stage"const ZSTD_cParamMode_econst ZSTD_compressionParameters *constZSTDMT_JOBSIZE_MIN"ZSTD_compressStream2: creating new mtctx for nbWorkers=%u", params.nbWorkerscctx->mtctx == NULLcctx->mtctx == ((void *)0)"NULL pointer!""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->mtctx == ((void *)0)), ERR_QUOTE(ERROR(memory_allocation))": " "NULL pointer!""call ZSTDMT_initCStream_internal as nbWorkers=%u", params.nbWorkersZSTDMT_initCStream_internal( cctx->mtctx, prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, cctx->cdict, params, cctx->pledgedSrcSizePlusOne-1)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTDMT_initCStream_internal( cctx->mtctx, prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, cctx->cdict, params, cctx->pledgedSrcSizePlusOne-1)), ERR_getErrorName(err_code)!ZSTD_isError(ZSTD_checkCParams(params.cParams))!ERR_isError(ZSTD_checkCParams(params.cParams))ZSTD_compressBegin_internal(cctx, prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, ZSTD_dtlm_fast, cctx->cdict, &params, pledgedSrcSize, ZSTDb_buffered)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_compressBegin_internal(cctx, prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, ZSTD_dtlm_fast, cctx->cdict, &params, pledgedSrcSize, ZSTDb_buffered)), ERR_getErrorName(err_code)cctx->appliedParams.nbWorkers == 0const ZSTD_CCtx_sconst ZSTD_CCtx_s *NULL pointer!zcss_load56105616ZSTD_checkBufferStability"ZSTD_c_stableInBuffer enabled but input differs!""%s:%d: ERROR!: unconditional check failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERROR(srcBuffer_wrong))": " "ZSTD_c_stableInBuffer enabled but input differs!""ZSTD_c_stableInBuffer can only be used with ZSTD_e_end!"": " "ZSTD_c_stableInBuffer can only be used with ZSTD_e_end!"expectZSTD_c_stableInBuffer enabled but input differs!18446744073709551511ZSTD_c_stableInBuffer can only be used with ZSTD_e_end!"ZSTD_c_stableOutBuffer enabled but output size differs!""%s:%d: ERROR!: unconditional check failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERROR(dstBuffer_wrong))": " "ZSTD_c_stableOutBuffer enabled but output size differs!"outBufferSizeZSTD_c_stableOutBuffer enabled but output size differs!18446744073709551512ZSTD_setBufferExpectationsZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)), ERR_getErrorName(err_code)ZSTD_nextInputSizeHint_MTorSTcctx->mtctx != NULLcctx->mtctx != ((void *)0)5499const ZSTDMT_CCtxconst ZSTDMT_CCtx *ZSTD_compressStream_genericsomeMoreWork"ZSTD_compressStream_generic, flush=%u", (unsigned)flushModezcs->inBuff != NULLzcs->inBuff != ((void *)0)zcs->inBuffSize > 053445345zcs->outBuff != NULLzcs->outBuff != ((void *)0)zcs->outBuffSize > 053485349output->pos <= output->size5351input->pos <= input->size5352(U32)flushMode <= (U32)ZSTD_e_end5353"call ZSTD_initCStream() first!""%s:%d: ERROR!: unconditional check failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERROR(init_missing))": " "call ZSTD_initCStream() first!""ZSTD_compressEnd : cSize=%u", (unsigned)cSize"ZSTD_compressEnd failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(cSize), ERR_getErrorName(err_code)": " "ZSTD_compressEnd failed""stream compression stage (flushMode==%u)", flushMode(size_t)(iend - ip)zcs->blockSize"%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed"": " "%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed""inBuffTarget:%u / inBuffSize:%u", (unsigned)zcs->inBuffTarget, (unsigned)zcs->inBuffSizezcs->inBuffTarget <= zcs->inBuffSizeflushMode == ZSTD_e_endip == iend"Frame completed directly in outBuffer""flush stage"zcs->appliedParams.outBufferMode == ZSTD_bm_buffered"toFlush: %u into %u ==> flushed: %u", (unsigned)toFlush, (unsigned)(oend-op), (unsigned)flushedop==oend"Frame completed on flush"call ZSTD_initCStream() first!18446744073709551554ZSTD_compressEnd failedtoLoadloadedinputBufferedcDstZSTD_compressContinue failed5426flushMode54305440zcss_flush545854695485ZSTD_nextInputSizeHinthintInSize"ZSTD_initCStream"ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only)), ERR_getErrorName(err_code)ZSTD_CCtx_refCDict(zcs, NULL)ZSTD_CCtx_refCDict(zcs, ((void *)0))"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_refCDict(zcs, ((void *)0))), ERR_getErrorName(err_code)ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel)), ERR_getErrorName(err_code)"ZSTD_initCStream_srcSize"ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize)), ERR_getErrorName(err_code)"ZSTD_initCStream_usingDict"ZSTD_CCtx_loadDictionary(zcs, dict, dictSize)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_loadDictionary(zcs, dict, dictSize)), ERR_getErrorName(err_code)"ZSTD_initCStream_advanced"ZSTD_checkCParams(params.cParams)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_checkCParams(params.cParams)), ERR_getErrorName(err_code)const ZSTD_parametersconst ZSTD_parameters *"ZSTD_initCStream_usingCDict"ZSTD_CCtx_refCDict(zcs, cdict)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_CCtx_refCDict(zcs, cdict)), ERR_getErrorName(err_code)"ZSTD_initCStream_usingCDict_advanced"ZSTD_initCStream_internal"ZSTD_initCStream_internal"!ZSTD_isError(ZSTD_checkCParams(params->cParams))!ERR_isError(ZSTD_checkCParams(params->cParams))5223!((dict) && (cdict))5225"ZSTD_resetCStream: pledgedSrcSize = %u", (unsigned)pledgedSrcSizeZSTD_getCParamMode"ZSTD_createCStream"pssZSTD_compress_usingCDict_internalZSTD_compressBegin_usingCDict_internal(cctx, cdict, fParams, srcSize)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_compressBegin_usingCDict_internal(cctx, cdict, fParams, srcSize)), ERR_getErrorName(err_code)ZSTD_compressBegin_usingCDict_internal"ZSTD_compressBegin_usingCDict_internal"cdict==NULLcdict==((void *)0)"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cdict==((void *)0)), ERR_QUOTE(ERROR(dictionary_wrong))18446744073709551584ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFFZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER1U << 19cctxParams.cParams.windowLoglimitedSrcLoglimitedSrcSizeZSTD_dtlm_fastZSTDb_not_bufferedZSTD_getCParamsFromCDictcdict != NULLcdict != ((void *)0)5040const ZSTD_paramSwitch_euseRowMatchFindermatchStateSizeneededSize6048sizeof(ZSTD_CDict)wsZSTD_cwksp *ZSTD_cwksp_static_alloc"(workspaceSize < neededSize) : (%u < %u) => %u", (unsigned)workspaceSize, (unsigned)neededSize, (unsigned)(workspaceSize < neededSize)cMemcdictInWorkspaceconst ZSTD_cwkspconst ZSTD_cwksp *ZSTD_CDict *const"ZSTD_createCDict_advanced2, mode %u", (unsigned)dictContentType"ZSTD_createCDict_advanced2: DDS: %u", cctxParams.enableDedicatedDictSearch&cctxParamssizeof(cctxParams)ZSTD_createCDict_advanced_internalZSTD_cwksp_dynamic_alloc4868ZSTD_NO_CLEVELZSTD_initCDict_internal"ZSTD_initCDict_internal (dictContentType:%u)", (unsigned)dictContentType!ZSTD_checkCParams(params.cParams)4796!internalBuffer"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(!internalBuffer), ERR_QUOTE(ERROR(memory_allocation))internalBufferZSTD_reset_matchState( &cdict->matchState, &cdict->workspace, &params.cParams, params.useRowMatchFinder, ZSTDcrp_makeClean, ZSTDirp_reset, ZSTD_resetTarget_CDict)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_reset_matchState( &cdict->matchState, &cdict->workspace, &params.cParams, params.useRowMatchFinder, ZSTDcrp_makeClean, ZSTDirp_reset, ZSTD_resetTarget_CDict)), ERR_getErrorName(err_code)const ZSTD_compResetPolicy_econst ZSTD_indexResetPolicy_econst ZSTD_resetTarget_eldmState_t *ZSTD_dtlm_full"ZSTD_compress_insertDictionary failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(dictID), ERR_getErrorName(err_code)": " "ZSTD_compress_insertDictionary failed"ZSTD_compress_insertDictionary faileddictID <= (size_t)(U32)-14833originalCctxParamsenableDedicatedDictSearch"sizeof(*cdict) : %u", (unsigned)sizeof(*cdict)"sizeof(ZSTD_CDict) : %u", (unsigned)sizeof(ZSTD_CDict)"ZSTD_compressCCtx (srcSize=%u)", (unsigned)srcSize4730params.fParams.contentSizeFlag == 14717"ZSTD_compress_usingDict (srcSize=%u)", (unsigned)srcSizeZSTD_compress_advanced_internal"ZSTD_compress_advanced_internal (srcSize:%u)", (unsigned)srcSizeZSTD_compressBegin_internal(cctx, dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL, params, srcSize, ZSTDb_not_buffered)ZSTD_compressBegin_internal(cctx, dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, ((void *)0), params, srcSize, ZSTDb_not_buffered)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_compressBegin_internal(cctx, dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, ((void *)0), params, srcSize, ZSTDb_not_buffered)), ERR_getErrorName(err_code)"ZSTD_compress_advanced"endResult"ZSTD_compressContinue_internal failed"": " "ZSTD_compressContinue_internal failed"ZSTD_compressContinue_internal failed"ZSTD_writeEpilogue failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(endResult), ERR_getErrorName(err_code)": " "ZSTD_writeEpilogue failed"ZSTD_writeEpilogue failed!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0)4663ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1(0ULL - 1) == (unsigned long long)-1"end of frame : controlling src size"cctx->pledgedSrcSizePlusOne != cctx->consumedSrcSize+1"error : pledgedSrcSize = %u, while realSrcSize = %u", (unsigned)cctx->pledgedSrcSizePlusOne-1, (unsigned)cctx->consumedSrcSize"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->pledgedSrcSizePlusOne != cctx->consumedSrcSize+1), ERR_QUOTE(ERROR(srcSize_wrong))": " "error : pledgedSrcSize = %u, while realSrcSize = %u", (unsigned)cctx->pledgedSrcSizePlusOne-1, (unsigned)cctx->consumedSrcSizeerror : pledgedSrcSize = %u, while realSrcSize = %uZSTD_CCtx_trace&tracesizeof(trace)const ZSTD_Traceconst ZSTD_Trace *streamingtraceZSTD_Trace *const ZSTD_CCtx_params_sconst ZSTD_CCtx_params_s *ZSTD_writeEpiloguefhSize"ZSTD_writeEpilogue"cctx->stage == ZSTDcs_created"init missing""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->stage == ZSTDcs_created), ERR_QUOTE(ERROR(stage_wrong))": " "init missing"init missing18446744073709551556"ZSTD_writeFrameHeader failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(fhSize), ERR_getErrorName(err_code)": " "ZSTD_writeFrameHeader failed"ZSTDcs_initZSTD_writeFrameHeader failedZSTDcs_ongoing"no room for epilogue"": " "no room for epilogue"ZSTDcs_ending1 /* last block */ + (((U32)bt_raw)<<1) + 0no room for epilogue"ZSTD_writeEpilogue: write checksum : %08X", (unsigned)checksumZSTDcs_created"ZSTD_compressBegin_usingDict (dictSize=%u)", (unsigned)dictSizeZSTD_compressBegin_advanced_internal"ZSTD_compressBegin_advanced_internal: wlog=%u", params->cParams.windowLogZSTD_checkCParams(params->cParams)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_checkCParams(params->cParams)), ERR_getErrorName(err_code)ZSTD_compressBegin_internaldictContentSize"ZSTD_compressBegin_internal: wlog=%u", params->cParams.windowLog45034504ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize, dictContentSize, ZSTDcrp_makeClean, zbuff)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize, dictContentSize, ZSTDcrp_makeClean, zbuff)), ERR_getErrorName(err_code)const ZSTD_buffered_policy_edictID <= UINT_MAXdictID <= (0x7fffffff * 2U + 1U)extraCSizedtlmzbuff4529ZSTD_compress_insertDictionary"ZSTD_compress_insertDictionary (dictSize=%u)", (U32)dictSizedictContentType == ZSTD_dct_fullDict"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dictContentType == ZSTD_dct_fullDict), ERR_QUOTE(ERROR(dictionary_wrong))"raw content dictionary detected"39626107434476ZSTD_loadZstdDictionaryeSizeHUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog))((8 << 10) + 512 ) >= (1<<((9)>(9) ? (9) : (9)))dictSize >= 84428MEM_readLE32(dictPtr) == ZSTD_MAGIC_DICTIONARYMEM_readLE32(dictPtr) == 0xEC30A4374429"ZSTD_loadCEntropy failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(eSize), ERR_getErrorName(err_code)": " "ZSTD_loadCEntropy failed"ZSTD_loadCEntropy failedZSTD_loadDictionaryContent( ms, NULL, ws, params, dictPtr, dictContentSize, dtlm)ZSTD_loadDictionaryContent( ms, ((void *)0), ws, params, dictPtr, dictContentSize, dtlm)"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_loadDictionaryContent( ms, ((void *)0), ws, params, dictPtr, dictContentSize, dtlm)), ERR_getErrorName(err_code)ZSTD_loadCEntropyshort[32]offcodeNCountoffcodeMaxValuehufHeaderSizeHUF_isError(hufHeaderSize)ERR_isError(hufHeaderSize)"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(hufHeaderSize)), ERR_QUOTE(ERROR(dictionary_corrupted))18446744073709551586maxSymbolValue < 255"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(maxSymbolValue < 255), ERR_QUOTE(ERROR(dictionary_corrupted))offcodeLogoffcodeHeaderSizeFSE_isError(offcodeHeaderSize)ERR_isError(offcodeHeaderSize)"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(offcodeHeaderSize)), ERR_QUOTE(ERROR(dictionary_corrupted))offcodeLog > OffFSELogoffcodeLog > 8"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(offcodeLog > 8), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_isError(FSE_buildCTable_wksp( bs->entropy.fse.offcodeCTable, offcodeNCount, MaxOff, offcodeLog, workspace, HUF_WORKSPACE_SIZE))ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.offcodeCTable, offcodeNCount, 31, offcodeLog, workspace, ((8 << 10) + 512 )))"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.offcodeCTable, offcodeNCount, 31, offcodeLog, workspace, ((8 << 10) + 512 )))), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_CTable[193]unsigned int[193]short[53]matchlengthNCountmatchlengthMaxValuematchlengthLogmatchlengthHeaderSizeFSE_isError(matchlengthHeaderSize)ERR_isError(matchlengthHeaderSize)"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(matchlengthHeaderSize)), ERR_QUOTE(ERROR(dictionary_corrupted))matchlengthLog > MLFSELogmatchlengthLog > 9"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(matchlengthLog > 9), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_isError(FSE_buildCTable_wksp( bs->entropy.fse.matchlengthCTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog, workspace, HUF_WORKSPACE_SIZE))ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.matchlengthCTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog, workspace, ((8 << 10) + 512 )))"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.matchlengthCTable, matchlengthNCount, matchlengthMaxValue, matchlengthLog, workspace, ((8 << 10) + 512 )))), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_CTable[363]unsigned int[363]short[36]litlengthNCountlitlengthMaxValuelitlengthLoglitlengthHeaderSizeFSE_isError(litlengthHeaderSize)ERR_isError(litlengthHeaderSize)"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(litlengthHeaderSize)), ERR_QUOTE(ERROR(dictionary_corrupted))litlengthLog > LLFSELoglitlengthLog > 9"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(litlengthLog > 9), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_isError(FSE_buildCTable_wksp( bs->entropy.fse.litlengthCTable, litlengthNCount, litlengthMaxValue, litlengthLog, workspace, HUF_WORKSPACE_SIZE))ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.litlengthCTable, litlengthNCount, litlengthMaxValue, litlengthLog, workspace, ((8 << 10) + 512 )))"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(ERR_isError(FSE_buildCTable_wksp( bs->entropy.fse.litlengthCTable, litlengthNCount, litlengthMaxValue, litlengthLog, workspace, ((8 << 10) + 512 )))), ERR_QUOTE(ERROR(dictionary_corrupted))FSE_CTable[329]unsigned int[329]dictPtr+12 > dictEnd"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dictPtr+12 > dictEnd), ERR_QUOTE(ERROR(dictionary_corrupted))offcodeMax((U32)-1)4294836223((U32)-1) - 128 KBmaxOffsetbs->rep[u] == 0"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(bs->rep[u] == 0), ERR_QUOTE(ERROR(dictionary_corrupted))bs->rep[u] > dictContentSize"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(bs->rep[u] > dictContentSize), ERR_QUOTE(ERROR(dictionary_corrupted))ZSTD_dictNCountRepeatZSTD_loadDictionaryContentloadLdmDictZSTD_window_isEmpty(ms->window)ZSTD_window_isEmpty(ls->window)16106127363758096384ZSTD_CHUNKSIZE_MAXZSTD_CURRENT_MAX3758096383const ZSTD_window_t4221bsdictMaxSymbolValue4223"ZSTD_loadDictionaryContent(): useRowMatchFinder=%d", (int)params->useRowMatchFinderZSTD_window_t *HASH_READ_SIZEconst ldmParams_tconst ldmParams_t *srcSize >= HASH_READ_SIZEsrcSize >= 8ms->chainTable != NULLms->chainTable != ((void *)0)params->useRowMatchFinder != ZSTD_ps_automs->tagTabletagTableSize"Using row-based hash table for lazy dict""Using chain-based hash table for lazy dict"426142634266sizeof(U16)42834288"ZSTD_compressBlock: srcSize = %u", (unsigned)srcSizesrcSize > blockSizeMax"input is larger than a block""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(srcSize > blockSizeMax), ERR_QUOTE(ERROR(srcSize_wrong))": " "input is larger than a block"input is larger than a block!ZSTD_checkCParams(cParams)4184(U32)1 << cParams.windowLog"ZSTD_compressContinue (srcSize=%u)", (unsigned)srcSizeZSTD_compressContinue_internal"ZSTD_compressContinue_internal, stage: %u, srcSize: %u", cctx->stage, (unsigned)srcSizecctx->stage==ZSTDcs_created"missing init (ZSTD_compressBegin)""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->stage==ZSTDcs_created), ERR_QUOTE(ERROR(stage_wrong))": " "missing init (ZSTD_compressBegin)"missing init (ZSTD_compressBegin)fhSize <= dstCapacity4128"ZSTD_compressContinue_internal (blockSize=%u)", (unsigned)cctx->blockSize"%s", frame ? "ZSTD_compress_frameChunk failed" : "ZSTD_compressBlock_internal failed"": " "%s", frame ? "ZSTD_compress_frameChunk failed" : "ZSTD_compressBlock_internal failed"ZSTD_compress_frameChunk failedZSTD_compressBlock_internal failed4158cctx->consumedSrcSize+1 > cctx->pledgedSrcSizePlusOne"error : pledgedSrcSize = %u, while realSrcSize >= %u", (unsigned)cctx->pledgedSrcSizePlusOne-1, (unsigned)cctx->consumedSrcSize"%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->consumedSrcSize+1 > cctx->pledgedSrcSizePlusOne), ERR_QUOTE(ERROR(srcSize_wrong))": " "error : pledgedSrcSize = %u, while realSrcSize >= %u", (unsigned)cctx->pledgedSrcSizePlusOne-1, (unsigned)cctx->consumedSrcSizeerror : pledgedSrcSize = %u, while realSrcSize >= %uZSTD_referenceExternalSequencesrawSeq *cctx->stage != ZSTDcs_init"wrong cctx stage""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->stage != ZSTDcs_init), ERR_QUOTE(ERROR(stage_wrong))": " "wrong cctx stage"wrong cctx stagecctx->appliedParams.ldmParams.enableLdm == ZSTD_ps_enable"incompatible with ldm""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(cctx->appliedParams.ldmParams.enableLdm == ZSTD_ps_enable), ERR_QUOTE(ERROR(parameter_unsupported))": " "incompatible with ldm"incompatible with ldm18446744073709551576ZSTD_writeLastEmptyBlockdstCapacity < ZSTD_blockHeaderSize"dst buf is too small to write frame trailer empty block.""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dstCapacity < ZSTD_blockHeaderSize), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "dst buf is too small to write frame trailer empty block."dst buf is too small to write frame trailer empty block.1 /*lastBlock*/ + (((U32)bt_raw)<<1)dstCapacity < srcSize + ZSTD_SKIPPABLEHEADERSIZEdstCapacity < srcSize + 8"Not enough room for skippable frame""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dstCapacity < srcSize + 8), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "Not enough room for skippable frame"Not enough room for skippable framesrcSize > (unsigned)0xFFFFFFFF"Src size too large for skippable frame""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(srcSize > (unsigned)0xFFFFFFFF), ERR_QUOTE(ERROR(srcSize_wrong))": " "Src size too large for skippable frame"Src size too large for skippable framemagicVariant > 15"Skippable frame magic number variant not supported""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(magicVariant > 15), ERR_QUOTE(ERROR(parameter_outOfBound))": " "Skippable frame magic number variant not supported"Skippable frame magic number variant not supportedZSTD_writeFrameHeaderdictIDSizeCodeLengthdictIDSizeCodesingleSegmentwindowLogBytefcsCode6579265536+256frameHeaderDescriptionByte!(params->fParams.contentSizeFlag && pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN)!(params->fParams.contentSizeFlag && pledgedSrcSize == (0ULL - 1))4026dstCapacity < ZSTD_FRAMEHEADERSIZE_MAXdstCapacity < 18"dst buf is too small to fit worst-case frame header size.""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dstCapacity < 18), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "dst buf is too small to fit worst-case frame header size."dst buf is too small to fit worst-case frame header size."ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u", !params->fParams.noDictIDFlag, (unsigned)dictID, (unsigned)dictIDSizeCode424776221640404050ZSTD_compress_frameChunkmaxDistcctx->appliedParams.cParams.windowLog <= ZSTD_WINDOWLOG_MAXcctx->appliedParams.cParams.windowLog <= ((int)(sizeof(size_t) == 4 ? 30 : 31))framelastFrameChunknbSeq3944"ZSTD_compress_frameChunk (blockSize=%u)", (unsigned)blockSizedstCapacity < ZSTD_blockHeaderSize + MIN_CBLOCK_SIZEdstCapacity < ZSTD_blockHeaderSize + (1 + 1 + 1 )"not enough space to store compressed block""%s:%d: ERROR!: check %s failed, returning %s", __FILE__, __LINE__, ERR_QUOTE(dstCapacity < ZSTD_blockHeaderSize + (1 + 1 + 1 )), ERR_QUOTE(ERROR(dstSize_tooSmall))": " "not enough space to store compressed block""ZSTD_compressBlock_targetCBlockSize failed"": " "ZSTD_compressBlock_targetCBlockSize failed"cSize > 0cSize <= blockSize + ZSTD_blockHeaderSize"ZSTD_compressBlock_splitBlock failed"": " "ZSTD_compressBlock_splitBlock failed"cSize > 0 || cctx->seqCollector.collectSequences == 1"ZSTD_compressBlock_internal failed"": " "ZSTD_compressBlock_internal failed""ZSTD_noCompressBlock failed"": " "ZSTD_noCompressBlock failed"remaining >= blockSizedstCapacity >= cSize"ZSTD_compress_frameChunk: adding a block of size %u", (unsigned)cSizenot enough space to store compressed blockconst ZSTD_window_t *const ZSTD_matchState_tconst ZSTD_matchState_t *const ZSTD_matchState_t **ZSTD_matchState_t **ZSTD_compressBlock_targetCBlockSize failed39713972ZSTD_compressBlock_splitBlock failed3976ZSTD_noCompressBlock failed(U32)bt_rle((U32)bt_rle)((U32)bt_rle)<<1(((U32)bt_rle)<<1)39974000ZSTD_overflowCorrectIfNeededcycleLogZSTD_CHAINLOG_MAX <= 30((int)(sizeof(size_t) == 4 ? 29 : 30)) <= 30ZSTD_WINDOWLOG_MAX_32 <= 3030 <= 30ZSTD_WINDOWLOG_MAX <= 31((int)(sizeof(size_t) == 4 ? 30 : 31)) <= 31ZSTD_compressBlock_targetCBlockSizebss"ZSTD_compressBlock_targetCBlockSize (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u, srcSize=%zu)", (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit, (unsigned)zc->blockState.matchState.nextToUpdate, srcSize"ZSTD_buildSeqStore failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(bss), ERR_getErrorName(err_code)": " "ZSTD_buildSeqStore failed"ZSTD_buildSeqStore failed"ZSTD_compressBlock_targetCBlockSize_body failed"": " "ZSTD_compressBlock_targetCBlockSize_body failed"ZSTD_compressBlock_targetCBlockSize_body failedZSTD_compressBlock_targetCBlockSize_body"Attempting ZSTD_compressSuperBlock()""ZSTD_compressSuperBlock failed"": " "ZSTD_compressSuperBlock failed"ZSTDbss_compressmaxCSizeZSTD_compressSuperBlock failed"Resorting to ZSTD_noCompressBlock()"ZSTD_compressBlock_internalrleMaxLength"ZSTD_compressBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)", (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit, (unsigned)zc->blockState.matchState.nextToUpdateZSTDbss_noCompressZSTD_compressBlock_splitBlock"ZSTD_compressBlock_splitBlock"zc->appliedParams.useBlockSplitter == ZSTD_ps_enable3742"ZSTD_compressBlock_splitBlock: Nocompress block""Splitting blocks failed!"": " "Splitting blocks failed!"Splitting blocks failed!ZSTD_compressBlock_splitBlock_internalsrcBytesTotalpartitionsU32[196]unsigned int[196]nextSeqStorecurrSeqStorenumSplitsdRepcRepdRep.repzc->blockState.prevCBlock->repcRep.repsizeof(seqStore_t)"ZSTD_compressBlock_splitBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)", (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit, (unsigned)zc->blockState.matchState.nextToUpdatecSizeSingleBlock"Compressing single block from splitBlock_internal() failed!""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(cSizeSingleBlock), ERR_getErrorName(err_code)": " "Compressing single block from splitBlock_internal() failed!""ZSTD_compressBlock_splitBlock_internal: No splits"cSizeSingleBlock <= ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSizecSizeSingleBlock <= (1<<17) + ZSTD_blockHeaderSizeseqStore_t *constrepcodes_t *repcodes_s *repcodes_t *constCompressing single block from splitBlock_internal() failed!1310753689"Estimated size: %zu actual size: %zu", ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(currSeqStore, zc), cSizeChunkcSizeChunk"Compressing chunk failed!""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(cSizeChunk), ERR_getErrorName(err_code)": " "Compressing chunk failed!"cSizeChunk <= ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSizecSizeChunk <= (1<<17) + ZSTD_blockHeaderSizesrcByteslastPartitionlastBlockEntireSrcconst seqStore_t *constCompressing chunk failed!3723ZSTD_deriveBlockSplitsU32[]splits"ZSTD_deriveBlockSplits: Too few sequences to split"seqStoreSplits *"ZSTD_deriveBlockSplits: final nb partitions: %zu", splits.idx+1ZSTD_deriveBlockSplitsHelperfullSeqStoreChunkfirstHalfSeqStoresecondHalfSeqStoreestimatedOriginalSizeestimatedFirstHalfSizeestimatedSecondHalfSizemidIdx"ZSTD_deriveBlockSplitsHelper: Too few sequences"MIN_SEQUENCES_BLOCK_SPLITTINGZSTD_MAX_NB_BLOCK_SPLITS"ZSTD_deriveBlockSplitsHelper: startIdx=%zu endIdx=%zu", startIdx, endIdx"Estimated original block size: %zu -- First half split: %zu -- Second half split: %zu", estimatedOriginalSize, estimatedFirstHalfSize, estimatedSecondHalfSizeZSTD_compressSeqStore_singleBlockcSeqsSizeconst repcodes_tdRepOriginal"ZSTD_compressSeqStore_singleBlock""Block header doesn't fit"": " "Block header doesn't fit"Block header doesn't fit"ZSTD_entropyCompressSeqStore failed!""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(cSeqsSize), ERR_getErrorName(err_code)": " "ZSTD_entropyCompressSeqStore failed!"ZSTD_entropyCompressSeqStore failed!"Writing out nocompress block, size: %zu", cSize"Writing out RLE block, size: %zu", cSize"Writing out compressed block, size: %zu", cSizeZSTD_seqStore_resolveOffCodesseq->offBaseseq->offBase > 0seqDef *const3472dRawOffsetcRawOffsetZSTD_resolveRepcodeToRawOffsetSTORED_IS_REPCODE(offCode)((offCode) <= (3-1))adjustedOffCode34423443rep[0] > 03446ZSTD_deriveSeqStoreChunklitEndliteralsBytesliteralsBytesPrecedingZSTD_countSeqStoreMatchBytesmatchBytesnbSeqsZSTD_countSeqStoreLiteralsBytesZSTD_buildEntropyStatisticsAndEstimateSubBlockSizeZSTD_entropyCTablesMetadata_t *entropyMetadata"ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize()"ZSTD_buildBlockEntropyStats(seqStore, &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy, &zc->appliedParams, entropyMetadata, zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE )ZSTD_buildBlockEntropyStats(seqStore, &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy, &zc->appliedParams, entropyMetadata, zc->entropyWorkspace, (((8 << 10) + 512 ) + (sizeof(unsigned) * (((35)>(52) ? (35) : (52)) + 2))) )"%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(ZSTD_buildBlockEntropyStats(seqStore, &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy, &zc->appliedParams, entropyMetadata, zc->entropyWorkspace, (((8 << 10) + 512 ) + (sizeof(unsigned) * (((35)>(52) ? (35) : (52)) + 2))) )), ERR_getErrorName(err_code)const ZSTD_entropyCTablesMetadata_tconst ZSTD_entropyCTablesMetadata_t *ZSTD_estimateBlockSizeliteralsSizeconst ZSTD_hufCTables_tconst ZSTD_hufCTables_t *const ZSTD_hufCTablesMetadata_tconst ZSTD_hufCTablesMetadata_t *seqSizeconst ZSTD_fseCTables_tconst ZSTD_fseCTables_t *const ZSTD_fseCTablesMetadata_tconst ZSTD_fseCTablesMetadata_t *ZSTD_estimateBlockSize_sequencessequencesSectionHeaderSize1 /* seqHead */ + 132512cSeqSizeEstimateconst U8 *const S16 *ZSTD_estimateBlockSize_symbolTypecountWkspctpctStartctEndcSymbolTypeSizeEstimateInBitsmax <= defaultMax3280ZSTD_estimateBlockSize_literalliteralSectionHeaderSize1 KBcLitSizeEstimate3258ZSTD_buildBlockEntropyStatslitSizeZSTD_hufCTables_t *ZSTD_hufCTablesMetadata_t *entropyMetadata->hufMetadata.hufDesSize"ZSTD_buildBlockEntropyStats_literals failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(entropyMetadata->hufMetadata.hufDesSize), ERR_getErrorName(err_code)": " "ZSTD_buildBlockEntropyStats_literals failed"ZSTD_buildBlockEntropyStats_literals failedZSTD_fseCTables_t *ZSTD_fseCTablesMetadata_t *entropyMetadata->fseMetadata.fseTablesSize"ZSTD_buildBlockEntropyStats_sequences failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(entropyMetadata->fseMetadata.fseTablesSize), ERR_getErrorName(err_code)": " "ZSTD_buildBlockEntropyStats_sequences failed"ZSTD_buildBlockEntropyStats_sequences failedZSTD_buildBlockEntropyStats_sequencesconst ZSTD_strategyBYTE[133]unsigned char[133]477startIdxendIdxorigSeqStoreisPartitiondRepcodescRepcodesresultSeqStoreoriginalSeqStoreofCodeTablellCodeTablemlCodeTablewriteLitEntropywriteSeqEntropyfseTablesfseMetadatawriteEntropycodeTablefseCTableadditionalBitsdefaultNormdefaultNormLogdefaultMaxhufhufMetadataprevEntropynextEntropy3241064sizeof(fseMetadata->fseTablesBuffer)countWorkspaceentropyWorkspace(MaxSeq + 1)entropyWorkspaceSizesizeof(*countWorkspace)(MaxSeq + 1) * sizeof(*countWorkspace)"ZSTD_buildBlockEntropyStats_sequences (nbSeq=%zu)", nbSeqstats.size"ZSTD_buildSequencesStatistics failed!""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(stats.size), ERR_getErrorName(err_code)": " "ZSTD_buildSequencesStatistics failed!"ZSTD_buildSequencesStatistics failed!ZSTD_buildDummySequencesStatisticsZSTD_buildBlockEntropyStats_literalswkspStartwkspEndcountWkspStartcountWkspSize(HUF_SYMBOLVALUE_MAX + 1)(HUF_SYMBOLVALUE_MAX + 1) * sizeof(unsigned)nodeWkspnodeWkspSize"ZSTD_buildBlockEntropyStats_literals (srcSize=%zu)", srcSizenextHufprevHufsizeof(*prevHuf)2064"set_basic - disabled"minLitSizeCOMPRESS_LITERALS_SIZE_MIN"set_basic - too small""HIST_count_wksp failed""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(largest), ERR_getErrorName(err_code)": " "HIST_count_wksp failed"HIST_count_wksp failed"set_rle""set_basic - no gain"nextHuf->CTablesizeof(nextHuf->CTable)"HUF_buildCTable_wksp""%s:%d: ERROR!: forwarding error in %s: %s", __FILE__, __LINE__, ERR_QUOTE(maxBits), ERR_getErrorName(err_code)": " "HUF_buildCTable_wksp"newCSizesizeof(hufMetadata->hufDesBuffer)"set_repeat - smaller"oldCSize"set_basic - no gains""set_compressed (hSize=%u)", (U32)hSizewriteBlockHeader"writeBlockHeader: cSize: %zu blockSize: %zu lastBlock: %u", cSize, blockSize, lastBlockZSTD_blockState_confirmRepcodesAndEntropyTablesZSTD_compressedBlockState_t *constZSTD_maybeRLEnbLitsZSTD_isRLEvalueST0x0101010101010101ULLunrollSizesizeof(size_t) * 4unrollMaskunrollSize - 1prefixLengthseqCollectordst == NULLdst == ((void *)0)"%s:%d: ERROR!: check %s failed, return       